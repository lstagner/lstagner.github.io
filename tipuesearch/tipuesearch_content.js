var tipuesearch = {"pages":[{"title":" Fortran Program ","loc":"index.html","text":"Fortran Program This is a project which I wrote. This file will provide the documents. I'm\nwriting the body of the text here. It contains an overall description of the\nproject. It might explain how to go about installing/compiling it. It might\nprovide a change-log for the code. Maybe it will talk about the\nhistory and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. You can have as many paragraphs as you like here and can use headlines, links,\nimages, etc. Basically, you can use anything in Markdown and Markdown-Extra.\nFurthermore, you can insert LaTeX into your documentation. So, for example,\nyou can provide inline math using like  y = x&#94;2  or math on its own line\nlike  x = \\sqrt{y}  or  e = mc&#94;2.  You can even use LaTeX environments!\nSo you can get numbered equations like this:\n\\begin{equation}\n  PV = nRT\n\\end{equation}\nSo let your imagination run wild. As you can tell, I'm more or less just\nfilling in space now. This will be the last sentence. Developer Info Luke Stagner I program stuff in Fortran.","tags":""},{"title":"eigensystem.f90 – Fortran Program","loc":"sourcefile/eigensystem.f90.html","text":"Source Code !! This file contains all the linear algebra routines FIDASIM uses module eigensystem implicit none !!Definition for the kind of the variables: integer , parameter :: long = kind ( int ( 1 )) integer , parameter :: float = kind ( 1.e0 ) integer , parameter :: double = kind ( 1. d0 ) !! eigenvalue decomposition values real ( double ), parameter :: ONE = 1. d0 , TWO = 2. d0 , ZERO = 0. d0 real ( double ), parameter :: XMACH_EPS = 2.22 d - 16 integer , parameter :: MAXIT = 50 contains ! first subroutines for eigenvalue decomposition subroutine RSWAP ( a , b ) real ( double ) :: a , b , t t = a ; a = b ; b = t end subroutine RSWAP subroutine balance ( n , & !size of matrix mat , & !input matrix scal , & !Scaling data low , & !first relevant row index high ) !last relevant row index integer , intent ( in ) :: n real ( double ) :: mat ( 0 : n , 0 : n ), scal ( 0 : n ) integer , intent ( out ) :: high , low integer , parameter :: basis = 2 real ( double ) :: b2 , r , c , f , g , s integer :: m , k , i , j , iter !*====================================================================* !*  balance balances the matrix so that the rows with zero entries    * !*  off the diagonal are isolated and the remaining columns and rows  * !*  are resized to have one norm close to 1.                          * !*   Input parameters:                                                * !*      n        integer;  ( n > 0 )                                  * !*               Dimension of mat                                     * !*      mat      n x n input matrix                                   * !*                                                                    * !*   Output parameters:                                               * !*      mat      n x n scaled matrix                                  * !*      low      integer;                                             * !*      high     integer;                                             * !*               the rows 0 to low-1 and those from high to n-1       * !*               contain isolated eigenvalues (only nonzero entry on  * !*               the diagonal)                                        * !*      scal     vector of size n                                     * !*               the vector scal contains the isolated eigenvalues in * !*               the positions 0 to low-1 and high to n-1, its other  * !*               components contain the scaling factors for           * !*               transforming mat.                                    * !*====================================================================* scal = 0. d0 b2 = basis * basis m = 0 k = n - 1 iter = 1 do while ( iter == 1 ) iter = 0 do j = k , 0 , - 1 r = ZERO do i = 0 , k if ( i . ne . j ) r = r + DABS ( mat ( j , i )) enddo if ( r == ZERO ) then scal ( k ) = j if ( j . ne . k ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , k )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( k , i )) enddo endif k = k - 1 iter = 1 endif enddo !j loop enddo !while iter=1 iter = 1 do while ( iter == 1 ) iter = 0 do j = m , k c = ZERO do i = m , k if ( i . ne . j ) c = c + DABS ( mat ( i , j )) enddo if ( c == ZERO ) then scal ( m ) = j if ( j . ne . m ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , m )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( m , i )) enddo endif m = m + 1 iter = 1 endif enddo !j loop enddo !while iter=1 low = m high = k do i = m , k scal ( i ) = ONE enddo iter = 1 do while ( iter == 1 ) iter = 0 do i = m , k c = ZERO ; r = ZERO do j = m , k if ( j . ne . i ) then c = c + DABS ( mat ( j , i )) r = r + DABS ( mat ( i , j )) endif enddo g = r / basis f = ONE s = c + r do while ( c < g ) f = f * basis c = c * b2 enddo g = r * basis do while ( c >= g ) f = f / basis c = c / b2 enddo if (( c + r ) / f < 0.95 * s ) then g = ONE / f scal ( i ) = scal ( i ) * f iter = 1 do j = m , n - 1 mat ( i , j ) = mat ( i , j ) * g enddo do j = 0 , k mat ( j , i ) = mat ( j , i ) * f enddo endif enddo !i loop enddo !while iter=1 return end subroutine balance subroutine balback ( n , & !Dimension of matrix ......... low , & !first nonzero row ........... high , & !last nonzero row ............ scal , & !Scaling data ................ eivec ) !Eigenvectors ................ integer , intent ( in ) :: high , low integer , intent ( in ) :: n real ( double ), intent ( in ) :: scal ( 0 : n ) real ( double ), intent ( inout ) :: eivec ( 0 : n , 0 : n ) real ( double ) :: s integer :: i , j , k !*====================================================================* !*  balback reverses the balancing of balance for the eigenvactors.   * !*   Input parameters:                                                * !*   ----------------                                                 * !*      n        integer;  ( n > 0 )                                  * !*               Dimension of mat                                     * !*      low      integer;                                             * !*      high     integer;   see balance                               * !*      eivec    n x n matrix of eigenvectors, as computed in  qr2    * !*      scal     vector of size n;                                    * !*               Scaling data from  balance                           * !*   Output parameter:                                                * !*   ----------------                                                 * !*      eivec    n x n matrix;                                        * !*               Non-normalized eigenvectors of the original matrix   * !*====================================================================* do i = low , high s = scal ( i ) do j = 0 , n - 1 eivec ( i , j ) = eivec ( i , j ) * s enddo enddo do i = low - 1 , 0 , - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo do i = high + 1 , n - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo return end subroutine balback subroutine elmhes ( n , & !Dimension of matrix low , & !first nonzero row ........... high , & !last nonzero row ............ mat , & !input/output matrix ......... perm ) !Permutation vector .......... integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ), intent ( inout ) :: mat ( 0 : n , 0 : n ) integer , intent ( out ) :: perm ( 0 : n ) integer :: i , j , m real ( double ) :: x , y !*====================================================================* !*  elmhes transforms the matrix mat to upper Hessenberg form.        * !*   Input parameters:                                                * !*      n        integer;  ( n > 0 )                                  * !*               Dimension of mat                                     * !*      low      integer;                                             * !*      high     integer; see  balance                                * !*      mat      n x n matrix                                         * !*   Output parameter:                                                * !*      mat      n x n matrix;                                        * !*               upper Hessenberg matrix; additional information on   * !*               the transformation is stored in the lower triangle   * !*      perm     integer vector of size n;                            * !*               Permutation vector for elmtrans                      * !*====================================================================* do m = low + 1 , high - 1 i = m x = ZERO do j = m , high if ( DABS ( mat ( j , m - 1 )) > DABS ( x )) then x = mat ( j , m - 1 ) i = j endif enddo perm ( m ) = i if ( i . ne . m ) then do j = m - 1 , n - 1 call RSWAP ( mat ( i , j ), mat ( m , j )) enddo do j = 0 , high call RSWAP ( mat ( j , i ), mat ( j , m )) enddo endif if ( x . ne . ZERO ) then do i = m + 1 , high y = mat ( i , m - 1 ) if ( y . ne . ZERO ) then y = y / x mat ( i , m - 1 ) = y do j = m , n - 1 mat ( i , j ) = mat ( i , j ) - y * mat ( m , j ) enddo do j = 0 , high mat ( j , m ) = mat ( j , m ) + y * mat ( j , i ) enddo endif enddo !i loop endif !x <> ZERO enddo !m loop end subroutine elmhes Subroutine elmtrans ( n , & !Dimension of matrix ......... low , & !first nonzero row ........... high , & !last nonzero row ............ mat , & !input matrix ................ perm , & !row permutations ............ h ) !Hessenberg matrix ........... integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ), intent ( in ) :: mat ( 0 : n , 0 : n ) integer , intent ( in ) :: perm ( 0 : n ) real ( double ), intent ( out ) :: h ( 0 : n , 0 : n ) integer :: i , j , k !*====================================================================* !*  Elmtrans copies the Hessenberg matrix stored in mat to h.         * !*   Input parameters:                                                * !*      n        integer;  ( n > 0 )                                  * !*               Dimension of  mat and eivec                          * !*      low      integer;                                             * !*      high     integer; see  balance                                * !*      mat      n x n input matrix                                   * !*      perm     Integer vector of size n;                            * !*               Permutation data from  elmhes                        * !*   Output parameter:                                                * !*      h        n x n matrix;                                        * !*               Hessenberg matrix                                    * !*====================================================================* do i = 0 , n - 1 do k = 0 , n - 1 h ( i , k ) = ZERO enddo h ( i , i ) = ONE enddo do i = high - 1 , low + 1 , - 1 j = perm ( i ) do k = i + 1 , high h ( k , i ) = mat ( k , i - 1 ) enddo if ( i . ne . j ) then do k = i , high h ( i , k ) = h ( j , k ) h ( j , k ) = ZERO enddo h ( j , i ) = ONE endif enddo end subroutine elmtrans subroutine Comdiv ( ar , & !Real part of numerator .......... ai , & !Imaginary part of numerator ..... br , & !Real part of denominator ........ bi , & !Imaginary part of denominator ... cr , & !Real part of quotient ........... ci , & !Imaginary part of quotient ...... rc ) !return code ..................... real ( double ) :: ar , ai , br , bi , cr , ci integer :: rc real ( double ) :: tmp !*====================================================================* !*  Complex division  c = a / b                                       * !*   Input parameters:                                                * !*   ================                                                 * !*      ar,ai    real, imaginary parts of numerator                   * !*      br,bi    real, imaginary parts of denominator                 * !*   Output parameters:                                               * !*   ==================                                               * !*      cr,ci     real , imaginary parts of the quotient              * !*====================================================================* if ( br == ZERO . AND . bi == ZERO ) then rc = 1 return endif if ( dabs ( br ) > dabs ( bi )) then tmp = bi / br br = tmp * bi + br cr = ( ar + tmp * ai ) / br ci = ( ai - tmp * ar ) / br else tmp = br / bi bi = tmp * br + bi cr = ( tmp * ar + ai ) / bi ci = ( tmp * ai - ar ) / bi endif rc = 0 end subroutine Comdiv !Comdiv function comabs ( ar , ai ) !Real part ,Imaginary part ................. real ( double ) :: ar , ai real ( double ) :: comabs !*====================================================================* !*   Input parameters:                                                * !*      ar,ai     Real, imaginary parts of  a                         * !*   Return value :                                                   * !*      Absolute value of a (real)                                    * !*====================================================================* if ( ar == ZERO . and . ai == ZERO ) then Comabs = ZERO return endif ar = DABS ( ar ) ai = DABS ( ai ) if ( ai > ar ) then !Switch  ai and ar call RSWAP ( ai , ar ) endif if ( ai == ZERO ) then Comabs = ar else Comabs = ar * DSQRT ( ONE + ai / ar * ai / ar ) endif end function comabs subroutine hqrvec ( n , & !Dimension of matrix ....... low , & !first nonzero row ......... high , & !last nonzero row .......... h , & !upper Hessenberg matrix ... wr , & !Real parts of evalues ..... wi , & !Imaginary parts of evalues eivec , & !Eigenvectors .............. rc ) !return code ............... integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ), intent ( in ) :: wr ( 0 : n ), wi ( 0 : n ) real ( double ), intent ( out ) :: eivec ( 0 : n , 0 : n ) real ( double ) :: h ( 0 : n , 0 : n ) integer :: rc integer :: i , j , m , k , na , l integer :: code , en real ( double ) :: p , q , r , s , t , w , x , y , z , ra , sa , vr , vi , norm , temp !*====================================================================* !*  hqrvec computes the eigenvectors for the eigenvalues found in hqr2* !*   Input parameters:                                                * !*   ================                                                 * !*      n        int n;  ( n > 0 )                                    * !*               Dimension of  mat and eivec, number of eigenvalues.  * !*      low      int low;                                             * !*      high     int high; see  balance                               * !*      h        n x n upper Hessenberg matrix                        * !*      wr       vector of size n;                                    * !*               Real parts of the n eigenvalues.                     * !*      wi       vector of size n;                                    * !*               Imaginary parts of the n eigenvalues.                * !*   Output parameter:                                                * !*   ================                                                 * !*      eivec    n x n matrix, whose columns are the eigenvectors     * !*====================================================================* r = ZERO ; s = ZERO ; z = ZERO ; norm = ZERO do i = 0 , n - 1 !find norm of h do j = i , n - 1 norm = norm + DABS ( h ( i , j )) enddo enddo if ( norm == ZERO ) then rc = 1 !zero matrix return endif do en = n - 1 , 0 , - 1 !transform back p = wr ( en ) q = wi ( en ) na = en - 1 if ( q == ZERO ) then m = en h ( en , en ) = ONE do i = na , 0 , - 1 w = h ( i , i ) - p r = h ( i , en ) do j = m , na r = r + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w s = r else m = i if ( wi ( i ) == ZERO ) then if ( w . ne . ZERO ) then temp = w else temp = XMACH_EPS * norm endif h ( i , en ) = - r / temp else !Solve the linear system: !| w   x |  | h[i][en]   |   | -r | !|       |  |            | = |    | !| y   z |  | h[i+1][en] |   | -s | x = h ( i , i + 1 ) y = h ( i + 1 , i ) q = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 h ( i , en ) = ( x * s - z * r ) / q t = h ( i , en ) if ( DABS ( x ) > DABS ( z )) then temp = ( - r - w * t ) / x else temp = ( - s - y * t ) / z endif h ( i + 1 , en ) = temp endif endif !wi[i] < 0 enddo !i loop else if ( q < ZERO ) then m = na if ( DABS ( h ( en , na )) > DABS ( h ( na , en ))) then h ( na , na ) = - ( h ( en , en ) - p ) / h ( en , na ) h ( na , en ) = - q / h ( en , na ) else call Comdiv ( - h ( na , en ), 0. d0 , h ( na , na ) - p , q , h ( na , na ), h ( na , en ), code ) endif h ( en , na ) = ONE h ( en , en ) = ZERO do i = na - 1 , 0 , - 1 w = h ( i , i ) - p ra = h ( i , en ) sa = ZERO do j = m , na ra = ra + h ( i , j ) * h ( j , na ) sa = sa + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w r = ra s = sa else m = i if ( wi ( i ) == ZERO ) then call Comdiv ( - ra , - sa , w , q , h ( i , na ), h ( i , en ), code ) else !  solve complex linear system: !| w+i*q     x | | h[i][na] + i*h[i][en]  |   | -ra+i*sa | !|             | |                        | = |          | !|   y    z+i*q| | h[i+1][na]+i*h[i+1][en]|   | -r+i*s   | x = h ( i , i + 1 ) y = h ( i + 1 , i ) vr = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 - q * q vi = TWO * q * ( wr ( i ) - p ) if ( vr == ZERO . AND . vi == ZERO ) then vr = XMACH_EPS * norm * ( DABS ( w ) + DABS ( q ) & + DABS ( x ) + DABS ( y ) + DABS ( z )) endif call Comdiv ( x * r - z * ra + q * sa , x * s - z * sa - q * ra & , vr , vi , h ( i , na ), h ( i , en ), code ) if ( DABS ( x ) > DABS ( z ) + DABS ( q )) then h ( i + 1 , na ) = ( - ra - w * h ( i , na ) + q * h ( i , en )) / x h ( i + 1 , en ) = ( - sa - w * h ( i , en ) - q * h ( i , na )) / x else call Comdiv ( - r - y * h ( i , na ), - s - y * h ( i , en ) & , z , q , h ( i + 1 , na ), h ( i + 1 , en ), code ) endif endif !wi[i] = 0 endif !wi[i] < 0 enddo !i loop endif !else if q < 0 enddo !en loop do i = 0 , n - 1 !Eigenvectors for the evalues for if ( i < low . or . i > high ) then !rows < low  and rows  > high do k = i + 1 , n - 1 eivec ( i , k ) = h ( i , k ) enddo endif enddo j = n - 1 do while ( j >= low ) if ( j <= high ) then m = j else j = high endif if ( wi ( j ) < ZERO ) then l = j - 1 do i = low , high y = ZERO ; z = ZERO do k = low , m y = y + eivec ( i , k ) * h ( k , l ) z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , l ) = y eivec ( i , j ) = z enddo else if ( wi ( j ) == ZERO ) then do i = low , high z = ZERO do k = low , m z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , j ) = z enddo endif endif j = j - 1 enddo !j loop rc = 0 end subroutine hqrvec subroutine hqr2 ( n , & !Dimension of matrix ......... low , & !first nonzero row ........... high , & !last nonzero row ............ h , & !Hessenberg matrix ........... wr , & !Real parts of eigenvalues ... wi , & !Imaginary parts of evalues .. eivec ,& !Matrix of eigenvectors ...... cnt , & !Iteration counter ........... rc ) !return code ................. integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ) , intent ( out ) :: h ( 0 : n , 0 : n ) real ( double ), intent ( out ) :: wr ( 0 : n ), wi ( 0 : n ) real ( double ), intent ( out ) :: eivec ( 0 : n , 0 : n ) integer , intent ( out ) :: rc integer , intent ( out ) :: cnt ( 0 : n ) integer :: en integer :: i , j , na , iter , l , ll , m , k real ( double ) :: p , q , r , s , t , w , x , y , z !********************************************************************** !* hqr2 computes the eigenvalues and (if vec = True) the eigenvectors * !* of an  n * n upper Hessenberg matrix.                              * !*   Input parameters:                                                * !*   ----------------                                                 * !*      n        integer;  ( n > 0 )                                  * !*               Dimension of  h and eivec,                           * !*               length of the real parts vector  wr and of the       * !*               imaginary parts vector  wi of the eigenvalues.       * !*      low      integer;                                             * !*      high     integer;  see balance                                * !*      h        n x n matrix;                                        * !*               upper Hessenberg matrix as output of Elmhes          * !*               (destroyed in the process).                          * !*   Output parameters:                                               * !*   -----------------                                                * !*      eivec    n x n matrix;  (only if vec = 1)                     * !*               Matrix, which for vec = 1 contains the               * !*               eigenvectors as follows:                             * !*               For real eigebvalues the corresponding column        * !*               contains the corresponding eigenvactor, while for    * !*               complex eigenvalues the corresponding column contains* !*               the real part of the eigenvactor with its imaginary  * !*               part is stored in the subsequent column of eivec.    * !*               The eigenvactor for the complex conjugate eigenvactor* !*               is given by the complex conjugate eigenvactor.       * !*      wr       vector of size n;                                    * !*               Real part of the n eigenvalues.                      * !*      wi       vector of size n;                                    * !*               Imaginary parts of the eigenvalues                   * !*      cnt      Integer vector of size n;                            * !*               vector of iterations used for each eigenvalue.       * !*               For a complex conjugate eigenvalue pair the second   * !*               entry is negative.                                   * !********************************************************************** p = ZERO ; q = ZERO ; r = ZERO do i = 0 , n - 1 if ( i < low . or . i > high ) then wr ( i ) = h ( i , i ) wi ( i ) = ZERO cnt ( i ) = 0 endif enddo en = high t = ZERO do while ( en >= low ) iter = 0 na = en - 1 do while ( 1 < 2 ) ll = 999 do l = en , low + 1 , - 1 !search for small !subdiagonal element if ( DABS ( h ( l , l - 1 )) <= XMACH_EPS * ( DABS ( h ( l - 1 , l - 1 )) + DABS ( h ( l , l )))) then ll = l ; !save current index goto 10 !exit l loop endif enddo 10 if ( ll . ne . 999 ) then l = ll else l = 0 !restore l endif x = h ( en , en ) if ( l == en ) then !found one evalue wr ( en ) = x + t h ( en , en ) = x + t wi ( en ) = ZERO cnt ( en ) = iter en = en - 1 goto 15 !exit from loop while(True) endif y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) then !found two evalues p = ( y - x ) * 0.5 d0 q = p * p + w z = DSQRT ( DABS ( q )) x = x + t h ( en , en ) = x + t h ( na , na ) = y + t cnt ( en ) = - iter cnt ( na ) = iter if ( q >= ZERO ) then !real eigenvalues if ( p < ZERO ) then z = p - z else z = p + z endif wr ( na ) = x + z wr ( en ) = x - w / z s = w - w / z wi ( na ) = ZERO wi ( en ) = ZERO x = h ( en , na ) r = DSQRT ( x * x + z * z ) p = x / r q = z / r do j = na , n - 1 z = h ( na , j ) h ( na , j ) = q * z + p * h ( en , j ) h ( en , j ) = q * h ( en , j ) - p * z enddo do i = 0 , en z = h ( i , na ) h ( i , na ) = q * z + p * h ( i , en ) h ( i , en ) = q * h ( i , en ) - p * z enddo do i = low , high z = eivec ( i , na ) eivec ( i , na ) = q * z + p * eivec ( i , en ) eivec ( i , en ) = q * eivec ( i , en ) - p * z enddo else !pair of complex wr ( na ) = x + p wr ( en ) = x + p wi ( na ) = z wi ( en ) = - z endif !if q>=ZERO en = en - 2 goto 15 !exit while(1<2) endif !if l = na if ( iter >= MAXIT ) then cnt ( en ) = MAXIT + 1 rc = en write ( * , * ) ' stop at iter >= MAXIT.' return endif if ( iter . ne . 0. and . MOD ( iter , 10 ) == 0 ) then t = t + x do i = low , en h ( i , i ) = h ( i , i ) - x enddo s = DABS ( h ( en , na )) + DABS ( h ( na , en - 2 )) x = 0.75 d0 * s ; y = x w = - 0.4375 d0 * s * s endif iter = iter + 1 do m = en - 2 , l , - 1 z = h ( m , m ) r = x - z s = y - z p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - z - r - s r = h ( m + 2 , m + 1 ) s = DABS ( p ) + DABS ( q ) + DABS ( r ) p = p / s q = q / s r = r / s if ( m == l ) goto 12 if ( DABS ( h ( m , m - 1 )) * ( DABS ( q ) + DABS ( r )) <= XMACH_EPS * DABS ( p ) & * ( DABS ( h ( m - 1 , m - 1 )) + DABS ( z ) + DABS ( h ( m + 1 , m + 1 )))) then goto 12 !exit m loop endif enddo 12 do i = m + 2 , en h ( i , i - 2 ) = ZERO enddo do i = m + 3 , en h ( i , i - 3 ) = ZERO enddo do k = m , na if ( k . ne . m ) then !double QR step, for rows l to en and columns m to en p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) if ( k . ne . na ) then r = h ( k + 2 , k - 1 ) else r = ZERO endif x = DABS ( p ) + DABS ( q ) + DABS ( r ) if ( x == ZERO ) goto 30 !next k p = p / x q = q / x r = r / x endif s = DSQRT ( p * p + q * q + r * r ) if ( p < ZERO ) s = - s if ( k . ne . m ) then h ( k , k - 1 ) = - s * x else if ( l . ne . m ) then h ( k , k - 1 ) = - h ( k , k - 1 ) endif p = p + s x = p / s y = q / s z = r / s q = q / p r = r / p do j = k , n - 1 !modify rows p = h ( k , j ) + q * h ( k + 1 , j ) if ( k . ne . na ) then p = p + r * h ( k + 2 , j ) h ( k + 2 , j ) = h ( k + 2 , j ) - p * z endif h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k , j ) = h ( k , j ) - p * x enddo if ( k + 3 < en ) then j = k + 3 else j = en endif do i = 0 , j !modify columns p = x * h ( i , k ) + y * h ( i , k + 1 ) if ( k . ne . na ) then p = p + z * h ( i , k + 2 ) h ( i , k + 2 ) = h ( i , k + 2 ) - p * r endif h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k ) = h ( i , k ) - p enddo do i = low , high p = x * eivec ( i , k ) + y * eivec ( i , k + 1 ) if ( k . ne . na ) then p = p + z * eivec ( i , k + 2 ) eivec ( i , k + 2 ) = eivec ( i , k + 2 ) - p * r endif eivec ( i , k + 1 ) = eivec ( i , k + 1 ) - p * q eivec ( i , k ) = eivec ( i , k ) - p enddo 30 continue enddo !k loop enddo !while(1<2) 15 continue enddo !while en >= low                         All evalues found !transform evectors back call hqrvec ( n , low , high , h , wr , wi , eivec , rc ) end subroutine hqr2 subroutine eigen ( n , matrix , eigvec , eigval ) integer , intent ( in ) :: n ! nlevels real ( double ) , intent ( in ), dimension ( n , n ) :: matrix real ( double ) , intent ( out ), dimension ( n , n ) :: eigvec real ( double ) , intent ( out ), dimension ( n ) :: eigval real ( double ) :: mat ( 0 : n , 0 : n ) real ( double ) :: eivec ( 0 : n , 0 : n ) real ( double ) :: valre ( 0 : n ) !real parts of eigenvalues real ( double ) :: valim ( 0 : n ) !imaginary parts of eigenvalues integer :: rc !return code integer :: cnt ( 0 : n ) !Iteration counter integer :: high , low real ( double ) :: d ( 0 : n ), scale ( 0 : n ) integer :: perm ( 0 : n ) !********************************************************************** !* The subroutine eigen  determines all eigenvalues and (if desired)  * !* all eigenvectors of a real square  n * n  matrix via the QR method * !* in the version of Martin, Parlett, Peters, Reinsch and Wilkinson.  * !*   Litterature:                                                     * !*   -----------                                                      * !*      1) Peters, Wilkinson: Eigenvectors of real and complex        * !*         matrices by LR and QR triangularisations,                  * !*         Num. Math. 16, p.184-204, (1970); [PETE70]; contribution   * !*         II/15, p. 372 - 395 in [WILK71].                           * !*      2) Martin, Wilkinson: Similarity reductions of a general      * !*         matrix to Hessenberg form, Num. Math. 12, p. 349-368,(1968)* !*         [MART 68]; contribution II,13, p. 339 - 358 in [WILK71].   * !*      3) Parlett, Reinsch: Balancing a matrix for calculations of   * !*         eigenvalues and eigenvectors, Num. Math. 13, p. 293-304,   * !*         (1969); [PARL69]; contribution II/11, p.315 - 326 in       * !*         [WILK71].                                                  * !*   Input parameters:                                                * !*   ----------------                                                 * !*      n        integer; ( n > 0 )                                   * !*               size of matrix, number of eigenvalues                * !*      mat      n x n matrix;                                        * !*               input matrix                                         * !*   Output parameters:                                               * !*   -----------------                                                * !*      eivec    n x n matrix;     (only if vec = 1)                  * !*               matrix, if  vec = 1  that holds the eigenvectors     * !*               thus :                                               * !*               If the jth eigenvalue of the matrix is real then the * !*               jth column is the corresponding real eigenvector;    * !*               if the jth eigenvalue is complex then the jth column * !*               of eivec contains the real part of the eigenvector   * !*               while its imaginary part is in column j+1.           * !*               (the j+1st eigenvector is the complex conjugate      * !*               vector.)                                             * !*      valre    vector of size n;                                    * !*               Real parts of the eigenvalues.                       * !*      valim    vector of size n;                                    * !*               Imaginary parts of the eigenvalues                   * !*      cnt      Integer vector of size n;                            * !*               vector containing the number of iterations for each  * !*               eigenvalue. (for a complex conjugate pair the second * !*               entry is negative).                                  * !********************************************************************** cnt = 0 ; d = 0. d0 mat ( 0 : n - 1 , 0 : n - 1 ) = matrix ( 1 : n , 1 : n ) !balance mat for nearly call balance ( n , mat , scale , low , high ) !equal row and column !reduce mat to upper call elmhes ( n , low , high , mat , perm ) !reduce mat to upper !Hessenberg form call elmtrans ( n , low , high , mat , perm , eivec ) !QR algorithm for eigenvalues and eigenvectors call hqr2 ( n , low , high , mat , valre , valim , eivec , cnt , rc ) !reverse balancing to determine eigenvectors call balback ( n , low , high , scale , eivec ) if ( rc . ne . 0 ) then print * , 'matrix = ' print * , matrix stop 'problem in eigen!' endif eigval ( 1 : n ) = valre ( 0 : n - 1 ) eigvec ( 1 : n , 1 : n ) = eivec ( 0 : n - 1 , 0 : n - 1 ) end subroutine eigen function outerprod ( a , b ) real ( double ), dimension (:), intent ( IN ) :: a , b real ( double ), dimension ( size ( a ), size ( b )) :: outerprod outerprod = spread ( a , dim = 2 , ncopies = size ( b )) * & spread ( b , dim = 1 , ncopies = size ( a )) end function outerprod subroutine swap ( a , b ) real ( double ), dimension (:), intent ( INOUT ) :: a , b real ( double ), dimension ( size ( a )) :: dum dum = a a = b b = dum end subroutine swap subroutine ludcmp ( a , indx , d ) real ( double ), dimension (:,:), intent ( INOUT ) :: a integer , dimension (:), intent ( OUT ) :: indx real ( double ), intent ( OUT ) :: d real ( double ), dimension ( size ( a , 1 )) :: vv integer , dimension ( 1 ) :: imaxloc integer :: j , n , imax n = size ( indx ) d = 1.0 vv = maxval ( abs ( a ), dim = 2 ) if ( any ( vv . eq . 0. )) stop 'singular matrix in ludcmp' vv = 1. d0 / vv do j = 1 , n imaxloc = maxloc ( vv ( j : n ) * abs ( a ( j : n , j ))) imax = ( j - 1 ) + imaxloc ( 1 ) if ( j /= imax ) then call swap ( a ( imax ,:), a ( j ,:)) d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( a ( j , j ) == 0.0 ) a ( j , j ) = 1.0 d - 20 a ( j + 1 : n , j ) = a ( j + 1 : n , j ) / a ( j , j ) a ( j + 1 : n , j + 1 : n ) = a ( j + 1 : n , j + 1 : n ) - outerprod ( a ( j + 1 : n , j ), a ( j , j + 1 : n )) enddo end subroutine ludcmp subroutine lubksb ( a , indx , b ) real ( double ), dimension (:,:), intent ( IN ) :: a integer , dimension (:), intent ( IN ) :: indx real ( double ), dimension (:), intent ( INOUT ) :: b integer :: i , n , ii , ll real ( double ) :: summ n = size ( indx ) ii = 0 do i = 1 , n ll = indx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( a ( i , ii : i - 1 ), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i endif b ( i ) = summ enddo do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( a ( i , i + 1 : n ), b ( i + 1 : n ))) / a ( i , i ) enddo end subroutine lubksb subroutine matinv ( a , b ) !! - Matrix inversion with LU-decomposition !==================================================== real ( double ), dimension (:,:), intent ( IN ) :: a real ( double ), dimension (:,:), intent ( OUT ) :: b real ( double ), dimension ( size ( a , dim = 1 ), size ( a , dim = 2 )) :: ah , y integer :: i , N integer , dimension ( size ( a , dim = 1 )) :: indx real ( double ) :: d N = size ( a , dim = 1 ) if ( N /= size ( a , dim = 2 )) stop 'SUB matinv: ludcmp matrix must be square!' ah = a y = 0. do i = 1 , N y ( i , i ) = 1. d0 enddo call ludcmp ( ah , indx , d ) do i = 1 , N call lubksb ( ah , indx , y (:, i )) enddo b = y end subroutine matinv end module eigensystem","tags":""},{"title":"fidasim.f90 – Fortran Program","loc":"sourcefile/fidasim.f90.html","text":"Source Code !!FIDASIM Version 1.0.0 !The main routine (fidasim) is at the end of the file! module simulation USE H5LT !! High level HDF5 Interface USE HDF5 !! Base HDF5 USE hdf5_extra !! Additional HDF5 routines USE eigensystem , ONLY : eigen , matinv USE parallel_rng implicit none integer , parameter :: long = 4 !bytes = 32 bits (-2,147,483,648 to 2,147,483,647) integer , parameter :: long64 = 8 !bytes = 64 bits (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807) integer , parameter :: float = 4 !bytes = 32 bits (1.2E-38 to 3.4E+38) at 6 decimal places integer , parameter :: double = 8 !bytes = 64 bits (2.3E-308 to 1.7E+308) at 15 decimal places character ( 120 ) :: namelist_file integer , parameter :: nbif_type = 1 ! full energy NBI spectra/density integer , parameter :: nbih_type = 2 ! half energy NBI spectra/density integer , parameter :: nbit_type = 3 ! third energy NBI spectra/density integer , parameter :: halo_type = 4 ! halo spectra/density integer , parameter :: fida_type = 5 ! fida spectra/density integer , parameter :: brems_type = 6 ! brems-strahlung integer , parameter :: ntypes = 6 ! number of different types of neutrals integer , parameter :: beam_ion = 1 integer , parameter :: thermal_ion = 2 !!Physical units: real ( double ), parameter :: e_amu = 5.485799093287202 d - 4 real ( double ), parameter :: H_1_amu = 1.00782504 d0 real ( double ), parameter :: H_2_amu = 2.0141017778 d0 real ( double ), parameter :: B5_amu = 1 0.81 d0 real ( double ), parameter :: C6_amu = 1 2.011 d0 real ( double ), parameter :: mass_u = 1.6605402 d - 27 ! [kg] real ( double ), parameter :: e0 = 1.60217733 d - 19 ! [C] real ( double ), parameter :: pi = 3.14159265358979323846264 d0 real ( double ), parameter :: c0 = 2.99792458 d + 08 !! [m/s] real ( double ), parameter :: h_planck = 4.135667516 d - 15 !![eV/s] real ( double ), parameter :: lambda0 = 656 1. d0 !!D-alpha [A] real ( double ), parameter :: v2_to_E_per_amu = mass_u / ( 2. * e0 * 1. d3 ) * 1. d - 4 !!conversion cm&#94;2/s&#94;2 to keV !! ---- Stark splitting, wavelength and intenisty of all 15 lines ---- !! integer , parameter :: n_stark = 15 real ( double ), parameter , dimension ( n_stark ) :: stark_wavel = & [ - 2.20200 d - 06 , - 1.65200 d - 06 , - 1.37700 d - 06 , - 1.10200 d - 06 , & - 8.26400 d - 07 , - 5.51000 d - 07 , - 2.75600 d - 07 , 0.00000 d0 , & 2.75700 d - 07 , 5.51500 d - 07 , 8.27400 d - 07 , 1.10300 d - 06 , & 1.38000 d - 06 , 1.65600 d - 06 , 2.20900 d - 06 ] real ( double ), parameter , dimension ( n_stark ) :: stark_intens = & [ 1.000 d0 , 1 8.00 d0 , 1 6.00 d0 , 168 1. d0 , 230 4. d0 , & 72 9.0 d0 , 193 6. d0 , 549 0. d0 , 193 6. d0 , 72 9.0 d0 , & 230 4. d0 , 168 1. d0 , 1 6.00 d0 , 1 8.00 d0 , 1.000 d0 ] integer , parameter , dimension ( n_stark ) :: stark_pi = & [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 ] integer , parameter , dimension ( n_stark ) :: stark_sigma = 1 - stark_pi !!Numerical Settings integer , parameter :: nlevs = 6 !!nr of quantum states real ( double ), parameter :: n_halo_neutrate = 2 0. !! to average halo neut-rate real ( double ) :: colrad_threshold = 1. d6 !! to speed up simulation! real ( double ), dimension ( ntypes ) :: halo_iter_dens = 0. d0 integer :: nbi_outside = 0 type BeamGrid !! Beam Grid settings integer ( long ) :: nx !! Nr. of cells in x direction integer ( long ) :: ny !! Nr. of cells in y direction integer ( long ) :: nz !! Nr. of cells in z direction real ( double ) :: xmin , xmax real ( double ) :: ymin , ymax real ( double ) :: zmin , zmax !! Tait-bryan angles for z-y'-x\" rotation real ( double ) :: alpha !! rotation about z real ( double ) :: beta !! rotation about y' real ( double ) :: gamma !! rotation about x\" real ( double ) :: drmin !! min(dx,dy,dz) real ( double ) :: dv !! volume of cells real ( double ) :: volume !! Grid volume integer ( long ) :: ntrack !! Maximum Nr. of cells for tracking integer ( long ) :: ngrid !! Nr. of cells real ( double ), dimension ( 3 ) :: origin real ( double ), dimension ( 3 ) :: center !! Center of grid real ( double ), dimension ( 3 ) :: dr !! dx, dy, dz real ( double ), dimension ( 3 ) :: lwh !! Grid length(x),width(y),height(z) real ( double ), dimension ( 3 , 3 ) :: basis real ( double ), dimension ( 3 , 3 ) :: inv_basis real ( double ), dimension (:), allocatable :: xc !! X centers real ( double ), dimension (:), allocatable :: yc !! Y centers real ( double ), dimension (:), allocatable :: zc !! Z centers end type BeamGrid type InterpolationGrid integer ( long ) :: nr !! Number of radii integer ( long ) :: nz !! Number of Z real ( double ) :: dr !! Radial spacing real ( double ) :: dz !! Vertical spacing real ( double ) :: da !! Area real ( double ), dimension (:), allocatable :: r !! Radius real ( double ), dimension (:), allocatable :: z !! W/Z real ( double ), dimension (:,:), allocatable :: r2d !! 2D radius grid real ( double ), dimension (:,:), allocatable :: z2d !! 2D W grid end type InterpolationGrid type Profiles real ( double ) :: dene = 0. d0 real ( double ) :: denp = 0. d0 real ( double ) :: denimp = 0. d0 real ( double ) :: denf = 0. d0 real ( double ) :: te = 0. d0 real ( double ) :: ti = 0. d0 real ( double ) :: zeff = 0. d0 real ( double ) :: vr = 0. d0 real ( double ) :: vt = 0. d0 real ( double ) :: vz = 0. d0 end type Profiles type , extends ( Profiles ) :: LocalProfiles logical :: in_plasma = . False . real ( double ), dimension ( 3 ) :: pos = [ 0. d0 , 0. d0 , 0. d0 ] real ( double ), dimension ( 3 ) :: vrot = [ 0. d0 , 0. d0 , 0. d0 ] !xyz end type LocalProfiles type EMFields real ( double ) :: br = 0. d0 real ( double ) :: bt = 0. d0 real ( double ) :: bz = 0. d0 real ( double ) :: er = 0. d0 real ( double ) :: et = 0. d0 real ( double ) :: ez = 0. d0 end type EMFields type , extends ( EMFields ) :: LocalEMFields logical :: in_plasma = . False . real ( double ) :: b_abs = 0. d0 real ( double ) :: e_abs = 0. d0 real ( double ), dimension ( 3 ) :: pos = [ 0. d0 , 0. d0 , 0. d0 ] real ( double ), dimension ( 3 ) :: a_norm = [ 0. d0 , 0. d0 , 0. d0 ] real ( double ), dimension ( 3 ) :: b_norm = [ 0. d0 , 0. d0 , 0. d0 ] real ( double ), dimension ( 3 ) :: c_norm = [ 0. d0 , 0. d0 , 0. d0 ] real ( double ), dimension ( 3 ) :: e_norm = [ 0. d0 , 0. d0 , 0. d0 ] end type LocalEMFields type Equilibrium type ( EMFields ), dimension (:,:), allocatable :: fields type ( Profiles ), dimension (:,:), allocatable :: plasma real ( double ), dimension (:,:), allocatable :: mask end type Equilibrium type FastIonDistribution integer ( long ) :: nenergy !! Number of energies integer ( long ) :: npitch !! Number of pitches real ( double ) :: dE !! Energy spacing real ( double ) :: dp !! Pitch spacing real ( double ) :: emin real ( double ) :: emax real ( double ) :: e_range real ( double ) :: pmin real ( double ) :: pmax real ( double ) :: p_range real ( double ), dimension (:), allocatable :: energy !! Energy array real ( double ), dimension (:), allocatable :: pitch !! Pitch array real ( double ), dimension (:,:,:,:), allocatable :: f !! F(E,p,r,w) end type FastIonDistribution type FastIon logical :: cross_grid = . False . real ( double ) :: r = 0. d0 !cm real ( double ) :: z = 0. d0 !cm real ( double ) :: phi_enter = 0. d0 !radians real ( double ) :: delta_phi = 0. d0 !radians real ( double ) :: energy = 0. d0 !keV real ( double ) :: pitch = 0. d0 real ( double ) :: vabs = 0. d0 real ( double ) :: vr = 0. d0 ! Radial velocity real ( double ) :: vt = 0. d0 ! Torodial velocity real ( double ) :: vz = 0. d0 ! Z velocity real ( double ) :: weight = 0. d0 integer ( long ) :: class = 0 end type FastIon type FastIonParticles logical :: guiding_center = . True . integer ( long ) :: nparticle = 0 integer ( long ) :: nclass = 1 type ( FastIon ), dimension (:), allocatable :: fast_ion end type FastIonParticles type NeutralBeam character ( 25 ) :: name = '' !! Beam name integer :: shape !! beam source shape 1=\"rectangular\", 2=\"circular\" real ( double ) :: widy !! half height in y direction real ( double ) :: widz !! half width in z direction real ( double ) :: focy !! focal length in y direction real ( double ) :: focz !! focal length in z direction real ( double ) :: einj !! NBI voltage  [kV] real ( double ) :: pinj !! NBI power    [MW] real ( double ) :: vinj !! NBI velocity [cm/s] real ( double ) :: alpha !! Z rotation not same as beam_grid%alpha real ( double ) :: beta !! Tilt rotation not same as beam_grid%beta real ( double ), dimension ( 3 ) :: divy !! divergence in y direction real ( double ), dimension ( 3 ) :: divz !! divergence in z direction real ( double ), dimension ( 3 ) :: species_mix real ( double ), dimension ( 3 ) :: src !! position of source real ( double ), dimension ( 3 ) :: axis !! position along beam sightline real ( double ), dimension ( 3 , 3 ) :: basis !! Basis of neutral beam real ( double ), dimension ( 3 , 3 ) :: inv_basis !! Inverse of basis end type NeutralBeam type AtomicCrossSection integer :: nenergy = 1 real ( double ) :: logemin = 0. d0 real ( double ) :: logemax = 0. d0 integer :: n_max = nlevs integer :: m_max = nlevs real ( double ) :: dlogE = 0. d0 real ( double ) :: minlog_cross real ( double ), dimension (:,:,:), allocatable :: log_cross end type AtomicCrossSection type AtomicRates integer :: nenergy = 1 real ( double ) :: logemin = 0. d0 real ( double ) :: logemax = 0. d0 integer :: ntemp = 1 real ( double ) :: logtmin = 0. d0 real ( double ) :: logtmax = 0. d0 integer :: n_max = nlevs integer :: m_max = nlevs real ( double ) :: dlogE = 0. d0 real ( double ) :: dlogT = 0. d0 real ( double ) :: minlog_pop = 0. d0 real ( double ) :: minlog_depop = 0. d0 real ( double ), dimension ( 2 ) :: ab = 0. d0 real ( double ), dimension (:,:,:,:,:), allocatable :: log_pop real ( double ), dimension (:,:,:,:), allocatable :: log_depop end type AtomicRates type AtomicTables type ( AtomicCrossSection ) :: H_H_cx type ( AtomicRates ) :: H_H type ( AtomicRates ) :: H_e type ( AtomicRates ) :: H_Aq real ( double ), dimension ( nlevs , nlevs ) :: einstein end type AtomicTables type LineOfSight real ( double ) :: sigma_pi = 1. d0 real ( double ) :: spot_size = 0. d0 ! Radius of spot size real ( double ), dimension ( 3 ) :: lens = [ 0. d0 , 0. d0 , 0. d0 ] ! xyz pos real ( double ), dimension ( 3 ) :: axis = [ 0. d0 , 0. d0 , 0. d0 ] ! xyz dir end type LineOfSight type SpectralChords integer :: nchan = 0 type ( LineOfSight ), dimension (:), allocatable :: los real ( double ), dimension (:), allocatable :: radius logical , dimension (:,:,:), allocatable :: los_inter real ( double ), dimension (:,:,:,:), allocatable :: dlength end type SpectralChords type BoundedPlane integer :: shape = 0 ! 1=\"Rectangular\", 2=\"circular\" real ( double ) :: hh = 0. d0 ! Half height [cm] real ( double ) :: hw = 0. d0 ! Half width [cm] real ( double ), dimension ( 3 ) :: origin = 0. d0 ! Origin of plane in machine coordinates real ( double ), dimension ( 3 , 3 ) :: basis = 0. d0 ! Basis vectors basis(:,1) = u_1 is plane normal real ( double ), dimension ( 3 , 3 ) :: inv_basis = 0. d0 ! Inverse basis end type BoundedPlane type NPADetector type ( BoundedPlane ) :: detector type ( BoundedPlane ) :: aperture end type NPADetector type NPAProbability real ( double ) :: p = 0. d0 real ( double ), dimension ( 3 ) :: eff_rd = [ 0. d0 , 0. d0 , 0. d0 ] !Effective position of detector end type NPAProbability type NPAChords integer :: nchan = 0 type ( NPADetector ), dimension (:), allocatable :: det real ( double ), dimension (:), allocatable :: radius logical , dimension (:,:,:), allocatable :: hit type ( NPAProbability ), dimension (:,:,:,:), allocatable :: phit ! probability of hitting detector end type NPAChords type NPAParticle integer :: detector = 0 real ( double ) :: xi = 0. d0 real ( double ) :: yi = 0. d0 real ( double ) :: zi = 0. d0 real ( double ) :: xf = 0. d0 real ( double ) :: yf = 0. d0 real ( double ) :: zf = 0. d0 real ( double ) :: weight = 0. d0 real ( double ) :: energy = 0. d0 real ( double ) :: pitch = 0. d0 end type NPAParticle type NPAResults integer ( long ) :: nchan = 0 integer ( long ) :: npart = 0 integer ( long ) :: nmax = 1000000 integer ( long ) :: nloop = 1000 type ( NPAParticle ), dimension (:), allocatable :: part real ( double ), dimension (:), allocatable :: energy !! energy array real ( double ), dimension (:,:), allocatable :: flux !! flux end type NPAResults type BirthProfile integer :: ind = 1 real ( double ), dimension (:,:), allocatable :: ri real ( double ), dimension (:,:), allocatable :: vi real ( double ), dimension (:,:,:,:), allocatable :: dens end type BirthProfile type Spectra real ( double ), dimension (:,:), allocatable :: brems real ( double ), dimension (:,:,:), allocatable :: bes real ( double ), dimension (:,:,:), allocatable :: fida end type Spectra type NeutralDensity real ( double ), dimension (:,:,:,:,:), allocatable :: dens end type NeutralDensity type FIDAWeights real ( double ), dimension (:,:), allocatable :: fida real ( double ), dimension (:,:,:), allocatable :: mean_f real ( double ), dimension (:,:,:,:), allocatable :: weight end type FIDAWeights type NPAWeights real ( double ), dimension (:,:,:,:,:), allocatable :: attenuation real ( double ), dimension (:,:,:,:,:), allocatable :: cx real ( double ), dimension (:,:,:,:), allocatable :: emissivity real ( double ), dimension (:,:,:), allocatable :: weight real ( double ), dimension (:,:), allocatable :: flux end type NPAWeights type SimulationInputs integer ( long ) :: shot_number real ( double ) :: time character ( 120 ) :: runid = '' character ( 10 ) :: version = '' character ( 120 ) :: result_dir = '' character ( 120 ) :: tables_file = '' character ( 120 ) :: geometry_file = '' character ( 120 ) :: equilibrium_file = '' character ( 120 ) :: distribution_file = '' character ( 120 ) :: neutrals_file = '' !! Monte Carlo settings integer ( long ) :: n_fida integer ( long ) :: n_npa integer ( long ) :: n_nbi integer ( long ) :: n_dcx integer ( long ) :: n_halo integer ( long ) :: n_birth !! Simulation switches integer ( long ) :: calc_spec integer ( long ) :: calc_brems integer ( long ) :: calc_bes integer ( long ) :: calc_fida integer ( long ) :: load_neutrals integer ( long ) :: calc_npa integer ( long ) :: calc_fida_wght integer ( long ) :: calc_npa_wght integer ( long ) :: calc_birth integer ( long ) :: dump_dcx integer ( long ) :: verbose !! Neutral Beam Settings real ( double ) :: ab !! atomic mass of beam neutrals !! Plasma parameters integer ( long ) :: impurity_charge !! charge of impurity real ( double ) :: ai !! atomic mass of plasma ions !! Distribution settings integer ( long ) :: dist_type !! Spectrum parameters integer ( long ) :: nlambda real ( double ) :: dlambda real ( double ) :: lambdamin real ( double ) :: lambdamax !! Weight function settings integer ( long ) :: ne_wght integer ( long ) :: np_wght integer ( long ) :: nphi_wght integer ( long ) :: nlambda_wght real ( double ) :: emax_wght real ( double ) :: lambdamin_wght real ( double ) :: lambdamax_wght end type SimulationInputs type ParticleTrack real ( double ) :: time = 0. d0 real ( double ) :: flux = 0. d0 integer ( long ), dimension ( 3 ) :: ind = [ 0 , 0 , 0 ] real ( double ), dimension ( 3 ) :: pos = [ 0. d0 , 0. d0 , 0. d0 ] end type ParticleTrack !! operator overloading interface definitions !! this allows for adding,multipying,and dividing !! LocalProfiles/LocalEMFields types interface assignment ( = ) module procedure pp_assign , lpp_assign , plp_assign , lplp_assign , & ff_assign , lff_assign , flf_assign , lflf_assign , & fast_ion_assign , npa_part_assign end interface interface operator ( + ) module procedure pp_add , lplp_add , ff_add , lflf_add end interface interface operator ( - ) module procedure pp_subtract , lplp_subtract , ff_subtract , lflf_subtract end interface interface operator ( * ) module procedure sp_multiply , ps_multiply , lps_multiply , slp_multiply , & sf_multiply , fs_multiply , lfs_multiply , slf_multiply end interface interface operator ( / ) module procedure ps_divide , lps_divide , fs_divide , lfs_divide end interface interface interpol_coeff module procedure interpol1D_coeff , interpol1D_coeff_arr module procedure interpol2D_coeff , interpol2D_coeff_arr end interface interface interpol module procedure interpol1D_arr module procedure interpol2D_arr , interpol2D_2D_arr end interface !! definition of the structures: type ( BeamGrid ) :: beam_grid type ( InterpolationGrid ) :: inter_grid type ( FastIonDistribution ) :: fbm type ( FastIonParticles ) :: particles type ( Equilibrium ) :: equil type ( NeutralBeam ) :: nbi type ( AtomicTables ) :: tables type ( NPAResults ) :: npa type ( SpectralChords ) :: spec_chords type ( NPAChords ) :: npa_chords type ( SimulationInputs ) :: inputs type ( BirthProfile ) :: birth type ( NeutralDensity ) :: neut type ( Spectra ) :: spec type ( FIDAWeights ) :: fweight type ( NPAWeights ) :: nweight contains subroutine print_banner () write ( * , '(a)' ) \"   ____ ____ ___   ___    ____ ____ __  ___\" write ( * , '(a)' ) \"  / __//  _// _ \\ / _ |  / __//  _//  |/  /\" write ( * , '(a)' ) \" / _/ _/ / / // // __ | _\\ \\ _/ / / /|_/ / \" write ( * , '(a)' ) \"/_/  /___//____//_/ |_|/___//___//_/  /_/  \" write ( * , '(a)' ) \"                                           \" write ( * , '(a)' ) \"Version: 1.0.0\" write ( * , '(a)' ) \"\" write ( * , '(a)' ) \"FIDASIM is released as open source code under the MIT Licence.\" write ( * , '(a)' ) \"For more information visit ENTER WEBSITE HERE\" write ( * , '(a)' ) \"\" end subroutine print_banner !============================================================================ !---------------------------Operator Overloading----------------------------- !============================================================================ subroutine fast_ion_assign ( p1 , p2 ) type ( FastIon ), intent ( in ) :: p2 type ( FastIon ), intent ( out ) :: p1 p1 % cross_grid = p2 % cross_grid p1 % r = p2 % r p1 % z = p2 % z p1 % phi_enter = p2 % phi_enter p1 % delta_phi = p2 % delta_phi p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % vabs = p2 % vabs p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % weight = p2 % weight p1 % class = p2 % class end subroutine fast_ion_assign subroutine npa_part_assign ( p1 , p2 ) type ( NPAParticle ), intent ( in ) :: p2 type ( NPAParticle ), intent ( out ) :: p1 p1 % xi = p2 % xi p1 % yi = p2 % yi p1 % zi = p2 % zi p1 % xf = p2 % xf p1 % yf = p2 % yf p1 % zf = p2 % zf p1 % weight = p2 % weight p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % detector = p2 % detector end subroutine npa_part_assign subroutine pp_assign ( p1 , p2 ) type ( Profiles ), intent ( in ) :: p2 type ( Profiles ), intent ( out ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz end subroutine pp_assign subroutine lpp_assign ( p1 , p2 ) type ( Profiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( out ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz end subroutine lpp_assign subroutine plp_assign ( p1 , p2 ) type ( LocalProfiles ), intent ( in ) :: p2 type ( Profiles ), intent ( out ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz end subroutine plp_assign subroutine lplp_assign ( p1 , p2 ) type ( LocalProfiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( out ) :: p1 p1 % pos = p2 % pos p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % vrot = p2 % vrot end subroutine lplp_assign subroutine ff_assign ( p1 , p2 ) type ( EMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( out ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez end subroutine ff_assign subroutine lff_assign ( p1 , p2 ) type ( EMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( out ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez end subroutine lff_assign subroutine flf_assign ( p1 , p2 ) type ( LocalEMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( out ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez end subroutine flf_assign subroutine lflf_assign ( p1 , p2 ) type ( LocalEMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( out ) :: p1 p1 % pos = p2 % pos p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % b_abs = p2 % b_abs p1 % e_abs = p2 % e_abs p1 % a_norm = p2 % a_norm p1 % b_norm = p2 % b_norm p1 % c_norm = p2 % c_norm p1 % e_norm = p2 % e_norm end subroutine lflf_assign function pp_add ( p1 , p2 ) result ( p3 ) type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz end function pp_add function pp_subtract ( p1 , p2 ) result ( p3 ) type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz end function pp_subtract function lplp_add ( p1 , p2 ) result ( p3 ) type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos + p2 % pos p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz p3 % vrot = p1 % vrot + p2 % vrot end function lplp_add function lplp_subtract ( p1 , p2 ) result ( p3 ) type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos - p2 % pos p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz p3 % vrot = p1 % vrot - p2 % vrot end function lplp_subtract function ps_multiply ( p1 , real_scalar ) result ( p3 ) type ( Profiles ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar end function ps_multiply function sp_multiply ( real_scalar , p1 ) result ( p3 ) type ( Profiles ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * real_scalar end function sp_multiply function ps_divide ( p1 , real_scalar ) result ( p3 ) type ( Profiles ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * ( 1. d0 / real_scalar ) end function ps_divide function lps_multiply ( p1 , real_scalar ) result ( p3 ) type ( LocalProfiles ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar p3 % vrot = p1 % vrot * real_scalar end function lps_multiply function slp_multiply ( real_scalar , p1 ) result ( p3 ) type ( LocalProfiles ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * real_scalar end function slp_multiply function lps_divide ( p1 , real_scalar ) result ( p3 ) type ( LocalProfiles ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * ( 1. d0 / real_scalar ) end function lps_divide function ff_add ( p1 , p2 ) result ( p3 ) type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez end function ff_add function ff_subtract ( p1 , p2 ) result ( p3 ) type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez end function ff_subtract function fs_multiply ( p1 , real_scalar ) result ( p3 ) type ( EMFields ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar end function fs_multiply function sf_multiply ( real_scalar , p1 ) result ( p3 ) type ( EMFields ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * real_scalar end function sf_multiply function fs_divide ( p1 , real_scalar ) result ( p3 ) type ( EMFields ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * ( 1. d0 / real_scalar ) end function fs_divide function lflf_add ( p1 , p2 ) result ( p3 ) type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 p3 % pos = p1 % pos + p2 % pos p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez p3 % b_abs = p1 % b_abs + p2 % b_abs p3 % e_abs = p1 % e_abs + p2 % e_abs p3 % a_norm = p1 % a_norm + p2 % a_norm p3 % b_norm = p1 % b_norm + p2 % b_norm p3 % c_norm = p1 % c_norm + p2 % c_norm p3 % e_norm = p1 % e_norm + p2 % e_norm end function lflf_add function lflf_subtract ( p1 , p2 ) result ( p3 ) type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 p3 % pos = p1 % pos - p2 % pos p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez p3 % b_abs = p1 % b_abs - p2 % b_abs p3 % e_abs = p1 % e_abs - p2 % e_abs p3 % a_norm = p1 % a_norm - p2 % a_norm p3 % b_norm = p1 % b_norm - p2 % b_norm p3 % c_norm = p1 % c_norm - p2 % c_norm p3 % e_norm = p1 % e_norm - p2 % e_norm end function lflf_subtract function lfs_multiply ( p1 , real_scalar ) result ( p3 ) type ( LocalEMFields ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar p3 % b_abs = p1 % b_abs * real_scalar p3 % e_abs = p1 % e_abs * real_scalar p3 % a_norm = p1 % a_norm * real_scalar p3 % b_norm = p1 % b_norm * real_scalar p3 % c_norm = p1 % c_norm * real_scalar p3 % e_norm = p1 % e_norm * real_scalar end function lfs_multiply function slf_multiply ( real_scalar , p1 ) result ( p3 ) type ( LocalEMFields ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * real_scalar end function slf_multiply function lfs_divide ( p1 , real_scalar ) result ( p3 ) type ( LocalEMFields ), intent ( in ) :: p1 real ( double ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * ( 1. d0 / real_scalar ) end function lfs_divide !============================================================================ !-------------------------------I/O Routines--------------------------------- !============================================================================ subroutine read_inputs character ( 120 ) :: runid , version , result_dir , tables_file character ( 120 ) :: distribution_file , equilibrium_file character ( 120 ) :: geometry_file , neutrals_file integer :: calc_brems , calc_bes , calc_fida , calc_npa integer :: calc_birth , calc_fida_wght , calc_npa_wght integer :: load_neutrals , verbose , dump_dcx integer ( long ) :: shot , n_fida , n_npa , n_nbi , n_halo , n_dcx , n_birth integer ( long ) :: nlambda , ne_wght , np_wght , nphi_wght , nlambda_wght real ( double ) :: time , lambdamin , lambdamax , emax_wght real ( double ) :: lambdamin_wght , lambdamax_wght real ( double ) :: ai , ab , pinj , einj , species_mix ( 3 ) integer ( long ) :: impurity_charge integer ( long ) :: nx , ny , nz real ( double ) :: xmin , xmax , ymin , ymax , zmin , zmax real ( double ) :: alpha , beta , gamma , origin ( 3 ) logical :: exis , error NAMELIST / fidasim_inputs / result_dir , tables_file , & distribution_file , geometry_file , equilibrium_file , neutrals_file , & shot , time , runid , version , & calc_brems , calc_bes , calc_fida , calc_npa , calc_birth , & calc_fida_wght , calc_npa_wght , load_neutrals , dump_dcx , verbose , & n_fida , n_npa , n_nbi , n_halo , n_dcx , n_birth , & ab , pinj , einj , species_mix , ai , impurity_charge , & nx , ny , nz , xmin , xmax , ymin , ymax , zmin , zmax , & origin , alpha , beta , gamma , & ne_wght , np_wght , nphi_wght , & nlambda , lambdamin , lambdamax , emax_wght , & nlambda_wght , lambdamin_wght , lambdamax_wght inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'READ_INPUTS: Input file does not exist: ' , trim ( namelist_file ) stop endif open ( 13 , file = namelist_file ) read ( 13 , NML = fidasim_inputs ) close ( 13 ) !!General Information inputs % shot_number = shot inputs % time = time inputs % runid = runid inputs % result_dir = result_dir !!Input Files inputs % tables_file = tables_file inputs % geometry_file = geometry_file inputs % equilibrium_file = equilibrium_file inputs % distribution_file = distribution_file inputs % neutrals_file = neutrals_file !!Simulation Switches if (( calc_brems + calc_bes + calc_fida ). gt . 0 ) then inputs % calc_spec = 1 else inputs % calc_spec = 0 endif inputs % calc_brems = calc_brems inputs % calc_bes = calc_bes inputs % calc_fida = calc_fida inputs % calc_npa = calc_npa inputs % calc_birth = calc_birth inputs % calc_fida_wght = calc_fida_wght inputs % calc_npa_wght = calc_npa_wght inputs % load_neutrals = load_neutrals inputs % dump_dcx = dump_dcx inputs % verbose = verbose !!Monte Carlo Settings inputs % n_fida = max ( 10 , n_fida ) inputs % n_npa = max ( 10 , n_npa ) inputs % n_nbi = max ( 10 , n_nbi ) inputs % n_halo = max ( 10 , n_halo ) inputs % n_dcx = max ( 10 , n_dcx ) inputs % n_birth = max ( 1 , nint ( n_birth / real ( n_nbi ))) !!Plasma Settings inputs % ai = ai inputs % impurity_charge = impurity_charge !!Neutral Beam Settings inputs % ab = ab nbi % species_mix = species_mix nbi % einj = einj nbi % pinj = pinj !!Weight Function Settings inputs % ne_wght = ne_wght inputs % np_wght = np_wght inputs % nphi_wght = nphi_wght inputs % emax_wght = emax_wght inputs % nlambda_wght = nlambda_wght inputs % lambdamin_wght = lambdamin_wght inputs % lambdamax_wght = lambdamax_wght !!Wavelength Grid Settings inputs % nlambda = nlambda inputs % lambdamin = lambdamin * 1 0. !convert to angstroms inputs % lambdamax = lambdamax * 1 0. !convert to angstroms inputs % dlambda = ( inputs % lambdamax - inputs % lambdamin ) / inputs % nlambda !!Beam Grid Settings beam_grid % nx = nx beam_grid % ny = ny beam_grid % nz = nz beam_grid % xmin = xmin beam_grid % xmax = xmax beam_grid % ymin = ymin beam_grid % ymax = ymax beam_grid % zmin = zmin beam_grid % zmax = zmax beam_grid % alpha = alpha beam_grid % beta = beta beam_grid % gamma = gamma beam_grid % origin = origin if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Shot settings ----\" write ( * , '(T2,\"Shot: \",i8)' ) inputs % shot_number write ( * , '(T2,\"Time: \",i4,\" [ms]\")' ) int ( inputs % time * 1. d3 ) write ( * , '(T2,\"Runid: \",a)' ) trim ( adjustl ( inputs % runid )) write ( * , * ) '' write ( * , '(a)' ) \"---- input files ----\" endif inquire ( file = inputs % tables_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Tables file: \",a)' ) trim ( inputs % tables_file ) endif else write ( * , '(a,a)' ) 'READ_INPUTS: Tables file does not exist: ' , & trim ( inputs % tables_file ) error = . True . endif inquire ( file = inputs % geometry_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Geometry file: \",a)' ) trim ( inputs % geometry_file ) endif else write ( * , '(a,a)' ) 'READ_INPUTS: Geometry file does not exist: ' , & trim ( inputs % geometry_file ) error = . True . endif inquire ( file = inputs % equilibrium_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Equilibrium file: \",a)' ) trim ( inputs % equilibrium_file ) endif else write ( * , '(a,a)' ) 'READ_INPUTS: Equilibrium file does not exist: ' , & trim ( inputs % equilibrium_file ) error = . True . endif inquire ( file = inputs % distribution_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution file: \",a)' ) trim ( inputs % distribution_file ) endif else write ( * , '(a,a)' ) 'READ_INPUTS: Distribution file does not exist: ' , & trim ( inputs % distribution_file ) error = . True . endif if ( inputs % verbose . ge . 1 ) then write ( * , * ) '' endif if ( error ) then stop endif end subroutine read_inputs subroutine make_beam_grid integer ( long ) :: i real ( double ) :: dx , dy , dz allocate ( beam_grid % xc ( beam_grid % nx ), & beam_grid % yc ( beam_grid % ny ), & beam_grid % zc ( beam_grid % nz )) dx = ( beam_grid % xmax - beam_grid % xmin ) / beam_grid % nx dy = ( beam_grid % ymax - beam_grid % ymin ) / beam_grid % ny dz = ( beam_grid % zmax - beam_grid % zmin ) / beam_grid % nz do i = 1 , beam_grid % nx beam_grid % xc ( i ) = beam_grid % xmin + ( i - 0.5 ) * dx enddo do i = 1 , beam_grid % ny beam_grid % yc ( i ) = beam_grid % ymin + ( i - 0.5 ) * dy enddo do i = 1 , beam_grid % nz beam_grid % zc ( i ) = beam_grid % zmin + ( i - 0.5 ) * dz enddo beam_grid % dr ( 1 ) = abs ( beam_grid % xc ( 2 ) - beam_grid % xc ( 1 )) beam_grid % dr ( 2 ) = abs ( beam_grid % yc ( 2 ) - beam_grid % yc ( 1 )) beam_grid % dr ( 3 ) = abs ( beam_grid % zc ( 2 ) - beam_grid % zc ( 1 )) beam_grid % lwh ( 1 ) = abs ( beam_grid % xc ( beam_grid % nx ) - beam_grid % xc ( 1 )) + beam_grid % dr ( 1 ) beam_grid % lwh ( 2 ) = abs ( beam_grid % yc ( beam_grid % ny ) - beam_grid % yc ( 1 )) + beam_grid % dr ( 2 ) beam_grid % lwh ( 3 ) = abs ( beam_grid % zc ( beam_grid % nz ) - beam_grid % zc ( 1 )) + beam_grid % dr ( 3 ) beam_grid % volume = beam_grid % lwh ( 1 ) * beam_grid % lwh ( 3 ) * beam_grid % lwh ( 3 ) beam_grid % center ( 1 ) = ( minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 )) + 0.5 * beam_grid % lwh ( 1 ) beam_grid % center ( 2 ) = ( minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 )) + 0.5 * beam_grid % lwh ( 2 ) beam_grid % center ( 3 ) = ( minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 )) + 0.5 * beam_grid % lwh ( 3 ) beam_grid % drmin = minval ( beam_grid % dr ) beam_grid % dv = beam_grid % dr ( 1 ) * beam_grid % dr ( 2 ) * beam_grid % dr ( 3 ) beam_grid % ntrack = beam_grid % nx + beam_grid % ny + beam_grid % nz beam_grid % ngrid = beam_grid % nx * beam_grid % ny * beam_grid % nz call tb_zyx ( beam_grid % alpha , beam_grid % beta , beam_grid % gamma , & beam_grid % basis , beam_grid % inv_basis ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Beam grid settings ----\" write ( * , '(T2,\"Nx: \", i3)' ) beam_grid % nx write ( * , '(T2,\"Ny: \", i3)' ) beam_grid % ny write ( * , '(T2,\"Nz: \", i3)' ) beam_grid % nz write ( * , '(T2,\"dV: \", f5.2,\" [cm&#94;3]\")' ) beam_grid % dv write ( * , '(T2,\"alpha: \",f5.2,\" [rad]\")' ) beam_grid % alpha write ( * , '(T2,\"beta:  \",f5.2,\" [rad]\")' ) beam_grid % beta write ( * , '(T2,\"gamma: \",f5.2,\" [rad]\")' ) beam_grid % gamma write ( * , '(T2,\"origin: [\",f7.2,\",\",f7.2,\",\",f7.2,\"] [cm]\")' ) beam_grid % origin write ( * , * ) '' endif end subroutine make_beam_grid subroutine read_beam integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 1 ) :: dims real ( double ), dimension ( 3 ) :: uvw_src , uvw_axis , pos real ( double ) :: dis integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Open NBI group call h5gopen_f ( fid , \"/nbi\" , gid , error ) !!Read in datasets call h5ltread_dataset_string_f ( gid , \"/nbi/name\" , nbi % name , error ) dims ( 1 ) = 3 call h5ltread_dataset_double_f ( gid , \"/nbi/src\" , uvw_src , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/axis\" , uvw_axis , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divy\" , nbi % divy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divz\" , nbi % divz , dims , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/nbi/shape\" , nbi % shape , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focy\" , nbi % focy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focz\" , nbi % focz , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widy\" , nbi % widy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widz\" , nbi % widz , error ) !!Close NBI group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) !!Convert to beam grid coordinates call uvw_to_xyz ( uvw_src , nbi % src ) nbi % axis = matmul ( beam_grid % inv_basis , uvw_axis ) nbi % vinj = sqrt ( 2. d0 * nbi % einj * 1. d3 * e0 / ( inputs % ab * mass_u )) * 1. d2 !! [cm/s] pos = nbi % src + 20 0.0 * nbi % axis dis = sqrt ( sum (( pos - nbi % src ) ** 2.0 )) nbi % beta = asin (( nbi % src ( 3 ) - pos ( 3 )) / dis ) nbi % alpha = atan2 ( pos ( 2 ) - nbi % src ( 2 ), pos ( 1 ) - nbi % src ( 1 )) call tb_zyx ( nbi % alpha , nbi % beta , 0. d0 , nbi % basis , nbi % inv_basis ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Neutral beam settings ----' write ( * , '(T2,\"Beam: \",a)' ) nbi % name write ( * , '(T2,\"Power:   \",f5.2,\" [MW]\")' ) nbi % pinj write ( * , '(T2,\"Voltage: \",f5.2,\" [keV]\")' ) nbi % einj write ( * , * ) '' endif end subroutine read_beam subroutine read_chords integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( double ), dimension (:,:), allocatable :: lenses real ( double ), dimension (:,:), allocatable :: axes real ( double ), dimension (:), allocatable :: spot_size , sigma_pi real ( double ) :: r0 ( 3 ), v0 ( 3 ), r_enter ( 3 ), r_exit ( 3 ) real ( double ) :: xyz_lens ( 3 ), xyz_axis ( 3 ), length real ( double ), dimension ( 3 , 3 ) :: basis real ( double ), dimension ( 2 ) :: randomu real ( double ) :: theta , sqrt_rho type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks character ( len = 20 ) :: system = '' integer :: i , j , ic , nc , ncell , ind ( 3 ) integer :: error if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- FIDA/BES settings ----' endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Check if SPEC group exists call h5ltpath_valid_f ( fid , \"/spec\" , . True ., path_valid , error ) if (. not . path_valid ) then write ( * , '(a)' ) 'FIDA/BES geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without spectral diagnostics' inputs % calc_spec = 0 inputs % calc_fida = 0 inputs % calc_bes = 0 inputs % calc_brems = 0 inputs % calc_fida_wght = 0 return endif !!Open SPEC group call h5gopen_f ( fid , \"/spec\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/spec/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/spec/nchan\" , spec_chords % nchan , error ) allocate ( lenses ( 3 , spec_chords % nchan )) allocate ( axes ( 3 , spec_chords % nchan )) allocate ( spot_size ( spec_chords % nchan )) allocate ( sigma_pi ( spec_chords % nchan )) allocate ( spec_chords % los ( spec_chords % nchan )) allocate ( spec_chords % radius ( spec_chords % nchan )) allocate ( spec_chords % dlength ( spec_chords % nchan , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) allocate ( spec_chords % los_inter ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) spec_chords % dlength = 0. d0 spec_chords % los_inter = . False . dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/spec/lens\" , lenses , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/axis\" , axes , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/spot_size\" , spot_size , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/sigma_pi\" , sigma_pi , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/radius\" , spec_chords % radius , dims ( 2 : 2 ), error ) !!Close SPEC group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) chan_loop : do i = 1 , spec_chords % nchan call uvw_to_xyz ( lenses (:, i ), xyz_lens ) xyz_axis = matmul ( beam_grid % inv_basis , axes (:, i )) spec_chords % los ( i )% lens = xyz_lens spec_chords % los ( i )% axis = xyz_axis spec_chords % los ( i )% sigma_pi = sigma_pi ( i ) spec_chords % los ( i )% spot_size = spot_size ( i ) r0 = xyz_lens v0 = xyz_axis v0 = v0 / normp ( v0 ) call line_basis ( r0 , v0 , basis ) call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) if ( length . le . 0. d0 ) then WRITE ( * , '(\"Channel \",i3,\" missed the beam grid\")' ), i cycle chan_loop endif if ( spot_size ( i ). le . 0. d0 ) then nc = 1 else nc = 100 endif !$OMP PARALLEL DO schedule(guided) private(ic,randomu,sqrt_rho,theta,r0, & !$OMP& length, r_enter, r_exit, j, tracks, ncell, ind) do ic = 1 , nc ! Uniformally sample within spot size call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0. d0 r0 ( 2 ) = spot_size ( i ) * sqrt_rho * cos ( theta ) r0 ( 3 ) = spot_size ( i ) * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + xyz_lens call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) call track ( r_enter , v0 , tracks , ncell ) track_loop : do j = 1 , ncell ind = tracks ( j )% ind !inds can repeat so add rather than assign !$OMP CRITICAL(read_chords_1) spec_chords % dlength ( i , ind ( 1 ), ind ( 2 ), ind ( 3 )) = & spec_chords % dlength ( i , ind ( 1 ), ind ( 2 ), ind ( 3 )) + tracks ( j )% time / real ( nc ) !time == distance spec_chords % los_inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) = . True . !$OMP END CRITICAL(read_chords_1) enddo track_loop enddo !$OMP END PARALLEL DO enddo chan_loop if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"FIDA/BES System: \",a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i3)' ) spec_chords % nchan write ( * , * ) '' endif deallocate ( lenses , axes , spot_size , sigma_pi ) end subroutine read_chords subroutine read_npa integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( double ), dimension (:,:), allocatable :: a_tedge , a_redge , a_cent real ( double ), dimension (:,:), allocatable :: d_tedge , d_redge , d_cent integer , dimension (:), allocatable :: a_shape , d_shape character ( len = 20 ) :: system = '' real ( double ), dimension ( 3 ) :: xyz_a_tedge , xyz_a_redge , xyz_a_cent real ( double ), dimension ( 3 ) :: xyz_d_tedge , xyz_d_redge , xyz_d_cent real ( double ), dimension ( 3 ) :: eff_rd , rd , rd_d , r0 , r0_d , v0 real ( double ), dimension ( 3 , 3 ) :: basis , inv_basis real ( double ), dimension ( 50 ) :: xd , yd real ( double ), dimension (:,:,:,:,:), allocatable :: effrd real ( double ), dimension (:,:,:,:), allocatable :: phit real ( double ) :: total_prob , hh , hw , dprob , dx , dy , r integer :: ichan , i , j , k , ix , iy , d_index , nd , cnt integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDWR_F , fid , error ) !!Check if NPA group exists call h5ltpath_valid_f ( fid , \"/npa\" , . True ., path_valid , error ) if (. not . path_valid ) then write ( * , '(a)' ) 'NPA geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without NPA diagnostics' inputs % calc_npa = 0 inputs % calc_npa_wght = 0 return endif !!Open NPA group call h5gopen_f ( fid , \"/npa\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/npa/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/npa/nchan\" , npa_chords % nchan , error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- NPA settings ----\" write ( * , '(T2,\"NPA System: \", a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i3)' ) npa_chords % nchan endif allocate ( a_tedge ( 3 , npa_chords % nchan )) allocate ( a_redge ( 3 , npa_chords % nchan )) allocate ( a_cent ( 3 , npa_chords % nchan )) allocate ( a_shape ( npa_chords % nchan )) allocate ( d_tedge ( 3 , npa_chords % nchan )) allocate ( d_redge ( 3 , npa_chords % nchan )) allocate ( d_cent ( 3 , npa_chords % nchan )) allocate ( d_shape ( npa_chords % nchan )) allocate ( npa_chords % radius ( npa_chords % nchan )) allocate ( npa_chords % det ( npa_chords % nchan )) allocate ( npa_chords % phit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan ) ) allocate ( npa_chords % hit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) npa_chords % hit = . False . allocate ( effrd ( 3 , beam_grid % nx ,& beam_grid % ny ,& beam_grid % nz ,& npa_chords % nchan ) ) allocate ( phit ( beam_grid % nx ,& beam_grid % ny ,& beam_grid % nz ,& npa_chords % nchan ) ) effrd = 0. d0 phit = 0. d0 dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/npa/radius\" , npa_chords % radius , dims ( 2 : 2 ), error ) call h5ltread_dataset_int_f ( gid , \"/npa/a_shape\" , a_shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_tedge\" , a_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_redge\" , a_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_cent\" , a_cent , dims , error ) call h5ltread_dataset_int_f ( gid , \"/npa/d_shape\" , d_shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_tedge\" , d_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_redge\" , d_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_cent\" , d_cent , dims , error ) !!Close NPA group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) ! Define detector/aperture shape npa_chords % det % detector % shape = d_shape npa_chords % det % aperture % shape = a_shape if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,a)' ) \"Calculating hit probabilities for NPA channels\" endif chan_loop : do ichan = 1 , npa_chords % nchan ! Convert to beam grid coordinates call uvw_to_xyz ( a_cent (:, ichan ), xyz_a_cent ) call uvw_to_xyz ( a_redge (:, ichan ), xyz_a_redge ) call uvw_to_xyz ( a_tedge (:, ichan ), xyz_a_tedge ) call uvw_to_xyz ( d_cent (:, ichan ), xyz_d_cent ) call uvw_to_xyz ( d_redge (:, ichan ), xyz_d_redge ) call uvw_to_xyz ( d_tedge (:, ichan ), xyz_d_tedge ) ! Define detector/aperture hh/hw npa_chords % det ( ichan )% detector % hw = normp ( xyz_d_redge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hw = normp ( xyz_a_redge - xyz_a_cent ) npa_chords % det ( ichan )% detector % hh = normp ( xyz_d_tedge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hh = normp ( xyz_a_tedge - xyz_a_cent ) ! Define detector/aperture origin npa_chords % det ( ichan )% detector % origin = xyz_d_cent npa_chords % det ( ichan )% aperture % origin = xyz_a_cent ! Define detector/aperture basis call plane_basis ( xyz_d_cent , xyz_d_redge , xyz_d_tedge , & npa_chords % det ( ichan )% detector % basis , & npa_chords % det ( ichan )% detector % inv_basis ) call plane_basis ( xyz_a_cent , xyz_a_redge , xyz_a_tedge , & npa_chords % det ( ichan )% aperture % basis , & npa_chords % det ( ichan )% aperture % inv_basis ) hw = npa_chords % det ( ichan )% detector % hw hh = npa_chords % det ( ichan )% detector % hh nd = size ( xd ) do i = 1 , nd xd ( i ) = - hw + 2 * hw * ( i - 0.5 ) / real ( nd ) yd ( i ) = - hh + 2 * hh * ( i - 0.5 ) / real ( nd ) enddo dx = abs ( xd ( 2 ) - xd ( 1 )) dy = abs ( yd ( 2 ) - yd ( 1 )) basis = npa_chords % det ( ichan )% detector % basis inv_basis = npa_chords % det ( ichan )% detector % inv_basis cnt = 0 ! For each grid point find the probability of hitting the detector given an isotropic source !$OMP PARALLEL DO schedule(guided) collapse(3) private(i,j,k,ix,iy,total_prob,eff_rd,r0,r0_d, & !$OMP& rd_d,rd,d_index,v0,dprob,r) do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx cnt = cnt + 1 total_prob = 0. d0 eff_rd = eff_rd * 0. d0 r0 = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] r0_d = matmul ( inv_basis , r0 - xyz_d_cent ) do ix = 1 , nd do iy = 1 , nd rd_d = [ xd ( ix ), yd ( iy ), 0. d0 ] rd = matmul ( basis , rd_d ) + xyz_d_cent v0 = rd - r0 d_index = 0 call hit_npa_detector ( r0 , v0 , d_index ) if ( d_index . ne . 0 ) then r = normp ( rd_d - r0_d ) ** 2.0 dprob = ( dx * dy ) * (( 4 * pi ) ** ( - 1.0 )) * r0_d ( 3 ) * ( r ** ( - 1.5 )) eff_rd = eff_rd + dprob * rd total_prob = total_prob + dprob endif enddo !yd loop enddo !xd loop if ( total_prob . gt . 0.0 ) then eff_rd = eff_rd / total_prob phit ( i , j , k , ichan ) = total_prob call xyz_to_uvw ( eff_rd , effrd (:, i , j , k , ichan )) npa_chords % phit ( i , j , k , ichan )% p = total_prob npa_chords % phit ( i , j , k , ichan )% eff_rd = eff_rd npa_chords % hit ( i , j , k ) = . True . endif if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(T4,\"Channel: \",i3,\" \",f7.2,\"% completed\",a,$)' ) & ichan , cnt / real ( beam_grid % ngrid ) * 100 , char ( 13 ) endif enddo !x loop enddo !y loop enddo !z loop !$OMP END PARALLEL DO total_prob = sum ( npa_chords % phit (:,:,:, ichan )% p ) if ( total_prob . le . 0. d0 ) then WRITE ( * , '(\"Channel \",i3,\" missed the beam grid\")' ), ichan cycle chan_loop endif enddo chan_loop if ( inputs % verbose . ge . 1 ) write ( * , '(50X,a)' ) \"\" deallocate ( phit , effrd ) deallocate ( a_shape , a_cent , a_redge , a_tedge ) deallocate ( d_shape , d_cent , d_redge , d_tedge ) end subroutine read_npa subroutine read_equilibrium integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims integer :: impc integer :: error integer , dimension (:,:), allocatable :: p_mask , f_mask !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % equilibrium_file , H5F_ACC_RDONLY_F , fid , error ) !!Open PLASMA group call h5gopen_f ( fid , \"/plasma\" , gid , error ) !!Read in interpolation grid call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nr\" , inter_grid % nr , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nz\" , inter_grid % nz , error ) allocate ( inter_grid % r ( inter_grid % nr ), inter_grid % z ( inter_grid % nz )) allocate ( inter_grid % r2d ( inter_grid % nr , inter_grid % nz )) allocate ( inter_grid % z2d ( inter_grid % nr , inter_grid % nz )) allocate ( p_mask ( inter_grid % nr , inter_grid % nz )) allocate ( f_mask ( inter_grid % nr , inter_grid % nz )) dims = [ inter_grid % nr , inter_grid % nz ] call h5ltread_dataset_double_f ( gid , \"/plasma/r\" , inter_grid % r , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( gid , \"/plasma/z\" , inter_grid % z , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/plasma/r2d\" , inter_grid % r2d , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/z2d\" , inter_grid % z2d , dims , error ) inter_grid % dr = abs ( inter_grid % r ( 2 ) - inter_grid % r ( 1 )) inter_grid % dz = abs ( inter_grid % z ( 2 ) - inter_grid % z ( 1 )) inter_grid % da = inter_grid % dr * inter_grid % dz if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Interpolation grid settings ----' write ( * , '(T2,\"Nr: \",i3)' ) inter_grid % nr write ( * , '(T2,\"Nz: \",i3)' ) inter_grid % nz write ( * , '(T2,\"dA: \", f4.2,\" [cm&#94;2]\")' ) inter_grid % da write ( * , * ) '' endif !!Read in plasma parameters allocate ( equil % plasma ( inter_grid % nr , inter_grid % nz )) call h5ltread_dataset_double_f ( gid , \"/plasma/dene\" , equil % plasma % dene , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/te\" , equil % plasma % te , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/ti\" , equil % plasma % ti , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/zeff\" , equil % plasma % zeff , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vr\" , equil % plasma % vr , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vt\" , equil % plasma % vt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vz\" , equil % plasma % vz , dims , error ) call h5ltread_dataset_int_f ( gid , \"/plasma/mask\" , p_mask , dims , error ) impc = inputs % impurity_charge equil % plasma % denimp = (( equil % plasma % zeff - 1. d0 ) / ( impc * ( impc - 1. d0 ))) * equil % plasma % dene equil % plasma % denp = equil % plasma % dene - impc * equil % plasma % denimp !!Close PLASMA group call h5gclose_f ( gid , error ) !!Open FIELDS group call h5gopen_f ( fid , \"/fields\" , gid , error ) allocate ( equil % fields ( inter_grid % nr , inter_grid % nz )) !!Read in electromagnetic fields call h5ltread_dataset_double_f ( gid , \"/fields/br\" , equil % fields % br , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bt\" , equil % fields % bt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bz\" , equil % fields % bz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/er\" , equil % fields % er , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/et\" , equil % fields % et , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/ez\" , equil % fields % ez , dims , error ) call h5ltread_dataset_int_f ( gid , \"/fields/mask\" , f_mask , dims , error ) !!Close FIELDS group call h5gclose_f ( gid , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) allocate ( equil % mask ( inter_grid % nr , inter_grid % nz )) equil % mask = 0. d0 where (( p_mask . eq . 1 ). and .( f_mask . eq . 1 )) equil % mask = 1. d0 end subroutine read_equilibrium subroutine read_f ( fid , error ) integer ( HID_T ), intent ( inout ) :: fid integer , intent ( out ) :: error integer ( HSIZE_T ), dimension ( 4 ) :: dims real ( double ) :: dummy ( 1 ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nenergy\" , fbm % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/npitch\" , fbm % npitch , error ) allocate ( fbm % energy ( fbm % nenergy ), fbm % pitch ( fbm % npitch )) allocate ( fbm % f ( fbm % nenergy , fbm % npitch , inter_grid % nr , inter_grid % nz )) dims = [ fbm % nenergy , fbm % npitch , inter_grid % nr , inter_grid % nz ] call h5ltread_dataset_double_f ( fid , \"/energy\" , fbm % energy , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , fbm % pitch , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( fid , \"/f\" , fbm % f , dims , error ) call h5ltread_dataset_double_f ( fid , \"/denf\" , equil % plasma % denf , dims ( 3 : 4 ), error ) fbm % dE = abs ( fbm % energy ( 2 ) - fbm % energy ( 1 )) fbm % dp = abs ( fbm % pitch ( 2 ) - fbm % pitch ( 1 )) dummy = minval ( fbm % energy ) fbm % emin = dummy ( 1 ) dummy = maxval ( fbm % energy ) fbm % emax = dummy ( 1 ) fbm % e_range = fbm % emax - fbm % emin dummy = minval ( fbm % pitch ) fbm % pmin = dummy ( 1 ) dummy = maxval ( fbm % pitch ) fbm % pmax = dummy ( 1 ) fbm % p_range = fbm % pmax - fbm % pmin if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) \"Fast-ion Density Function F(energy,pitch,R,Z)\" write ( * , '(T2,\"Nenergy = \",i3)' ), fbm % nenergy write ( * , '(T2,\"Npitch  = \",i3)' ), fbm % npitch write ( * , '(T2,\"Energy range = [\",f5.2,\",\",f6.2,\"]\")' ), fbm % emin , fbm % emax write ( * , '(T2,\"Pitch  range = [\",f5.2,\",\",f5.2,\"]\")' ), fbm % pmin , fbm % pmax write ( * , * ) '' endif end subroutine read_f subroutine read_mc ( fid , error ) integer ( HID_T ), intent ( inout ) :: fid integer , intent ( out ) :: error integer ( HSIZE_T ), dimension ( 1 ) :: dims integer ( long ) :: i , ii , ir , iz , nphi real ( double ) :: phi , xmin , xmax , ymin , ymax , zmin , zmax real ( double ) :: phi_enter , delta_phi real ( double ), dimension ( 3 ) :: uvw , xyz integer ( long ), dimension ( 1 ) :: minpos logical :: in_grid real ( double ), dimension (:), allocatable :: weight real ( double ), dimension (:), allocatable :: r , z , vr , vt , vz real ( double ), dimension (:), allocatable :: energy , pitch integer ( long ), dimension (:), allocatable :: orbit_class integer :: cnt , num character ( len = 32 ) :: dist_type_name = '' if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nparticle\" , particles % nparticle , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nclass\" , particles % nclass , error ) !!ALLOCATE SPACE allocate ( particles % fast_ion ( particles % nparticle )) allocate ( r ( particles % nparticle )) allocate ( z ( particles % nparticle )) allocate ( weight ( particles % nparticle )) allocate ( orbit_class ( particles % nparticle )) dims ( 1 ) = particles % nparticle call h5ltread_dataset_double_f ( fid , \"/r\" , r , dims , error ) call h5ltread_dataset_double_f ( fid , \"/z\" , z , dims , error ) call h5ltread_dataset_double_f ( fid , \"/weight\" , weight , dims , error ) call h5ltread_dataset_int_f ( fid , \"/class\" , orbit_class , dims , error ) if ( inputs % dist_type . eq . 2 ) then dist_type_name = \"Guiding Center Monte Carlo\" allocate ( energy ( particles % nparticle )) allocate ( pitch ( particles % nparticle )) call h5ltread_dataset_double_f ( fid , \"/energy\" , energy , dims , error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , pitch , dims , error ) particles % guiding_center = . True . else dist_type_name = \"Full Orbit Monte Carlo\" allocate ( vr ( particles % nparticle )) allocate ( vt ( particles % nparticle )) allocate ( vz ( particles % nparticle )) call h5ltread_dataset_double_f ( fid , \"/vr\" , vr , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vt\" , vt , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vz\" , vz , dims , error ) particles % guiding_center = . False . endif xmin = beam_grid % xmin xmax = beam_grid % xmax ymin = beam_grid % ymin ymax = beam_grid % ymax zmin = beam_grid % zmin zmax = beam_grid % zmax cnt = 0 num = 0 nphi = 1000 !$OMP PARALLEL DO schedule(guided) private(i,ii,ir,iz,phi,uvw,xyz, & !$OMP& in_grid,minpos,delta_phi,phi_enter) do i = 1 , particles % nparticle if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt / real ( particles % nparticle ) * 100 , char ( 13 ) endif delta_phi = 0.0 phi_enter = 0.0 phi = 0.0 do ii = 1 , nphi phi = phi + 2 * pi / dble ( nphi ) uvw ( 1 ) = r ( i ) * cos ( phi ) uvw ( 2 ) = r ( i ) * sin ( phi ) uvw ( 3 ) = z ( i ) call uvw_to_xyz ( uvw , xyz ) if ((( xyz ( 1 ). ge . xmin . and . xyz ( 1 ). le . xmax ). and . & ( xyz ( 2 ). ge . ymin . and . xyz ( 2 ). le . ymax ). and . & ( xyz ( 3 ). ge . zmin . and . xyz ( 3 ). le . zmax ))) then delta_phi = delta_phi + 2 * pi / dble ( nphi ) if ( ii . ne . 1 ) then if (. not . in_grid ) phi_enter = phi endif in_grid = . True . else in_grid = . False . endif enddo minpos = minloc ( abs ( inter_grid % r - r ( i ))) ir = minpos ( 1 ) minpos = minloc ( abs ( inter_grid % z - z ( i ))) iz = minpos ( 1 ) equil % plasma ( ir , iz )% denf = equil % plasma ( ir , iz )% denf + weight ( i ) / ( 2 * pi * r ( i ) * inter_grid % da ) particles % fast_ion ( i )% r = r ( i ) particles % fast_ion ( i )% z = z ( i ) particles % fast_ion ( i )% phi_enter = phi_enter particles % fast_ion ( i )% delta_phi = delta_phi particles % fast_ion ( i )% weight = weight ( i ) * ( delta_phi / ( 2 * pi )) / beam_grid % dv particles % fast_ion ( i )% class = orbit_class ( i ) if ( delta_phi . gt . 0 ) then particles % fast_ion ( i )% cross_grid = . True . else particles % fast_ion ( i )% cross_grid = . False . endif if ( particles % guiding_center ) then particles % fast_ion ( i )% energy = energy ( i ) particles % fast_ion ( i )% pitch = pitch ( i ) particles % fast_ion ( i )% vabs = sqrt ( energy ( i ) / ( v2_to_E_per_amu * inputs % ab )) else particles % fast_ion ( i )% vr = vr ( i ) particles % fast_ion ( i )% vt = vt ( i ) particles % fast_ion ( i )% vz = vz ( i ) particles % fast_ion ( i )% vabs = sqrt ( vr ( i ) ** 2 + vt ( i ) ** 2 + vz ( i ) ** 2 ) endif if ( delta_phi . gt . 0. d0 ) num = num + 1 cnt = cnt + 1 enddo !$OMP END PARALLEL DO if ( num . le . 0 ) then write ( * , '(a)' ) 'READ_MC: No mc particles in beam grid' stop endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) dist_type_name write ( * , '(T2,\"Number of mc particles: \",i9)' ) particles % nparticle write ( * , '(T2,\"Number of orbit classes: \",i6)' ) particles % nclass write ( * , * ) '' endif end subroutine read_mc subroutine read_distribution integer ( HID_T ) :: fid integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % distribution_file , H5F_ACC_RDONLY_F , fid , error ) !!Get distribution type call h5ltread_dataset_int_scalar_f ( fid , \"/type\" , inputs % dist_type , error ) if ( inputs % dist_type . eq . 1 ) then call read_f ( fid , error ) else !2 or 3 call read_mc ( fid , error ) endif !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) end subroutine read_distribution subroutine read_cross ( fid , grp , cross ) integer ( HID_T ), intent ( in ) :: fid character ( len =* ), intent ( in ) :: grp type ( AtomicCrossSection ), intent ( inout ) :: cross integer ( HSIZE_T ), dimension ( 3 ) :: dim3 real ( double ) :: emin , emax , rmin integer :: i , n_max , m_max , error real ( double ), dimension (:,:,:), allocatable :: dummy3 call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , cross % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , cross % dlogE , error ) cross % logemin = log10 ( emin ) cross % logemax = log10 ( emax ) allocate ( dummy3 ( n_max , m_max , cross % nenergy )) allocate ( cross % log_cross ( cross % m_max , cross % n_max , cross % nenergy )) dim3 = [ n_max , m_max , tables % H_H_cx % nenergy ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy3 , dim3 , error ) rmin = minval ( dummy3 , dummy3 . gt . 0. d0 ) where ( dummy3 . le . 0.0 ) dummy3 = 0.9 * rmin end where cross % minlog_cross = log10 ( rmin ) do i = 1 , cross % nenergy cross % log_cross (:,:, i ) = log10 ( transpose ( dummy3 ( 1 : nlevs , 1 : nlevs , i ))) enddo deallocate ( dummy3 ) end subroutine read_cross subroutine read_rates ( fid , grp , b_amu , t_amu , rates ) integer ( HID_T ), intent ( in ) :: fid character ( len =* ), intent ( in ) :: grp real ( double ), dimension ( 2 ), intent ( in ) :: b_amu real ( double ), intent ( in ) :: t_amu type ( AtomicRates ), intent ( inout ) :: rates integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 logical :: path_valid integer :: i , j , n , n_max , m_max , error integer :: n_bt_amu , tt_ind , bt_ind , drank real ( double ) :: emin , emax , tmin , tmax , rmin real ( double ) :: bt_min , tt_min , tt_dum , bt_dum real ( double ), dimension ( 2 ) :: bt_amu , tt_amu real ( double ), dimension (:,:), allocatable :: dummy2 real ( double ), dimension (:,:,:,:), allocatable :: dummy4 real ( double ), dimension (:,:,:,:,:), allocatable :: dummy5 call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_bt_amu\" , n_bt_amu , error ) allocate ( dummy2 ( 2 , n_bt_amu )) dim2 = [ 2 , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , dummy2 , dim2 , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) bt_ind = 1 tt_ind = 1 bt_amu = [ b_amu ( 1 ), t_amu ] tt_amu = [ b_amu ( 2 ), t_amu ] bt_min = normp ( bt_amu - dummy2 (:, 1 )) tt_min = normp ( tt_amu - dummy2 (:, 1 )) do i = 2 , n_bt_amu bt_dum = normp ( bt_amu - dummy2 (:, i )) tt_dum = normp ( tt_amu - dummy2 (:, i )) if ( bt_dum . lt . bt_min ) then bt_min = bt_dum bt_ind = i endif if ( tt_dum . lt . tt_min ) then tt_min = tt_dum tt_ind = i endif enddo rates % ab ( 1 ) = dummy2 ( 1 , bt_ind ) rates % ab ( 2 ) = dummy2 ( 1 , tt_ind ) deallocate ( dummy2 ) allocate ( rates % log_pop (& rates % m_max , & rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) allocate ( rates % log_depop (& rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) rates % log_pop = 0. d0 rates % log_depop = 0. d0 !!Read CX call h5ltpath_valid_f ( fid , grp // \"/cx\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltget_dataset_ndims_f ( fid , grp // \"/cx\" , drank , error ) if ( drank . eq . 4 ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif if ( drank . eq . 5 ) then allocate ( dummy5 ( n_max , m_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif endif !!Read ionization call h5ltpath_valid_f ( fid , grp // \"/ionization\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/ionization\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif !!Read excitation call h5ltpath_valid_f ( fid , grp // \"/excitation\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy5 ( n_max , m_max ,& rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/excitation\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy rates % log_pop (:,:, i , j , 1 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , bt_ind )) rates % log_pop (:,:, i , j , 2 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , tt_ind )) do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif rmin = minval ( rates % log_depop , rates % log_depop . gt . 0. d0 ) where ( rates % log_depop . le . 0. d0 ) rates % log_depop = 0.9 * rmin end where rates % minlog_depop = log10 ( rmin ) rates % log_depop = log10 ( rates % log_depop ) rmin = minval ( rates % log_pop , rates % log_pop . gt . 0. d0 ) where ( rates % log_pop . le . 0. d0 ) rates % log_pop = 0.9 * rmin end where rates % minlog_pop = log10 ( rmin ) rates % log_pop = log10 ( rates % log_pop ) end subroutine read_rates subroutine read_tables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error integer :: n_max , m_max character ( len = 4 ) :: impname real ( double ) :: imp_amu real ( double ), dimension ( 2 ) :: b_amu real ( double ), dimension (:,:), allocatable :: dummy2 if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Atomic tables settings ----\" endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % tables_file , H5F_ACC_RDONLY_F , fid , error ) !!Read Hydrogen-Hydrogen CX Cross Sections call read_cross ( fid , \"/cross/H_H\" , tables % H_H_cx ) !!Read Hydrogen-Hydrogen Rates b_amu = [ inputs % ab , inputs % ai ] call read_rates ( fid , \"/rates/H_H\" , b_amu , inputs % ai , tables % H_H ) inputs % ab = tables % H_H % ab ( 1 ) inputs % ai = tables % H_H % ab ( 2 ) !!Read Hydrogen-Electron Rates call read_rates ( fid , \"/rates/H_e\" , b_amu , e_amu , tables % H_e ) !!Read Hydrogen-Impurity rates impname = '' select case ( inputs % impurity_charge ) case ( 5 ) impname = \"B5\" imp_amu = B5_amu case ( 6 ) impname = \"C6\" imp_amu = C6_amu case DEFAULT impname = \"Aq\" imp_amu = 2. d0 * inputs % impurity_charge end select call read_rates ( fid , \"/rates/H_\" // trim ( adjustl ( impname )), b_amu , imp_amu , tables % H_Aq ) !!Read Einstein coefficients call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/m_max\" , m_max , error ) allocate ( dummy2 ( n_max , m_max )) dim2 = [ n_max , m_max ] call h5ltread_dataset_double_f ( fid , \"/rates/spontaneous/einstein\" , dummy2 , dim2 , error ) tables % einstein (:,:) = transpose ( dummy2 ( 1 : nlevs , 1 : nlevs )) deallocate ( dummy2 ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Maximum n/m: \",i2)' ) nlevs write ( * , '(T2,\"Beam/Fast-ion mass: \",f6.3,\" [amu]\")' ) inputs % ab write ( * , '(T2,\"Thermal/Bulk-ion mass: \",f6.3,\" [amu]\")' ) inputs % ai write ( * , '(T2,\"Impurity mass: \",f6.3,\" [amu]\")' ) imp_amu write ( * , * ) '' endif end subroutine read_tables subroutine write_beam_grid ( id , error ) integer ( HID_T ), intent ( inout ) :: id integer , intent ( out ) :: error integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 3 ) :: dims real ( double ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: u_grid , v_grid , w_grid real ( double ) :: xyz ( 3 ), uvw ( 3 ) integer :: i , j , k !Create uvw grids do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx xyz = [ beam_grid % xc ( i ), & beam_grid % yc ( j ), & beam_grid % zc ( k )] call xyz_to_uvw ( xyz , uvw ) u_grid ( i , j , k ) = uvw ( 1 ) v_grid ( i , j , k ) = uvw ( 2 ) w_grid ( i , j , k ) = uvw ( 3 ) enddo enddo enddo !Create grid group call h5gcreate_f ( id , \"grid\" , gid , error ) !Write variables dims ( 1 ) = 1 call h5ltmake_dataset_int_f ( gid , \"nx\" , 0 , dims ( 1 : 1 ), [ beam_grid % nx ], error ) call h5ltmake_dataset_int_f ( gid , \"ny\" , 0 , dims ( 1 : 1 ), [ beam_grid % ny ], error ) call h5ltmake_dataset_int_f ( gid , \"nz\" , 0 , dims ( 1 : 1 ), [ beam_grid % nz ], error ) dims = [ beam_grid % nx , beam_grid % ny , beam_grid % nz ] call h5ltmake_compressed_dataset_double_f ( gid , \"x\" , 1 , dims ( 1 : 1 ), beam_grid % xc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y\" , 1 , dims ( 2 : 2 ), beam_grid % yc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z\" , 1 , dims ( 3 : 3 ), beam_grid % zc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"x_grid\" , 3 , dims , u_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y_grid\" , 3 , dims , v_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z_grid\" , 3 , dims , w_grid , error ) !Write attributes call h5ltset_attribute_string_f ( gid , \"nx\" , \"description\" , & \"Number of cells in the X direction\" , error ) call h5ltset_attribute_string_f ( gid , \"ny\" , \"description\" , & \"Number of cells in the Y direction\" , error ) call h5ltset_attribute_string_f ( gid , \"nz\" , \"description\" , & \"Number of cells in the Z direction\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"description\" , & \"X value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"description\" , & \"Y value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"description\" , & \"Z value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"description\" , & \"X value of cell center in machine coordinates: x_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"description\" , & \"Y value of cell center in machine coordinates: y_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"description\" , & \"Z value of cell center in machine coordinates: z_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( id , \"grid\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) !Close grid group call h5gclose_f ( gid , error ) end subroutine write_beam_grid subroutine write_birth_profile integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error , i character ( 120 ) :: filename real ( double ), dimension (:,:), allocatable :: ri real ( double ), dimension (:,:), allocatable :: vi real ( double ), dimension ( 3 ) :: xyz , uvw , v_uvw allocate ( ri ( 3 , size ( birth % ri , 2 ))) allocate ( vi ( 3 , size ( birth % vi , 2 ))) do i = 1 , size ( birth % ri , 2 ) ! Convert position to rzphi xyz = birth % ri (:, i ) call xyz_to_uvw ( xyz , uvw ) ri ( 1 , i ) = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) ri ( 2 , i ) = uvw ( 3 ) ri ( 3 , i ) = atan2 ( uvw ( 2 ), uvw ( 1 )) ! Convert velocity to rzphi v_uvw = matmul ( beam_grid % basis , birth % vi (:, i )) vi ( 1 , i ) = v_uvw ( 1 ) * cos ( ri ( 3 , i )) + v_uvw ( 2 ) * sin ( ri ( 3 , i )) vi ( 2 , i ) = v_uvw ( 3 ) vi ( 3 , i ) = - v_uvw ( 1 ) * sin ( ri ( 3 , i )) + v_uvw ( 2 ) * cos ( ri ( 3 , i )) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_birth.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/n_nbi\" , 0 , d , [ inputs % n_nbi ], error ) call h5ltmake_dataset_int_f ( fid , \"/n_birth\" , 0 , d , [ inputs % n_birth ], error ) dim4 = shape ( birth % dens ) call h5ltmake_compressed_dataset_double_f ( fid , \"/dens\" , 4 , dim4 , birth % dens , error ) dim2 = shape ( birth % ri ) call h5ltmake_compressed_dataset_double_f ( fid , \"/ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vi\" , 2 , dim2 , vi , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/n_nbi\" , \"description\" , & \"Number of beam mc particles\" , error ) call h5ltset_attribute_string_f ( fid , \"/n_birth\" , \"description\" , & \"Number of birth mc particles deposited per beam mc particle\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"description\" , & \"Birth density: dens(beam_component,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"units\" , & \"fast-ions/(s*cm&#94;3*dE*dP)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"description\" , & \"Fast-ion birth position in R-Z-Phi: ri([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"units\" , \"cm, radians\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"description\" , & \"Fast-ion birth velocity in R-Z-Phi: vi([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"coordinate_system\" , & \"Cylindrical (R,Z,Phi)\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Birth density and particles calculated by FIDASIM\" , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) deallocate ( ri , vi ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'birth profile written to: ' , trim ( filename ) endif end subroutine write_birth_profile subroutine write_dcx integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( 120 ) :: filename integer :: i real ( double ), dimension (:) , allocatable :: lambda_arr real ( double ), dimension (:,:), allocatable :: dcx_spec filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_dcx.h5\" allocate ( lambda_arr ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = ( i - 0.5 ) * inputs % dlambda * 0.1 d0 & + inputs % lambdamin * 0.1 d0 ! [nm] enddo allocate ( dcx_spec ( inputs % nlambda , spec_chords % nchan )) !! convert [Ph/(s*wavel_bin*cm&#94;2*all_directions)] to [Ph/(s*nm*sr*m&#94;2)]! dcx_spec = spec % bes (:,:, halo_type ) / ( 0.1 d0 * inputs % dlambda ) / ( 4. d0 * pi ) * 1. d4 !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nlevel\" , 0 , d , [ nlevs ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ spec_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nlambda\" , 0 , d , [ inputs % nlambda ], error ) dims ( 1 ) = inputs % nlambda dims ( 2 ) = spec_chords % nchan call h5ltmake_compressed_dataset_double_f ( fid , \"/spec\" , 2 , dims ( 1 : 2 ), & dcx_spec , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dims ( 1 : 1 ), & lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dims ( 2 : 2 ), & spec_chords % radius , error ) dims = [ nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ] call h5ltmake_compressed_dataset_double_f ( fid , \"/dens\" , 4 , dims , & neut % dens (:, halo_type ,:,:,:), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/nlevel\" , \"description\" , & \"Number of atomic energy levels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nlambda\" , \"description\" , & \"Number of wavelengths\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"description\" , & \"Direct Charge Exchange (DCX) neutral density: dcx(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/spec\" , \"description\" , & \"Direct Charge Exchange (DCX) beam emission: spec(lambda, chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/spec\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Direct Charge Exchange spectra and neutral density calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) deallocate ( dcx_spec , lambda_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'dcx written to: ' , trim ( filename ) endif end subroutine write_dcx subroutine write_neutrals integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( inputs % neutrals_file , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) dims = [ nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ] d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nlevel\" , 0 , d , [ nlevs ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fdens\" , 4 , dims , & neut % dens (:, nbif_type ,:,:,:), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/hdens\" , 4 , dims , & neut % dens (:, nbih_type ,:,:,:), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/tdens\" , 4 , dims , & neut % dens (:, nbit_type ,:,:,:), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/halodens\" , 4 , dims , & neut % dens (:, halo_type ,:,:,:), error ) !Write attributes call h5ltset_attribute_string_f ( fid , \"/nlevel\" , \"description\" , & \"Number of atomic energy levels\" , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"description\" , & \"Neutral density for the full energy component of the beam: fdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"description\" , & \"Neutral density for the half energy component of the beam: hdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"description\" , & \"Neutral density for the third energy component of the beam: tdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"description\" , & \"Neutral density of the beam halo(including dcx): halodens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Beam neutral density calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'neutral density written to: ' , trim ( inputs % neutrals_file ) endif end subroutine write_neutrals subroutine write_npa integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error integer , dimension (:), allocatable :: dcount real ( double ), dimension (:,:), allocatable :: ri , rf integer :: i , n character ( 120 ) :: filename = '' allocate ( dcount ( npa_chords % nchan )) do i = 1 , npa_chords % nchan dcount ( i ) = count ( npa % part % detector . eq . i ) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 dim2 = [ fbm % nenergy , npa % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ fbm % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim2 ( 1 : 1 ),& npa % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim2 ( 2 : 2 ),& npa_chords % radius , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , dim2 , npa % flux , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/count\" , 1 , dim2 ( 2 : 2 ), dcount , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" ,& \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" ,& \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Detector line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , \"neutrals/(s*dE)\" , error ) call h5ltset_attribute_string_f ( fid , \"/count\" , \"description\" , & \"Number of particles that hit the detector: count(chan)\" , error ) deallocate ( dcount ) if (( npa % npart . ne . 0 ). and .( inputs % calc_npa . ge . 2 )) then n = npa % npart allocate ( ri ( 3 , n ), rf ( 3 , n )) ri ( 1 ,:) = npa % part ( 1 : n )% xi ri ( 2 ,:) = npa % part ( 1 : n )% yi ri ( 3 ,:) = npa % part ( 1 : n )% zi rf ( 1 ,:) = npa % part ( 1 : n )% xf rf ( 2 ,:) = npa % part ( 1 : n )% yf rf ( 3 ,:) = npa % part ( 1 : n )% zf !Create Group call h5gcreate_f ( fid , \"/particles\" , gid , error ) call h5ltmake_dataset_int_f ( gid , \"nparticle\" , 0 , d , [ npa % npart ], error ) d ( 1 ) = npa % npart dim2 = [ 3 , n ] call h5ltmake_compressed_dataset_double_f ( gid , \"ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"rf\" , 2 , dim2 , rf , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"pitch\" , 1 , d , & npa % part ( 1 : n )% pitch , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , d ,& npa % part ( 1 : n )% energy , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"weight\" , 1 , d ,& npa % part ( 1 : n )% weight , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"detector\" , 1 , d ,& npa % part ( 1 : n )% detector , error ) !Add attributes call h5ltset_attribute_string_f ( gid , \"nparticle\" , \"description\" , & \"Number of particles that hit a detector\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"description\" , & \"Neutral particle's birth position in machine coordinates: ri([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"description\" , & \"Neutral particle's hit position in machine coordinates: rf([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"pitch\" , \"description\" , & \"Pitch value of the neutral particle: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy value of the neutral particle\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"description\" , & \"Neutral particle's contribution to the flux\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"units\" , \"neutrals/s\" , error ) call h5ltset_attribute_string_f ( gid , \"detector\" , \"description\" , & \"Detector that the neutral particle hit\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"description\" , & \"Monte Carlo particles\" , error ) !Close group call h5gclose_f ( gid , error ) deallocate ( ri , rf ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA data written to: ' , trim ( filename ) endif end subroutine write_npa subroutine write_spectra integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 3 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( 120 ) :: filename integer :: i real ( double ), dimension (:) , allocatable :: lambda_arr allocate ( lambda_arr ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = ( i - 0.5 ) * inputs % dlambda * 0.1 d0 & + inputs % lambdamin * 0.1 d0 enddo !! convert [Ph/(s*wavel_bin*cm&#94;2*all_directions)] to [Ph/(s*nm*sr*m&#94;2)]! spec % brems = spec % brems / ( 0.1 d0 * inputs % dlambda ) / ( 4. d0 * pi ) * 1. d4 spec % bes = spec % bes / ( 0.1 d0 * inputs % dlambda ) / ( 4. d0 * pi ) * 1. d4 spec % fida = spec % fida / ( 0.1 d0 * inputs % dlambda ) / ( 4. d0 * pi ) * 1. d4 !! write to file filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_spectra.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ spec_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nlambda\" , 0 , d , [ inputs % nlambda ], error ) dims ( 1 ) = inputs % nlambda dims ( 2 ) = spec_chords % nchan dims ( 3 ) = particles % nclass call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dims ( 1 : 1 ), & lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dims ( 2 : 2 ), & spec_chords % radius , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nlambda\" , \"description\" , & \"Number of wavelengths\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) if ( inputs % calc_brems . ge . 1 ) then !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/brems\" , 2 , & dims ( 1 : 2 ), spec % brems , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/brems\" , \"description\" , & \"Visible Bremsstrahlung: brems(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/brems\" , \"units\" ,& \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_bes . ge . 1 ) then !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/full\" , 2 , dims ( 1 : 2 ), & spec % bes (:,:, nbif_type ), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/half\" , 2 , dims ( 1 : 2 ), & spec % bes (:,:, nbih_type ), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/third\" , 2 , dims ( 1 : 2 ),& spec % bes (:,:, nbit_type ), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/halo\" , 2 , dims ( 1 : 2 ), & spec % bes (:,:, halo_type ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/full\" , \"description\" , & \"Full energy component of the beam emmision: full(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/full\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"description\" , & \"Half energy component of the beam emmision: half(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"description\" , & \"Third energy component of the beam emmision: third(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"description\" , & \"Halo component of the beam emmision (includes dcx): halo(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_fida . ge . 1 ) then !Write variables if ( particles % nclass . le . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , & dims ( 1 : 2 ), spec % fida (:,:, 1 ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan)\" , error ) else call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , & dims , spec % fida , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan,class)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" ,& \"Spectra calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'Spectra written to: ' , trim ( filename ) endif end subroutine write_spectra subroutine write_fida_weights !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer :: error character ( 120 ) :: filename integer :: i , ie , ip , ic real ( double ), dimension (:), allocatable :: lambda_arr real ( double ), dimension (:), allocatable :: ebarr , ptcharr real ( double ), dimension (:,:), allocatable :: jacobian , e_grid , p_grid real ( double ), dimension (:,:), allocatable :: vpa_grid , vpe_grid real ( double ) :: dlambda , wtot , dE , dP dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght allocate ( lambda_arr ( inputs % nlambda_wght )) do i = 1 , inputs % nlambda_wght lambda_arr ( i ) = ( i - 0.5 ) * dlambda + inputs % lambdamin_wght enddo !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) !! define 2d grids !! define energy grid allocate ( e_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % ne_wght e_grid ( i ,:) = ebarr ( i ) enddo !! define pitch grid allocate ( p_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % np_wght p_grid (:, i ) = ptcharr ( i ) enddo !! define velocity space grid allocate ( vpe_grid ( inputs % ne_wght , inputs % np_wght )) !! V perpendicular allocate ( vpa_grid ( inputs % ne_wght , inputs % np_wght )) !! V parallel vpa_grid = 100 * sqrt (((( 2.0 d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid ) * p_grid ! [cm/s] vpe_grid = 100 * sqrt (((( 2.0 d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid * ( 1.0 - p_grid ** 2.0 )) ![cm/s] !! define jacobian to convert between E-p to velocity allocate ( jacobian ( inputs % ne_wght , inputs % np_wght )) jacobian = (( inputs % ab * mass_u ) / ( e0 * 1.0 d3 )) * vpe_grid / sqrt ( vpa_grid ** 2.0 + vpe_grid ** 2.0 ) !! normalize mean_f do ic = 1 , spec_chords % nchan do ip = 1 , inputs % np_wght do ie = 1 , inputs % ne_wght wtot = sum ( fweight % weight (:, ie , ip , ic )) if (( wtot . gt . 0. d0 )) then fweight % mean_f ( ie , ip , ic ) = fweight % mean_f ( ie , ip , ic ) / wtot endif enddo enddo enddo if ( inputs % calc_fida_wght . eq . 1 ) then fweight % mean_f = fweight % mean_f / ( dE * dP ) endif filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_fida_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) dim1 ( 1 ) = 1 dim2 = [ inputs % nlambda_wght , spec_chords % nchan ] dim4 = [ inputs % nlambda_wght , inputs % ne_wght , inputs % np_wght , spec_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , dim1 ,[ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , dim1 ,[ inputs % np_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , dim1 ,[ spec_chords % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 4 , dim4 , fweight % weight , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , dim2 , fweight % fida , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/mean_f\" , 3 , dim4 ( 2 : 4 ), fweight % mean_f , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dim4 ( 1 : 1 ), lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim4 ( 2 : 2 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim4 ( 3 : 3 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim4 ( 4 : 4 ), spec_chords % radius , error ) dim2 = [ inputs % ne_wght , inputs % np_wght ] call h5ltmake_compressed_dataset_double_f ( fid , \"/jacobian\" , 2 , dim2 , jacobian , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpe_grid\" , 2 , dim2 , vpe_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpa_grid\" , 2 , dim2 , vpa_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/e_grid\" , 2 , dim2 , e_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/p_grid\" , 2 , dim2 , p_grid , error ) !Add attributes if ( inputs % calc_fida_wght . eq . 1 ) then call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Line of Sight averaged FIDA E-p space sensitivity/weights \" // & \"and spectra calculated by FIDASIM\" , error ) else call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Full FIDA E-p space sensitivity/weights and spectra calculated \" // & \"by FIDASIM via Monte Carlo method\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of FIDA diagnostic: weight(lambda,energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"(Ph*cm)/(s*nm*sr*fast-ion*dE*dP)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , & \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"description\" , & \"Mean fast-ion distribution function seen by los: mean_f(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"units\" , & \"fast-ion/(dE*dP*cm&#94;3)\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"description\" , & \"Jacobian used to convert from E-p space to velocity space\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"units\" , & \"(dE*dP)/(dvpa*dvpe)\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"description\" , & \"2D energy grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/p_grid\" , \"description\" , & \"2D pitch grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"description\" , & \"2D perpendicular velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"description\" , & \"2D parallel velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"units\" , \"cm/s\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'FIDA weights written to: ' , trim ( filename ) endif end subroutine write_fida_weights subroutine write_npa_weights character ( 120 ) :: filename integer :: i real ( double ), dimension (:), allocatable :: ebarr , ptcharr !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 dim2 = [ inputs % ne_wght , npa_chords % nchan ] dim3 = [ inputs % ne_wght , inputs % np_wght , npa_chords % nchan ] dim5 = [ inputs % ne_wght , beam_grid % nx , beam_grid % ny , beam_grid % nz , npa_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , d , [ inputs % np_wght ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , & dim2 ( 2 : 2 ), npa_chords % radius , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , & dim2 ( 1 : 1 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , & dim3 ( 2 : 2 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , & dim2 , nweight % flux , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 3 , & dim3 , nweight % weight , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA E-p space sensitivity/weights and Flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , & \"neutrals/(s*dE)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of NPA diagnostics: weight(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"neutrals/(s*fast-ion*dE*dP)\" , error ) if ( inputs % calc_npa_wght . ge . 2 ) then !Write diagnostic variables call write_beam_grid ( fid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/emissivity\" , 4 , & dim5 ( 2 : 5 ), nweight % emissivity , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/attenuation\" , 5 , & dim5 , nweight % attenuation , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/cx\" , 5 , & dim5 , nweight % cx , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/phit\" , 4 , & dim5 ( 2 : 5 ), npa_chords % phit % p , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"description\" , & \"Neutral emissivity: emissivity(x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"units\" , & \"neutrals/(s*dV)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"description\" , & \"Charge-exchange rate: cx(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"units\" , \"s&#94;(-1)\" , error ) call h5ltset_attribute_string_f ( fid , \"/attenuation\" , \"description\" , & \"Attenuation factor i.e. survival probability: attenuation(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/phit\" , \"description\" , & \"Probability of hitting the detector given an isotropic source: phit(x,y,z,chan)\" , error ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA weights written to: ' , trim ( filename ) endif end subroutine write_npa_weights subroutine read_neutrals integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer :: error , nx , ny , nz logical :: exis if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- loading neutrals ----' endif inquire ( file = inputs % neutrals_file , exist = exis ) if ( exis ) then write ( * , '(T2,\"Neutrals file: \",a)' ) trim ( inputs % neutrals_file ) write ( * , * ) '' else write ( * , '(a,a)' ) 'READ_NEUTRALS: Neutrals file does not exist: ' , inputs % neutrals_file stop endif !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fopen_f ( inputs % neutrals_file , H5F_ACC_RDONLY_F , fid , error ) call h5gopen_f ( fid , \"/grid\" , gid , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nx\" , nx , error ) call h5ltread_dataset_int_scalar_f ( gid , \"ny\" , ny , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nz\" , nz , error ) call h5gclose_f ( gid , error ) if (( nx . ne . beam_grid % nx ). or . & ( ny . ne . beam_grid % ny ). or . & ( nz . ne . beam_grid % nz )) then write ( * , '(a)' ) 'READ_NEUTRALS: Neutrals file has incompatable grid dimensions' stop endif dims = [ nlevs , nx , ny , nz ] call h5ltread_dataset_double_f ( fid , \"/fdens\" , & neut % dens (:, nbif_type ,:,:,:), dims , error ) call h5ltread_dataset_double_f ( fid , \"/hdens\" , & neut % dens (:, nbih_type ,:,:,:), dims , error ) call h5ltread_dataset_double_f ( fid , \"/tdens\" , & neut % dens (:, nbit_type ,:,:,:), dims , error ) call h5ltread_dataset_double_f ( fid , \"/halodens\" , & neut % dens (:, halo_type ,:,:,:), dims , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) end subroutine read_neutrals !============================================================================= !-----------------------------Geometry Routines------------------------------- !============================================================================= function cross_product ( u , v ) result ( s ) real ( double ), dimension ( 3 ), intent ( in ) :: u real ( double ), dimension ( 3 ), intent ( in ) :: v real ( double ), dimension ( 3 ) :: s s ( 1 ) = u ( 2 ) * v ( 3 ) - u ( 3 ) * v ( 2 ) s ( 2 ) = u ( 3 ) * v ( 1 ) - u ( 1 ) * v ( 3 ) s ( 3 ) = u ( 1 ) * v ( 2 ) - u ( 2 ) * v ( 1 ) end function cross_product function normp ( u , p_in ) result ( n ) real ( double ), dimension (:), intent ( in ) :: u integer , intent ( in ), optional :: p_in real ( double ) :: n integer :: p IF ( present ( p_in )) THEN p = p_in ELSE p = 2 ENDIF SELECT CASE ( p ) CASE ( 1 ) n = sum ( abs ( u )) CASE ( 2 ) n = sqrt ( dot_product ( u , u )) CASE DEFAULT write ( * , '(\"NORMP: Unknown p value: \",i2)' ), p stop END SELECT end function normp subroutine tb_zyx ( alpha , beta , gamma , basis , inv_basis ) !! Creates active rotation matrix for z-y'-x\" rotation given Tait-bryan angles real ( double ), intent ( in ) :: alpha real ( double ), intent ( in ) :: beta real ( double ), intent ( in ) :: gamma real ( double ), dimension ( 3 , 3 ), intent ( out ) :: basis real ( double ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis real ( double ) :: sa , sb , sg , ca , cb , cg sa = sin ( alpha ) ; sb = sin ( beta ) ; sg = sin ( gamma ) ca = cos ( alpha ) ; cb = cos ( beta ) ; cg = cos ( gamma ) basis ( 1 , 1 ) = ca * cb ; basis ( 1 , 2 ) = ca * sb * sg - cg * sa ; basis ( 1 , 3 ) = sa * sg + ca * cg * sb basis ( 2 , 1 ) = cb * sa ; basis ( 2 , 2 ) = ca * cg + sa * sb * sg ; basis ( 2 , 3 ) = cg * sa * sb - ca * sg basis ( 3 , 1 ) = - sb ; basis ( 3 , 2 ) = cb * sg ; basis ( 3 , 3 ) = cb * cg if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine tb_zyx subroutine line_basis ( r0 , v0 , basis , inv_basis ) !calculates basis from a line with +x in the direction of line real ( double ), dimension ( 3 ), intent ( in ) :: r0 real ( double ), dimension ( 3 ), intent ( in ) :: v0 real ( double ), dimension ( 3 , 3 ), intent ( out ) :: basis real ( double ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis real ( double ), dimension ( 3 ) :: rf real ( double ) :: alpha , beta , dis rf = r0 + v0 dis = sqrt ( sum (( rf - r0 ) ** 2.0 )) beta = asin (( r0 ( 3 ) - rf ( 3 )) / dis ) alpha = atan2 ( rf ( 2 ) - r0 ( 2 ), rf ( 1 ) - r0 ( 1 )) call tb_zyx ( alpha , beta , 0. d0 , basis ) if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine line_basis subroutine plane_basis ( center , redge , tedge , basis , inv_basis ) !calculates basis from 3 points on a plane with +z being the plane normal real ( double ), dimension ( 3 ), intent ( in ) :: center real ( double ), dimension ( 3 ), intent ( in ) :: redge real ( double ), dimension ( 3 ), intent ( in ) :: tedge real ( double ), dimension ( 3 , 3 ), intent ( out ) :: basis real ( double ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis real ( double ), dimension ( 3 ) :: u1 , u2 , u3 u1 = ( redge - center ) u1 = u1 / normp ( u1 ) u2 = ( tedge - center ) u2 = u2 / normp ( u2 ) u3 = cross_product ( u1 , u2 ) u3 = u3 / normp ( u3 ) basis (:, 1 ) = u1 basis (:, 2 ) = u2 basis (:, 3 ) = u3 if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine plane_basis subroutine plane_intercept ( l0 , l , p0 , n , p , t ) real ( double ), dimension ( 3 ), intent ( in ) :: l0 ! Point on line real ( double ), dimension ( 3 ), intent ( in ) :: l ! Ray of line real ( double ), dimension ( 3 ), intent ( in ) :: p0 ! Point on plane real ( double ), dimension ( 3 ), intent ( in ) :: n ! Normal vector of plane real ( double ), dimension ( 3 ), intent ( out ) :: p ! Line-plane intercept point real ( double ), intent ( out ) :: t ! \"time\" to intercept t = dot_product ( p0 - l0 , n ) / dot_product ( l , n ) p = l0 + t * l end subroutine plane_intercept function in_boundary ( bplane , p ) result ( in_b ) type ( BoundedPlane ), intent ( in ) :: bplane real ( double ), dimension ( 3 ), intent ( in ) :: p real ( double ), dimension ( 3 ) :: pp real ( double ) :: hh , hw logical :: in_b hh = bplane % hh hw = bplane % hw pp = matmul ( bplane % inv_basis , p - bplane % origin ) in_b = . False . SELECT CASE ( bplane % shape ) CASE ( 1 ) !Rectangular boundary if (( abs ( pp ( 1 )). le . hw ). and . & ( abs ( pp ( 2 )). le . hh )) then in_b = . True . endif CASE ( 2 ) !Circular/Ellipsoidal boundary if ((( hh * pp ( 1 )) ** 2.0 + ( hw * pp ( 2 )) ** 2.0 ). le .(( hh * hw ) ** 2.0 )) then in_b = . True . endif CASE DEFAULT write ( * , '(\"IN_BOUNDARY: Unknown boundary shape: \",i2)' ), bplane % shape stop END SELECT end function in_boundary subroutine hit_npa_detector ( r0 , v0 , d_index , rd ) real ( double ), dimension ( 3 ), intent ( in ) :: r0 real ( double ), dimension ( 3 ), intent ( in ) :: v0 integer , intent ( out ) :: d_index real ( double ), dimension ( 3 ), intent ( out ), optional :: rd real ( double ), dimension ( 3 ) :: d , a real ( double ) :: t_a , t_d integer :: i , ndet ndet = npa_chords % nchan d_index = 0 detector_loop : do i = 1 , ndet !! Find where trajectory crosses detector plane call plane_intercept ( r0 , v0 , npa_chords % det ( i )% detector % origin , & npa_chords % det ( i )% detector % basis (:, 3 ), d , t_d ) !! Find where trajectory crosses aperture plane call plane_intercept ( r0 , v0 , npa_chords % det ( i )% aperture % origin , & npa_chords % det ( i )% aperture % basis (:, 3 ), a , t_a ) !! If both points are in plane boundaries and the !! particle is heading toward the detector then its a hit if ( in_boundary ( npa_chords % det ( i )% aperture , a ) . and . & in_boundary ( npa_chords % det ( i )% detector , d ) . and . & ( t_d . gt . 0.0 ) ) then d_index = i if ( present ( rd )) rd = d exit detector_loop endif enddo detector_loop end subroutine hit_npa_detector subroutine xyz_to_uvw ( xyz , uvw ) real ( double ), dimension ( 3 ), intent ( in ) :: xyz real ( double ), dimension ( 3 ), intent ( out ) :: uvw real ( double ), dimension ( 3 ) :: origin real ( double ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % basis uvw = matmul ( basis , xyz ) uvw = uvw + origin end subroutine xyz_to_uvw subroutine uvw_to_xyz ( uvw , xyz ) real ( double ), dimension ( 3 ), intent ( in ) :: uvw real ( double ), dimension ( 3 ), intent ( out ) :: xyz real ( double ), dimension ( 3 ) :: origin , uvw_p real ( double ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % inv_basis uvw_p = uvw - origin xyz = matmul ( basis , uvw_p ) end subroutine uvw_to_xyz subroutine grid_intersect ( r0 , v0 , length , r_enter , r_exit , center_in , lwh_in ) real ( double ), dimension ( 3 ), intent ( in ) :: r0 real ( double ), dimension ( 3 ), intent ( in ) :: v0 real ( double ), intent ( out ) :: length real ( double ), dimension ( 3 ), intent ( out ) :: r_enter real ( double ), dimension ( 3 ), intent ( out ) :: r_exit real ( double ), dimension ( 3 ), intent ( in ), optional :: center_in real ( double ), dimension ( 3 ), intent ( in ), optional :: lwh_in real ( double ), dimension ( 3 , 6 ) :: ipnts real ( double ), dimension ( 3 ) :: vi real ( double ), dimension ( 3 ) :: center real ( double ), dimension ( 3 ) :: lwh integer , dimension ( 6 ) :: side_inter integer , dimension ( 2 ) :: ind integer :: i , j , nunique , ind1 , ind2 if ( present ( center_in )) then center = center_in else center = beam_grid % center endif if ( present ( lwh_in )) then lwh = lwh_in else lwh = beam_grid % lwh endif side_inter = 0 ipnts = 0. d0 do i = 1 , 6 j = int ( ceiling ( i / 2.0 )) if ( j . eq . 1 ) ind = [ 2 , 3 ] if ( j . eq . 2 ) ind = [ 1 , 3 ] if ( j . eq . 3 ) ind = [ 1 , 2 ] if ( abs ( v0 ( j )). gt . 0. d0 ) then ipnts (:, i ) = r0 + v0 * ( ( ( center ( j ) + & ( mod ( i , 2 ) - 0.5 ) * lwh ( j )) - r0 ( j )) / v0 ( j ) ) if (( abs ( ipnts ( ind ( 1 ), i ) - center ( ind ( 1 ))). le .( 0.5 * lwh ( ind ( 1 )))). and . & ( abs ( ipnts ( ind ( 2 ), i ) - center ( ind ( 2 ))). le .( 0.5 * lwh ( ind ( 2 ))))) then side_inter ( i ) = 1 endif endif enddo length = 0. d0 r_enter = r0 r_exit = r0 if ( sum ( side_inter ). ge . 2 ) then ! Find first intersection side i = 1 do while ( i . le . 6 ) if ( side_inter ( i ). eq . 1 ) exit i = i + 1 enddo ind1 = i !Find number of unique points nunique = 0 do i = ind1 , 6 if ( side_inter ( i ). ne . 1 ) cycle if ( sqrt ( sum ( ( ipnts (:, i ) - ipnts (:, ind1 ) ) ** 2.0 ) ). gt . 0.001 ) then ind2 = i nunique = 2 exit endif enddo if ( nunique . eq . 2 ) then vi = ipnts (:, ind2 ) - ipnts (:, ind1 ) if ( dot_product ( v0 , vi ). gt . 0.0 ) then r_enter = ipnts (:, ind1 ) r_exit = ipnts (:, ind2 ) else r_enter = ipnts (:, ind2 ) r_exit = ipnts (:, ind1 ) endif length = sqrt ( sum (( r_exit - r_enter ) ** 2.0 )) endif endif end subroutine grid_intersect subroutine get_indices ( pos , ind ) real ( double ), dimension ( 3 ), intent ( in ) :: pos integer ( long ), dimension ( 3 ), intent ( out ) :: ind real ( double ), dimension ( 3 ) :: mini integer ( long ), dimension ( 3 ) :: maxind integer :: i maxind ( 1 ) = beam_grid % nx maxind ( 2 ) = beam_grid % ny maxind ( 3 ) = beam_grid % nz mini ( 1 ) = minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 ) mini ( 2 ) = minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 ) mini ( 3 ) = minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 ) do i = 1 , 3 ind ( i ) = floor (( pos ( i ) - mini ( i )) / beam_grid % dr ( i )) + 1 if ( ind ( i ). gt . maxind ( i )) ind ( i ) = maxind ( i ) if ( ind ( i ). lt . 1 ) ind ( i ) = 1 enddo end subroutine get_indices subroutine get_position ( ind , pos ) integer ( long ), dimension ( 3 ), intent ( in ) :: ind real ( double ), dimension ( 3 ), intent ( out ) :: pos pos ( 1 ) = beam_grid % xc ( ind ( 1 )) pos ( 2 ) = beam_grid % yc ( ind ( 2 )) pos ( 3 ) = beam_grid % zc ( ind ( 3 )) end subroutine get_position subroutine track ( rin , vin , tracks , ncell , los_intersect ) !!track computes the path of a neutral through the beam grid real ( double ), dimension ( 3 ), intent ( in ) :: rin ! initial position real ( double ), dimension ( 3 ), intent ( in ) :: vin ! velocitiy type ( ParticleTrack ), dimension (:), intent ( inout ) :: tracks integer ( long ), intent ( out ) :: ncell logical , intent ( out ), optional :: los_intersect integer :: cc , i , ii , mind integer , dimension ( 3 ) :: ind logical :: in_plasma1 , in_plasma2 , in_plasma_tmp , los_inter real ( double ) :: dT , dt1 , inv_50 real ( double ), dimension ( 3 ) :: dt_arr , dr real ( double ), dimension ( 3 ) :: vn , inv_vn real ( double ), dimension ( 3 ) :: ri , ri_tmp , ri_cell integer , dimension ( 3 ) :: sgn integer , dimension ( 3 ) :: gdims integer , dimension ( 1 ) :: minpos vn = vin ; ri = rin ; sgn = 0 ; ncell = 0 if ( dot_product ( vin , vin ). eq . 0.0 ) then return endif gdims ( 1 ) = beam_grid % nx gdims ( 2 ) = beam_grid % ny gdims ( 3 ) = beam_grid % nz !! define actual cell call get_indices ( ri , ind ) ri_cell = [ beam_grid % xc ( ind ( 1 )), & beam_grid % yc ( ind ( 2 )), & beam_grid % zc ( ind ( 3 ))] do i = 1 , 3 if ( vn ( i ). gt . 0.0 ) sgn ( i ) = 1 if ( vn ( i ). lt . 0.0 ) sgn ( i ) =- 1 if ( vn ( i ). eq . 0.0 ) vn ( i ) = 1.0 d - 3 enddo dr = beam_grid % dr * sgn inv_vn = 1 / vn inv_50 = 1.0 / 5 0.0 cc = 1 los_inter = . False . tracks % time = 0. d0 tracks % flux = 0. d0 call in_plasma ( ri , in_plasma1 ) track_loop : do i = 1 , beam_grid % ntrack if ( cc . gt . beam_grid % ntrack ) exit track_loop if ( spec_chords % los_inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )). and .(. not . los_inter )) then los_inter = . True . endif dt_arr = abs (( ( ri_cell + 0.5 * dr ) - ri ) * inv_vn ) minpos = minloc ( dt_arr ) mind = minpos ( 1 ) dT = dt_arr ( mind ) ri_tmp = ri + dT * vn call in_plasma ( ri_tmp , in_plasma2 ) if ( in_plasma1 . neqv . in_plasma2 ) then dt1 = 0.0 track_fine : do ii = 1 , 50 dt1 = dt1 + dT * inv_50 ri_tmp = ri + vn * dt1 call in_plasma ( ri_tmp , in_plasma_tmp ) if ( in_plasma2 . eqv . in_plasma_tmp ) exit track_fine enddo track_fine tracks ( cc )% pos = ri + 0.5 * dt1 * vn tracks ( cc + 1 )% pos = ri + 0.5 * ( dt1 + dT ) * vn tracks ( cc )% time = dt1 tracks ( cc + 1 )% time = dT - dt1 tracks ( cc )% ind = ind tracks ( cc + 1 )% ind = ind cc = cc + 2 else tracks ( cc )% pos = ri + 0.5 * dT * vn tracks ( cc )% time = dT tracks ( cc )% ind = ind cc = cc + 1 endif in_plasma1 = in_plasma2 ri = ri + dT * vn ind ( mind ) = ind ( mind ) + sgn ( mind ) ri_cell ( mind ) = ri_cell ( mind ) + dr ( mind ) if ( ind ( mind ). gt . gdims ( mind )) exit track_loop if ( ind ( mind ). lt . 1 ) exit track_loop enddo track_loop ncell = cc - 1 if ( present ( los_intersect )) then los_intersect = los_inter endif end subroutine track !============================================================================ !---------------------------Interpolation Routines--------------------------- !============================================================================ subroutine interpol1D_coeff ( xmin , dx , nx , xout , i , b1 , b2 , err ) !!Linear interpolation coefficients and index for a 1D grid y(x) real ( double ), intent ( in ) :: xmin real ( double ), intent ( in ) :: dx integer , intent ( in ) :: nx real ( double ), intent ( in ) :: xout integer , intent ( out ) :: i real ( double ), intent ( out ) :: b1 real ( double ), intent ( out ) :: b2 integer , intent ( out ), optional :: err real ( double ) :: x1 , xp integer :: err_status err_status = 1 xp = max ( xout , xmin ) i = floor (( xp - xmin ) / dx ) + 1 if (( i . gt . 0 ). and .( i . le .( nx - 1 ))) then x1 = xmin + ( i - 1 ) * dx b2 = ( xp - x1 ) / dx b1 = ( 1.0 - b2 ) err_status = 0 else b1 = 0. d0 ; b2 = 0. d0 endif if ( present ( err )) err = err_status end subroutine interpol1D_coeff subroutine interpol1D_coeff_arr ( x , xout , i , b1 , b2 , err ) !!Linear interpolation coefficients and index for a 1D grid y(x) real ( double ), dimension (:), intent ( in ) :: x real ( double ), intent ( in ) :: xout integer , intent ( out ) :: i real ( double ), intent ( out ) :: b1 real ( double ), intent ( out ) :: b2 integer , intent ( out ), optional :: err real ( double ) :: xmin , dx integer :: sx , err_status err_status = 1 sx = size ( x ) xmin = minval ( x ) dx = abs ( x ( 2 ) - x ( 1 )) call interpol1D_coeff ( xmin , dx , sx , xout , & i , b1 , b2 , err_status ) if ( present ( err )) err = err_status end subroutine interpol1D_coeff_arr subroutine interpol2D_coeff ( xmin , dx , nx , ymin , dy , ny , xout , yout , i , j , b11 , b12 , b21 , b22 , err ) !!Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( double ), intent ( in ) :: xmin real ( double ), intent ( in ) :: dx integer , intent ( in ) :: nx real ( double ), intent ( in ) :: ymin real ( double ), intent ( in ) :: dy integer , intent ( in ) :: ny real ( double ), intent ( in ) :: xout real ( double ), intent ( in ) :: yout integer , intent ( out ) :: i integer , intent ( out ) :: j real ( double ), intent ( out ) :: b11 real ( double ), intent ( out ) :: b12 real ( double ), intent ( out ) :: b21 real ( double ), intent ( out ) :: b22 integer , intent ( out ), optional :: err real ( double ) :: x1 , x2 , y1 , y2 , xp , yp integer :: err_status err_status = 1 xp = max ( xout , xmin ) yp = max ( yout , ymin ) i = floor (( xp - xmin ) / dx ) + 1 j = floor (( yp - ymin ) / dy ) + 1 if ((( i . gt . 0 ). and .( i . le .( nx - 1 ))). and .(( j . gt . 0 ). and .( j . le .( ny - 1 )))) then x1 = xmin + ( i - 1 ) * dx x2 = x1 + dx y1 = ymin + ( j - 1 ) * dy y2 = y1 + dy b11 = (( x2 - xp ) * ( y2 - yp )) / ( dx * dy ) b21 = (( xp - x1 ) * ( y2 - yp )) / ( dx * dy ) b12 = (( x2 - xp ) * ( yp - y1 )) / ( dx * dy ) b22 = (( xp - x1 ) * ( yp - y1 )) / ( dx * dy ) err_status = 0 else b11 = 0. d0 ; b12 = 0. d0 ; b21 = 0. d0 ; b22 = 0. d0 endif if ( present ( err )) err = err_status end subroutine interpol2D_coeff subroutine interpol2D_coeff_arr ( x , y , xout , yout , i , j , b11 , b12 , b21 , b22 , err ) !!Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( double ), dimension (:), intent ( in ) :: x real ( double ), dimension (:), intent ( in ) :: y real ( double ), intent ( in ) :: xout real ( double ), intent ( in ) :: yout integer , intent ( out ) :: i integer , intent ( out ) :: j real ( double ), intent ( out ) :: b11 real ( double ), intent ( out ) :: b12 real ( double ), intent ( out ) :: b21 real ( double ), intent ( out ) :: b22 integer , intent ( out ), optional :: err real ( double ) :: xmin , ymin , dx , dy integer :: sx , sy , err_status err_status = 1 sx = size ( x ) sy = size ( y ) xmin = minval ( x ) ymin = minval ( y ) dx = abs ( x ( 2 ) - x ( 1 )) dy = abs ( y ( 2 ) - y ( 1 )) call interpol2D_coeff ( xmin , dx , sx , ymin , dy , sy , xout , yout , & i , j , b11 , b12 , b21 , b22 , err_status ) if ( present ( err )) err = err_status end subroutine interpol2D_coeff_arr subroutine interpol1D_arr ( x , y , xout , yout , err ) !!Interpolate on a uniform 1D grid y(x) real ( double ), dimension (:), intent ( in ) :: x real ( double ), dimension (:), intent ( in ) :: y real ( double ), intent ( in ) :: xout real ( double ), intent ( out ) :: yout integer , intent ( out ), optional :: err real ( double ) :: b1 real ( double ) :: b2 integer :: i , err_status err_status = 1 call interpol_coeff ( x , xout , i , b1 , b2 , err_status ) if ( err_status . eq . 0 ) then yout = b1 * y ( i ) + b2 * y ( i + 1 ) else yout = 0. d0 endif if ( present ( err )) err = err_status end subroutine interpol1D_arr subroutine interpol2D_arr ( x , y , z , xout , yout , zout , err ) !!Interpolate on a 2D grid z(x,y) real ( double ), dimension (:), intent ( in ) :: x real ( double ), dimension (:), intent ( in ) :: y real ( double ), dimension (:,:), intent ( in ) :: z real ( double ), intent ( in ) :: xout real ( double ), intent ( in ) :: yout real ( double ), intent ( out ) :: zout integer , intent ( out ), optional :: err real ( double ) :: b11 real ( double ) :: b12 real ( double ) :: b21 real ( double ) :: b22 integer :: i , j , err_status err_status = 1 call interpol_coeff ( x , y , xout , yout , i , j , b11 , b12 , b21 , b22 , err_status ) if ( err_status . eq . 0 ) then zout = b11 * z ( i , j ) + b12 * z ( i , j + 1 ) + b21 * z ( i + 1 , j ) + b22 * z ( i + 1 , j + 1 ) else zout = 0. d0 endif if ( present ( err )) err = err_status end subroutine interpol2D_arr subroutine interpol2D_2D_arr ( x , y , z , xout , yout , zout , err ) !!Interpolate on a 2D grid of 2D arrays z(:,:,x,y) real ( double ), dimension (:), intent ( in ) :: x real ( double ), dimension (:), intent ( in ) :: y real ( double ), dimension (:,:,:,:), intent ( in ) :: z real ( double ), intent ( in ) :: xout real ( double ), intent ( in ) :: yout real ( double ), dimension (:,:), intent ( out ) :: zout integer , intent ( out ), optional :: err real ( double ) :: b11 real ( double ) :: b12 real ( double ) :: b21 real ( double ) :: b22 integer :: i , j , err_status err_status = 1 call interpol_coeff ( x , y , xout , yout , i , j , b11 , b12 , b21 , b22 , err_status ) if ( err_status . eq . 0 ) then zout = b11 * z (:,:, i , j ) + b12 * z (:,:, i , j + 1 ) + b21 * z (:,:, i + 1 , j ) + b22 * z (:,:, i + 1 , j + 1 ) else zout = 0.0 endif if ( present ( err )) err = err_status end subroutine interpol2D_2D_arr !============================================================================= !-------------------------Profiles and Fields Routines------------------------ !============================================================================= subroutine in_plasma ( xyz , inp ) real ( double ), dimension ( 3 ), intent ( in ) :: xyz logical , intent ( out ) :: inp real ( double ), dimension ( 3 ) :: uvw real ( double ) :: R , W , phi , mask integer :: err err = 1 !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) W = uvw ( 3 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) !! Interpolate mask value call interpol ( inter_grid % r , inter_grid % z , equil % mask , R , W , mask , err ) if (( mask . ge . 0.5 ). and .( err . eq . 0 )) then inp = . True . else inp = . False . endif end subroutine in_plasma subroutine get_plasma ( plasma , pos , ind ) type ( LocalProfiles ), intent ( out ) :: plasma real ( double ), dimension ( 3 ), intent ( in ), optional :: pos integer ( long ), dimension ( 3 ), intent ( in ), optional :: ind logical :: inp real ( double ), dimension ( 3 ) :: xyz , uvw , vrot_uvw real ( double ) :: R , W , phi , s , c real ( double ) :: b11 , b12 , b21 , b22 integer :: i , j plasma % in_plasma = . False . if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos call in_plasma ( xyz , inp ) if ( inp ) then !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) W = uvw ( 3 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) call interpol_coeff ( inter_grid % r , inter_grid % z , R , W , & i , j , b11 , b12 , b21 , b22 ) plasma = b11 * equil % plasma ( i , j ) + b12 * equil % plasma ( i , j + 1 ) + & b21 * equil % plasma ( i + 1 , j ) + b22 * equil % plasma ( i + 1 , j + 1 ) s = sin ( phi ) ; c = cos ( phi ) vrot_uvw ( 1 ) = plasma % vr * c - plasma % vt * s vrot_uvw ( 2 ) = plasma % vr * s + plasma % vt * c vrot_uvw ( 3 ) = plasma % vz plasma % vrot = matmul ( beam_grid % inv_basis , vrot_uvw ) plasma % pos = xyz plasma % in_plasma = . True . endif end subroutine get_plasma subroutine calc_perp_vectors ( b , a , c ) !!Returns normalized vectors that are perpendicular to b !!such that a x c = bnorm real ( double ), dimension ( 3 ), intent ( in ) :: b real ( double ), dimension ( 3 ), intent ( out ) :: a real ( double ), dimension ( 3 ), intent ( out ) :: c real ( double ), dimension ( 3 ) :: bnorm bnorm = b / normp ( b ) if ( abs ( bnorm ( 3 )). eq . 1 ) then a = [ 1. d0 , 0. d0 , 0. d0 ] c = [ 0. d0 , 1. d0 , 0. d0 ] else if ( bnorm ( 3 ). eq . 0. ) then a = [ 0. d0 , 0. d0 , 1. d0 ] c = [ bnorm ( 2 ), - bnorm ( 1 ), 0. d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) else a = [ bnorm ( 2 ), - bnorm ( 1 ), 0. d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) c =- [ a ( 2 ) , - a ( 1 ) , ( a ( 1 ) * bnorm ( 2 ) - a ( 2 ) * bnorm ( 1 )) / bnorm ( 3 ) ] c = c / normp ( c ) if ( bnorm ( 3 ). lt . 0.0 ) then c =- c endif endif endif end subroutine calc_perp_vectors subroutine get_fields ( fields , pos , ind ) type ( LocalEMFields ), intent ( out ) :: fields real ( double ), dimension ( 3 ), intent ( in ), optional :: pos integer ( long ), dimension ( 3 ), intent ( in ), optional :: ind logical :: inp real ( double ), dimension ( 3 ) :: xyz , uvw real ( double ), dimension ( 3 ) :: uvw_bfield , uvw_efield real ( double ), dimension ( 3 ) :: xyz_bfield , xyz_efield real ( double ) :: R , W , phi , s , c real ( double ) :: b11 , b12 , b21 , b22 integer :: i , j fields % in_plasma = . False . if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos call in_plasma ( xyz , inp ) if ( inp ) then !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) W = uvw ( 3 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) s = sin ( phi ) ; c = cos ( phi ) call interpol_coeff ( inter_grid % r , inter_grid % z , R , W , & i , j , b11 , b12 , b21 , b22 ) fields = b11 * equil % fields ( i , j ) + b12 * equil % fields ( i , j + 1 ) + & b21 * equil % fields ( i + 1 , j ) + b22 * equil % fields ( i + 1 , j + 1 ) !Convert cylindrical coordinates to uvw uvw_bfield ( 1 ) = c * fields % br - s * fields % bt uvw_bfield ( 2 ) = s * fields % br + c * fields % bt uvw_bfield ( 3 ) = fields % bz uvw_efield ( 1 ) = c * fields % er - s * fields % et uvw_efield ( 2 ) = s * fields % er + c * fields % et uvw_efield ( 3 ) = fields % ez !Represent fields in beam grid coordinates xyz_bfield = matmul ( beam_grid % inv_basis , uvw_bfield ) xyz_efield = matmul ( beam_grid % inv_basis , uvw_efield ) !Calculate field directions and magnitudes fields % b_abs = normp ( xyz_bfield ) fields % e_abs = normp ( xyz_efield ) if ( fields % b_abs . ne . 0 ) fields % b_norm = xyz_bfield / fields % b_abs if ( fields % e_abs . ne . 0 ) fields % e_norm = xyz_efield / fields % e_abs call calc_perp_vectors ( fields % b_norm , fields % a_norm , fields % c_norm ) fields % pos = xyz fields % in_plasma = . True . endif end subroutine get_fields subroutine get_distribution ( fbeam , pos , ind ) real ( double ), dimension (:,:), intent ( out ) :: fbeam real ( double ), dimension ( 3 ), intent ( in ), optional :: pos integer ( long ), dimension ( 3 ), intent ( in ), optional :: ind real ( double ), dimension ( 3 ) :: xyz , uvw real ( double ) :: R , Z logical :: in_plasma1 integer :: err if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) in_plasma1 = . False . call in_plasma ( xyz , in_plasma1 ) if ( in_plasma1 ) then call interpol ( inter_grid % r , inter_grid % z , fbm % f , R , Z , fbeam , err ) else fbeam = 0.0 endif end subroutine get_distribution subroutine get_ep_denf ( energy , pitch , denf , pos , ind ) real ( double ), intent ( in ) :: energy real ( double ), intent ( in ) :: pitch real ( double ), intent ( out ) :: denf real ( double ), dimension ( 3 ), intent ( in ), optional :: pos integer ( long ), dimension ( 3 ), intent ( in ), optional :: ind real ( double ), dimension ( 3 ) :: xyz , uvw real ( double ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam integer ( long ), dimension ( 2 ) :: epi integer ( long ), dimension ( 1 ) :: dummy real ( double ) :: R , Z real ( double ) :: dE , dp logical :: in_plasma1 if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) dummy = minloc ( abs ( fbm % energy - energy )) epi ( 1 ) = dummy ( 1 ) dummy = minloc ( abs ( fbm % pitch - pitch )) epi ( 2 ) = dummy ( 1 ) dE = abs ( fbm % energy ( epi ( 1 )) - energy ) dp = abs ( fbm % pitch ( epi ( 2 )) - pitch ) in_plasma1 = . False . call in_plasma ( xyz , in_plasma1 ) if ( in_plasma1 . and .( dE . le . fbm % dE ). and .( dp . le . fbm % dp )) then call interpol ( inter_grid % r , inter_grid % z , fbm % f , R , Z , fbeam ) denf = fbeam ( epi ( 1 ), epi ( 2 )) else denf = 0.0 endif end subroutine get_ep_denf !============================================================================= !--------------------------Result Storage Routines---------------------------- !============================================================================= subroutine store_neutrals ( ind , neut_type , dens , store_iter ) integer ( long ), dimension ( 3 ), intent ( in ) :: ind integer , intent ( in ) :: neut_type real ( double ), dimension (:), intent ( in ) :: dens logical , intent ( in ), optional :: store_iter logical :: iter if ( present ( store_iter )) then iter = store_iter else iter = . False . endif !$OMP CRITICAL(store_neutrals_1) if ( iter ) halo_iter_dens ( neut_type ) = halo_iter_dens ( neut_type ) + sum ( dens ) neut % dens (:, neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) = & neut % dens (:, neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) + dens ![neutrals/cm&#94;3] !$OMP END CRITICAL(store_neutrals_1) end subroutine store_neutrals subroutine store_births ( ind , neut_type , dflux ) integer ( long ), dimension ( 3 ), intent ( in ) :: ind integer ( long ), intent ( in ) :: neut_type real ( double ), intent ( in ) :: dflux !$OMP CRITICAL(store_births_1) birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) = & birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) + dflux !$OMP END CRITICAL(store_births_1) end subroutine store_births subroutine store_npa ( det , ri , rf , vn , flux ) integer , intent ( in ) :: det !! Detector/Channel Number real ( double ), dimension ( 3 ), intent ( in ) :: ri !! birth position real ( double ), dimension ( 3 ), intent ( in ) :: rf !! detector position real ( double ), dimension ( 3 ), intent ( in ) :: vn !! particle velocity real ( double ), intent ( in ) :: flux !sum(states)/(nlaunch*nloop)*beam_grid%dv [neutrals/s]a type ( LocalEMFields ) :: fields real ( double ), dimension ( 3 ) :: uvw_ri , uvw_rf , vn_norm real ( double ) :: energy , pitch integer ( long ), dimension ( 1 ) :: ienergy type ( NPAParticle ), dimension (:), allocatable :: parts ! Convert to machine coordinates call xyz_to_uvw ( ri , uvw_ri ) call xyz_to_uvw ( rf , uvw_rf ) ! Calculate energy energy = inputs % ab * v2_to_E_per_amu * dot_product ( vn , vn ) ! Calculate pitch if distribution actually uses pitch if ( inputs % dist_type . le . 2 ) then call get_fields ( fields , pos = ri ) vn_norm = vn / normp ( vn ) pitch = dot_product ( fields % b_norm , vn_norm ) else pitch = 0. d0 endif !$OMP CRITICAL(store_npa_1) npa % npart = npa % npart + 1 if ( npa % npart . gt . npa % nmax ) then allocate ( parts ( npa % npart - 1 )) parts = npa % part deallocate ( npa % part ) npa % nmax = int ( npa % nmax * 2 ) allocate ( npa % part ( npa % nmax )) npa % part ( 1 :( npa % npart - 1 )) = parts deallocate ( parts ) endif npa % part ( npa % npart )% detector = det npa % part ( npa % npart )% xi = uvw_ri ( 1 ) npa % part ( npa % npart )% yi = uvw_ri ( 2 ) npa % part ( npa % npart )% zi = uvw_ri ( 3 ) npa % part ( npa % npart )% xf = uvw_rf ( 1 ) npa % part ( npa % npart )% yf = uvw_rf ( 2 ) npa % part ( npa % npart )% zf = uvw_rf ( 3 ) npa % part ( npa % npart )% energy = energy npa % part ( npa % npart )% pitch = pitch npa % part ( npa % npart )% weight = flux ienergy = minloc ( abs ( npa % energy - energy )) npa % flux ( ienergy ( 1 ), det ) = npa % flux ( ienergy ( 1 ), det ) + flux / fbm % dE !$OMP END CRITICAL(store_npa_1) end subroutine store_npa !============================================================================= !--------------------------Atomic Physics Routines---------------------------- !============================================================================= subroutine neut_rates ( denn , vi , vn , rates ) real ( double ), dimension ( nlevs ), intent ( in ) :: denn !!density of neutrals cm-3 real ( double ), dimension ( 3 ), intent ( in ) :: vi , vn !!of neutrals/ions (cm/s) real ( double ), dimension ( nlevs ), intent ( out ) :: rates !! rates real ( double ), dimension ( nlevs , nlevs ) :: neut !!rate coeff real ( double ) :: eb !! relative Energy real ( double ) :: b1 , b2 , dlogE , logEmin , logeb real ( double ) :: vrel !! relative velocity integer :: ebi , neb , err !Eeff vrel = normp ( vi - vn ) eb = v2_to_E_per_amu * vrel ** 2 ! [kev/amu] logeb = log10 ( eb ) logEmin = tables % H_H_cx % logemin dlogE = tables % H_H_cx % dlogE neb = tables % H_H_cx % nenergy call interpol_coeff ( logEmin , dlogE , neb , logeb , ebi , b1 , b2 , err ) if ( err . eq . 1 ) then write ( * , '(a)' ) \"NEUT_RATES: Eb out of range of H_H_cx table\" stop endif neut (:,:) = ( b1 * tables % H_H_cx % log_cross (:,:, ebi ) + & b2 * tables % H_H_cx % log_cross (:,:, ebi + 1 )) where ( neut . lt . tables % H_H_cx % minlog_cross ) neut = 0. d0 elsewhere neut = 1 0. d0 ** neut end where rates = matmul ( neut , denn ) * vrel end subroutine neut_rates subroutine get_beam_cx_prob ( ind , pos , v_ion , types , prob ) integer ( long ), dimension ( 3 ), intent ( in ) :: ind real ( double ), dimension ( 3 ), intent ( in ) :: pos real ( double ), dimension ( 3 ), intent ( in ) :: v_ion integer ( long ), dimension (:), intent ( in ) :: types real ( double ), dimension ( nlevs ), intent ( out ) :: prob integer :: ntypes , i , ii real ( double ), dimension ( nlevs ) :: rates , denn real ( double ), dimension ( 3 ) :: vhalo , vnbi , vn vnbi = pos - nbi % src vnbi = vnbi / normp ( vnbi ) * nbi % vinj ntypes = size ( types ) prob = 0 do i = 1 , ntypes if (( types ( i ). le . 3 ). and .( types ( i ). ne . 0 )) then ! CX with full type'th energy NBI neutrals denn = neut % dens (:, types ( i ), ind ( 1 ), ind ( 2 ), ind ( 3 )) vn = vnbi / sqrt ( real ( types ( i ))) call neut_rates ( denn , v_ion , vn , rates ) prob = prob + rates else denn = neut % dens (:, types ( i ), ind ( 1 ), ind ( 2 ), ind ( 3 )) do ii = 1 , int ( n_halo_neutrate ) call mc_halo ( ind , vhalo ) call neut_rates ( denn , v_ion , vhalo , rates ) prob = prob + rates / n_halo_neutrate enddo endif enddo end subroutine get_beam_cx_prob subroutine get_rate_matrix ( plasma , i_type , eb , rmat ) type ( LocalProfiles ), intent ( in ) :: plasma integer , intent ( in ) :: i_type real ( double ), intent ( in ) :: eb real ( double ), dimension ( nlevs , nlevs ), intent ( out ) :: rmat real ( double ) :: logEmin , dlogE , logeb real ( double ) :: logTmin , dlogT , logti , logte integer :: neb , nt real ( double ) :: b11 , b12 , b21 , b22 , dene , denp , denimp real ( double ), dimension ( nlevs , nlevs ) :: H_H_pop , H_e_pop , H_Aq_pop real ( double ), dimension ( nlevs ) :: H_H_depop , H_e_depop , H_Aq_depop integer :: ebi , tii , tei , n , err_status H_H_pop = 0. d0 H_e_pop = 0. d0 H_Aq_pop = 0. d0 H_H_depop = 0. d0 H_e_depop = 0. d0 H_Aq_depop = 0. d0 denp = plasma % denp dene = plasma % dene denimp = plasma % denimp logeb = log10 ( eb ) logti = log10 ( plasma % ti ) logte = log10 ( plasma % te ) !!H_H err_status = 1 logEmin = tables % H_H % logemin logTmin = tables % H_H % logtmin dlogE = tables % H_H % dlogE dlogT = tables % H_H % dlogT neb = tables % H_H % nenergy nt = tables % H_H % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , & ebi , tii , b11 , b12 , b21 , b22 , err_status ) if ( err_status . eq . 1 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_H table. Setting H_H rates to zero\" write ( * , '(\"eb = \",f6.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",f6.3,\" [keV]\")' ) plasma % ti denp = 0. d0 endif H_H_pop = ( b11 * tables % H_H % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_H % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_H_pop . lt . tables % H_H % minlog_pop ) H_H_pop = 0. d0 elsewhere H_H_pop = denp * 1 0. d0 ** H_H_pop end where H_H_depop = ( b11 * tables % H_H % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_H % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_H_depop . lt . tables % H_H % minlog_depop ) H_H_depop = 0. d0 elsewhere H_H_depop = denp * 1 0. d0 ** H_H_depop end where !!H_e err_status = 1 logEmin = tables % H_e % logemin logTmin = tables % H_e % logtmin dlogE = tables % H_e % dlogE dlogT = tables % H_e % dlogT neb = tables % H_e % nenergy nt = tables % H_e % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logte , & ebi , tei , b11 , b12 , b21 , b22 , err_status ) if ( err_status . eq . 1 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Te out of range of H_e table. Setting H_e rates to zero\" write ( * , '(\"eb = \",f6.3,\" [keV]\")' ) eb write ( * , '(\"te = \",f6.3,\" [keV]\")' ) plasma % te dene = 0. d0 endif H_e_pop = ( b11 * tables % H_e % log_pop (:,:, ebi , tei , i_type ) + & b12 * tables % H_e % log_pop (:,:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_pop (:,:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_pop (:,:, ebi + 1 , tei + 1 , i_type )) where ( H_e_pop . lt . tables % H_e % minlog_pop ) H_e_pop = 0. d0 elsewhere H_e_pop = dene * 1 0. d0 ** H_e_pop end where H_e_depop = ( b11 * tables % H_e % log_depop (:, ebi , tei , i_type ) + & b12 * tables % H_e % log_depop (:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_depop (:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_depop (:, ebi + 1 , tei + 1 , i_type )) where ( H_e_depop . lt . tables % H_e % minlog_depop ) H_e_depop = 0. d0 elsewhere H_e_depop = dene * 1 0. d0 ** H_e_depop end where !!H_Aq err_status = 1 logEmin = tables % H_Aq % logemin logTmin = tables % H_Aq % logtmin dlogE = tables % H_Aq % dlogE dlogT = tables % H_Aq % dlogT neb = tables % H_Aq % nenergy nt = tables % H_Aq % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , & ebi , tii , b11 , b12 , b21 , b22 , err_status ) if ( err_status . eq . 1 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_Aq table. Setting H_Aq rates to zero\" write ( * , '(\"eb = \",f6.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",f6.3,\" [keV]\")' ) plasma % ti denimp = 0. d0 endif H_Aq_pop = ( b11 * tables % H_Aq % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_pop . lt . tables % H_Aq % minlog_pop ) H_Aq_pop = 0. d0 elsewhere H_Aq_pop = denimp * 1 0. d0 ** H_Aq_pop end where H_Aq_depop = ( b11 * tables % H_Aq % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_depop . lt . tables % H_Aq % minlog_depop ) H_Aq_depop = 0. d0 elsewhere H_Aq_depop = denimp * 1 0. d0 ** H_Aq_depop end where rmat = tables % einstein + H_H_pop + H_e_pop + H_Aq_pop do n = 1 , nlevs rmat ( n , n ) = - sum ( tables % einstein (:, n )) - H_H_depop ( n ) - H_e_depop ( n ) - H_Aq_depop ( n ) enddo end subroutine get_rate_matrix subroutine colrad ( plasma , i_type , vn , dt , states , dens , photons ) type ( LocalProfiles ), intent ( in ) :: plasma !! Local plasma parameters integer , intent ( in ) :: i_type !! Ion type (beam,thermal) real ( double ), dimension (:), intent ( in ) :: vn !!velocitiy (cm/s) real ( double ), intent ( in ) :: dt !!time interval in cell real ( double ), dimension (:), intent ( inout ) :: states !! Density of states real ( double ), dimension ( nlevs ), intent ( out ) :: dens !! Density of neutrals real ( double ), intent ( out ) :: photons !! Emitted photons(3->2) real ( double ), dimension ( nlevs , nlevs ) :: matrix !! Matrix real ( double ) :: b_amu real ( double ) :: vnet_square !! netto velocity of neutrals real ( double ) :: eb !! Energy of the fast neutral real ( double ), dimension ( nlevs , nlevs ) :: eigvec , eigvec_inv real ( double ), dimension ( nlevs ) :: eigval , coef real ( double ), dimension ( nlevs ) :: exp_eigval_dt real ( double ) :: iflux !!Initial total flux integer :: n photons = 0. d0 dens = 0. d0 iflux = sum ( states ) if ( iflux . lt . colrad_threshold . and . inputs % calc_npa . eq . 0 ) then return endif if (. not . plasma % in_plasma ) then dens = states * dt return endif if ( i_type . eq . beam_ion ) then b_amu = inputs % ab else b_amu = inputs % ai endif vnet_square = dot_product ( vn - plasma % vrot , vn - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * b_amu * vnet_square ![kev] call get_rate_matrix ( plasma , i_type , eb , matrix ) call eigen ( nlevs , matrix , eigvec , eigval ) call matinv ( eigvec , eigvec_inv ) coef = matmul ( eigvec_inv , states ) !coeffs determined from states at t=0 exp_eigval_dt = exp ( eigval * dt ) ! to improve speed (used twice) do n = 1 , nlevs if ( eigval ( n ). eq . 0.0 ) eigval ( n ) = eigval ( n ) + 1 !protect against dividing by zero enddo states = matmul ( eigvec , coef * exp_eigval_dt ) ![neutrals/cm&#94;3/s]! dens = matmul ( eigvec , coef * ( exp_eigval_dt - 1. d0 ) / eigval ) if (( minval ( states ). lt . 0 ). or .( minval ( dens ). lt . 0 )) then do n = 1 , nlevs if ( states ( n ). lt . 0 ) states ( n ) = 0. d0 if ( dens ( n ). lt . 0 ) dens ( n ) = 0. d0 enddo endif photons = dens ( 3 ) * tables % einstein ( 2 , 3 ) !! - [Ph/(s*cm&#94;3)] - !! end subroutine colrad subroutine attenuate ( ri , rf , vi , states , dstep_in ) real ( double ), dimension ( 3 ), intent ( in ) :: ri real ( double ), dimension ( 3 ), intent ( in ) :: rf real ( double ), dimension ( 3 ), intent ( in ) :: vi real ( double ), dimension ( nlevs ), intent ( inout ) :: states real ( double ), intent ( in ), optional :: dstep_in type ( LocalProfiles ) :: plasma real ( double ) :: photons , vabs , dt , dstep , dis , max_dis real ( double ), dimension ( 3 ) :: r0 real ( double ), dimension ( nlevs ) :: dens if ( present ( dstep_in )) then dstep = dstep_in else dstep = sqrt ( inter_grid % da ) !cm endif max_dis = normp ( rf - ri ) vabs = normp ( vi ) dt = dstep / vabs call get_plasma ( plasma , pos = ri ) r0 = ri dis = 0. d0 do while ( dis . le . max_dis ) call colrad ( plasma , beam_ion , vi , dt , states , dens , photons ) r0 = r0 + vi * dt dis = dis + dstep call get_plasma ( plasma , pos = r0 ) enddo end subroutine attenuate subroutine spectrum ( vecp , vi , fields , sigma_pi , photons , dlength , lambda , intensity ) real ( double ), dimension ( 3 ), intent ( in ) :: vecp real ( double ), dimension ( 3 ), intent ( in ) :: vi type ( LocalEMFields ), intent ( in ) :: fields real ( double ), intent ( in ) :: sigma_pi real ( double ), intent ( in ) :: photons real ( double ), intent ( in ) :: dlength real ( double ), dimension ( n_stark ), intent ( out ) :: lambda real ( double ), dimension ( n_stark ), intent ( out ) :: intensity real ( double ), dimension ( 3 ) :: vp , vn real ( double ), dimension ( 3 ) :: bfield , efield real ( double ) :: E , cos_los_Efield , lambda_shifted integer , parameter , dimension ( n_stark ) :: stark_sign = + 1 * stark_sigma - 1 * stark_pi !! vector directing towards the optical head vp = vecp / normp ( vecp ) ! Calculate Doppler shift vn = vi * 0.01 d0 ! [m/s] lambda_shifted = lambda0 * ( 1. d0 + dot_product ( vn , vp ) / c0 ) !! Calculate Stark Splitting ! Calculate E-field bfield = fields % b_norm * fields % b_abs efield = fields % e_norm * fields % e_abs efield ( 1 ) = efield ( 1 ) + vn ( 2 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 2 ) efield ( 2 ) = efield ( 2 ) - ( vn ( 1 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 1 )) efield ( 3 ) = efield ( 3 ) + vn ( 1 ) * bfield ( 2 ) - vn ( 2 ) * bfield ( 1 ) E = normp ( efield ) !Stark Splitting lambda = lambda_shifted + E * stark_wavel ![A] !Intensities of stark components if ( E . eq . 0. d0 ) then cos_los_Efield = 0. d0 else cos_los_Efield = dot_product ( vp , efield ) / E endif intensity = stark_intens * ( 1. d0 + stark_sign * cos_los_Efield ** 2. d0 ) !! --- E.g. mirrors may change the pi to sigma intensity ratio  --- !! where ( stark_sigma . eq . 1 ) intensity = intensity * sigma_pi endwhere !! --- normalize and multiply with photon density from colrad --- !! intensity = intensity / sum ( intensity ) * photons * dlength endsubroutine spectrum subroutine store_bes_photons ( pos , vi , photons , neut_type ) real ( double ), dimension ( 3 ), intent ( in ) :: pos !! Position of neutral real ( double ), dimension ( 3 ), intent ( in ) :: vi !!velocitiy of neutral [cm/s] real ( double ), intent ( in ) :: photons !! photons from colrad [Ph/(s*cm&#94;3)] integer , intent ( in ) :: neut_type real ( double ), dimension ( n_stark ) :: lambda , intensity real ( double ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( long ), dimension ( 3 ) :: ind real ( double ), dimension ( 3 ) :: vp integer :: ichan , i , bin call get_indices ( pos , ind ) call get_fields ( fields , pos = pos ) loop_over_channels : do ichan = 1 , spec_chords % nchan dlength = spec_chords % dlength ( ichan , ind ( 1 ), ind ( 2 ), ind ( 3 )) if ( dlength . le . 0.0 ) cycle loop_over_channels sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin ) / inputs % dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda ) cycle loop_over_stark !$OMP CRITICAL(bes_spectrum) spec % bes ( bin , ichan , neut_type ) = & spec % bes ( bin , ichan , neut_type ) + intensity ( i ) !$OMP END CRITICAL(bes_spectrum) enddo loop_over_stark enddo loop_over_channels end subroutine store_bes_photons subroutine store_fida_photons ( pos , vi , photons , orbit_class ) real ( double ), dimension ( 3 ), intent ( in ) :: pos !! Position of neutral real ( double ), dimension ( 3 ), intent ( in ) :: vi !!velocitiy of fast neutral [cm/s] real ( double ), intent ( in ) :: photons !! photons from colrad [Ph/(s*cm&#94;3)] integer , intent ( in ), optional :: orbit_class real ( double ), dimension ( n_stark ) :: lambda , intensity real ( double ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( long ), dimension ( 3 ) :: ind real ( double ), dimension ( 3 ) :: vp integer :: ichan , i , bin , iclass if ( present ( orbit_class )) then iclass = orbit_class else iclass = 1 endif call get_indices ( pos , ind ) call get_fields ( fields , pos = pos ) loop_over_channels : do ichan = 1 , spec_chords % nchan dlength = spec_chords % dlength ( ichan , ind ( 1 ), ind ( 2 ), ind ( 3 )) if ( dlength . le . 0.0 ) cycle loop_over_channels sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin ) / inputs % dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda ) cycle loop_over_stark !$OMP CRITICAL(fida_spectrum) spec % fida ( bin , ichan , iclass ) = & spec % fida ( bin , ichan , iclass ) + intensity ( i ) !$OMP END CRITICAL(fida_spectrum) enddo loop_over_stark enddo loop_over_channels end subroutine store_fida_photons subroutine store_fw_photons_at_chan ( ichan , eind , pind , vp , vi , fields , dlength , sigma_pi , denf , photons ) integer , intent ( in ) :: ichan integer , intent ( in ) :: eind integer , intent ( in ) :: pind real ( double ), dimension ( 3 ), intent ( in ) :: vp !! Photon direction real ( double ), dimension ( 3 ), intent ( in ) :: vi !!velocity of neutral [cm/s] type ( LocalEMFields ), intent ( in ) :: fields real ( double ), intent ( in ) :: dlength real ( double ), intent ( in ) :: sigma_pi real ( double ), intent ( in ) :: denf real ( double ), intent ( in ) :: photons !! photons from colrad [Ph/(s*cm&#94;3)] real ( double ), dimension ( n_stark ) :: lambda , intensity real ( double ) :: dlambda , intens_fac integer :: i , bin dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght intens_fac = ( 1. d0 ) / ( 4. d0 * pi * dlambda ) call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) !$OMP CRITICAL(fida_wght) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) * 0.1 - inputs % lambdamin_wght ) / dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda_wght ) cycle loop_over_stark fweight % fida ( bin , ichan ) = fweight % fida ( bin , ichan ) + & ( denf * intens_fac * 1. d4 ) * intensity ( i ) !ph/(s*nm*sr*m&#94;2) fweight % weight ( bin , eind , pind , ichan ) = & fweight % weight ( bin , eind , pind , ichan ) + intensity ( i ) * intens_fac !(ph*cm)/(s*nm*sr*fast-ion*dE*dp) enddo loop_over_stark if ( denf . gt . 0. d0 ) then fweight % mean_f ( eind , pind , ichan ) = fweight % mean_f ( eind , pind , ichan ) + & ( denf * intens_fac ) * sum ( intensity ) endif !$OMP END CRITICAL(fida_wght) end subroutine store_fw_photons_at_chan subroutine store_fw_photons ( eind , pind , pos , vi , denf , photons ) integer , intent ( in ) :: eind integer , intent ( in ) :: pind real ( double ), dimension ( 3 ), intent ( in ) :: pos !! Position of neutral real ( double ), dimension ( 3 ), intent ( in ) :: vi !!velocity of neutral [cm/s] real ( double ), intent ( in ) :: denf real ( double ), intent ( in ) :: photons !! photons from colrad [Ph/(s*cm&#94;3)] real ( double ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( long ), dimension ( 3 ) :: ind real ( double ), dimension ( 3 ) :: vp integer :: ichan call get_indices ( pos , ind ) call get_fields ( fields , pos = pos ) loop_over_channels : do ichan = 1 , spec_chords % nchan dlength = spec_chords % dlength ( ichan , ind ( 1 ), ind ( 2 ), ind ( 3 )) if ( dlength . le . 0.0 ) cycle loop_over_channels sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call store_fw_photons_at_chan ( ichan , eind , pind , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo loop_over_channels end subroutine store_fw_photons !============================================================================= !---------------------------Monte Carlo Routines------------------------------ !============================================================================= subroutine get_nlaunch ( nr_markers , papprox , papprox_tot , nlaunch ) !! routine to define the number of MC particles started in one cell integer ( long ), intent ( in ) :: nr_markers real ( double ), dimension (:,:,:), intent ( in ) :: papprox real ( double ) , intent ( in ) :: papprox_tot real ( double ), dimension (:,:,:), intent ( out ) :: nlaunch integer :: i , j , k , cc real ( double ), dimension (:), allocatable :: randomu do i = 1 , 1000 nlaunch (:,:,:) = papprox (:,:,:) / papprox_tot * nr_markers * ( 1. + i * 0.01 ) if ( sum ( nlaunch ). gt . nr_markers ) then exit endif enddo allocate ( randomu ( count ( nlaunch . gt . 0 ))) call randu ( randomu ) cc = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx if ( nlaunch ( i , j , k ). gt . 0. ) then if ( mod ( nlaunch ( i , j , k ), 1. ). gt . randomu ( cc )) then nlaunch ( i , j , k ) = nlaunch ( i , j , k ) + 1. endif cc = cc + 1 endif enddo enddo enddo do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx nlaunch ( i , j , k ) = floor ( nlaunch ( i , j , k )) enddo enddo enddo deallocate ( randomu ) end subroutine get_nlaunch subroutine pitch_to_vec ( pitch , gyroangle , fields , vi_norm ) real ( double ), intent ( in ) :: pitch real ( double ), intent ( in ) :: gyroangle type ( LocalEMFields ), intent ( in ) :: fields real ( double ), dimension ( 3 ), intent ( out ) :: vi_norm real ( double ) :: sinus sinus = sqrt ( 1. d0 - pitch ** 2 ) vi_norm = ( sinus * cos ( gyroangle ) * fields % a_norm + & pitch * fields % b_norm + & sinus * sin ( gyroangle ) * fields % c_norm ) end subroutine pitch_to_vec subroutine gyro_correction ( vi , fields , r_gyro ) real ( double ), dimension ( 3 ), intent ( in ) :: vi type ( LocalEMFields ), intent ( in ) :: fields real ( double ), dimension ( 3 ), intent ( out ) :: r_gyro real ( double ), dimension ( 3 ) :: vxB real ( double ) :: one_over_omega one_over_omega = inputs % ab * mass_u / ( fields % b_abs * e0 ) vxB = cross_product ( vi , fields % b_norm ) r_gyro = vxB * one_over_omega end subroutine gyro_correction subroutine mc_fastion ( ind , ri , vi , at_guiding_center ) integer , dimension ( 3 ), intent ( in ) :: ind !ind of actual cell real ( double ), dimension ( 3 ), intent ( out ) :: ri !starting position real ( double ), dimension ( 3 ), intent ( out ) :: vi !velocity [cm/s] logical , intent ( in ), optional :: at_guiding_center !indicates that ri is at gyrocenter !Defaults to true type ( LocalEMFields ) :: fields real ( double ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam real ( double ), dimension ( 3 ) :: r_gyro , rp real ( double ) :: eb , ptch integer :: ii , ienergy , ipitch real ( double ) :: vabs , phi real ( double ), dimension ( 3 ) :: randomu3 real ( double ), dimension ( 4 ) :: randomu4 integer , dimension ( 1 ) :: minpos integer , dimension ( 2 , 1 ) :: ep_ind real ( double ), dimension ( 1 ) :: max_fbm logical :: use_inverse_sampler if ( present ( at_guiding_center )) then use_inverse_sampler = at_guiding_center else use_inverse_sampler = . True . endif call randu ( randomu3 ) ri ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( randomu3 ( 1 ) - 0.5 ) ri ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( randomu3 ( 2 ) - 0.5 ) ri ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( randomu3 ( 3 ) - 0.5 ) vi = 0. d0 call get_fields ( fields , pos = ri ) if (. not . fields % in_plasma ) return if ( use_inverse_sampler ) then call get_distribution ( fbeam , pos = ri ) call randind ( fbeam , ep_ind ) call randu ( randomu3 ) eb = fbm % energy ( ep_ind ( 1 , 1 )) + fbm % dE * ( randomu3 ( 1 ) - 0.5 ) ptch = fbm % pitch ( ep_ind ( 2 , 1 )) + fbm % dp * ( randomu3 ( 2 ) - 0.5 ) phi = 2. d0 * pi * randomu3 ( 3 ) !! Calculate gyroradius vabs = sqrt ( eb / ( v2_to_E_per_amu * inputs % ab )) call pitch_to_vec ( ptch , phi , fields , vi ) vi = vabs * vi call gyro_correction ( vi , fields , r_gyro ) !! Move a gyro-orbit away ri = ri - r_gyro else !! Use rejection method to determine velocity vector rejection_loop : do ii = 1 , 10000 call randu ( randomu4 ) !! Pick a random energy, pitch, and gyro angle eb = fbm % emin + fbm % e_range * randomu4 ( 1 ) ptch = fbm % pmin + fbm % p_range * randomu4 ( 2 ) phi = 2. d0 * pi * randomu4 ( 3 ) !! Calculate gyroradius vabs = sqrt ( eb / ( v2_to_E_per_amu * inputs % ab )) call pitch_to_vec ( ptch , phi , fields , vi ) vi = vabs * vi call gyro_correction ( vi , fields , r_gyro ) !! Move a gyro-orbit away and sample distribution there rp = ri + r_gyro call get_distribution ( fbeam , pos = rp ) max_fbm = maxval ( fbeam ) !! Find new cell if ( max_fbm ( 1 ). gt . 0.0 ) then !! take point in FBM distribution closest to eb, ptch. minpos = minloc ( abs ( eb - fbm % energy )) ienergy = minpos ( 1 ) minpos = minloc ( abs ( ptch - fbm % pitch )) ipitch = minpos ( 1 ) if (( fbeam ( ienergy , ipitch )). gt .( randomu4 ( 4 ) * max_fbm ( 1 ))) then return endif endif vi = 0. d0 enddo rejection_loop write ( * , '(a)' ) 'MC_FASTION: Rejection method found no solution!' endif end subroutine mc_fastion subroutine mc_halo ( ind , vhalo , ri , plasma_in ) integer , dimension ( 3 ), intent ( in ) :: ind !! index of actual cell real ( double ), dimension ( 3 ), intent ( out ) :: vhalo !! velocity [cm/s] real ( double ), dimension ( 3 ), intent ( out ), optional :: ri type ( LocalProfiles ), intent ( in ), optional :: plasma_in type ( LocalProfiles ) :: plasma real ( double ), dimension ( 3 ) :: random3 if (. not . present ( plasma_in )) then if ( present ( ri )) then call randu ( random3 ) ri ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( random3 ( 1 ) - 0.5 ) ri ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( random3 ( 2 ) - 0.5 ) ri ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( random3 ( 3 ) - 0.5 ) call get_plasma ( plasma , pos = ri ) else call get_plasma ( plasma , ind = ind ) endif else plasma = plasma_in endif call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 !![cm/s] end subroutine mc_halo subroutine mc_nbi ( vnbi , efrac , rnbi ) integer , intent ( in ) :: efrac !! energy fraction real ( double ), dimension ( 3 ), intent ( out ) :: vnbi !! velocity [cm/s] real ( double ), dimension ( 3 ), intent ( out ) :: rnbi !! position real ( double ), dimension ( 3 ) :: r_exit real ( double ), dimension ( 3 ) :: uvw_src !! Start position on ion source real ( double ), dimension ( 3 ) :: xyz_src !! Start position on ion source real ( double ), dimension ( 3 ) :: uvw_ray !! NBI velocity in uvw coords real ( double ), dimension ( 3 ) :: xyz_ray !! NBI velocity in xyz coords real ( double ), dimension ( 2 ) :: randomu !! uniform random numbers real ( double ), dimension ( 2 ) :: randomn !! normal random numbers real ( double ) :: length , sqrt_rho , theta call randu ( randomu ) select case ( nbi % shape ) case ( 1 ) ! Uniformally sample in rectangle xyz_src ( 1 ) = 0. d0 xyz_src ( 2 ) = nbi % widy * 2. d0 * ( randomu ( 1 ) - 0.5 d0 ) xyz_src ( 3 ) = nbi % widz * 2. d0 * ( randomu ( 2 ) - 0.5 d0 ) case ( 2 ) ! Uniformally sample in ellipse sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) xyz_src ( 1 ) = 0. d0 xyz_src ( 2 ) = nbi % widy * sqrt_rho * cos ( theta ) xyz_src ( 3 ) = nbi % widz * sqrt_rho * sin ( theta ) end select !! Create random velocity vector call randn ( randomn ) xyz_ray ( 1 ) = 1. d0 xyz_ray ( 2 ) = ( xyz_src ( 2 ) / nbi % focy + tan ( nbi % divy ( efrac ) * randomn ( 1 ))) xyz_ray ( 3 ) = ( xyz_src ( 3 ) / nbi % focz + tan ( nbi % divz ( efrac ) * randomn ( 2 ))) !! Convert to beam sightline coordinates to beam grid coordinates uvw_src = matmul ( nbi % basis , xyz_src ) + nbi % src uvw_ray = matmul ( nbi % basis , xyz_ray ) vnbi = uvw_ray / normp ( uvw_ray ) !! ----------- Determine start postition on FIDASIM beam grid --------- !! call grid_intersect ( uvw_src , vnbi , length , rnbi , r_exit ) if ( length . le . 0.0 ) then rnbi = [ - 1. d0 , 0. d0 , 0. d0 ] nbi_outside = nbi_outside + 1 endif !! ---- Determine velocity of neutrals corrected by efrac ---- !! vnbi = vnbi * nbi % vinj / sqrt ( real ( efrac )) end subroutine mc_nbi !============================================================================= !------------------------Primary Simulation Routines-------------------------- !============================================================================= subroutine ndmc integer :: neut_type !! full half third energy real ( double ) :: nlaunch !! nr. of markers real ( double ) :: nneutrals !! # NBI particles real ( double ), dimension ( 3 ) :: vnbi !! velocities(full..) real ( double ), dimension ( 3 ) :: rnbi !! initial position integer :: jj , ii , kk integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks integer , dimension ( 3 ) :: nl_birth type ( LocalProfiles ) :: plasma real ( double ), dimension ( nlevs ) :: states , dens real ( double ) :: photons , iflux integer ( long ), dimension ( 3 ) :: ind real ( double ), dimension ( 1 ) :: randomu integer , dimension ( 1 ) :: randi if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) inputs % n_nbi endif !! ------------- calculate nr. of injected neutrals ---------------- !! !! # of injected neutrals = NBI power/energy_per_particle nneutrals = 1. d6 * nbi % pinj / ( 1. d3 * nbi % einj * e0 & * ( nbi % species_mix ( 1 ) & + nbi % species_mix ( 2 ) / 2. d0 & + nbi % species_mix ( 3 ) / 3. d0 ) ) nlaunch = real ( inputs % n_nbi ) !$OMP PARALLEL DO schedule(guided) & !$OMP& private(vnbi,rnbi,tracks,ncell,plasma,nl_birth,randi, & !$OMP& states,dens,iflux,photons,neut_type,jj,ii,kk,ind) loop_over_markers : do ii = 1 , inputs % n_nbi !! (type = 1: full energy, =2: half energy, =3: third energy if ( inputs % calc_birth . ge . 1 ) then nl_birth = 0 do kk = 1 , inputs % n_birth call randind ( nbi % species_mix , randi ) nl_birth ( randi ( 1 )) = nl_birth ( randi ( 1 )) + 1 enddo endif energy_fractions : do neut_type = 1 , 3 call mc_nbi ( vnbi , neut_type , rnbi ) if ( rnbi ( 1 ). eq . - 1 ) cycle loop_over_markers call track ( rnbi , vnbi , tracks , ncell ) if ( ncell . eq . 0 ) cycle loop_over_markers !! --------- solve collisional radiative model along track ----- !! states = 0. d0 states ( 1 ) = nneutrals * nbi % species_mix ( neut_type ) / beam_grid % dv loop_along_track : do jj = 1 , ncell iflux = sum ( states ) ind = tracks ( jj )% ind call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vnbi , tracks ( jj )% time , states , dens , photons ) call store_neutrals ( ind , neut_type , dens / nlaunch ) tracks ( jj )% flux = ( iflux - sum ( states )) * beam_grid % dv / nlaunch if ( inputs % calc_birth . ge . 1 ) then call store_births ( ind , neut_type , tracks ( jj )% flux ) endif if (( photons . gt . 0. d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vnbi , photons / nlaunch , neut_type ) endif enddo loop_along_track if ( inputs % calc_birth . ge . 1 ) then do kk = 1 , nl_birth ( neut_type ) call randind ( tracks ( 1 : ncell )% flux , randi ) call randu ( randomu ) birth % vi (:, birth % ind ) = vnbi birth % ri (:, birth % ind ) = tracks ( randi ( 1 ))% pos + & vnbi * ( tracks ( randi ( 1 ))% time * ( randomu ( 1 ) - 0.5 )) birth % ind = birth % ind + 1 enddo endif enddo energy_fractions enddo loop_over_markers !$OMP END PARALLEL DO if ( nbi_outside . gt . 0 ) then write ( * , '(a, f6.2)' ) 'Percent of markers outside the grid: ' , & 10 0. * nbi_outside / ( 3. * inputs % n_nbi ) if ( sum ( neut % dens ). eq . 0 ) stop 'Beam does not intersect the grid!' endif end subroutine ndmc subroutine bremsstrahlung type ( LocalProfiles ) :: plasma integer :: i , ichan , nc , ic real ( double ) :: dlength , gaunt , max_length real ( double ) :: spot_size , theta , sqrt_rho real ( double ), dimension ( 2 ) :: randomu real ( double ), dimension ( 3 ) :: vi , xyz , r0 real ( double ), dimension ( 3 , 3 ) :: basis real ( double ), dimension (:), allocatable :: lambda_arr , brems allocate ( lambda_arr ( inputs % nlambda )) allocate ( brems ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = ( i - 0.5 ) * inputs % dlambda + inputs % lambdamin ! [A] enddo dlength = 0.3 !cm !! $OMP PARALLEL DO schedule(guided) private(ichan,xyz,vi,basis,spot_size, & !! $OMP& ic, nc,randomu,sqrt_rho,theta,r0,plasma,gaunt,brems) loop_over_channels : do ichan = 1 , spec_chords % nchan xyz = spec_chords % los ( ichan )% lens vi = spec_chords % los ( ichan )% axis vi = vi / normp ( vi ) spot_size = spec_chords % los ( ichan )% spot_size call line_basis ( xyz , vi , basis ) if ( spot_size . le . 0. d0 ) then nc = 1 else nc = 100 endif do ic = 1 , nc call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0. d0 r0 ( 2 ) = spot_size * sqrt_rho * cos ( theta ) r0 ( 3 ) = spot_size * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + xyz ! Find edge of plasma call get_plasma ( plasma , pos = r0 ) max_length = 0.0 do while (. not . plasma % in_plasma ) r0 = r0 + vi * dlength ! move dlength call get_plasma ( plasma , pos = r0 ) max_length = max_length + dlength if ( max_length . gt . 300 ) cycle loop_over_channels enddo ! Calculate bremsstrahlung along los do while ( plasma % in_plasma ) if ( plasma % te . gt . 0.0 ) then gaunt = 5.542 - ( 3.108 - log ( plasma % te )) * ( 0.6905 - 0.1323 / plasma % zeff ) brems = 7.57 d - 9 * gaunt * plasma % dene ** 2 * plasma % zeff / ( lambda_arr & * sqrt ( plasma % te * 100 0.0 )) * exp ( - h_planck * c0 / ( lambda_arr * plasma % te * 100 0.0 )) & * inputs % dlambda * ( 4. d0 * pi ) * 1. d - 4 spec % brems (:, ichan ) = spec % brems (:, ichan ) + ( brems * dlength * 1. d - 2 ) / nc endif ! Take a step r0 = r0 + vi * dlength call get_plasma ( plasma , pos = r0 ) enddo enddo if ( inputs % verbose . eq . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) 100 * ichan / real ( spec_chords % nchan ), char ( 13 ) endif enddo loop_over_channels !! $OMP END PARALLEL DO deallocate ( lambda_arr , brems ) end subroutine bremsstrahlung subroutine dcx integer :: i , j , k !indices of cells integer :: idcx !! counter real ( double ), dimension ( 3 ) :: ri !! start position real ( double ), dimension ( 3 ) :: vihalo integer , dimension ( 3 ) :: ind !! actual cell integer , dimension ( 3 ) :: neut_types = [ 1 , 2 , 3 ] !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( double ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( double ), dimension ( nlevs ) :: prob !!  Prob. for CX !! Collisiional radiative model along track real ( double ), dimension ( nlevs ) :: states ! Density of n-states integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle tracks integer :: jj !! counter along track real ( double ) :: tot_denn , photons !! photon flux real ( double ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density real ( double ) :: papprox_tot , ccnt , inv_ng halo_iter_dens ( halo_type ) = 0. d0 !! ------------- calculate papprox needed for guess of nlaunch --------!! papprox = 0. d0 papprox_tot = 0. d0 tot_denn = 0. d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) tot_denn = sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo call get_nlaunch ( inputs % n_dcx , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch )) endif ccnt = 0. d0 inv_ng = 10 0.0 / real ( beam_grid % ngrid ) !$OMP PARALLEL DO schedule(guided) collapse(3) private(i,j,k,idcx,ind,vihalo, & !$OMP& ri,tracks,ncell,prob,denn,states,jj,photons,plasma) loop_along_z : do k = 1 , beam_grid % nz loop_along_y : do j = 1 , beam_grid % ny loop_along_x : do i = 1 , beam_grid % nx !! ------------- loop over the markers ---------------------- !! loop_over_dcx : do idcx = 1 , int ( nlaunch ( i , j , k )) !! ---------------- calculate ri,vhalo and track ----------!! ind = [ i , j , k ] call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ncell ) if ( ncell . eq . 0 ) cycle loop_over_dcx !! ---------------- calculate CX probability --------------!! call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vihalo , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_dcx !! --------- solve collisional radiative model along track-!! call get_plasma ( plasma , pos = tracks ( 1 )% pos ) states = prob * ( plasma % denp - plasma % denf ) loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) call store_neutrals ( tracks ( jj )% ind , halo_type , denn / nlaunch ( i , j , k ), plasma % in_plasma ) if (( photons . gt . 0. d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), halo_type ) endif enddo loop_along_track enddo loop_over_dcx ccnt = ccnt + 1 if ( inputs % verbose . eq . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) ccnt * inv_ng , char ( 13 ) endif enddo loop_along_x enddo loop_along_y enddo loop_along_z !$OMP END PARALLEL DO end subroutine dcx subroutine halo integer :: i , j , k !indices of cells integer :: ihalo !! counter real ( double ), dimension ( 3 ) :: ri !! start position real ( double ), dimension ( 3 ) :: vihalo !! velocity bulk plasma ion integer , dimension ( 3 ) :: ind !! actual cell !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( double ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( double ), dimension ( nlevs ) :: prob !!  Prob. for CX !! Collisiional radiative model along track real ( double ), dimension ( nlevs ) :: states ! Density of n-states integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle Tracks integer :: jj !! counter along track real ( double ) :: tot_denn , photons !! photon flux real ( double ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density real ( double ) :: papprox_tot , ccnt , inv_ng !! Halo iteration integer :: hh !! counters real ( double ) :: dcx_dens , halo_iteration_dens integer :: s1type ! halo iteration integer :: s2type ! halo iteration s1type = fida_type s2type = brems_type dcx_dens = halo_iter_dens ( halo_type ) if ( dcx_dens . eq . 0 ) then write ( * , '(a)' ) 'HALO: Density of DCX-neutrals is zero' stop endif inv_ng = 10 0.0 / real ( beam_grid % ngrid ) neut % dens (:, s1type ,:,:,:) = neut % dens (:, halo_type ,:,:,:) iterations : do hh = 1 , 200 !! ------------- calculate papprox needed for guess of nlaunch --------!! papprox = 0. d0 papprox_tot = 0. d0 tot_denn = 0. d0 halo_iter_dens ( s2type ) = 0. d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) tot_denn = sum ( neut % dens (:, s1type , i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo call get_nlaunch ( inputs % n_halo , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch )) endif ccnt = 0. d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(i,j,k,ihalo,ind,vihalo, & !$OMP& ri,tracks,ncell,prob,denn,states,jj,photons,plasma) loop_along_z : do k = 1 , beam_grid % nz loop_along_y : do j = 1 , beam_grid % ny loop_along_x : do i = 1 , beam_grid % nx !! ------------- loop over the markers ---------------------- !! loop_over_halos : do ihalo = 1 , int ( nlaunch ( i , j , k )) !! ---------------- calculate ri,vhalo and track ----------!! ind = [ i , j , k ] call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ncell ) if ( ncell . eq . 0 ) cycle loop_over_halos !! ---------------- calculate CX probability --------------!! call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vihalo ,[ s1type ], prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_halos !! --------- solve collisional radiative model along track-!! call get_plasma ( plasma , pos = tracks ( 1 )% pos ) states = prob * plasma % denp loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) call store_neutrals ( tracks ( jj )% ind , s2type , & denn / nlaunch ( i , j , k ), plasma % in_plasma ) if (( photons . gt . 0. d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), halo_type ) endif enddo loop_along_track enddo loop_over_halos ccnt = ccnt + 1 if ( inputs % verbose . eq . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) ccnt * inv_ng , char ( 13 ) endif enddo loop_along_x enddo loop_along_y enddo loop_along_z !$OMP END PARALLEL DO halo_iteration_dens = halo_iter_dens ( s2type ) neut % dens (:, halo_type ,:,:,:) = neut % dens (:, halo_type ,:,:,:) & + neut % dens (:, s2type ,:,:,:) neut % dens (:, s1type ,:,:,:) = neut % dens (:, s2type ,:,:,:) neut % dens (:, s2type ,:,:,:) = 0. if ( halo_iteration_dens / dcx_dens . gt . 1 ) exit iterations inputs % n_halo = int ( inputs % n_dcx * halo_iteration_dens / dcx_dens ) if ( inputs % n_halo . lt . inputs % n_dcx * 0.01 ) exit iterations enddo iterations !! set the neutral density in s1type(fida_type) and s2type (brems) to 0! neut % dens (:, s1type ,:,:,:) = 0. d0 neut % dens (:, s2type ,:,:,:) = 0. d0 end subroutine halo subroutine fida_f integer :: i , j , k !! indices  x,y,z of cells integer ( kind = 8 ) :: iion , ip real ( double ), dimension ( 3 ) :: ri !! start position real ( double ), dimension ( 3 ) :: vi !! velocity of fast ions integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] logical :: los_intersect !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( double ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track integer :: ncell integer :: jj !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( double ) :: photons !! photon flux real ( double ), dimension ( nlevs ) :: states !! Density of n-states real ( double ), dimension ( nlevs ) :: denn !! Number of particles to launch integer ( kind = 8 ) :: pcnt real ( double ) :: papprox_tot , inv_maxcnt , cnt integer , dimension ( 3 , beam_grid % ngrid ) :: pcell real ( double ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density !! Estimate how many particles to launch in each cell papprox = 0. d0 papprox_tot = 0. d0 pcnt = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) papprox ( i , j , k ) = ( sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) + & sum ( neut % dens (:, halo_type , i , j , k ))) * & plasma % denf if ( papprox ( i , j , k ). gt . 0 ) then pcell (:, pcnt ) = ind pcnt = pcnt + 1 endif if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo pcnt = pcnt - 1 inv_maxcnt = 10 0.0 / real ( pcnt ) call get_nlaunch ( inputs % n_fida , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch )) endif !! Loop over all cells that have neutrals cnt = 0. d0 !$OMP PARALLEL DO schedule(guided) private(ip,i,j,k,iion,ind,vi,ri, & !$OMP tracks,ncell,jj,plasma,prob,denn,states,photons) loop_over_cells : do ip = 1 , int ( pcnt ) i = pcell ( 1 , ip ) j = pcell ( 2 , ip ) k = pcell ( 3 , ip ) ind = [ i , j , k ] loop_over_fast_ions : do iion = 1 , int8 ( nlaunch ( i , j , k )) !! Sample fast ion distribution for velocity and position call mc_fastion ( ind , ri , vi ) if ( sum ( vi ). eq . 0 ) cycle loop_over_fast_ions !! Find the particles path through the beam grid call track ( ri , vi , tracks , ncell , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ncell . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_fast_ions !! Calculate initial states of particle call get_plasma ( plasma , pos = tracks ( 1 )% pos ) states = prob * plasma % denf !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions cnt = cnt + 1 if ( inputs % verbose . eq . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_cells !$OMP END PARALLEL DO end subroutine fida_f subroutine fida_mc integer :: iion , iphi type ( FastIon ) :: fast_ion type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( double ) :: phi , theta real ( double ), dimension ( 3 ) :: ri !! start position real ( double ), dimension ( 3 ) :: vi , vi_norm !! velocity of fast ions !! Determination of the CX probability real ( double ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( double ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track real ( double ), dimension ( nlevs ) :: states ! Density of n-states integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks logical :: los_intersect integer :: jj !! counter along track real ( double ) :: photons !! photon flux integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] real ( double ), dimension ( 3 ) :: xyz , uvw , r_gyro , uvw_vi real ( double ) :: s , c real ( double ) :: maxcnt , inv_maxcnt , cnt real ( double ), dimension ( 2 ) :: randomu integer ( long ) :: nlaunch maxcnt = particles % nparticle inv_maxcnt = 10 0. d0 / maxcnt nlaunch = ceiling ( dble ( inputs % n_fida ) / particles % nparticle ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers per mc particle: \",i7)' ) int ( nlaunch ) endif cnt = 0.0 !$OMP PARALLEL DO schedule(guided) private(iion,iphi,fast_ion,vi,vi_norm,ri,phi,fields,tracks,s,c, & !$OMP& plasma,theta,randomu,xyz,uvw,uvw_vi,r_gyro,ncell,jj,prob,denn,los_intersect,states,photons) loop_over_fast_ions : do iion = 1 , particles % nparticle fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if ( fast_ion % cross_grid ) then phi_loop : do iphi = 1 , nlaunch !! Pick random torodial angle call randu ( randomu ) phi = fast_ion % phi_enter + fast_ion % delta_phi * randomu ( 1 ) s = sin ( phi ) ; c = cos ( phi ) uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z call uvw_to_xyz ( uvw , xyz ) if ( particles % guiding_center ) then !! Pick random gyroangle theta = 2 * pi * randomu ( 2 ) call get_fields ( fields , pos = xyz ) call pitch_to_vec ( fast_ion % pitch , theta , fields , vi_norm ) vi = fast_ion % vabs * vi_norm call gyro_correction ( vi , fields , r_gyro ) ri = xyz - r_gyro else uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) ri = xyz endif call track ( ri , vi , tracks , ncell , los_intersect ) if (. not . los_intersect ) cycle phi_loop if ( ncell . eq . 0 ) cycle phi_loop !! ---------------- calculate CX probability --------------!! call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle phi_loop !! Calculate the spectra produced in each cell along the path states = prob * fast_ion % weight loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons / dble ( nlaunch ), fast_ion % class ) enddo loop_along_track enddo phi_loop endif cnt = cnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO end subroutine fida_mc subroutine npa_f integer :: i , j , k !! indices  x,y,z  of cells integer :: iion , det , ip real ( double ), dimension ( 3 ) :: ri !! start position real ( double ), dimension ( 3 ) :: rf !! end position real ( double ), dimension ( 3 ) :: vi !! velocity of fast ions integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 3 , beam_grid % ngrid ) :: pcell !! Determination of the CX probability type ( LocalProfiles ) :: plasma integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] real ( double ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track real ( double ), dimension ( nlevs ) :: states !! Density of n-states real ( double ) :: flux !! flux integer :: inpa , pcnt real ( double ) :: papprox_tot , maxcnt , cnt , inv_maxcnt real ( double ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density !! ------------- calculate papprox needed for guess of nlaunch --------!! papprox = 0. d0 papprox_tot = 0. d0 pcnt = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) papprox ( i , j , k ) = ( sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) + & sum ( neut % dens (:, halo_type , i , j , k ))) * & plasma % denf if ( papprox ( i , j , k ). gt . 0. and .( npa_chords % hit ( i , j , k ))) then pcell (:, pcnt ) = ind pcnt = pcnt + 1 endif if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo pcnt = pcnt - 1 maxcnt = real ( pcnt ) inv_maxcnt = 10 0.0 / maxcnt call get_nlaunch ( inputs % n_npa , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch )) endif !! Loop over all cells that can contribute to NPA signal cnt = 0. d0 !$OMP PARALLEL DO schedule(guided) private(ip,i,j,k,inpa,iion,ind, & !$OMP& vi,ri,rf,det,plasma,prob,states,flux) loop_over_cells : do ip = 1 , int ( pcnt ) i = pcell ( 1 , ip ) j = pcell ( 2 , ip ) k = pcell ( 3 , ip ) ind = [ i , j , k ] npa_loop : do inpa = 1 , npa % nloop loop_over_fast_ions : do iion = 1 , int ( nlaunch ( i , j , k )) !! Sample fast ion distribution for velocity and position call mc_fastion ( ind , ri , vi , at_guiding_center = . False .) if ( sum ( vi ). eq . 0 ) cycle loop_over_fast_ions !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf ) if ( det . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_fast_ions !! Attenuate states as the particle move through plasma call get_plasma ( plasma , pos = ri ) states = prob * plasma % denf call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = sum ( states ) * beam_grid % dv / ( nlaunch ( i , j , k ) * real ( npa % nloop )) call store_npa ( det , ri , rf , vi , flux ) enddo loop_over_fast_ions enddo npa_loop cnt = cnt + 1 if ( inputs % verbose . eq . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_cells !$OMP END PARALLEL DO write ( * , '(\"Number of NPA particles that hit a detector: \",i8)' ) npa % npart end subroutine npa_f subroutine npa_mc integer :: iion , iphi type ( FastIon ) :: fast_ion type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( double ) :: phi , theta real ( double ), dimension ( 3 ) :: ri , rf !! positions real ( double ), dimension ( 3 ) :: vi , vi_norm !! velocity of fast ions integer :: det !! detector real ( double ), dimension ( nlevs ) :: prob !! Prob. for CX real ( double ), dimension ( nlevs ) :: states ! Density of n-states real ( double ) :: flux integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] integer , dimension ( 3 ) :: ind real ( double ), dimension ( 3 ) :: xyz , uvw , r_gyro , uvw_vi real ( double ) :: s , c real ( double ) :: maxcnt , inv_maxcnt , cnt real ( double ), dimension ( 2 ) :: randomu integer ( long ) :: nlaunch maxcnt = particles % nparticle inv_maxcnt = 10 0. d0 / maxcnt nlaunch = ceiling ( dble ( inputs % n_npa ) / particles % nparticle ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers per mc particle: \",i7)' ) int ( nlaunch ) endif cnt = 0.0 !$OMP PARALLEL DO schedule(guided) private(iion,ind,iphi,fast_ion,vi,vi_norm,ri,rf,phi,fields,s,c, & !$OMP& plasma,theta,randomu,xyz,uvw,uvw_vi,r_gyro,prob,states,flux,det) loop_over_fast_ions : do iion = 1 , particles % nparticle fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if ( fast_ion % cross_grid ) then phi_loop : do iphi = 1 , nlaunch !! Pick random torodial angle call randu ( randomu ) phi = fast_ion % phi_enter + fast_ion % delta_phi * randomu ( 1 ) s = sin ( phi ) ; c = cos ( phi ) uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z call uvw_to_xyz ( uvw , xyz ) if ( particles % guiding_center ) then !! Pick random gyroangle theta = 2 * pi * randomu ( 2 ) call get_fields ( fields , pos = xyz ) call pitch_to_vec ( fast_ion % pitch , theta , fields , vi_norm ) vi = fast_ion % vabs * vi_norm call gyro_correction ( vi , fields , r_gyro ) ri = xyz - r_gyro else uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) ri = xyz endif !! Get beam grid indices call get_indices ( ri , ind ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf ) if ( det . eq . 0 ) cycle phi_loop !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle phi_loop !! Attenuate states as the particle moves though plasma call get_plasma ( plasma , pos = ri ) states = prob * plasma % denf call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = sum ( states ) * beam_grid % dv / dble ( nlaunch ) call store_npa ( det , ri , rf , vi , flux ) enddo phi_loop endif cnt = cnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO end subroutine npa_mc subroutine fida_weights_mc integer :: i , j , k !! indices  x,y,z of cells integer ( kind = 8 ) :: iion , ip real ( double ), dimension ( 3 ) :: ri , r_gyro !! start position real ( double ), dimension ( 3 ) :: vi , vi_norm !! velocity of fast ions integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] logical :: los_intersect !! Determination of the CX probability type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( double ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track integer :: ncell integer :: jj , kk !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( double ) :: photons !! photon flux real ( double ), dimension ( nlevs ) :: states !! Density of n-states real ( double ), dimension ( nlevs ) :: denn integer :: nwav real ( double ) :: etov2 , energy , pitch , phi real ( double ) :: dE , dP , dEdP real ( double ), dimension (:), allocatable :: ebarr , ptcharr integer , dimension ( 1 ) :: ienergy , ipitch real ( double ), dimension ( 3 ) :: randomu3 !! Number of particles to launch integer ( kind = 8 ) :: pcnt real ( double ) :: papprox_tot , inv_maxcnt , cnt , fbm_denf , phase_area integer , dimension ( 3 , beam_grid % ngrid ) :: pcell real ( double ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density nwav = inputs % nlambda_wght !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP phase_area = dEdP * real ( inputs % np_wght ) * real ( inputs % ne_wght ) !! allocate storage arrays allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % fida ( nwav , spec_chords % nchan )) allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Number of Channels: \",i3)' ) spec_chords % nchan write ( * , '(T2,\"Nlambda: \",i4)' ) nwav write ( * , '(T2,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T2,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T2,\"LOS averaged: \",a)' ) \"False\" endif !! zero out arrays fweight % weight = 0. d0 fweight % fida = 0. d0 fweight % mean_f = 0. d0 etov2 = 1. d0 / ( v2_to_E_per_amu * inputs % ab ) !! Estimate how many particles to launch in each cell papprox = 0. d0 papprox_tot = 0. d0 pcnt = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) papprox ( i , j , k ) = ( sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) + & sum ( neut % dens (:, halo_type , i , j , k ))) if ( papprox ( i , j , k ). gt . 0 ) then pcell (:, pcnt ) = ind pcnt = pcnt + 1 endif if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo pcnt = pcnt - 1 inv_maxcnt = 10 0.0 / real ( pcnt ) call get_nlaunch ( 10 * inputs % n_fida , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch )) endif !! Loop over all cells that have neutrals cnt = 0. d0 !$OMP PARALLEL DO schedule(guided) private(ip,i,j,k,iion,ind,vi,vi_norm,ri,ienergy,ipitch, & !$OMP tracks,ncell,jj,kk,plasma,fields,prob,denn,states,photons,energy,pitch,phi, & !$OMP r_gyro,los_intersect,randomu3,fbm_denf) loop_over_cells : do ip = 1 , int ( pcnt ) i = pcell ( 1 , ip ) j = pcell ( 2 , ip ) k = pcell ( 3 , ip ) ind = [ i , j , k ] loop_over_fast_ions : do iion = 1 , int8 ( nlaunch ( i , j , k )) !! Sample fast ion distribution uniformally call randind ( inputs % ne_wght , ienergy ) call randind ( inputs % np_wght , ipitch ) call randu ( randomu3 ) phi = 2 * pi * randomu3 ( 1 ) energy = ebarr ( ienergy ( 1 )) + dE * ( randomu3 ( 2 ) - 0.5 ) pitch = ptcharr ( ipitch ( 1 )) + dP * ( randomu3 ( 3 ) - 0.5 ) call randu ( randomu3 ) ri = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] + beam_grid % dr * ( randomu3 - 0.5 ) fbm_denf = 0.0 call get_ep_denf ( energy , pitch , fbm_denf , pos = ri ) !! Get velocity call get_fields ( fields , pos = ri ) call pitch_to_vec ( pitch , phi , fields , vi_norm ) vi = sqrt ( energy * etov2 ) * vi_norm if ( energy . eq . 0 ) cycle loop_over_fast_ions !! Correct for gyro motion call gyro_correction ( vi , fields , r_gyro ) ri = ri - r_gyro !! Find the particles path through the beam grid call track ( ri , vi , tracks , ncell , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ncell . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_fast_ions states = prob * 1. d20 !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fw_photons ( ienergy ( 1 ), ipitch ( 1 ), & tracks ( jj )% pos , vi , fbm_denf , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions cnt = cnt + 1 if ( inputs % verbose . eq . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_cells !$OMP END PARALLEL DO fweight % weight = (( 1. d - 20 ) * phase_area / dEdP ) * fweight % weight fweight % fida = (( 1. d - 20 ) * phase_area ) * fweight % fida fweight % mean_f = (( 1. d - 20 ) * phase_area / dEdP ) * fweight % mean_f call write_fida_weights () end subroutine fida_weights_mc subroutine fida_weights_los type ( LocalProfiles ) :: plasma , plasma_cell type ( LocalEMFields ) :: fields , fields_cell real ( double ) :: denf real ( double ) :: wght , wght_tot real ( double ) :: photons !! photon flux real ( double ) :: length type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks integer :: nwav integer ( long ) :: i , j , k , ienergy integer ( long ) :: ipitch , igyro , icell , ichan real ( double ), dimension (:), allocatable :: ebarr , ptcharr , phiarr real ( double ), dimension (:,:), allocatable :: mean_f real ( double ), dimension ( 3 ) :: vi , vi_norm , vp real ( double ), dimension ( 3 ) :: vnbi_f , vnbi_h , vnbi_t , vhalo real ( double ), dimension ( 3 ) :: r_enter , r_exit real ( double ) :: vabs , dE , dP !! Determination of the CX probability real ( double ), dimension ( nlevs ) :: fdens , hdens , tdens , halodens real ( double ), dimension ( nlevs ) :: rates real ( double ), dimension ( nlevs ) :: states ! Density of n-states real ( double ), dimension ( nlevs ) :: denn ! Density of n-states !! COLRAD real ( double ) :: dt , max_dens , dlength , sigma_pi real ( double ) :: eb , ptch , phi !! ---- Solution of differential equation  ---- ! integer , dimension ( 3 ) :: ind !!actual cell real ( double ), dimension ( 3 ) :: ri integer ( long ) :: ncell real ( double ) :: etov2 , dEdP nwav = inputs % nlambda_wght !! Define energy array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! Define pitch array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP !! define gyro - array allocate ( phiarr ( inputs % nphi_wght )) do i = 1 , inputs % nphi_wght phiarr ( i ) = real ( i - 0.5 ) * 2. d0 * pi / real ( inputs % nphi_wght ) enddo !! allocate storage arrays allocate ( fweight % fida ( nwav , spec_chords % nchan )) allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( mean_f ( inputs % ne_wght , inputs % np_wght )) !! zero out arrays fweight % weight = 0. d0 fweight % fida = 0. d0 fweight % mean_f = 0. d0 mean_f = 0. d0 if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Number of Channels: \",i3)' ) spec_chords % nchan write ( * , '(T2,\"Nlambda: \",i4)' ) nwav write ( * , '(T2,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T2,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T2,\"Ngyro: \", i3)' ) inputs % nphi_wght write ( * , '(T2,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T2,\"LOS averaged: \",a)' ) \"True\" write ( * , * ) '' endif etov2 = 1.0 / ( v2_to_E_per_amu * inputs % ab ) chan_loop : do ichan = 1 , spec_chords % nchan fdens = 0. d0 ; hdens = 0. d0 ; tdens = 0. d0 ; halodens = 0. d0 plasma = plasma * 0. d0 fields = fields * 0. d0 wght_tot = 0. d0 mean_f = 0. d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx if ( spec_chords % los_inter ( i , j , k )) then ind = [ i , j , k ] dlength = spec_chords % dlength ( ichan , i , j , k ) fdens = fdens + neut % dens (:, nbif_type , i , j , k ) * dlength hdens = hdens + neut % dens (:, nbih_type , i , j , k ) * dlength tdens = tdens + neut % dens (:, nbit_type , i , j , k ) * dlength halodens = halodens + neut % dens (:, halo_type , i , j , k ) * dlength wght = sum ( neut % dens ( 3 , 1 : 4 , i , j , k )) * dlength call get_plasma ( plasma_cell , ind = ind ) call get_fields ( fields_cell , ind = ind ) plasma = plasma + wght * plasma_cell fields = fields + wght * fields_cell do ipitch = 1 , inputs % np_wght do ienergy = 1 , inputs % ne_wght call get_ep_denf ( ebarr ( ienergy ), ptcharr ( ipitch ), denf , ind = ind ) mean_f ( ienergy , ipitch ) = mean_f ( ienergy , ipitch ) + wght * denf enddo enddo wght_tot = wght_tot + wght endif enddo enddo enddo if ( wght_tot . le . 0 ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Skipping channel \",i3,\": Neutral density is zero\")' ) ichan endif cycle chan_loop else plasma = plasma / wght_tot plasma % in_plasma = . True . fields = fields / wght_tot fields % in_plasma = . True . call calc_perp_vectors ( fields % b_norm , fields % a_norm , fields % c_norm ) mean_f = mean_f / wght_tot if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i3)' ) ichan write ( * , '(T4,\"Radius: \",f7.2)' ) spec_chords % radius ( ichan ) write ( * , '(T4,\"Mean Fast-ion Density: \",ES14.5)' ) sum ( mean_f ) * dEdP write ( * , * ) '' endif endif ri = plasma % pos vp = ri - spec_chords % los ( ichan )% lens vnbi_f = ri - nbi % src vnbi_f = vnbi_f / normp ( vnbi_f ) * nbi % vinj vnbi_h = vnbi_f / sqrt ( 2. d0 ) vnbi_t = vnbi_f / sqrt ( 3. d0 ) sigma_pi = spec_chords % los ( ichan )% sigma_pi dlength = 1. d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(eb,vabs,ptch,phi,vi,vi_norm, & !$OMP& ri,r_enter,r_exit,length,max_dens,ind,tracks,ncell,dt,icell,states,rates, & !$OMP& vhalo,denn,denf,photons,ienergy,ipitch,igyro) do ienergy = 1 , inputs % ne_wght do ipitch = 1 , inputs % np_wght do igyro = 1 , inputs % nphi_wght eb = ebarr ( ienergy ) vabs = sqrt ( eb * etov2 ) ptch = ptcharr ( ipitch ) phi = phiarr ( igyro ) call pitch_to_vec ( ptch , phi , fields , vi_norm ) vi = vabs * vi_norm call grid_intersect ( ri , vi , length , r_enter , r_exit ) call track ( r_enter , vi , tracks , ncell ) max_dens = 0. d0 do icell = 1 , ncell ind = tracks ( icell )% ind tracks ( icell )% flux = sum ( neut % dens ( 3 , 1 : 4 , ind ( 1 ), ind ( 2 ), ind ( 3 ))) if ( tracks ( icell )% flux . gt . max_dens ) max_dens = tracks ( icell )% flux enddo dt = 0. d0 do icell = 1 , ncell if ( tracks ( icell )% flux . gt .( 0.5 * max_dens )) then dt = dt + tracks ( icell )% time endif enddo states = 0. d0 call neut_rates ( fdens , vi , vnbi_f , rates ) states = states + rates call neut_rates ( hdens , vi , vnbi_h , rates ) states = states + rates call neut_rates ( tdens , vi , vnbi_t , rates ) states = states + rates do i = 1 , int ( n_halo_neutrate ) call mc_halo ( ind , vhalo , plasma_in = plasma ) call neut_rates ( halodens , vi , vhalo , rates ) states = states + rates / real ( n_halo_neutrate ) enddo call colrad ( plasma , beam_ion , vi , dt , states , denn , photons ) denf = mean_f ( ienergy , ipitch ) * dEdP photons = photons / real ( inputs % nphi_wght ) call store_fw_photons_at_chan ( ichan , ienergy , ipitch , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo enddo enddo !$OMP END PARALLEL DO enddo chan_loop call write_fida_weights () end subroutine fida_weights_los subroutine npa_weights type ( LocalEMFields ) :: fields real ( double ) :: pitch real ( double ) :: pcxa integer ( long ) :: det integer ( long ) :: ii , jj , kk , i , ic !!indices integer , dimension ( 1 ) :: ipitch real ( double ), dimension ( 3 ) :: vi , vi_norm real ( double ) :: vabs , fbm_denf , dE , dP , ccnt real ( double ), dimension ( nlevs ) :: pcx !! Rate coefficiants for CX real ( double ), dimension ( nlevs ) :: states , states_i ! Density of n-states integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] real ( double ), dimension ( 3 ) :: pos , dpos , r_gyro integer ( long ) :: ichan real ( double ), dimension (:), allocatable :: ebarr , ptcharr !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Number of Channels: \",i3)' ) npa_chords % nchan write ( * , '(T2,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T2,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T2,\"Maximum energy: \",f7.2)' ) inputs % emax_wght write ( * , * ) '' endif !! define storage arrays allocate ( nweight % emissivity ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % attenuation ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % cx ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % weight ( inputs % ne_wght , & inputs % np_wght , & npa_chords % nchan )) allocate ( nweight % flux ( inputs % ne_wght , npa_chords % nchan )) nweight % emissivity = 0. d0 nweight % attenuation = 0. d0 nweight % cx = 0. d0 nweight % weight = 0. d0 nweight % flux = 0. d0 loop_over_channels : do ichan = 1 , npa_chords % nchan if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i3)' ) ichan write ( * , '(T4,\"Radius: \",f10.3)' ) npa_chords % radius ( ichan ) endif ccnt = 0. d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(ii,jj,kk,fields, & !$OMP& ic,det,pos,dpos,r_gyro,pitch,ipitch,vabs,vi,pcx,pcxa,states,states_i,vi_norm,fbm_denf) loop_along_z : do kk = 1 , beam_grid % nz loop_along_y : do jj = 1 , beam_grid % ny loop_along_x : do ii = 1 , beam_grid % nx if ( npa_chords % phit ( ii , jj , kk , ichan )% p . gt . 0. d0 ) then pos = [ beam_grid % xc ( ii ), beam_grid % yc ( jj ), beam_grid % zc ( kk )] call get_fields ( fields , pos = pos ) if (. not . fields % in_plasma ) cycle loop_along_x !!Determine velocity vector dpos = npa_chords % phit ( ii , jj , kk , ichan )% eff_rd vi_norm = ( dpos - pos ) / normp ( dpos - pos ) !!Check if it hits a detector just to make sure call hit_npa_detector ( pos , vi_norm , det ) if ( det . ne . ichan ) then write ( * , '(a)' ) 'NPA_WEIGHTS: Missed detector' cycle loop_along_x endif !! Determine the angle between the B-field and the Line of Sight pitch = dot_product ( fields % b_norm , vi_norm ) ipitch = minloc ( abs ( ptcharr - pitch )) loop_over_energy : do ic = 1 , inputs % ne_wght !! energy loop vabs = sqrt ( ebarr ( ic ) / ( v2_to_E_per_amu * inputs % ab )) vi = vi_norm * vabs !!Correct for gyro orbit call gyro_correction ( vi , fields , r_gyro ) fbm_denf = 0 if ( inputs % dist_type . eq . 1 ) then call get_ep_denf ( ebarr ( ic ), pitch , fbm_denf , pos = ( pos + r_gyro )) endif if ( fbm_denf . ne . fbm_denf ) cycle loop_over_energy !! -------------- calculate CX probability -------!! call get_beam_cx_prob ([ ii , jj , kk ], pos , vi , neut_types , pcx ) if ( sum ( pcx ). le . 0 ) cycle loop_over_energy !!Calculate attenuation states = pcx * 1.0 d14 !!needs to be large aribitrary number so colrad works states_i = states call attenuate ( pos , dpos , vi , states ) pcxa = sum ( states ) / sum ( states_i ) !$OMP CRITICAL(npa_wght) nweight % attenuation ( ic , ii , jj , kk , ichan ) = pcxa nweight % cx ( ic , ii , jj , kk , ichan ) = sum ( pcx ) nweight % weight ( ic , ipitch ( 1 ), ichan ) = nweight % weight ( ic , ipitch ( 1 ), ichan ) + & 2 * sum ( pcx ) * pcxa * npa_chords % phit ( ii , jj , kk , ichan )% p * beam_grid % dv / dP nweight % flux ( ic , ichan ) = nweight % flux ( ic , ichan ) + & 2 * beam_grid % dv * fbm_denf * sum ( pcx ) * pcxa * npa_chords % phit ( ii , jj , kk , ichan )% p !Factor of 2 above is to convert fbm to ions/(cm&#94;3 dE (domega/4pi)) nweight % emissivity ( ii , jj , kk , ichan ) = nweight % emissivity ( ii , jj , kk , ichan ) + & 2 * fbm_denf * sum ( pcx ) * pcxa * npa_chords % phit ( ii , jj , kk , ichan )% p * dE !$OMP END CRITICAL(npa_wght) enddo loop_over_energy endif ccnt = ccnt + 1 if ( inputs % verbose . eq . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) ccnt / real ( beam_grid % ngrid ) * 100 , char ( 13 ) endif enddo loop_along_x enddo loop_along_y enddo loop_along_z !$OMP END PARALLEL DO if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5)' ), 'Flux:   ' , sum ( nweight % flux (:, ichan )) * dE write ( * , '(T4,A,ES14.5)' ), 'Weight: ' , sum ( nweight % weight (:,:, ichan )) * dE * dP write ( * , * ) '' endif enddo loop_over_channels call write_npa_weights () end subroutine npa_weights end module simulation !============================================================================= !-------------------------------Main Program---------------------------------- !============================================================================= program fidasim use simulation use hdf5_extra #ifdef _OMP use omp_lib #endif implicit none character ( 3 ) :: arg = '' integer , dimension ( 8 ) :: time_arr , time_start , time_end !Time array integer :: i , narg , nthreads , max_threads integer :: hour , minu , sec call print_banner () narg = command_argument_count () if ( narg . eq . 0 ) then write ( * , '(a)' ) \"usage: ./fidasim namelist_file [num_threads]\" stop else call get_command_argument ( 1 , namelist_file ) endif !! Check if compression is possible call check_compression_availability () !! measure time call date_and_time ( values = time_start ) call read_inputs () #ifdef _OMP max_threads = OMP_get_num_procs () if ( narg . ge . 2 ) then call get_command_argument ( 2 , arg ) read ( arg , '(i3)' ) nthreads else nthreads = max_threads endif max_threads = min ( nthreads , max_threads ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- OpenMP settings ----\" write ( * , '(T2,\"Number of threads: \",i2)' ) max_threads write ( * , * ) '' endif call OMP_set_num_threads ( max_threads ) #else max_threads = 1 #endif !! ---------------------------------------------------------- !! ------ INITIALIZE THE RANDOM NUMBER GENERATOR  ----------- !! ---------------------------------------------------------- allocate ( rng ( max_threads )) do i = 1 , max_threads call rng_init ( rng ( i ), 932117 + i ) enddo !! ---------------------------------------------------------- !! ------- READ GRIDS, PROFILES, LOS, TABLES, & FBM -------- !! ---------------------------------------------------------- call make_beam_grid () call read_equilibrium () call read_beam () call read_tables () call read_distribution () if (( inputs % calc_spec . ge . 1 ). or .( inputs % calc_fida_wght . ge . 1 )) then call read_chords () endif if (( inputs % calc_npa . ge . 1 ). or .( inputs % calc_npa_wght . ge . 1 )) then call read_npa () endif !! ---------------------------------------------------------- !! --------------- ALLOCATE THE RESULT ARRAYS --------------- !! ---------------------------------------------------------- !! neutral density array! allocate ( neut % dens ( nlevs , ntypes , beam_grid % nx , beam_grid % ny , beam_grid % nz )) neut % dens = 0. d0 !! birth profile if ( inputs % calc_birth . ge . 1 ) then allocate ( birth % dens ( 3 , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz )) allocate ( birth % ri ( 3 , int ( inputs % n_birth * inputs % n_nbi ))) allocate ( birth % vi ( 3 , int ( inputs % n_birth * inputs % n_nbi ))) birth % dens = 0. d0 birth % ri = 0. d0 birth % vi = 0. d0 endif if ( inputs % calc_spec . ge . 1 ) then allocate ( spec % brems ( inputs % nlambda , spec_chords % nchan )) allocate ( spec % bes ( inputs % nlambda , spec_chords % nchan , 4 )) allocate ( spec % fida ( inputs % nlambda , spec_chords % nchan , particles % nclass )) spec % brems = 0. d0 spec % bes = 0. d0 spec % fida = 0. d0 endif if ( inputs % calc_npa . ge . 1 ) then npa % nchan = npa_chords % nchan allocate ( npa % part ( npa % nmax )) allocate ( npa % energy ( fbm % nenergy )) allocate ( npa % flux ( fbm % nenergy , npa % nchan )) npa % energy = fbm % energy npa % flux = 0.0 endif !! ----------------------------------------------------------------------- !! --------------- CALCULATE/LOAD the BEAM and HALO DENSITY--------------- !! ----------------------------------------------------------------------- if ( inputs % load_neutrals . eq . 1 ) then call read_neutrals () else !! ----------- BEAM NEUTRALS ---------- !! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'ndmc:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call ndmc if ( inputs % calc_birth . eq . 1 ) then call write_birth_profile () endif write ( * , '(30X,a)' ) '' !! ---------- DCX (Direct charge exchange) ---------- !! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'dcx:     ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call dcx () if ( inputs % dump_dcx . eq . 1 ) call write_dcx () write ( * , '(30X,a)' ) '' !! ---------- HALO ---------- !! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'halo:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call halo () !! ---------- WRITE NEUTRALS ---------- !! call write_neutrals () write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !!----------------------------- BREMSSTRAHLUNG --------------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_brems . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'bremsstrahlung:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call bremsstrahlung () write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !! --------------------- CALCULATE the FIDA RADIATION -------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_fida . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'fida:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % dist_type . eq . 1 ) then call fida_f () else call fida_mc () endif write ( * , '(30X,a)' ) '' endif if ( inputs % calc_spec . ge . 1 ) call write_spectra () !! ----------------------------------------------------------------------- !! ----------------------- CALCULATE the NPA FLUX ------------------------ !! ----------------------------------------------------------------------- if ( inputs % calc_npa . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'npa:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % dist_type . eq . 1 ) then call npa_f () else call npa_mc () endif write ( * , '(30X,a)' ) '' endif if ( inputs % calc_npa . ge . 1 ) call write_npa () !! ------------------------------------------------------------------- !! ----------- Calculation of weight functions ----------------------- !! ------------------------------------------------------------------- if ( inputs % calc_fida_wght . ge . 1 ) then colrad_threshold = 0. !! to speed up simulation! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'fida weight function:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % calc_fida_wght . eq . 1 ) then call fida_weights_los () else call fida_weights_mc () endif write ( * , '(30X,a)' ) '' endif if ( inputs % calc_npa_wght . eq . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'npa weight function:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call npa_weights () write ( * , '(30X,a)' ) '' endif call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'END: hour, minute, second: ' ,& time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call date_and_time ( values = time_end ) hour = time_end ( 5 ) - time_start ( 5 ) minu = time_end ( 6 ) - time_start ( 6 ) sec = time_end ( 7 ) - time_start ( 7 ) if ( minu . lt . 0. ) then minu = minu + 60 hour = hour - 1 endif if ( sec . lt . 0. ) then sec = sec + 60 minu = minu - 1 endif if ( inputs % verbose . ge . 1 ) then write ( * , '(A,18X,I2,\":\",I2.2,\":\",I2.2)' ) 'duration:' , hour , minu , sec endif end program fidasim","tags":""},{"title":"hdf5_extra.f90 – Fortran Program","loc":"sourcefile/hdf5_extra.f90.html","text":"Source Code MODULE hdf5_extra !+ A library of helpful HDF5 routines USE H5LT USE HDF5 IMPLICIT NONE public :: h5ltmake_compressed_dataset_double_f public :: h5ltmake_compressed_dataset_double_f_1 public :: h5ltmake_compressed_dataset_double_f_2 public :: h5ltmake_compressed_dataset_double_f_3 public :: h5ltmake_compressed_dataset_double_f_4 public :: h5ltmake_compressed_dataset_double_f_5 public :: h5ltmake_compressed_dataset_double_f_6 public :: h5ltmake_compressed_dataset_double_f_7 public :: h5ltmake_compressed_dataset_int_f public :: h5ltmake_compressed_dataset_int_f_1 public :: h5ltmake_compressed_dataset_int_f_2 public :: h5ltmake_compressed_dataset_int_f_3 public :: h5ltmake_compressed_dataset_int_f_4 public :: h5ltmake_compressed_dataset_int_f_5 public :: h5ltmake_compressed_dataset_int_f_6 public :: h5ltmake_compressed_dataset_int_f_7 public :: h5ltread_dataset_int_scalar_f public :: h5ltread_dataset_double_scalar_f public :: check_compression_availability integer , parameter , private :: long = 4 !bytes = 32 bits (-2,147,483,648 to 2,147,483,647) integer , parameter , private :: long64 = 8 !bytes = 64 bits (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807) integer , parameter , private :: float = 4 !bytes = 32 bits (1.2E-38 to 3.4E+38) at 6 decimal places integer , parameter , private :: double = 8 !bytes = 64 bits (2.3E-308 to 1.7E+308) at 15 decimal places logical , private :: compress_data = . True . interface h5ltmake_compressed_dataset_double_f !+ Write a compressed datasets of 64-bit floats module procedure h5ltmake_compressed_dataset_double_f_1 module procedure h5ltmake_compressed_dataset_double_f_2 module procedure h5ltmake_compressed_dataset_double_f_3 module procedure h5ltmake_compressed_dataset_double_f_4 module procedure h5ltmake_compressed_dataset_double_f_5 module procedure h5ltmake_compressed_dataset_double_f_6 module procedure h5ltmake_compressed_dataset_double_f_7 end interface interface h5ltmake_compressed_dataset_int_f !+ Write a compressed dataset of 32-bit integers module procedure h5ltmake_compressed_dataset_int_f_1 module procedure h5ltmake_compressed_dataset_int_f_2 module procedure h5ltmake_compressed_dataset_int_f_3 module procedure h5ltmake_compressed_dataset_int_f_4 module procedure h5ltmake_compressed_dataset_int_f_5 module procedure h5ltmake_compressed_dataset_int_f_6 module procedure h5ltmake_compressed_dataset_int_f_7 end interface contains subroutine check_compression_availability !+ Checks whether dataset compression is available IMPLICIT NONE logical :: shuffle_avail , gzip_avail integer :: gzip_info , shuf_info , filter_info_both integer :: error call h5open_f ( error ) filter_info_both = ior ( H5Z_FILTER_ENCODE_ENABLED_F , H5Z_FILTER_DECODE_ENABLED_F ) !! Check for GZIP filter call h5zfilter_avail_f ( H5Z_FILTER_DEFLATE_F , gzip_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_DEFLATE_F , gzip_info , error ) if (. not . gzip_avail ) then print * , 'HDF5: gzip filter is not available' compress_data = . False . endif if ( filter_info_both . ne . gzip_info ) then print * , 'HDF5: gzip filter is not available for encoding and decoding' compress_data = . False . endif !! Check for SHUFFLE filter call h5zfilter_avail_f ( H5Z_FILTER_SHUFFLE_F , shuffle_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_SHUFFLE_F , shuf_info , error ) if (. not . shuffle_avail ) then print * , 'HDF5: shuffle filter is not available' compress_data = . False . endif if ( filter_info_both . ne . shuf_info ) then print * , 'HDF5: shuffle filter is not available for encoding and decoding' compress_data = . False . endif if (. not . compress_data ) then print * , 'HDF5: Compression is not available. Proceeding without compression.' endif call h5close_f ( error ) end subroutine check_compression_availability subroutine h5ltread_dataset_int_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 32-bit integer IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 integer , dimension ( 1 ) :: dummy call h5ltread_dataset_int_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_int_scalar_f subroutine h5ltread_dataset_double_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 64-bit float IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create real ( double ), intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 real ( double ), dimension ( 1 ) :: dummy call h5ltread_dataset_double_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_double_scalar_f !Compressed Doubles subroutine h5ltmake_compressed_dataset_double_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_1 subroutine h5ltmake_compressed_dataset_double_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_2 subroutine h5ltmake_compressed_dataset_double_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_3 subroutine h5ltmake_compressed_dataset_double_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_4 subroutine h5ltmake_compressed_dataset_double_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_5 subroutine h5ltmake_compressed_dataset_double_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_6 subroutine h5ltmake_compressed_dataset_double_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_7 !Compressed Integers subroutine h5ltmake_compressed_dataset_int_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_1 subroutine h5ltmake_compressed_dataset_int_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_2 subroutine h5ltmake_compressed_dataset_int_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_3 subroutine h5ltmake_compressed_dataset_int_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_4 subroutine h5ltmake_compressed_dataset_int_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_5 subroutine h5ltmake_compressed_dataset_int_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_6 subroutine h5ltmake_compressed_dataset_int_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_7 END MODULE hdf5_extra","tags":""},{"title":"parallel_rng.f90 – Fortran Program","loc":"sourcefile/parallel_rng.f90.html","text":"Source Code module parallel_rng !+ A basic parallel random number generator library #ifdef _OMP use omp_lib #endif implicit none private public :: rng_type , rng_init , rng , rng_uniform , rng_normal , randu , randn , randind , ind2sub integer , parameter :: Int64 = kind ( int8 ( 1 )) integer , parameter :: Float32 = kind ( 1.e0 ) integer , parameter :: Float64 = kind ( 1. d0 ) integer , parameter :: IA = 16807 integer , parameter :: IM = 2147483647 integer , parameter :: IQ = 127773 integer , parameter :: IR = 2836 real ( Float64 ), protected :: AM = nearest ( 1.0 , - 1.0 ) / IM integer , parameter :: ns = 2 type :: rng_type !+ Random Number Generator Derived Type integer , dimension ( ns ) :: state end type rng_type type ( rng_type ), dimension (:), allocatable :: rng interface randind !+ Procedure for generating a random array index/subscripts module procedure randind_n module procedure randind_w_1 module procedure randind_w_2 end interface contains subroutine rng_init ( self , seed ) !+ Procedure to initialize a random number generator with a seed type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator integer , intent ( in ) :: seed !+ Initial Seed Value self % state ( 1 ) = ieor ( 777755555 , abs ( seed )) self % state ( 2 ) = ior ( ieor ( 888889999 , abs ( seed )), 1 ) end subroutine rng_init function rng_uniform ( self ) result ( u ) !+ Generate a uniformally-distributed random number in the range [0,1) type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: u !+ Uniform random deviate integer :: ix , iy , k ix = self % state ( 1 ) iy = self % state ( 2 ) ix = ieor ( ix , ishft ( ix , 13 )) ix = ieor ( ix , ishft ( ix , - 17 )) ix = ieor ( ix , ishft ( ix , 5 )) k = iy / IQ iy = IA * ( iy - k * IQ ) - IR * k if ( iy . lt . 0 ) iy = iy + IM self % state ( 1 ) = ix self % state ( 2 ) = iy u = am * ior ( iand ( IM , ieor ( ix , iy )), 1 ) end function rng_uniform function rng_normal ( self ) result ( n ) !+ Generate a normally-distributed random number with mean 0 and standard deviation 1 type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: n !+ Normal random deviate real ( Float64 ) :: s = 0.449871 d0 real ( Float64 ) :: t = 0.386595 d0 real ( Float64 ) :: a = 0.196000 d0 real ( Float64 ) :: b = 0.254720 d0 real ( Float64 ) :: r1 = 0.27597 d0 real ( Float64 ) :: r2 = 0.27846 d0 real ( Float64 ) :: u , v , x , y , q do u = rng_uniform ( self ) v = rng_uniform ( self ) v = 1.7156 d0 * ( v - 0.5 d0 ) x = u - s y = abs ( v ) + t q = x ** 2 + y * ( a * y - b * x ) if ( q . lt . r1 ) exit if ( q . gt . r2 ) cycle if (( v ** 2 ). lt .( - 4.0 * log ( u ) * u ** 2 )) exit enddo n = v / u end function rng_normal subroutine randu ( randomu ) !+ Generate an array of uniformally-distributed random deviates real ( Float64 ), dimension (:), intent ( out ) :: randomu !+ Array of uniform random deviates integer :: i , thread_id #ifdef _OMP thread_id = OMP_get_thread_num () + 1 #else thread_id = 1 #endif randomu = 0. d0 do i = 1 , size ( randomu ) randomu ( i ) = rng_uniform ( rng ( thread_id )) enddo end subroutine randu subroutine randn ( randomn ) !+ Generate an array of normally-distributed random deviates real ( Float64 ), dimension (:), intent ( out ) :: randomn !+ Array of normal random deviates integer :: i , thread_id #ifdef _OMP thread_id = OMP_get_thread_num () + 1 #else thread_id = 1 #endif randomn = 0. d0 do i = 1 , size ( randomn ) randomn ( i ) = rng_normal ( rng ( thread_id )) enddo end subroutine randn subroutine randind_n ( n , randomi ) !+ Generate a array of uniformally-distributed random integers in the range [1, n] integer , intent ( in ) :: n !+ Largest possible value integer , dimension (:), intent ( out ) :: randomi !+ Array of uniform deviates integer :: i real ( Float64 ), dimension ( 1 ) :: randomu randomi = 0 do i = 1 , size ( randomi ) call randu ( randomu ) randomi ( i ) = ceiling ( randomu ( 1 ) * n ) enddo end subroutine randind_n subroutine randind_w_1 ( w , randomi ) !+ Generate an array of random indices of an 1D array distributed according to `w` real ( Float64 ), dimension (:), intent ( in ) :: w !+ 1D array of index weights integer , dimension (:), intent ( out ) :: randomi !+ Random indices integer :: i , j real ( Float64 ) :: dum , cdf_val , w_tot real ( Float64 ), dimension ( 1 ) :: randomu randomi = 0 w_tot = sum ( w ) do i = 1 , size ( randomi ) call randu ( randomu ) cdf_val = randomu ( 1 ) * w_tot j = 0 dum = 0. d0 elem_loop : do while ( j . lt . size ( w )) j = j + 1 dum = dum + w ( j ) if ( dum . ge . cdf_val ) exit elem_loop enddo elem_loop randomi ( i ) = j enddo end subroutine randind_w_1 subroutine ind2sub ( dims , ind , subs ) !+ Calculate the subscripts `subs` into an array with dimensions `dims` !+ given the corresponding linear index `ind` integer , dimension (:), intent ( in ) :: dims !+ Dimensions of array integer , intent ( in ) :: ind !+ Linear index integer , dimension (:), intent ( out ) :: subs !+ Subscripts corresponding to the linear index integer :: i , ndims , ind1 , ind2 ind1 = ind ndims = size ( dims ) do i = 1 , ndims - 1 ind2 = ( ind1 - 1 ) / dims ( i ) + 1 subs ( i ) = ind1 - dims ( i ) * ( ind2 - 1 ) ind1 = ind2 enddo subs ( ndims ) = ind1 end subroutine ind2sub subroutine randind_w_2 ( w , randomi ) !+ Generate an array of random subscripts of an 2D array distributed according to `w` real ( Float64 ), dimension (:,:), intent ( in ) :: w !+ 2D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts integer :: i , j integer , dimension ( 2 ) :: subs real ( Float64 ) :: dum , cdf_val , w_tot real ( Float64 ), dimension ( 1 ) :: randomu randomi = 0 w_tot = sum ( w ) do i = 1 , size ( randomi , 2 ) call randu ( randomu ) cdf_val = randomu ( 1 ) * w_tot j = 0 dum = 0. d0 subs = 0 elem_loop : do while ( j . lt . size ( w )) j = j + 1 call ind2sub ( shape ( w ), j , subs ) dum = dum + w ( subs ( 1 ), subs ( 2 )) if ( dum . ge . cdf_val ) exit elem_loop enddo elem_loop randomi (:, i ) = subs enddo end subroutine randind_w_2 end module parallel_rng","tags":""},{"title":"atomic_tables.f90 – Fortran Program","loc":"sourcefile/atomic_tables.f90.html","text":"Source Code module atomic_tables use H5LT use HDF5 use hdf5_extra IMPLICIT NONE interface bt_maxwellian module procedure bt_maxwellian_n , bt_maxwellian_n_m module procedure bt_maxwellian_q_n , bt_maxwellian_q_n_m end interface integer , parameter , private :: Int32 = 4 !bytes = 32 bits (-2,147,483,648 to 2,147,483,647) integer , parameter , private :: Int64 = 8 !bytes = 64 bits (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807) integer , parameter , private :: Float32 = 4 !bytes = 32 bits (1.2E-38 to 3.4E+38) at 6 decimal places integer , parameter , private :: Float64 = 8 !bytes = 64 bits (2.3E-308 to 1.7E+308) at 15 decimal places real ( Float64 ), parameter :: PI = 3.14159265 d0 real ( Float64 ), parameter :: e_amu = 5.485799093287202 d - 4 real ( Float64 ), parameter :: H1_amu = 1.00782504 d0 real ( Float64 ), parameter :: H2_amu = 2.0141017778 d0 real ( Float64 ), parameter :: B_amu = 1 0.81 d0 real ( Float64 ), parameter :: C_amu = 1 2.011 d0 integer , parameter :: B_q = 5 integer , parameter :: C_q = 6 !Spontaneous de-exitation Table n=1:15,m=1:15 for Hydrogen !EINSTEIN(initial,final) / EINSTEIN(higher,lower) / EINSTEIN(n,m) !Wiese, W. L., Smith, M. W., & Glennon, B. M. (1966). ATOMIC TRANSITION PROBABILITIES. VOLUME 1. !HYDROGEN THROUGH NEON. NATIONAL BUREAU OF STANDARDS WASHINGTON DC INST FOR BASIC STANDARDS. real ( Float64 ), dimension ( 15 , 15 ), parameter :: EINSTEIN = reshape ([ & !(n,m) 0. d0 , 4.699 d8 , 5.575 d7 , 1.278 d7 , 4.125 d6 , 1.644 d6 , 7.568 d5 , 3.869 d5 , 2.143 d5 , 1.263 d5 , 7.834 d4 , 5.066 d4 , 3.393 d4 , 2.341 d4 , 1.657 d4 ,& !(:,1) 0. d0 , 0. d0 , 4.410 d7 , 8.419 d6 , 2.530 d6 , 9.732 d5 , 4.389 d5 , 2.215 d5 , 1.216 d5 , 7.122 d4 , 4.397 d4 , 2.834 d4 , 1.893 d4 , 1.303 d4 , 9.210 d3 ,& !(:,2) 0. d0 , 0. d0 , 0. d0 , 8.986 d6 , 2.201 d6 , 7.783 d5 , 3.358 d5 , 1.651 d5 , 8.905 d4 , 5.156 d4 , 3.156 d4 , 2.021 d4 , 1.343 d4 , 9.211 d3 , 6.490 d3 ,& !(:,3) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 2.699 d6 , 7.711 d5 , 3.041 d5 , 1.424 d5 , 7.459 d4 , 4.235 d4 , 2.556 d4 , 1.620 d4 , 1.069 d4 , 7.288 d3 , 5.110 d3 ,& !(:,4) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 1.025 d6 , 3.253 d5 , 1.388 d5 , 6.908 d4 , 3.800 d4 , 2.246 d4 , 1.402 d4 , 9.148 d3 , 6.185 d3 , 4.308 d3 ,& !(:,5) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 4.561 d5 , 1.561 d5 , 7.065 d4 , 3.688 d4 , 2.110 d4 , 1.288 d4 , 8.271 d3 , 5.526 d3 , 3.815 d3 ,& !(:,6) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 2.272 d5 , 8.237 d4 , 3.905 d4 , 2.117 d4 , 1.250 d4 , 7.845 d3 , 5.156 d3 , 3.516 d3 ,& !(:,7) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 1.233 d5 , 4.676 d4 , 2.301 d4 , 1.287 d4 , 7.804 d3 , 5.010 d3 , 3.359 d3 ,& !(:,8) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 7.141 d4 , 2.812 d4 , 1.427 d4 , 8.192 d3 , 5.080 d3 , 3.325 d3 ,& !(:,9) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 4.377 d4 , 1.774 d4 , 9.231 d3 , 5.417 d3 , 3.324 d3 ,& !(:,10) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 2.799 d4 , 1.163 d4 , 6.186 d3 , 3.699 d3 ,& !(:,11) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 1.857 d4 , 7.884 d3 , 4.271 d3 ,& !(:,12) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 1.271 d4 , 5.496 d3 ,& !(:,13) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 8.933 d3 ,& !(:,14) 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 , 0. d0 ]& !(:,15) , [ 15 , 15 ]) contains !!Collisions with protons !!Charge Exchange !!H(+) + H(nl) -> H(m'l') + H(+) !!Eq. 44 \"Collision processes in low-temperature hydrogen plasma\" Janev et al function p_cx_1_janev ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.2345 d0 , 2.3588 d2 , 2.3713 d0 , & 3.8371 d - 2 , 3.8068 d - 6 , 1.1832 d - 10 ] real ( Float64 ), parameter :: n = 1. d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1. d - 16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1. d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_1_janev function p_cx_2_janev ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: a = [ 9.2750 d - 1 , 6.5040 d3 , 2.0699 d1 , & 1.3405 d - 2 , 3.0842 d - 6 , 1.1832 d - 10 ] real ( Float64 ), parameter :: n = 2. d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1. d - 16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1. d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_2_janev function p_cx_3_janev ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.7271 d - 1 , 2.7645 d6 , 1.4857 d3 , & 1.5720 d - 3 , 3.0842 d - 6 , 1.1832 d - 10 ] real ( Float64 ), parameter :: n = 3. d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1. d - 16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1. d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_3_janev function p_cx_4_janev ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: a = [ 2.1336 d - 1 , 1.0000 d10 , 1.3426 d6 , & 1.8184 d - 3 , 3.0842 d - 6 , 1.1832 d - 10 ] real ( Float64 ), parameter :: n = 4. d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1. d - 16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1. d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_4_janev function p_cx_janev ( Erel , n ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel integer , intent ( in ) :: n real ( Float64 ) :: sigma integer :: i i = min ( n , 4 ) select case ( i ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1_janev ( Erel ) case ( 2 ) sigma = p_cx_2_janev ( Erel ) case ( 3 ) sigma = p_cx_3_janev ( Erel ) case DEFAULT sigma = p_cx_4_janev ( Erel ) end select end function p_cx_janev function p_cx_1_1_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 7 ), parameter :: a = [ - 3.496092687 d2 , 4.724931484 d2 , & - 2.720493064 d2 , 8.158564625 d1 , & - 1.339790721 d1 , 1.138706949 d0 , & - 3.914774156 d - 2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1. d3 if ( e . ge . 1. d3 ) then ee = max ( e , 1.0 ) fac = 1. d0 else ee = 1.0 d3 fac = Erel ** ( - 0.2 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 sigma = fac * ( 1 0. d0 ** p ) end function p_cx_1_1_adas function p_cx_1_2_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 9 ), parameter :: a = [ - 4.036239511 d3 , 6.941235312 d3 , & - 5.186974866 d3 , 2.194885201 d3 , & - 5.765960509 d2 , 9.653534186 d1 , & - 1.008066138 d1 , 6.010731909 d - 1 ,& - 1.567417031 d - 2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1. d3 if ( e . ge . 1. d3 ) then ee = max ( e , 1.0 ) fac = 1. d0 else ee = 1.0 d3 fac = Erel ** ( 0.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0. d0 ** p ) end function p_cx_1_2_adas function p_cx_1_3_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 10 ), parameter :: a = [ 7.037287586 d4 , - 1.479161477 d5 , & 1.370120708 d5 , - 7.343180122 d4 , & 2.509832081 d4 , - 5.674317075 d3 , & 8.487767749 d2 , - 8.102284612 d1 , & 4.480007503 d0 , - 1.093512342 d - 1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1. d3 if ( e . ge . 2. d3 ) then ee = max ( e , 1.0 ) fac = 1. d0 else ee = 2.0 d3 fac = ( Erel ** ( 1.4 )) / 2.8 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0. d0 ** p ) end function p_cx_1_3_adas function p_cx_1_4_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 10 ), parameter :: a = [ 6.826447557 d4 , - 1.431980004 d5 , & 1.323968679 d5 , - 7.083995050 d4 , & 2.417608863 d4 , - 5.458418789 d3 , & 8.154875237 d2 , - 7.776012846 d1 , & 4.295431731 d0 , - 1.047567211 d - 1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1. d3 if ( e . ge . 2. d3 ) then ee = max ( e , 1.0 ) fac = 1. d0 else ee = 2.0 d3 fac = ( Erel ** ( 2.0 )) / 4.0 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0. d0 ** p ) end function p_cx_1_4_adas function p_cx_1 ( Erel , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma real ( Float64 ) :: norm_fac sigma = 0. d0 sigma ( 1 ) = p_cx_1_1_adas ( Erel ) sigma ( 2 ) = p_cx_1_2_adas ( Erel ) sigma ( 3 ) = p_cx_1_3_adas ( Erel ) sigma ( 4 ) = p_cx_1_4_adas ( Erel ) !Normalize to Janev norm_fac = p_cx_janev ( Erel , 1 ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_1 function p_cx_2_2_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 1.896015167 d6 , 4.431727330 d6 , & - 4.627815357 d6 , 2.843068107 d6 , & - 1.137952956 d6 , 3.100801094 d5 , & - 5.825744660 d4 , 7.452319142 d3 , & - 6.212350647 d2 , 3.047712749 d1 , & - 6.682658463 d - 1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.614213508 d5 , 3.772469288 d5 , & - 3.924736424 d5 , 2.393127027 d5 , & - 9.470300966 d4 , 2.541276100 d4 , & - 4.682860453 d3 , 5.851219013 d2 , & - 4.744504549 d1 , 2.254460913 d0 , & - 4.767235839 d - 2 ] real ( Float64 ), parameter :: n = 2. d0 real ( Float64 ) :: e , ee , fac , l , sigma2s , sigma2p e = Erel * 1. d3 * n ** 2.0 if ( Erel . le . 1.5 d2 ) then ee = max ( e , 1. d3 ) fac = 1. d0 else ee = 1.5e5 * n ** 2. d0 fac = 2. d15 * (( e * 1. d - 3 ) ** ( - 5.5 )) endif l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0. d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0. d0 ** ( sigma2p ) sigma = fac * ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_2_adas function p_cx_2_3_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 3.513030327 d5 , 9.281116596 d5 , & - 1.086843398 d6 , 7.437325055 d5 , & - 3.296609685 d5 , 9.897503768 d4 , & - 2.039707143 d4 , 2.850670244 d3 , & - 2.587092857 d2 , 1.377382945 d1 , & - 3.268306303 d - 1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.901264631 d5 , 5.124716103 d5 , & - 6.101921504 d5 , 4.234717934 d5 , & - 1.899866398 d5 , 5.764464326 d4 , & - 1.199087959 d4 , 1.689900512 d3 , & - 1.545334374 d2 , 8.285001228 d0 , & - 1.978656474 d - 1 ] real ( Float64 ), parameter :: n = 2. d0 real ( Float64 ) :: ee , l , sigma2s , sigma2p ee = max ( Erel * 1. d3 * n ** 2. d0 , 1. d3 ) l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0. d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0. d0 ** ( sigma2p ) sigma = ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_3_adas subroutine m_spread ( n , m_max , sigma_tot , sigma ) integer , intent ( in ) :: n integer , intent ( in ) :: m_max real ( Float64 ), intent ( in ) :: sigma_tot real ( Float64 ), dimension ( m_max ), intent ( inout ) :: sigma real ( Float64 ) :: En , Em real ( Float64 ) :: norm_fac real ( Float64 ), dimension ( m_max ) :: sigma_m integer :: m sigma_m = 0. d0 En = 1 3.6 / ( real ( n ) ** 2.0 ) do m = 1 , m_max Em = 1 3.6 / ( real ( m ) ** 2.0 ) if ( sigma ( m ). eq . 0. d0 ) then sigma_m ( m ) = ( sigma_tot / sqrt ( 2.0 * PI )) * exp ( - 0.5 * ( En - Em ) ** 2.0 ) endif enddo norm_fac = sigma_tot / sum ( sigma_m ) do m = 1 , m_max if ( sigma ( m ). eq . 0. d0 ) sigma ( m ) = sigma_m ( m ) * norm_fac if ( sigma ( m ). ne . sigma ( m )) sigma ( m ) = 0. d0 enddo end subroutine m_spread function p_cx_2 ( Erel , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma real ( Float64 ), parameter :: n2 = 4. d0 integer :: i real ( Float64 ) :: En , Em , sigma_n , norm_fac sigma = 0. d0 sigma ( 1 ) = p_cx_1_2_adas ( Erel * n2 ) / n2 sigma ( 2 ) = p_cx_2_2_adas ( Erel ) sigma ( 3 ) = p_cx_2_3_adas ( Erel ) sigma_n = max ( p_cx_janev ( Erel , 2 ) - sum ( sigma ), 0. d0 ) call m_spread ( 2 , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , 2 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_2 function p_cx_3_2_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 1.149224555 d6 , 2.750368877 d6 , & - 2.942222842 d6 , 1.852584954 d6 , & - 7.603284323 d5 , 2.125284465 d5 , & - 4.097580431 d4 , 5.380901722 d3 , & - 4.606297192 d2 , 2.321345254 d1 , & - 5.230186707 d - 1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1. d3 * n ** 2.0 , 1. d3 ) !keV to eV fac = 1. d0 else ee = 9 0.0 * 1. d3 * n ** 2.0 fac = 1. d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0. d0 sigma = fac * ( 1 0. d0 ** p ) end function p_cx_3_2_adas function p_cx_3_3_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 10 ), parameter :: a = [ - 4.302808608 d4 , 9.499298161 d4 , & - 9.264698488 d4 , 5.236947172 d4 , & - 1.890479538 d4 , 4.519068626 d3 , & - 7.152485009 d2 , 7.227063167 d1 , & - 4.230036444 d0 , 1.092702525 d - 1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1. d3 * n ** 2.0 , 1. d3 ) !keV to eV fac = 1. d0 else ee = 9 0.0 * 1. d3 * n ** 2 fac = 0.85 d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0. d0 ** p ) end function p_cx_3_3_adas function p_cx_3_4_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 9 ), parameter :: a = [ 1.705303425 d4 , - 3.316878090 d4 , & 2.792556433 d4 , - 1.330264490 d4 , & 3.921666688 d3 , - 7.327555138 d2 , & 8.476342861 d1 , - 5.551987930 d0 , & 1.577120745 d - 1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1. d3 * n ** 2.0 , 1. d3 ) !keV to eV fac = 1. d0 else ee = 9 0.0 * 1. d3 * n ** 2.0 fac = 0.82 d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0. d0 ** p ) end function p_cx_3_4_adas function p_cx_3_5_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 2.786268232 d2 , 4.269683825 d4 , & - 8.973561028 d4 , 8.365732310 d4 , & - 4.524587937 d4 , 1.563630402 d4 , & - 3.580391824 d3 , 5.432527332 d2 , & - 5.267599631 d1 , 2.962329657 d0 , & - 7.362649692 d - 2 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p ee = max ( Erel * 1. d3 * n ** 2.0 , 1. d3 ) !keV to eV fac = 1. d0 l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0. d0 ** p ) end function p_cx_3_5_adas function p_cx_3_6inf_adas ( Erel ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel real ( Float64 ) :: sigma real ( Float64 ), dimension ( 11 ), parameter :: a = [ 7.146969470 d5 , - 1.665413326 d6 , & 1.735840441 d6 , - 1.065792786 d6 , & 4.269334710 d5 , - 1.165954977 d5 , & 2.198700496 d4 , - 2.827160468 d3 , & 2.372409350 d2 , - 1.173264972 d1 , & 2.596865877 d - 1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1. d3 * n ** 2.0 , 1. d3 ) !keV to eV fac = 1. d0 else ee = 9 0.0 * 1. d3 * n ** 2.0 fac = 2. d20 * ( Erel * n ** 2.0 ) ** ( - 7.0 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0. d0 ** p ) end function p_cx_3_6inf_adas function p_cx_3 ( Erel , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma real ( Float64 ), parameter :: n2 = 9. d0 real ( Float64 ) :: eb , En , Em , sigma_m6 , norm_fac real ( Float64 ), dimension ( m_max ) :: sigma1 sigma = 0. d0 sigma1 = 0. d0 sigma1 = p_cx_1 ( Erel * n2 , m_max ) sigma ( 1 ) = p_cx_1_3_adas ( Erel * n2 ) / n2 sigma ( 2 ) = p_cx_3_2_adas ( Erel ) sigma ( 3 ) = p_cx_3_3_adas ( Erel ) sigma ( 4 ) = p_cx_3_4_adas ( Erel ) if ( m_max . ge . 5 ) then sigma ( 5 ) = p_cx_3_5_adas ( Erel ) endif if ( m_max . ge . 6 ) then sigma_m6 = p_cx_3_6inf_adas ( Erel ) call m_spread ( 3 , m_max , sigma_m6 , sigma ) endif norm_fac = p_cx_janev ( Erel , 3 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_3 function p_cx_n ( Erel , n , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel integer , intent ( in ) :: n integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma real ( Float64 ), dimension ( m_max ) :: sigma2 , sigma3 real ( Float64 ) :: sigma_n , e , norm_fac sigma = 0. d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1 ( Erel , m_max ) return case ( 2 ) sigma = p_cx_2 ( Erel , m_max ) return case ( 3 ) sigma = p_cx_3 ( Erel , m_max ) return case ( 4 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 1 ) = p_cx_1_4_adas ( e / ( 1.0 ** 2.0 )) * ( 1. d0 / n ) ** 2.0 sigma ( 2 ) = sigma2 ( 4 ) * ( 2. d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_4_adas ( e / ( 3.0 ** 2.0 )) * ( 3. d0 / n ) ** 2.0 case ( 5 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 5 ) * ( 2. d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_5_adas ( e / ( 3.0 ** 2.0 )) * ( 3. d0 / n ) ** 2.0 case ( 6 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 6 ) * ( 2. d0 / n ) ** 2.0 sigma3 = p_cx_3 ( e / ( 3.0 ** 2.0 ), m_max ) * ( 3. d0 / n ) ** 2.0 sigma ( 3 ) = sigma3 ( 6 ) case DEFAULT end select sigma_n = max ( p_cx_janev ( Erel , n ) - sum ( sigma ), 0.0 ) call m_spread ( n , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , n ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_n function p_cx_n_m ( Erel , n , m ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel integer , intent ( in ) :: n integer , intent ( in ) :: m real ( Float64 ) :: sigma integer :: m_max = 12 real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_cx_n ( Erel , n , m_max ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_cx_n_m function p_cx ( Erel , n_max , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: Erel integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max , n_max ) :: sigma real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_cx_n ( Erel , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_cx !Proton impact ionization function p_ioniz_1_omullane ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0160 d - 3 , 3.7154 d0 , & 3.9890 d - 2 , 3.1413 d - 1 , & 2.1254 d0 , 6.3990 d3 , & 6.1897 d1 , 9.2731 d3 ] real ( Float64 ), parameter :: n2 = 1. d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1. d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1. d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0 d - 16 * p1 * ( p2 + p3 ) end function p_ioniz_1_omullane function p_ioniz_2_omullane ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: b = [ 3.9330 d - 3 , 1.8188 d0 , & 1.8870 d - 2 , 6.7489 d - 3 , & 1.3768 d0 , 6.8852 d2 , & 9.6435 d1 , 5.6515 d23 ] real ( Float64 ), parameter :: n2 = 4. d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1. d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1. d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0 d - 16 * p1 * ( p2 + p3 ) end function p_ioniz_2_omullane function p_ioniz_3_omullane ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1076 d - 2 , 1.6197 d0 , & 6.7154 d - 3 , 5.1188 d - 3 , & 1.8549 d0 , 2.3696 d2 , & 7.8286 d1 , 1.0926 d23 ] real ( Float64 ), parameter :: n2 = 9. d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1. d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1. d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0 d - 16 * p1 * ( p2 + p3 ) end function p_ioniz_3_omullane function p_ioniz_4_omullane ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1033 d - 2 , 1.6281 d0 , & 5.5955 d - 3 , 7.2023 d - 3 , & 1.7358 d0 , 2.2755 d2 , & 8.6339 d1 , 3.9151 d29 ] real ( Float64 ), parameter :: n2 = 1 6. d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1. d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1. d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0 d - 16 * p1 * ( p2 + p3 ) end function p_ioniz_4_omullane function p_ioniz_5_omullane ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1297 d - 2 , 1.8685 d0 , & 1.5038 d - 2 , 1.1195 d - 1 , & 1.0538 d0 , 8.6096 d2 , & 8.9939 d1 , 1.9249 d4 ] real ( Float64 ), parameter :: n2 = 2 5. d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1. d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1. d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0 d - 16 * p1 * ( p2 + p3 ) end function p_ioniz_5_omullane function p_ioniz_n ( eb , n ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: n real ( Float64 ) :: sigma select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_ioniz_1_omullane ( eb ) case ( 2 ) sigma = p_ioniz_2_omullane ( eb ) case ( 3 ) sigma = p_ioniz_3_omullane ( eb ) case ( 4 ) sigma = p_ioniz_4_omullane ( eb ) case DEFAULT sigma = p_ioniz_5_omullane ( eb ) * ( real ( n ) / 5.0 ) ** 4.0 end select end function p_ioniz_n function p_ioniz ( eb , n_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: n_max real ( Float64 ), dimension ( n_max ) :: sigma integer :: i do i = 1 , n_max sigma ( i ) = p_ioniz_n ( eb , i ) enddo end function p_ioniz !! Proton impact excitation function p_excit_1_2_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 10 ), parameter :: a = [ 3 4.433 d0 , 8.5476 d0 , & 7.8501 d0 , - 9.2217 d0 , & 1.8020 d - 2 , 1.6931 d0 , & 1.9422 d - 3 , 2.9068 d0 , & 4 4.507 d0 , 0.56870 d0 ] sigma = 1. d - 16 * a ( 1 ) * ( a ( 2 ) * exp ( - a ( 3 ) * eb ) / ( eb ** a ( 4 )) + & a ( 5 ) * exp ( - a ( 6 ) / eb ) / ( 1. + a ( 7 ) * eb ** a ( 8 )) + & exp ( - a ( 9 ) / eb ) * log ( 1. + a ( 10 ) * eb ) / eb ) end function p_excit_1_2_janev function p_excit_1_3_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: b = [ 6.1950 d0 , 5.5162 d - 3 , & 0.29114 d0 , - 4.5264 d0 , & 6.0311 d0 , - 2.0679 d0 , & 3 5.773 d0 , 0.54818 d0 ] sigma = 1. d - 16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_3_janev function p_excit_1_4_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0661 d0 , 5.1335 d - 4 , & 0.28953 d0 , - 2.2849 d0 , & 0.11528 d0 , - 4.8970 d0 , & 3 4.975 d0 , 0.91213 d0 ] sigma = 1. d - 16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_4_janev function p_excit_1_5_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.2449 d0 , 3.0826 d - 4 , & 0.31063 d0 , - 2.4161 d0 , & 0.024664 d0 , - 6.3726 d0 , & 3 2.291 d0 , 0.21176 d0 ] sigma = 1. d - 16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_5_janev function p_excit_1_6_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: b = [ 0.63771 d0 , 3.2949 d - 4 , & 0.25757 d0 , - 2.2950 d0 , & 0.050796 d0 , - 5.5986 d0 , & 3 7.174 d0 , 0.39265 d0 ] sigma = 1. d - 16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_6_janev function p_excit_1_janev ( eb , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m sigma = 0. d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0. d0 case ( 2 ) sigma ( 2 ) = p_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = p_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_1_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_1_6_janev ( eb ) case DEFAULT sigma ( m ) = p_excit_1_6_janev ( eb ) * ( 6.0 / real ( m )) ** 3.0 end select enddo end function p_excit_1_janev function p_excit_2_3_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: c = [ 39 4.51 d0 , 0.013597 d0 , & 0.16565 d0 , - 0.8949 d0 , & 2 1.606 d0 , 0.62426 d0 ] sigma = 1. d - 16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_3_janev function p_excit_2_4_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: c = [ 5 0.744 d0 , 0.014398 d0 , & 0.31584 d0 , - 1.4799 d0 , & 1 9.416 d0 , 4.0262 d0 ] sigma = 1. d - 16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_4_janev function p_excit_2_5_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: c = [ 1 8.264 d0 , 0.013701 d0 , & 0.31711 d0 , - 1.4775 d0 , & 1 8.973 d0 , 2.9056 d0 ] sigma = 1. d - 16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_5_janev function p_excit_2_6_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 4.61 d - 1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_6_janev function p_excit_2_7_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 2.475 d - 1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_7_janev function p_excit_2_8_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 1.465 d - 1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_8_janev function p_excit_2_9_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 9.2 d - 2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_9_janev function p_excit_2_10_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 6.05 d - 2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_10_janev function p_excit_2_janev ( eb , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m sigma = 0. d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0. d0 case ( 2 ) sigma ( 2 ) = 0. d0 case ( 3 ) sigma ( 3 ) = p_excit_2_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_2_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_2_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_2_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_2_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_2_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_2_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_2_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_2_janev function p_excit_3_4_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: c = [ 124 7.5 d0 , 0.068781 d0 , & 0.521176 d0 , - 1.2722 d0 , & 1 1.319 d0 , 2.6235 d0 ] sigma = 1. d - 16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_4_janev function p_excit_3_5_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: c = [ 19 0.59 d0 , 0.073307 d0 , & 0.54177 d0 , - 1.2894 d0 , & 1 1.096 d0 , 2.9098 d0 ] sigma = 1. d - 16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_5_janev function p_excit_3_6_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: c = [ 6 3.494 d0 , 0.077953 d0 , & 0.53461 d0 , - 1.2881 d0 , & 1 1.507 d0 , 4.3417 d0 ] sigma = 1. d - 16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_6_janev function p_excit_3_7_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 4.67 d - 1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_7_janev function p_excit_3_8_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 2.545 d - 1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_8_janev function p_excit_3_9_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 1.54 d - 1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_9_janev function p_excit_3_10_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 1.0 d - 1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_10_janev function p_excit_3_janev ( eb , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m sigma = 0. d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0. d0 case ( 2 ) sigma ( 2 ) = 0. d0 case ( 3 ) sigma ( 3 ) = 0. d0 case ( 4 ) sigma ( 4 ) = p_excit_3_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_3_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_3_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_3_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_3_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_3_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_3_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_3_janev function p_excit_n ( eb , n , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: n integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m real ( Float64 ) :: nf , mf , Etil , s , D , A , G , L , F real ( Float64 ) :: y , zpl , zmi , C2pl , C2mi , H sigma = 0. d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_excit_1_janev ( eb , m_max ) case ( 2 ) sigma = p_excit_2_janev ( eb , m_max ) case ( 3 ) sigma = p_excit_3_janev ( eb , m_max ) case DEFAULT nf = real ( n ) m_loop : do m = 1 , m_max if ( n . ge . m ) then sigma ( m ) = 0. d0 cycle m_loop endif mf = real ( m ) Etil = Eb / 2 5.0 s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * Etil ** 2.0 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( Etil * nf ** 2.0 / ( mf - 1.0 / mf ) ) ** 3. L = log ( 1.0 + 0.53 * Etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * Etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf ) ) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s ) ) zpl = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 + 1.0 )) zmi = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = (( 8.8 d - 17 * n ** 4 ) / Etil ) * ( A * L * D + F * G * H ) enddo m_loop end select end function p_excit_n function p_excit_n_m ( eb , n , m ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: n integer , intent ( in ) :: m real ( Float64 ) :: sigma real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_excit_n_m function p_excit ( eb , n_max , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: m_max integer , intent ( in ) :: n_max real ( Float64 ), dimension ( m_max , n_max ) :: sigma real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_excit function e_ioniz_1_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma integer , parameter :: n = 1 real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.18450 d0 , - 0.032226 d0 , & - 0.034539 d0 , 1.4003 d0 , & - 2.8115 d0 , 2.2986 d0 ] real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1. d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1. d - 13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0. d0 ) end function e_ioniz_1_janev function e_ioniz_2_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma integer , parameter :: n = 2 real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.14784 d0 , 0.0080871 d0 , & - 0.062270 d0 , 1.9414 d0 , & - 2.1980 d0 , 0.95894 d0 ] real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1. d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1. d - 13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0. d0 ) end function e_ioniz_2_janev function e_ioniz_3_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma integer , parameter :: n = 3 real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.058463 d0 , - 0.051272 d0 , & 0.85310 d0 , - 0.57014 d0 , & 0.76684 d0 , 0.00 d0 ] real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1. d3 !keV to eV if ( e . ge . 1.5 ) then x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1. d - 13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) else sigma = 0. d0 endif end function e_ioniz_3_janev function e_ioniz_n ( eb , n ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: n real ( Float64 ) :: sigma real ( Float64 ) :: rn , xn , Edn2 real ( Float64 ) :: g0 , g1 , g2 , An , b , Bn select case ( n ) case ( 0 ) stop case ( 1 ) sigma = e_ioniz_1_janev ( eb ) case ( 2 ) sigma = e_ioniz_2_janev ( eb ) case ( 3 ) sigma = e_ioniz_3_janev ( eb ) case DEFAULT rn = 1.94 / n ** 1.57 Edn2 = 1 3.6 / n ** 2.0 xn = ( eb * 1. d3 ) / Edn2 g0 = 0.9935 + 0.2328 / n - 0.1296 / n ** 2.0 g1 = - ( 1.0 / n ) * ( 0.6282 - 0.5598 / n + 0.5299 / n ** 2.0 ) g2 = ( 1.0 / n ** 2.0 ) * ( 0.3887 - 1.181 / n + 1.47 / n ** 2.0 ) An = 3 2.0 * n / ( 3.0 * sqrt ( 3.0 ) * PI ) * ( g0 / 3.0 + g1 / 4.0 + g2 / 5.0 ) b = ( 1.0 / n ) * ( 4.0 - 1 8.63 / n + 3 6.24 / n ** 2.0 - 2 8.09 / n ** 3.0 ) Bn = ( 2.0 / 3.0 ) * ( n ** 2.0 ) * ( 5.0 + b ) if ( xn . gt . 1 ) then sigma = 1.76 * n ** 2 / xn * ( 1.0 - exp ( - rn * xn )) * & ( An * log ( xn ) + ( Bn - An * log ( 2.0 * n ** 2 )) * & ( 1.0 - 1.0 / xn ) ** 2 ) * 1.e-16 else sigma = 0. d0 endif end select end function e_ioniz_n function e_ioniz ( eb , n_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: n_max real ( Float64 ), dimension ( n_max ) :: sigma integer :: i do i = 1 , n_max sigma ( i ) = e_ioniz_n ( eb , i ) enddo end function e_ioniz function e_excit_1_2_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: sigma0 = 5.984 d0 real ( Float64 ), parameter :: deltaE = 1 0.2 d0 real ( Float64 ), parameter :: a = 0.228 d0 real ( Float64 ), parameter :: b = 0.1865 d0 real ( Float64 ), parameter :: c = 0.5025 d0 real ( Float64 ), dimension ( 6 ), parameter :: An = [ 4.4979 d0 , 1.4182 d0 , & - 2 0.877 d0 , 4 9.735 d0 , & - 4 6.249 d0 , 1 7.442 d0 ] real ( Float64 ) :: ecoll , x , s ecoll = eb * 1. d3 x = ( ecoll ) / deltaE if (( ecoll . gt . 1 0.2 ). and .( ecoll . le . 1 1.56 )) then sigma = 1. d - 16 * ( a + b * ( ecoll - deltaE )) return endif if (( ecoll . ge . 1 1.56 ). and .( ecoll . le . 1 2.23 )) then sigma = 1. d - 16 * c return endif if ( ecoll . ge . 1 2.23 ) then s = An ( 2 ) + An ( 3 ) / x + An ( 4 ) / x ** 2.0 + An ( 5 ) / x ** 3.0 + An ( 6 ) / x ** 4.0 sigma = 1. d - 16 * sigma0 / ( deltaE * x ) * ( An ( 1 ) * log ( x ) + s ) return endif if ( x . le . 1.0 ) then sigma = 0.0 return endif end function e_excit_1_2_janev function e_excit_1_3_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: sigma0 = 5.984 d0 real ( Float64 ), parameter :: deltaE = 1 2.09 d0 real ( Float64 ), parameter :: alpha = 0.38277 d0 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.75448 d0 , 0.42956 d0 , & - 0.58288 d0 , 1.0693 d0 , & 0. d0 ] real ( Float64 ) :: ecoll , x , s ecoll = eb * 1. d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1. d - 16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0. d0 end function e_excit_1_3_janev function e_excit_1_4_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: sigma0 = 5.984 d0 real ( Float64 ), parameter :: deltaE = 1 2.75 d0 real ( Float64 ), parameter :: alpha = 0.41844 d0 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.24300 d0 , 0.24846 d0 , & 0.19701 d0 , 0. d0 , & 0. d0 ] real ( Float64 ) :: ecoll , x , s ecoll = eb * 1. d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1. d - 16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0. d0 end function e_excit_1_4_janev function e_excit_1_5_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: sigma0 = 5.984 d0 real ( Float64 ), parameter :: deltaE = 1 3.06 d0 real ( Float64 ), parameter :: alpha = 0.45929 d0 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.11508 d0 , 0.13092 d0 , & 0.23581 d0 , 0. d0 , & 0. d0 ] real ( Float64 ) :: ecoll , x , s ecoll = eb * 1. d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1. d - 16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0. d0 end function e_excit_1_5_janev function e_excit_f ( n , m ) result ( fnm ) integer , intent ( in ) :: n integer , intent ( in ) :: m real ( Float64 ) :: fnm real ( Float64 ), dimension ( 3 ) :: g real ( Float64 ) :: x , nf , mf , gs nf = real ( n ) mf = real ( m ) x = 1.0 - ( nf / mf ) ** 2.0 select case ( n ) case ( 1 ) g = [ 1.133 , - 0.4059 , 0.0714 ] case ( 2 ) g = [ 1.0785 , - 0.2319 , 0.02947 ] case DEFAULT g ( 1 ) = 0.9935 + 0.2328 / nf - 0.1296 / nf ** 2 g ( 2 ) =- 1.0 / nf * ( 0.6282 - 0.5598 / nf + 0.5299 / nf ** 2 ) g ( 3 ) = 1.0 / nf ** 2.0 * ( 0.3887 - 1.1810 / nf + 1.4700 / nf ** 2 ) end select gs = g ( 1 ) + g ( 2 ) / x + g ( 3 ) / x ** 2 fnm = 3 2.0 / ( 3.0 * sqrt ( 3.0 ) * PI ) * nf / mf ** 3 * 1 / x ** 3 * gs end function e_excit_f function e_excit_1_janev ( eb , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m real ( Float64 ) :: x , y , A , B , deltaE do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0. d0 case ( 2 ) sigma ( 2 ) = e_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = e_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = e_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = e_excit_1_5_janev ( eb ) case DEFAULT y = 1.0 - ( 1. d0 / m ) ** 2.0 deltaE = 1 3.6 * y x = ( eb * 1. d3 ) / deltaE A = 2.0 * e_excit_f ( 1 , m ) / y B = 4.0 / ( m ** 3.0 * y ) * ( 1.0 + 4.0 / ( 3.0 * y ) - 0.603 / y ** 2.0 ) sigma ( m ) = 1.76e-16 / ( y * x ) * ( 1.0 - exp ( - 0.45 * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0. d0 end select enddo end function e_excit_1_janev function e_excit_2_3_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), parameter :: sigma0 = 5.984 d0 real ( Float64 ), parameter :: deltaE = 1.8888 d0 real ( Float64 ), parameter :: alpha = 1.3196 d0 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 3 8.906 d0 , 5.2373 d0 , 11 9.25 d0 , & - 59 5.39 d0 , 81 6.71 d0 ] real ( Float64 ) :: ecoll , x , s ecoll = eb * 1. d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1. d - 16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0. d0 end function e_excit_2_3_janev function e_excit_n ( eb , n , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: n integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m real ( Float64 ) :: nf , mf real ( Float64 ) :: x , y , A , B , bn , r , deltaE nf = real ( n ) if ( n . eq . 1 ) then sigma = e_excit_1_janev ( eb , m_max ) else m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0. d0 cycle m_loop endif if (( n . eq . 2 ). and .( m . eq . 3 )) then sigma ( m ) = e_excit_2_3_janev ( eb ) else deltaE = 1 3.6 * ( 1.0 / nf ** 2 - 1.0 / mf ** 2 ) x = ( eb * 1. d3 ) / deltaE y = 1.0 - ( nf / mf ) ** 2 r = 1.94 / nf ** 1.57 A = 2.0 * nf ** 2 * e_excit_f ( n , m ) / y bn = 1.0 / nf * ( 4.0 - 1 8.63 / nf + 3 6.24 / nf ** 2 - 2 8.09 / nf ** 3 ) B = 4.0 * nf ** 4 / ( mf ** 3 * y ** 2 ) * ( 1.0 + 4.0 / ( 3.0 * y ) + bn / y ** 2.0 ) sigma ( m ) = 1.76e-16 * nf ** 2 / ( y * x ) * ( 1.0 - exp ( - r * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 * n ** 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0. d0 endif enddo m_loop endif end function e_excit_n function e_excit_n_m ( eb , n , m ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: n integer , intent ( in ) :: m real ( Float64 ) :: sigma real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = e_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function e_excit_n_m function e_excit ( eb , n_max , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max real ( Float64 ), dimension ( n_max , m_max ) :: sigma real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n do n = 1 , 12 sigma_full ( n ,:) = e_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function e_excit !Impurities !A[q]_cx_[n]_[source] function B5_cx_1_adas ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 7 ), parameter :: A = [ 1.174052518 d3 , - 1.793561728 d3 , & 1.117522436 d3 , - 3.679435571 d2 , & 6.750816878 d1 , - 6.542029074 d0 , & 2.614113716 d - 1 ] real ( Float64 ) :: e , l , p e = max ( eb * 1. d3 , 1 0.0 ) l = log10 ( e ) if ( e . le . 4. d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 sigma = 1 0. d0 ** p else sigma = 0. d0 endif end function B5_cx_1_adas function B5_cx_2_adas ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 10 ), parameter :: A = [ 6.603246818 d1 , - 3.072575676 d2 , & 5.030801019 d2 , - 4.585636345 d2 , & 2.568666393 d2 , - 9.185150382 d1 , & 2.100012584 d1 , - 2.964174788 d0 , & 2.346396110 d - 1 , - 7.943766873 d - 3 ] real ( Float64 ) :: e , l , p e = max ( eb * 1. d3 , 1 0.0 ) l = log10 ( e ) if ( e . le . 1. d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 sigma = 1 0. d0 ** p else sigma = 0. d0 endif end function B5_cx_2_adas function C6_cx_1_adas ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 7 ), parameter :: A = [ 2.007882674 d2 , - 3.546893286 d2 , & 2.381542403 d2 , - 8.355431742 d1 , & 1.617519888 d1 , - 1.638152470 d0 , & 6.768953863 d - 2 ] real ( Float64 ) :: e , l , p e = max ( eb * 1. d3 , 1.5 d3 ) l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 sigma = 1 0. d0 ** p end function C6_cx_1_adas function C6_cx_2_adas ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.151879441 d5 , - 2.134573133 d6 , & 2.223792624 d6 , - 1.362648703 d6 , & 5.438401343 d5 , - 1.477110500 d5 , & 2.764972254 d4 , - 3.522105245 d3 , & 2.921934171 d2 , - 1.425552507 d1 , & 3.106007048 d - 1 ] real ( Float64 ) :: e , l , p e = max ( eb * 1. d3 , 1.5 d3 ) * 2.0 ** 2 l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 sigma = 1 0. d0 ** p end function C6_cx_2_adas function C6_cx_3_adas ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.208877916 d5 , - 2.147294379 d6 , & 2.236451628 d6 , - 1.370042347 d6 , & 5.466461899 d5 , - 1.484338816 d5 , & 2.777765778 d4 , - 3.537459450 d3 , & 2.933884362 d2 , - 1.430994136 d1 , & 3.117002878 d - 1 ] real ( Float64 ) :: e , l , p e = max ( eb * 1. d3 , 1.5 d3 ) * 3.0 ** 2 l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 sigma = 1 0. d0 ** p end function C6_cx_3_adas function Aq_cx_n_adas ( eb , q , n ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n real ( Float64 ) :: sigma sigma = 0. d0 select case ( q ) case ( 5 ) if ( n . eq . 1 ) sigma = B5_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = B5_cx_2_adas ( eb ) case ( 6 ) if ( n . eq . 1 ) sigma = C6_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = C6_cx_2_adas ( eb ) if ( n . eq . 3 ) sigma = C6_cx_3_adas ( eb ) case DEFAULT sigma = 0. d0 end select end function Aq_cx_n_adas function B5_cx_1_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 11 ), parameter :: A = [ 3 1.226 d0 , 1.1442 d0 , & 4.8372 d - 8 , 3.0961 d - 10 , & 4.7205 d0 , 6.2844 d - 7 , & 3.1297 d0 , 0.12556 d0 , & 0.30098 d0 , 5.9607 d - 2 , & - 0.57923 d0 ] sigma = 1. d - 16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function B5_cx_1_janev function C6_cx_1_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 11 ), parameter :: A = [ 41 8.18 d0 , 2.1585 d0 , & 3.4808 d - 4 , 5.3333 d - 9 , & 4.6556 d0 , 0.33755 d0 , & 0.81736 d0 , 0.27874 d0 , & 1.8003 d - 6 , 7.1033 d - 2 , & 0.53261 d0 ] sigma = 1. d - 16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function C6_cx_1_janev function Aq_cx_n_janev ( eb , q , n ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 1.507 d5 real ( Float64 ), parameter :: B = 1.974 d - 5 real ( Float64 ) :: etil , nf , qf nf = real ( n ) qf = real ( q ) if (( n . eq . 1 ). and .( q . eq . 5 )) then sigma = B5_cx_1_janev ( eb ) return endif if (( n . eq . 1 ). and .( q . eq . 6 )) then sigma = C6_cx_1_janev ( eb ) return endif if ( n . le . 1 ) then sigma = 0. d0 return endif etil = eb * ( nf ** 2.0 ) / ( qf ** 0.5 ) sigma = qf * nf ** 4 * 7.04 d - 16 * A / ( etil ** 3.5 * ( 1.0 + B * etil ** 2 )) * & ( 1.0 - exp ( - 2.0 * etil ** 3.5 * ( 1.0 + B * etil ** 2 ) / ( 3.0 * A ))) end function Aq_cx_n_janev function Aq_cx_n ( eb , q , n ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n real ( Float64 ) :: sigma sigma = Aq_cx_n_adas ( eb , q , n ) if ( sigma . eq . 0. d0 ) then sigma = Aq_cx_n_janev ( eb , q , n ) endif end function Aq_cx_n function Aq_cx ( eb , q , n_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n_max real ( Float64 ), dimension ( n_max ) :: sigma integer :: n do n = 1 , n_max sigma ( n ) = Aq_cx_n ( eb , q , n ) enddo end function Aq_cx !Impurity impact ionization function B5_ioniz_1_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: A = [ 35 1.52 d0 , 23 3.63 d0 , & 3.2952 d3 , 5.3787 d - 6 , & 1.8834 d - 2 , - 2.2064 d0 , & 7.2074 d0 , - 3.78664 d0 ] sigma = 1. d - 16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function B5_ioniz_1_janev function C6_ioniz_1_janev ( eb ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: A = [ 43 8.36 d0 , 32 7.10 d0 , & 1.4444 d5 , 3.5212 d - 3 , & 8.3031 d - 3 , - 0.63731 d0 , & 1.9116 d4 , - 3.1003 d0 ] sigma = 1. d - 16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function C6_ioniz_1_janev function Aq_ioniz_n_janev ( eb , q , n ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n real ( Float64 ) :: sigma real ( Float64 ), parameter :: M = 0.283 d0 real ( Float64 ), parameter :: B = 4.04 d0 real ( Float64 ), parameter :: c = 13 7. d0 real ( Float64 ), parameter :: g = 0.662 d0 real ( Float64 ), parameter :: lambda = 0.76 d0 real ( Float64 ) :: nf , qf , u , v , sigma_b nf = real ( n ) qf = real ( q ) v = sqrt ( eb / 2 5. ) u = nf * v sigma_b = 3.52 d - 16 * ( nf ** 4 ) * ( qf ** 2 ) / ( u ** 2 ) * & ( M * ( log (( u ** 2 ) / ( c ** 2 - u ** 2 )) - ( u ** 2 ) / ( c ** 2 )) + B - g / u ** 2 ) sigma_b = max ( sigma_b , 0. d0 ) sigma = exp ( - lambda * qf / u ** 2 ) * sigma_b end function Aq_ioniz_n_janev function Aq_ioniz_n ( eb , q , n ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n real ( Float64 ) :: sigma if (( q . eq . 5 ). and .( n . eq . 1 )) then sigma = B5_ioniz_1_janev ( eb ) return endif if (( q . eq . 6 ). and .( n . eq . 1 )) then sigma = C6_ioniz_1_janev ( eb ) return endif sigma = Aq_ioniz_n_janev ( eb , q , n ) end function Aq_ioniz_n function Aq_ioniz ( eb , q , n_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n_max real ( Float64 ), dimension ( n_max ) :: sigma integer :: n do n = 1 , n_max sigma ( n ) = Aq_ioniz_n ( eb , q , n ) enddo end function Aq_ioniz !Impurity impact excitation function Aq_excit_1_2_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 3 8.738 d0 , 3 7.033 d0 , & 0.39862 d0 , 7.7582 d - 5 , & 0.25402 d0 , - 2.7418 d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1. d - 16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_2_janev function Aq_excit_1_3_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 4.3619 d0 , 5 7.451 d0 , & 2 1.001 d0 , 2.3292 d - 4 , & 0.083130 d0 , - 2.2364 d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1. d - 16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_3_janev function Aq_excit_1_4_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1.3730 d0 , 6 0.710 d0 , & 3 1.797 d0 , 2.0207 d - 4 , & 0.082513 d0 , - 2.3055 d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1. d - 16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_4_janev function Aq_excit_1_5_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.56565 d0 , 6 7.333 d0 , & 5 5.290 d0 , 2.1595 d - 4 , & 0.081624 d0 , - 2.1971 d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1. d - 16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_5_janev function Aq_excit_1_janev ( eb , q , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m sigma = 0. d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0. d0 case ( 2 ) sigma ( 2 ) = Aq_excit_1_2_janev ( eb , q ) case ( 3 ) sigma ( 3 ) = Aq_excit_1_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_1_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_1_5_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 5 ) * ( 5.0 / m ) ** 3.0 end select enddo end function Aq_excit_1_janev function Aq_excit_2_3_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 35 8.03 d0 , 2 5.283 d0 , & 1.4726 d0 , 0.014398 d0 , & 0.12207 d0 , - 0.86210 d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_3_janev function Aq_excit_2_4_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 5 0.744 d0 , 1 9.416 d0 , & 4.0262 d0 , 0.014398 d0 , & 0.31584 d0 , - 1.4799 d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_4_janev function Aq_excit_2_5_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1 8.264 d0 , 1 8.973 d0 , & 2.9056 d0 , 0.013701 d0 , & 0.31711 d0 , - 1.4775 d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_5_janev function Aq_excit_2_6_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 0.4610 d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_6_janev function Aq_excit_2_7_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 0.2475 d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_7_janev function Aq_excit_2_8_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 0.1465 d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_8_janev function Aq_excit_2_9_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 0.092 d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_9_janev function Aq_excit_2_10_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 0.0605 d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_10_janev function Aq_excit_2_janev ( eb , q , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m sigma = 0. d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0. d0 case ( 2 ) sigma ( 2 ) = 0. d0 case ( 3 ) sigma ( 3 ) = Aq_excit_2_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_2_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_2_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_2_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_2_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_2_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_2_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_2_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_2_janev function Aq_excit_3_4_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 124 7.5 d0 , 1 1.319 d0 , & 2.6235 d0 , 0.068781 d0 , & 0.521176 d0 , - 1.2722 d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_4_janev function Aq_excit_3_5_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 19 0.59 d0 , 1 1.096 d0 , & 2.9098 d0 , 0.073307 d0 , & 0.54177 d0 , - 1.2894 d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_5_janev function Aq_excit_3_6_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), dimension ( 6 ), parameter :: A = [ 6 3.494 d0 , 1 1.507 d0 , & 4.3417 d0 , 0.077953 d0 , & 0.53461 d0 , - 1.2881 d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_6_janev function Aq_excit_3_7_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 0.4670 d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_7_janev function Aq_excit_3_8_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 0.2545 d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_8_janev function Aq_excit_3_9_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 0.1540 d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_9_janev function Aq_excit_3_10_janev ( eb , q ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q real ( Float64 ) :: sigma real ( Float64 ), parameter :: A = 0.1 d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_10_janev function Aq_excit_3_janev ( eb , q , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m sigma = 0. d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0. d0 case ( 2 ) sigma ( 2 ) = 0. d0 case ( 3 ) sigma ( 3 ) = 0. d0 case ( 4 ) sigma ( 4 ) = Aq_excit_3_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_3_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_3_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_3_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_3_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_3_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_3_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_3_janev function Aq_excit_n_janev ( eb , q , n , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma integer :: m real ( Float64 ) :: nf , mf , qf , etil , hi , s real ( Float64 ) :: D , A , G , L , F , H , y , zpl , zmi , C2pl , C2mi nf = real ( n ) qf = real ( q ) sigma = 0. d0 m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0. d0 cycle m_loop endif etil = eb / ( 2 5.0 * qf ) hi = 2.0 ** ( 0.322 * ( 1.0 - sqrt ( 2.0 / qf ))) s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * etil ** 2 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( etil * nf ** 2.0 / ( mf - 1.0 / mf )) ** 3.0 L = log ( 1.0 + 0.53 * etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf )) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s )) zpl = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) + 1.0 )) zmi = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = q * hi * 8.86e-17 * nf ** 4 / etil * ( A * D * L + F * G * H ) enddo m_loop end function Aq_excit_n_janev function Aq_excit_n ( eb , q , n , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n integer , intent ( in ) :: m_max real ( Float64 ), dimension ( m_max ) :: sigma select case ( n ) case ( 0 ) stop case ( 1 ) sigma = Aq_excit_1_janev ( eb , q , m_max ) case ( 2 ) sigma = Aq_excit_2_janev ( eb , q , m_max ) case ( 3 ) sigma = Aq_excit_3_janev ( eb , q , m_max ) case DEFAULT sigma = Aq_excit_n_janev ( eb , q , n , m_max ) end select end function Aq_excit_n function Aq_excit_n_m ( eb , q , n , m ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n integer , intent ( in ) :: m real ( Float64 ) :: sigma real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = Aq_excit_n ( eb , q , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function Aq_excit_n_m function Aq_excit ( eb , q , n_max , m_max ) result ( sigma ) real ( Float64 ), intent ( in ) :: eb integer , intent ( in ) :: q integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max real ( Float64 ), dimension ( n_max , m_max ) :: sigma real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = Aq_excit_n ( eb , q , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function Aq_excit function simpsons_rule ( f , dx ) result ( I ) real ( Float64 ), dimension (:), intent ( in ) :: f real ( Float64 ), intent ( in ) :: dx real ( Float64 ) :: I integer :: s , ii s = size ( f ) I = 0. d0 if ( mod ( s , 2 ). eq . 1 ) then write ( * , '(a)' ) \"Length of array must be even\" return endif I = f ( 1 ) do ii = 2 , s - 1 if ( mod ( ii , 2 ). eq . 1 ) then I = I + 4.0 * f ( ii ) else I = I + 2.0 * f ( ii ) endif enddo I = I + f ( s ) I = ( dx / 3.0 ) * I end function simpsons_rule subroutine bt_maxwellian_n ( fn , T , eb , am , ab , n , rate ) interface function fn ( a , b ) real ( 8 ) :: fn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n end function fn end interface real ( Float64 ), intent ( in ) :: T real ( Float64 ), intent ( in ) :: eb real ( Float64 ), intent ( in ) :: am real ( Float64 ), intent ( in ) :: ab integer , intent ( in ) :: n real ( Float64 ), intent ( out ) :: rate logical :: dxc integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j n_vr = 32 vr_max = 4. d0 dvr = vr_max / ( n_vr - 1. d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4. d0 dvz = 2.0 * vz_max / ( n_vz - 1. d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1. d - 6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6 d - 3 ) / ( n ** 2.0 ) v_therm = 1.384 d6 * sqrt ( T_per_amu * 1. d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0. d0 fr = 0. d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fn ( erel / ared , n ) else sig = 0. d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_n subroutine bt_maxwellian_q_n ( fqn , q , T , eb , am , ab , n , rate ) interface function fqn ( a , b , c ) real ( 8 ) :: fqn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n end function fqn end interface integer , intent ( in ) :: q real ( Float64 ), intent ( in ) :: T real ( Float64 ), intent ( in ) :: eb real ( Float64 ), intent ( in ) :: am real ( Float64 ), intent ( in ) :: ab integer , intent ( in ) :: n real ( Float64 ), intent ( out ) :: rate integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j n_vr = 32 vr_max = 4. d0 dvr = vr_max / ( n_vr - 1. d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4. d0 dvz = 2.0 * vz_max / ( n_vz - 1. d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1. d - 6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6 d - 3 ) / ( n ** 2.0 ) v_therm = 1.384 d6 * sqrt ( T_per_amu * 1. d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0. d0 fr = 0. d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fqn ( erel / ared , q , n ) else sig = 0. d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_q_n subroutine bt_maxwellian_n_m ( fnm , T , eb , am , ab , n , m , rate , deexcit ) interface function fnm ( a , b , c ) real ( 8 ) :: fnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n integer , intent ( in ) :: c !m end function fnm end interface real ( Float64 ), intent ( in ) :: T real ( Float64 ), intent ( in ) :: eb real ( Float64 ), intent ( in ) :: am real ( Float64 ), intent ( in ) :: ab integer , intent ( in ) :: n integer , intent ( in ) :: m real ( Float64 ), intent ( out ) :: rate logical , intent ( in ), optional :: deexcit logical :: dxc integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif n_vr = 32 vr_max = 4. d0 dvr = vr_max / ( n_vr - 1. d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4. d0 dvz = 2.0 * vz_max / ( n_vz - 1. d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6 d - 3 ) * ( 1.0 - ( 1. d0 / n ) ** 2.0 ) Em = ( 1 3.6 d - 3 ) * ( 1.0 - ( 1. d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1. d - 6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384 d6 * sqrt ( T_per_amu * 1. d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0. d0 fr = 0. d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fnm ( erel / ared , n , m ) else sig = 0. d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_n_m subroutine bt_maxwellian_q_n_m ( fqnm , q , T , eb , am , ab , n , m , rate , deexcit ) interface function fqnm ( a , b , c , d ) real ( 8 ) :: fqnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n integer , intent ( in ) :: d !m end function fqnm end interface integer , intent ( in ) :: q real ( Float64 ), intent ( in ) :: T real ( Float64 ), intent ( in ) :: eb real ( Float64 ), intent ( in ) :: am real ( Float64 ), intent ( in ) :: ab integer , intent ( in ) :: n integer , intent ( in ) :: m real ( Float64 ), intent ( out ) :: rate logical , intent ( in ), optional :: deexcit logical :: dxc integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif n_vr = 32 vr_max = 4. d0 dvr = vr_max / ( n_vr - 1. d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4. d0 dvz = 2.0 * vz_max / ( n_vz - 1. d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6 d - 3 ) * ( 1.0 - ( 1. d0 / n ) ** 2.0 ) Em = ( 1 3.6 d - 3 ) * ( 1.0 - ( 1. d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1. d - 6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384 d6 * sqrt ( T_per_amu * 1. d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0. d0 fr = 0. d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fqnm ( erel / ared , q , n , m ) else sig = 0. d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_q_n_m subroutine write_einstein ( id , n_max , m_max ) integer ( HID_T ), intent ( inout ) :: id integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max real ( Float64 ), dimension ( n_max , m_max ) :: ein integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error ein (:,:) = EINSTEIN ( 1 : n_max , 1 : m_max ) call h5gcreate_f ( id , \"spontaneous\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , m_max ] call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_compressed_dataset_double_f ( gid , \"einstein\" , 2 , dim2 , ein , error ) call h5ltset_attribute_string_f ( id , \"spontaneous\" , \"description\" , & \"Atomic rates for spontaneous emission/deexcitation\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"description\" , & \"n/m resolved einstein coefficients: einstein(n,m)\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"units\" , \"1/s\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"reaction\" , & \"H(n) -> H(m) + ph, n > m\" , error ) call h5gclose_f ( gid , error ) end subroutine write_einstein subroutine write_bb_H_H ( id , namelist_file , n_max , m_max ) integer ( HID_T ), intent ( inout ) :: id character ( len =* ), intent ( in ) :: namelist_file integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: cx , excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_H_cross / nenergy , emin , emax nenergy = 200 ; emin = 1. d - 3 ; emax = 8. d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , m_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0. d0 ioniz = 0. d0 cx = 0. d0 excit = 0. d0 write ( * , '(a)' ) \"---- H-H cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0. d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:,:, i ) = p_cx ( eb , n_max , m_max ) excit (:,:, i ) = p_excit ( eb , n_max , m_max ) ioniz (:, i ) = p_ioniz ( eb , n_max ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 3 , dim3 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Cross sections for Hydrogen-Hydrogen interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange cross sections: cx(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , cx , excit , ioniz ) end subroutine write_bb_H_H subroutine write_bb_H_e ( id , namelist_file , n_max , m_max ) integer ( HID_T ), intent ( inout ) :: id character ( len =* ), intent ( in ) :: namelist_file integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_e_cross / nenergy , emin , emax nenergy = 200 ; emin = 1. d - 3 ; emax = 8. d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0. d0 ioniz = 0. d0 excit = 0. d0 write ( * , '(a)' ) \"---- H-e cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0. d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb excit (:,:, i ) = e_excit ( eb , n_max , m_max ) ioniz (:, i ) = e_ioniz ( eb , n_max ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Cross sections for Hydrogen-Electron interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , ioniz , excit ) end subroutine write_bb_H_e subroutine write_bb_H_Aq ( id , namelist_file , n_max , m_max ) integer ( HID_T ), intent ( inout ) :: id character ( len =* ), intent ( in ) :: namelist_file integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max integer :: q real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: cx , ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 character ( len = 10 ) :: aname character ( len = 5 ) :: asym integer :: i , cnt , error logical :: exis NAMELIST / H_Aq_cross / q , nenergy , emin , emax nenergy = 200 ; emin = 1. d - 3 ; emax = 8. d2 q = 6 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0. d0 ioniz = 0. d0 cx = 0. d0 excit = 0. d0 select case ( q ) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT aname = \"Impurity\" asym = \"H_Aq\" end select write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" cross sections settings ----\" write ( * , '(T2,\"q = \", i2)' ), q write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0. d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:, i ) = Aq_cx ( eb , q , n_max ) ioniz (:, i ) = Aq_ioniz ( eb , q , n_max ) excit (:,:, i ) = Aq_excit ( eb , q , n_max , m_max ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 2 , dim2 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Cross sections for Hydrogen-\" // trim ( adjustl ( aname )) // \" interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n resolved charge exchange / electron capture cross sections: cx(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , ioniz , cx , excit ) end subroutine write_bb_H_Aq subroutine write_bt_H_H ( id , namelist_file , n_max , m_max ) integer ( HID_T ), intent ( inout ) :: id character ( len =* ), intent ( in ) :: namelist_file integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit , cx integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 4 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_H_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1. d - 3 ; emax = 4. d2 ntemp = 100 ; tmin = 1. d - 3 ; tmax = 2. d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , m_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0. d0 tarr = 0. d0 ioniz = 0. d0 cx = 0. d0 excit = 0. d0 a (:, 1 ) = [ H1_amu , H1_amu ] a (:, 2 ) = [ H1_amu , H2_amu ] a (:, 3 ) = [ H2_amu , H1_amu ] a (:, 4 ) = [ H2_amu , H2_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0. d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0. d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- H-H reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max call bt_maxwellian ( p_cx_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) cx ( n , m , ie , it , ia ) = rate if ( m . gt . n ) then call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( p_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 5 , dim5 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Reaction rates for Hydrogen(beam)-Hydrogen(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange reaction rates: cx(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , cx , excit , ioniz ) end subroutine write_bt_H_H subroutine write_bt_H_e ( id , namelist_file , n_max , m_max ) integer ( HID_T ), intent ( inout ) :: id character ( len =* ), intent ( in ) :: namelist_file integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 2 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_e_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1. d - 3 ; emax = 4. d2 ntemp = 100 ; tmin = 1. d - 3 ; tmax = 2. d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0. d0 ioniz = 0. d0 excit = 0. d0 a (:, 1 ) = [ H1_amu , e_amu ] a (:, 2 ) = [ H2_amu , e_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0. d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0. d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- H-e reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( e_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Reaction rates for Hydrogen(beam)-Electron(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , excit , ioniz ) end subroutine write_bt_H_e subroutine write_bt_H_Aq ( id , namelist_file , n_max , m_max ) integer ( HID_T ), intent ( inout ) :: id character ( len =* ), intent ( in ) :: namelist_file integer , intent ( in ) :: n_max integer , intent ( in ) :: m_max integer :: q real ( Float64 ) :: mass real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz , cx real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 2 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a character ( len = 10 ) :: aname character ( len = 5 ) :: asym logical :: exis NAMELIST / H_Aq_rates / q , mass , nenergy , emin , emax , ntemp , tmin , tmax q = 6 ; mass = C_amu nenergy = 100 ; emin = 1. d - 3 ; emax = 4. d2 ntemp = 100 ; tmin = 1. d - 3 ; tmax = 2. d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) select case ( q ) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT aname = \"Impurity\" asym = \"H_Aq\" end select ebarr = 0. d0 ioniz = 0. d0 cx = 0. d0 excit = 0. d0 a (:, 1 ) = [ H1_amu , mass ] a (:, 2 ) = [ H2_amu , mass ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0. d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0. d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" reaction rates settings ----\" write ( * , '(T2,\"q = \", i2)' ), q write ( * , '(T2,\"mass = \",f7.2, \" amu\")' ) mass write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( Aq_excit_n_m , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( Aq_excit_n_m , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( Aq_cx_n , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) cx ( n , ie , it , ia ) = rate call bt_maxwellian ( Aq_ioniz_n , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 4 , dim4 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Reaction rates for Hydrogen(beam)-\" // trim ( adjustl ( aname )) // & \"(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n-resolved charge exchange reaction rates: cx(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , excit , ioniz ) end subroutine write_bt_H_Aq end module atomic_tables program generate_tables use atomic_tables use H5LT use HDF5 use hdf5_extra #ifdef _OMP use omp_lib #endif character ( len = 200 ) :: namelist_file character ( len = 3 ) :: arg character ( len = 200 ) :: tables_file = '' integer :: n_max , m_max integer , dimension ( 8 ) :: time_arr , time_start , time_end integer :: hour , minu , sec integer :: argc , max_threads , nthreads integer ( HID_T ) :: fid , gid integer :: error logical :: exis NAMELIST / general_settings / n_max , m_max , tables_file argc = command_argument_count () if ( argc . ge . 1 ) then call get_command_argument ( 1 , namelist_file ) endif inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'Input file does not exist: ' , trim ( namelist_file ) stop else open ( 13 , file = namelist_file ) read ( 13 , NML = general_settings ) close ( 13 ) n_max = min ( n_max , 15 ) m_max = min ( m_max , 15 ) endif write ( * , '(a)' ) \"---- General settings ----\" write ( * , '(T2,\"n_max = \",i2)' ) n_max write ( * , '(T2,\"m_max = \",i2)' ) m_max write ( * , '(T2,\"Tables File: \",a)' ) trim ( tables_file ) write ( * , * ) '' #ifdef _OMP max_threads = OMP_get_num_procs () if ( argc . ge . 2 ) then call get_command_argument ( 2 , arg ) read ( arg , '(i3)' ) nthreads else nthreads = max_threads endif max_threads = min ( nthreads , max_threads ) write ( * , '(a)' ) \"---- OpenMP settings ----\" write ( * , '(T2,\"Number of threads: \",i2)' ) max_threads write ( * , * ) '' call OMP_set_num_threads ( max_threads ) #endif ! Check if compression is possible call check_compression_availability () ! measure time call date_and_time ( values = time_start ) call h5open_f ( error ) call h5fcreate_f ( tables_file , H5F_ACC_TRUNC_F , fid , error ) call h5gcreate_f ( fid , \"cross\" , gid , error ) call date_and_time ( values = time_arr ) write ( * , \"(A,I2,A,I2.2,A,I2.2)\" ) 'Cross Sections:   ' , time_arr ( 5 ), ':' , time_arr ( 6 ), ':' , time_arr ( 7 ) call write_bb_H_H ( gid , namelist_file , n_max , m_max ) call write_bb_H_e ( gid , namelist_file , n_max , m_max ) call write_bb_H_Aq ( gid , namelist_file , n_max , m_max ) call h5gclose_f ( gid , error ) call h5gcreate_f ( fid , \"rates\" , gid , error ) call date_and_time ( values = time_arr ) write ( * , \"(A,I2,A,I2.2,A,I2.2)\" ) 'Reaction Rates:   ' , time_arr ( 5 ), ':' , time_arr ( 6 ), ':' , time_arr ( 7 ) call write_bt_H_H ( gid , namelist_file , n_max , m_max ) call write_bt_H_e ( gid , namelist_file , n_max , m_max ) call write_bt_H_Aq ( gid , namelist_file , n_max , m_max ) call write_einstein ( gid , n_max , m_max ) call h5gclose_f ( gid , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Atomic Cross Sections and Rates\" , error ) call h5ltset_attribute_string_f ( fid , \"cross\" , \"description\" , & \"Atomic Cross Sections\" , error ) call h5ltset_attribute_string_f ( fid , \"rates\" , \"description\" , & \"Atomic Reaction Rates\" , error ) call h5fclose_f ( fid , error ) call h5close_f ( error ) write ( * , '(a)' ) \"Atomic tables written to \" // trim ( tables_file ) write ( * , * ) '' call date_and_time ( values = time_arr ) write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'END: hour, minute, second: ' , time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) call date_and_time ( values = time_end ) hour = time_end ( 5 ) - time_start ( 5 ) minu = time_end ( 6 ) - time_start ( 6 ) sec = time_end ( 7 ) - time_start ( 7 ) if ( minu . lt . 0. ) then minu = minu + 60 hour = hour - 1 endif if ( sec . lt . 0. ) then sec = sec + 60 minu = minu - 1 endif write ( * , '(A,18X,I2,\":\",I2.2,\":\",I2.2)' ) 'duration:' , hour , minu , sec end program","tags":""},{"title":"prefida.pro – Fortran Program","loc":"sourcefile/prefida.pro.html","text":"Create colored string Arguments:\nstr: String to be colored Keyword Arguments:\nc: Foreground color code\ns: Style code Return Value:\ncolored string Foreground Color Codes:\nk = Black\nr = Red\ng = Green\ny = Yellow\nb = Blue\nm = Magenta\nc = Cyan\nw = White [default] Style Format Codes\nn = Normal [default]\nb = Bright\nd = Dim\ni = Italics\nu = Underline\nr = Reverse (switch foreground and background colors)\nh = Hidden\ns = Strikethrough Example Usage: IDL > blue_bright_hello = colored( \"Hello\" ,c = \"b\" ,s = \"b\" ) Print a success message Arguments:\nstr: message Example Usage: IDL > success, \"Yay!!!\" Print a warning message Arguments:\nstr: message Example Usage: IDL > warn, \"This may be a problem\" Print a error message Arguments:\nstr: message Example Usage: IDL > error, \"=(\" Print a informational message Arguments:\nstr: message Example Usage: IDL > info, \"This is informative\" Check structure s is formatted according to schema Input Arguments:\nschema: structure schema\ns: structure to check Output Arguments:\nerr_status: error status. good: 0, bad: 1 Keyword Arguments:\ndesc: description of structure s Example usage: IDL > s = {a : 0 , b : [ 1.d0 , 2.d0 ], c : \"example\" }\nIDL > schema = {a : {dims : 0 ,type : \"INT\" },    $\nb : {dims : 1 ,type : \"DOUBLE\" }, $\nc : {dims : 0 ,type : \"STRING\" }  }\n\nIDL > check_struct_schema, schema, s, err_status, desc = \"Example structure\" Calculates Tait-Bryan z-y'-x\" active rotation matrix Arguments:\na: (alpha) rotation about z  [radians]\nb: (beta)  rotation about y' [radians]\ng: (gamma) rotation about x\" [radians] Return value:\nRotation Matrix Example Usage: IDL > rot_mat = tb_zyx(!DPI / 2 , 0.0 , !DPI / 3 ) Creates a tiled matrix out of an array or matrix Arguments:\narr: Array or Matrix of size (nx,ny) to be tiled\nncol: Number of columns in the tile\nnrow: Number of rows in the tile Return Value:\nTiled array of size (ncol nx,nrow ny) Example Usage: IDL > arr = indgen ( 2 , 2 )\nIDL > print , arr 0 1 2 3 IDL > tiled_arr = tile_array(arr, 2 , 2 )\nIDL > print , tiled_arr 0 1 0 1 2 3 2 3 0 1 0 1 2 3 2 3 Express rotated coordinate xyz in non-rotated uvw coordinates Arguments:\nalpha: Rotation about z  [rad]\nbeta: Rotation about y'  [rad]\ngamma: Rotation about x\" [rad]\nxyz: Point in rotated coordinate system Keyword Arguments:\norigin: Origin of rotated coordinate system in non-rotated (uvw) coordinates.\nDefaults to [0,0,0] Example Usage: IDL > uvw = xyz_to_uvw(!DPI / 2 , 0.0 ,!DPI / 3 ,xyz) Express non-rotated coordinate uvw in rotated xyz coordinates Arguments:\nalpha: Rotation about z  [rad]\nbeta: Rotation about y'  [rad]\ngamma: Rotation about x\" [rad]\nuvw: Point in non-rotated coordinate system Keyword Arguments:\norigin: Origin of rotated coordinate system in non-rotated (uvw) coordinates.\nDefaults to [0,0,0] Example Usage: IDL > xyz = uvw_to_xyz(!DPI / 2 , 0.0 ,!DPI / 3 ,uvw) Checks if ray intersect axis aligned bounding box (AABB) Input Arguments:\nrc: Center of AABB\ndr: length,width,height of AABB\nr0: starting point of ray\nd0: direction of ray Output Arguments:\nintersect: Intersection length of ray and AABB\nr_enter/r_exit: Enter/exit points respectively Example Usage: IDL > aabb_intersect, [ 0 , 0 , 0 ], [ 1 , 1 , 1 ], [ - 1 , 0 , 0 ], [ 1 , 0 , 0 ], intersect, r_enter,r_exit\nIDL > print , intersect 1.0 IDL > print , r_enter - 0.5 0.0 0.0 IDL > print , r_exit 0.5 0.0 0.0 Check if input structure is valid Input Arguments:\ninputs: input structure Output Arguments:\nerr_status: valid = 0, invalid = 1 Example Usage: IDL > check_inputs, inputs, err_status Check if grid structure is valid Input Arguments:\ngrid: Interpolation grid structure Output Arguments:\nerr_status: valid = 0, invalid = 1 Example Usage: IDL > check_grid, grid, err_status Check if beam structure is valid Input Arguments:\ninp: input structure\nnbi: nbi structure Output Arguments:\nerr_status: valid = 0, invalid = 1 Example Usage: IDL > check_beam, inputs, nbi, err_status Check if plasma structure is valid Input Arguments:\ninp: Input structure\ngrid: Interpolation grid structure\nplasma: Plasma parameters structure Output Arguments:\nerr_status: valid = 0, invalid = 1 Example Usage: IDL > check_plasma, inputs, grid, plasma, err_status Check if electromagnetic fields structure is valid Input Arguments:\ninp: Input structure\ngrid: Interpolation grid structure\nfields: Electromagnetic fields structure Output Arguments:\nerr_status: valid = 0, invalid = 1 Example Usage: IDL > check_fields, inputs, grid, fields, err_status Check if distribution structure is valid Input Arguments:\ninp: Input structure\ngrid: Interpolation grid structure\ndist: Fast-ion distribution structure Output Arguments:\nerr_status: valid = 0, invalid = 1 Example Usage: IDL > check_distribution, inputs, grid, dist , err_status Check if spectral geometry structure is valid Input Arguments:\ninp: input structure\nchords: spectral geometry structure Output Arguments:\nerr_status: valid = 0, invalid = 1 Example Usage: IDL > check_spec, inputs, chords, err_status Check if NPA geometry structure is valid Input Arguments:\ninp: input structure\nnpa: NPA geometry structure Output Arguments:\nerr_status: valid = 0, invalid = 1 Example Usage: IDL > check_npa, inputs, npa, err_status Write namelist file Input Arguments:\nfilename: Name of the namelist file\ninputs: Input structure Example Usage: IDL > write_namelist, filename, inputs Write geometry values to a HDF5 file Input Arguments:\nfilename: Name of the geometry file\nnbi: NBI geometry structure Keyword Arguments:\nspec: Spectral geometry structure\nnpa: NPA geometry structure Example Usage: IDL > write_geometry, filename, nbi, spec = spec, npa = npa Write MHD equilibrium values to a HDF5 file Input Arguments:\nfilename: Name of the equilibrium file\nplasma: Plasma structure\nfields: Electromagnetic fields structure Example Usage: IDL > write_equilibrium, filename, plasma, fields Write fast-ion distribution to a HDF5 file Input Arguments:\nfilename: Name of the distribution file\ndistri: Fast-ion distribution structure Example Usage: IDL > write_distribution, filename, distri Checks FIDASIM inputs and writes FIDASIM input HDF5 files Input Arguments:\ninputs: Inputs structure\ngrid: Interpolation grid structure\nnbi: Neutral beam geometry structure\nplasma: Plasma parameters structure\nequil: Electromagnetic fields structure\nfbm: Fast-ion distribution structure Keyword Arguments:\nspec: Spectral geometry structure\nnpa: NPA geometry structure Example Usage IDL > prefida, inputs, grid, nbi, plasma, equil, fbm, spec = spec, npa = npa Source Code FUNCTION colored , str , c = c , s = s ; + Create colored string ; + ; + Arguments : ; + str : String to be colored ; + ; + Keyword Arguments : ; + c : Foreground color code ; + s : Style code ; + ; + Return Value : ; + colored string ; + ; + Foreground Color Codes : ; + k = Black ; + r = Red ; + g = Green ; + y = Yellow ; + b = Blue ; + m = Magenta ; + c = Cyan ; + w = White [ default ] ; + ; + Style Format Codes ; + n = Normal [ default ] ; + b = Bright ; + d = Dim ; + i = Italics ; + u = Underline ; + r = Reverse ( switch foreground and background colors ) ; + h = Hidden ; + s = Strikethrough ; + ; + Example Usage : ; + ``` idl ; + IDL > blue_bright_hello = colored ( \"Hello\" , c= \"b\" , s= \"b\" ) ; + ``` ; + if not keyword_set ( c ) then c='w' ;; Foreground Color if not keyword_set ( s ) then s='n' ;; Style esc = string ( 27 b ) back = esc+ \"[0m\" style = { n : '0' , b : '1' , d : '2' , i : '3' , u : '4' , r : '7' , h : '8' , s : '9' } sTags = [ \"n\" , \"b\" , \"d\" , \"i\" , \"u\" , \"r\" , \"h\" , \"s\" ] fgColors = { k : '30' , r : '31' , g : '32' , y : '33' , $ b : '34' , m : '35' , c : '36' , w : '37' } fgTags = [ \"k\" , \"r\" , \"g\" , \"y\" , \"b\" , \"m\" , \"c\" , \"w\" ] sIndex = where ( s eq sTags ) fgIndex = where ( c eq fgTags ) if sIndex eq - 1 then sIndex = 0 if fgIndex eq - 1 then fgIndex = 7 return , esc+ \"[\" + style .( sIndex ) + \";\" + fgColors .( fgIndex ) + \"m\" + str + back END PRO success , str ; + Print a success message ; + ; + Arguments : ; + str : message ; + ; + Example Usage : ; + ``` idl ; + IDL > success , \"Yay!!!\" ; + ``` ; + print , colored ( 'SUCCESS: ' + str , c='g' ) END PRO warn , str ; + Print a warning message ; + ; + Arguments : ; + str : message ; + ; + Example Usage : ; + ``` idl ; + IDL > warn , \"This may be a problem\" ; + ``` ; + print , colored ( 'WARNING: ' + str , c='y' ) END PRO error , str ; + Print a error message ; + ; + Arguments : ; + str : message ; + ; + Example Usage : ; + ``` idl ; + IDL > error , \"=(\" ; + ``` ; + print , colored ( 'ERROR: ' + str , c='r' ) END PRO info , str ; + Print a informational message ; + ; + Arguments : ; + str : message ; + ; + Example Usage : ; + ``` idl ; + IDL > info , \"This is informative\" ; + ``` ; + print , colored ( 'INFO: ' + str , c='b' ) END PRO check_struct_schema , schema , s , err_status , desc = desc ; + Check structure ` s ` is formatted according to ` schema ` ; + ; + Input Arguments : ; + schema : structure schema ; + s : structure to check ; + ; + Output Arguments : ; + err_status: error status . good : 0 , bad : 1 ; + ; + Keyword Arguments : ; + desc : description of structure ` s ` ; + ; + Example usage : ; + ``` idl ; + IDL > s = { a : 0 , b :[ 1. d0 , 2. d0 ], c : \"example\" } ; + IDL > schema = { a :{ dims : 0 , type : \"INT\" }, $ ; + b :{ dims : 1 , type : \"DOUBLE\" }, $ ; + c :{ dims : 0 , type : \"STRING\" } } ; + ; + IDL > check_struct_schema , schema , s , err_status , desc= \"Example structure\" ; + ``` ; + if not keyword_set ( struct_name ) then desc = 'structure' err_status = 0 schema_tags = strlowcase ( TAG_NAMES ( schema )) tags = strlowcase ( TAG_NAMES ( s )) for i = 0 , n_elements ( tags ) - 1 do begin w = where ( tags [ i ] eq schema_tags , nw ) if nw eq 0 then begin info , 'Extra variable \"' + tags [ i ] +'\" found in ' + desc endif endfor for i = 0 , n_elements ( schema_tags ) - 1 do begin w = where ( schema_tags [ i ] eq tags , nw ) if nw eq 0 then begin error , '\"' + schema_tags [ i ] +'\" is missing from the ' + desc err_status = 1 endif else begin ;; Check dimensions ww = where (( size ( s .( w ), / dim ) eq schema .( i ). dims ) ne 1 , nww ) if nww ne 0 then begin error , '\"' + schema_tags [ i ] +'\" has the wrong dimensions. Expected (' + $ strjoin ( strcompress ( string ( schema .( i ). dims ), / remove_all ), ',' ) +')' print , 'size(' + schema_tags [ i ] +') = ' , size ( s .( w ), / dim ) err_status = 1 endif ;; Check type tname = size ( s .( w ), / tname ) if tname ne schema .( i ). type then begin error , '\"' + schema_tags [ i ] +'\" has the wrong type. Expected ' + schema .( i ). type print , 'type(' + schema_tags [ i ] +') = ' + tname err_status = 1 endif ;; Check for NaNs or Inf if tname ne 'STRING' and tname ne 'STRUCT' then begin ww = where ( finite ( s .( w )) eq 0 , nww ) endif else nww = 0 if nww ne 0 then begin error , 'NaN or Infinity detected in \"' + schema_tags [ i ] +'\"' err_status = 1 endif endelse endfor END FUNCTION tb_zyx , a , b , g ; + Calculates Tait - Bryan z - y'-x\" active rotation matrix ;+ ;+ Arguments: ;+     a: (alpha) rotation about z  [radians] ;+     b: (beta)  rotation about y' [ radians ] ; + g : ( gamma ) rotation about x \" [radians] ;+ ;+ Return value: ;+     Rotation Matrix ;+ ;+ Example Usage: ;+```idl ;+ IDL> rot_mat = tb_zyx(!DPI/2, 0.0, !DPI/3) ;+``` ;+ sa = sin(a) & ca = cos(a) sb = sin(b) & cb = cos(b) sg = sin(g) & cg = cos(g) R = dblarr(3,3) R[0,0] = ca*cb & R[1,0] = ca*sb*sg - cg*sa & R[2,0] = sa*sg + ca*cg*sb R[0,1] = cb*sa & R[1,1] = ca*cg + sa*sb*sg & R[2,1] = cg*sa*sb - ca*sg R[0,2] = -sb   & R[1,2] = cb*sg            & R[2,2] = cb*cg return, R END FUNCTION tile_array, arr, ncol, nrow ;+ Creates a tiled matrix out of an array or matrix ;+ ;+ Arguments: ;+     arr: Array or Matrix of size (nx,ny) to be tiled ;+     ncol: Number of columns in the tile ;+     nrow: Number of rows in the tile ;+ ;+ Return Value: ;+     Tiled array of size (ncol*nx,nrow*ny) ;+ ;+ Example Usage: ;+```idl ;+IDL> arr = indgen(2,2) ;+IDL> print, arr ;+    0  1 ;+    2  3 ;+IDL> tiled_arr = tile_array(arr, 2, 2) ;+IDL> print, tiled_arr ;+    0  1  0  1 ;+    2  3  2  3 ;+    0  1  0  1 ;+    2  3  2  3 ;+``` ;+ s = size(arr,/dim) if n_elements(s) eq 1 then s = [s,1] new_arr = make_array(s[0]*ncol,s[1]*nrow, type=size(arr,/type)) new_arr[0,0] = arr if nrow gt 1 then begin for i=1,nrow-1 do begin new_arr[0,i*s[1]] = arr endfor endif if ncol gt 1 then begin rarr = new_arr[0:s[0]-1,*] for j=1,ncol-1 do begin new_arr[(j*s[0]),0] = rarr endfor endif return, new_arr END FUNCTION xyz_to_uvw, alpha, beta, gamma, xyz, origin = origin ;+ Express rotated coordinate xyz in non-rotated uvw coordinates ;+ ;+ Arguments: ;+     alpha: Rotation about z  [rad] ;+     beta: Rotation about y'  [rad] ;+     gamma: Rotation about x\" [ rad ] ; + xyz : Point in rotated coordinate system ; + ; + Keyword Arguments : ; + origin : Origin of rotated coordinate system in non - rotated ( uvw ) coordinates . ; + Defaults to [ 0 , 0 , 0 ] ; + ; + Example Usage : ; + ``` idl ; + IDL > uvw = xyz_to_uvw (! DPI / 2 , 0.0 ,! DPI / 3 , xyz ) ; + ``` ; + if not keyword_set ( origin ) then origin = [ 0.0 , 0.0 , 0.0 ] s = size ( xyz , / dim ) if n_elements ( s ) ne 2 then s = [ s , 1 ] xyz = transpose ( xyz ) ; Column Vector R = tb_zyx ( alpha , beta , gamma ) uvw = R ##xyz return , tranpose ( uvw ) + tile_array ( origin , 1 , s [ 1 ]) END FUNCTION uvw_to_xyz , alpha , beta , gamma , uvw , origin = origin ; + Express non - rotated coordinate uvw in rotated xyz coordinates ; + ; + Arguments : ; + alpha : Rotation about z [ rad ] ; + beta : Rotation about y'  [rad] ;+     gamma: Rotation about x\" [rad] ;+     uvw: Point in non-rotated coordinate system ;+ ;+ Keyword Arguments: ;+     origin: Origin of rotated coordinate system in non-rotated (uvw) coordinates. ;+             Defaults to [0,0,0] ;+ ;+ Example Usage: ;+```idl ;+IDL> xyz = uvw_to_xyz(!DPI/2,0.0,!DPI/3,uvw) ;+``` ;+ if not keyword_set(origin) then origin=[0.0,0.0,0.0] s = size(uvw,/dim) if n_elements(s) ne 2 then s=[s,1] uvw_shifted = transpose(uvw - tile_array(origin,1,s[1])) R = transpose(tb_zyx(alpha,beta,gamma)) xyz = R##uvw_shifted return, transpose(xyz) END PRO aabb_intersect, rc, dr, r0, d0, intersect, r_enter, r_exit ;+ Checks if ray intersect axis aligned bounding box (AABB) ;+ ;+ Input Arguments: ;+     rc: Center of AABB ;+     dr: length,width,height of AABB ;+     r0: starting point of ray ;+     d0: direction of ray ;+ ;+ Output Arguments: ;+     intersect: Intersection length of ray and AABB ;+     r_enter/r_exit: Enter/exit points respectively ;+ ;+ Example Usage: ;+```idl ;+IDL> aabb_intersect, [0,0,0], [1,1,1], [-1,0,0], [1,0,0], intersect, r_enter,r_exit ;+IDL> print, intersect ;+    1.0 ;+IDL> print, r_enter ;+    -0.5  0.0  0.0 ;+IDL> print, r_exit ;+     0.5  0.0  0.0 ;+``` ;+ v0 = d0/sqrt(total(d0*d0)) ;; There are 6 sides to a cube/grid side_inter = dblarr(6) ;; Intersection points of ray with planes defined by grid ipnts = dblarr(3,6) ;; Find whether ray intersects each side for i=0L,5 do begin j = fix(floor(i/2)) ind = where([0,1,2] ne j) if abs(v0[j]) gt 0 then begin ;; Intersection point with plane ipnts[*,i] = r0 + v0*( ( (rc[j] + ( (i mod 2)-0.5)*dr[j] ) - r0[j])/v0[j] ) ;; Check if point on plane is within grid side if abs(ipnts[ind[0],i] - rc[ind[0]]) le 0.5*dr[ind[0]] and $ abs(ipnts[ind[1],i] - rc[ind[1]]) le 0.5*dr[ind[1]] then side_inter[i]=1 endif endfor intersect = 0.0 r_enter = r0 r_exit = r0 w = where(side_inter ne 0,nw) if nw ge 2 then begin ;;Find two unique intersection points nunique = 0 for i=0,nw-2 do begin if total(ipnts[*,w[0]] eq ipnts[*,w[i+1]]) ne 3 then begin w = [w[0],w[i+1]] nunique = 2 break end end if nunique eq 2 then begin vi = ipnts[*,w[1]]-ipnts[*,w[0]] vi = vi/sqrt(total(vi*vi)) dot_prod = total(v0*vi) if dot_prod gt 0.0 then begin r_enter = ipnts[*,w[0]] r_exit = ipnts[*,w[1]] endif else begin r_enter = ipnts[*,w[1]] r_exit = ipnts[*,w[0]] endelse ;; Calculate intersection length intersect = sqrt(total((r_exit-r_enter)&#94;2.0)) endif endif END PRO check_inputs, inputs, err_status ;+ Check if input structure is valid ;+ ;+ Input Arguments: ;+     inputs: input structure ;+ ;+ Output Arguments: ;+     err_status: valid = 0, invalid = 1 ;+ ;+ Example Usage: ;+```idl ;+IDL> check_inputs, inputs, err_status ;+``` ;+ info,' Checking simulation settings ... ' err_status = 0 zero_string = {dims:0,type:' STRING '} zero_int = {dims:0,type:' INT '} zero_long = {dims:0,type:' LONG '} zero_double = {dims:0,type:' DOUBLE '} three_double = {dims:[3],type:' DOUBLE '} schema = {comment:zero_string, $ shot:zero_int, time:zero_double, $ runid:zero_string, device:zero_string, $ install_dir:zero_string, tables_file:zero_string, result_dir:zero_string, $ nlambda:zero_int, lambdamin:zero_double, lambdamax:zero_double, $ nx:zero_int, ny:zero_int, nz:zero_int, $ alpha:zero_double, beta:zero_double, gamma:zero_double, $ origin:three_double, xmin:zero_double, xmax:zero_double, $ ymin:zero_double, ymax:zero_double, zmin:zero_double, zmax:zero_double, $ ab:zero_double, ai:zero_double, species_mix:three_double, $ pinj:zero_double, einj:zero_double, impurity_charge:zero_int, $ n_fida:zero_long, n_nbi:zero_long, n_dcx:zero_long, $ n_npa:zero_long, n_halo:zero_long, n_birth:zero_long, $ ne_wght:zero_int, np_wght:zero_int, nphi_wght:zero_int, $ emax_wght:zero_double, nlambda_wght:zero_int, $ lambdamin_wght:zero_double, lambdamax_wght:zero_double, $ calc_npa:zero_int, calc_fida:zero_int, calc_bes:zero_int, $ calc_brems:zero_int, calc_birth:zero_int, $ calc_fida_wght:zero_int, calc_npa_wght:zero_int, $ dump_dcx:zero_int, load_neutrals:zero_int, verbose:zero_int} check_struct_schema, schema, inputs, err_status, desc=\"simulation settings\" if err_status eq 1 then begin goto, GET_OUT endif if inputs.alpha gt 2*!DPI or $ inputs.beta gt 2*!DPI or $ inputs.gamma gt 2*!DPI then begin error,' Angles must be in radians' err_status = 1 endif if inputs.lambdamin ge inputs.lambdamax then begin error,' Invalid wavelength range . Expected lambdamin < lamdbdamax' err_status = 1 endif if inputs.lambdamin_wght ge inputs.lambdamax_wght then begin error,' Invalid wavelength range . Expected lambdamin_wght < lamdbdamax_wght' err_status = 1 endif if inputs.xmin ge inputs.xmax then begin error,' Invalid x range . Expected xmin < xmax' err_status = 1 endif if inputs.ymin ge inputs.ymax then begin error,' Invalid y range . Expected ymin < ymax' err_status = 1 endif if inputs.zmin ge inputs.zmax then begin error,' Invalid z range . Expected zmin < zmax' err_status = 1 endif if inputs.pinj le 0. or inputs.einj le 0.0 then begin error,' The selected source is not on' print,'einj = ',inputs.einj print,'pinj = ',inputs.pinj err_status = 1 endif if abs(total(inputs.species_mix) - 1.0) gt 1.d-3 then begin error,'species_mix does not sum to 1.0 ' print,' sum ( species_mix ) = ',total(inputs.species_mix) err_status = 1 endif if inputs.impurity_charge le 1 then begin error,' Invalid impurity charge . Expected impurity charge > 1 ' err_status = 1 endif ps = path_sep() input_file = inputs.result_dir+ps+inputs.runid+' _ inputs . dat' equilibrium_file = inputs.result_dir+ps+inputs.runid+' _ equilibrium . h5' geometry_file = inputs.result_dir+ps+inputs.runid+' _ geometry . h5' distribution_file = inputs.result_dir+ps+inputs.runid+' _ distribution . h5' neutrals_file = inputs.result_dir+ps+inputs.runid+' _ neutrals . h5' inputs = create_struct(inputs,'input_file',input_file, $ 'equilibrium_file',equilibrium_file,$ 'geometry_file',geometry_file, $ 'distribution_file',distribution_file, $ 'neutrals_file',neutrals_file) GET_OUT: if err_status ne 0 then begin error,' Invalid simulation settings . Exiting ... ' endif else begin success,' Simulation settings are valid' endelse END PRO check_grid, grid, err_status ;+ Check if grid structure is valid ;+ ;+ Input Arguments: ;+     grid: Interpolation grid structure ;+ ;+ Output Arguments: ;+     err_status: valid = 0, invalid = 1 ;+ ;+ Example Usage: ;+```idl ;+IDL> check_grid, grid, err_status ;+``` ;+ err_status = 0 info,' Checking interpolation grid ... ' w = where(\"nr\" eq strlowcase(TAG_NAMES(grid)),nw) if nw eq 0 then begin error,' \"nr\" is missing from the interpolation grid' err_status = 1 goto, GET_OUT endif w = where(\"nz\" eq strlowcase(TAG_NAMES(grid)),nw) if nw eq 0 then begin error,' \"nz\" is missing from the interpolation grid' err_status = 1 goto, GET_OUT endif nr = grid.nr nz = grid.nz zero_int = {dims:0,type:' INT '} schema = {nr:zero_int, nz:zero_int, $ r2d:{dims:[nr,nz], type:' DOUBLE '}, $ z2d:{dims:[nr,nz], type:' DOUBLE '}, $ r:{dims:[nr], type:' DOUBLE '}, $ z:{dims:[nz], type:' DOUBLE '} } check_struct_schema, schema, grid, err_status, desc=\"interpolation grid\" if err_status eq 1 then begin goto, GET_OUT endif w = where((indgen(nr) eq sort(grid.r)) ne 1, nw) if nw ne 0 then begin error,'r is not in ascending order' err_status = 1 endif w = where((indgen(nz) eq sort(grid.z)) ne 1, nw) if nw ne 0 then begin error,'z is not in ascending order' err_status = 1 endif w = where((grid.r eq grid.r2d[*,0]) ne 1, nw) if nw ne 0 then begin error,'r2d is defined incorrectly . Expected r == r2d [ * , 0 ] ' err_status = 1 endif w = where((grid.z eq grid.z2d[0,*]) ne 1, nw) if nw ne 0 then begin error,'z2d is defined incorrectly . Expected z == z2d [ 0 , * ] ' err_status = 1 endif GET_OUT: if err_status ne 0 then begin error,' Invalid interpolation grid . Exiting ... ' endif else begin success,' Interpolation grid is valid' endelse END PRO check_beam, inp, nbi, err_status ;+ Check if beam structure is valid ;+ ;+ Input Arguments: ;+     inp: input structure ;+     nbi: nbi structure ;+ ;+ Output Arguments: ;+     err_status: valid = 0, invalid = 1 ;+ ;+ Example Usage: ;+```idl ;+IDL> check_beam, inputs, nbi, err_status ;+``` ;+ err_status = 0 info,' Checking beam geometry ... ' zero_string = {dims:0, type:' STRING '} zero_int = {dims:0, type:' INT '} zero_double = {dims:0, type:' DOUBLE '} three_double = {dims:[3], type:' DOUBLE '} schema = {data_source:zero_string, $ name:zero_string, $ src:three_double,  axis:three_double, $ divy:three_double, divz:three_double, $ focy:zero_double,  focz:zero_double, $ widz:zero_double,  widy:zero_double, $ shape:zero_int } check_struct_schema,schema,nbi,err_status, desc=\"beam geometry\" if err_status eq 1 then begin goto, GET_OUT endif if abs(total(nbi.axis&#94;2.0) - 1.0) gt 1d-5 then begin error,' Invalid source axis . Expected norm ( axis ) == 1 ' err_status = 1 endif if nbi.focz le 0.0 then begin error,'focz cannot be in the range ( - Inf , 0.0 ] ' err_status = 1 endif if nbi.focy le 0.0 then begin error,'focy cannot be in the range ( - Inf , 0.0 ] ' err_status = 1 endif if nbi.shape gt 2 then begin error,' Invalid source shape . Expected 1 ( rectagular ) or 2 ( circular ) ' err_status = 1 endif if nbi.widz lt 0 then begin error,' Invalid widz . Expected widz > 0 ' err_status = 1 endif if nbi.widy lt 0 then begin error,' Invalid widy . Expected widy > 0 ' err_status = 1 endif origin = inp.origin uvw_src = nbi.src uvw_axis = nbi.axis uvw_pos = uvw_src + 200*uvw_axis xyz_src = uvw_to_xyz(inp.alpha,inp.beta,inp.gamma,uvw_src, origin=origin) xyz_axis = uvw_to_xyz(inp.alpha,inp.beta,inp.gamma,uvw_axis) xyz_pos = uvw_to_xyz(inp.alpha,inp.beta,inp.gamma,uvw_pos, origin=origin) xyz_center = uvw_to_xyz(inp.alpha,inp.beta,inp.gamma,origin, origin=origin) dis = sqrt(total((xyz_src - xyz_pos)&#94;2.0)) BETA=double(asin((xyz_src[2]-xyz_pos[2])/dis)) ALPHA=double(atan((xyz_pos[1]-xyz_src[1]),(xyz_pos[0]-xyz_src[0]))) print,' Beam injection start point in machine coordinates' print, f=' ( \"    [\" , F9 .3 , \",\" , F9 .3 , \",\" , F9 .3 , \"]\" ) ', uvw_src print,' Point 2 m along beam centerline in machine coordinates' print, f=' ( \"    [\" , F9 .3 , \",\" , F9 .3 , \",\" , F9 .3 , \"]\" ) ', uvw_pos print,' Machine center in beam grid coordinates' print, f=' ( \"    [\" , F9 .3 , \",\" , F9 .3 , \",\" , F9 .3 , \"]\" ) ', xyz_center print,' Beam injection start point in beam grid coordinates' print, f=' ( \"    [\" , F9 .3 , \",\" , F9 .3 , \",\" , F9 .3 , \"]\" ) ', xyz_src print,' Point 2 m along beam centerline in beam grid coordinates' print, f=' ( \"    [\" , F9 .3 , \",\" , F9 .3 , \",\" , F9 .3 , \"]\" ) ', xyz_pos print,' Beam grid rotation angles that would align it with the beam centerline' print, ALPHA/!DPI*180,FORMAT=' ( \"    alpha = \" , F14 .10 , \"°\" ) ' print, BETA/!DPI*180,FORMAT=' ( \"    beta = \" , F14 .10 , \"°\" ) ' ;; Calculate grid center rc and sides length dr dr = [inp.xmax-inp.xmin,inp.ymax-inp.ymin,inp.zmax-inp.zmin] rc = [inp.xmin,inp.ymin,inp.zmin] + 0.5*dr ;; Check if beam centerline intersects beam grid aabb_intersect,rc,dr,xyz_src,xyz_axis,length,r_enter,r_exit print,' Beam centerline - grid intersection length' print,f=' ( \"    length = \" , F8 .3 ) ',length if length le 10.0 then begin error,' Beam centerline does not intersect grid' err_status = 1 endif GET_OUT: if err_status ne 0 then begin error,' Invalid beam geometry . Exiting ... ' endif else begin success,' Beam geometry is valid' endelse END PRO check_plasma, inp, grid, plasma, err_status ;+ Check if plasma structure is valid ;+ ;+ Input Arguments: ;+     inp: Input structure ;+     grid: Interpolation grid structure ;+     plasma: Plasma parameters structure ;+ ;+ Output Arguments: ;+     err_status: valid = 0, invalid = 1 ;+ ;+ Example Usage: ;+```idl ;+IDL> check_plasma, inputs, grid, plasma, err_status ;+``` ;+ err_status=0 info,' Checking plasma parameters ... ' nr = grid.nr nz = grid.nz zero_string = {dims:0, type:' STRING '} zero_double = {dims:0, type:' DOUBLE '} nrnz_double = {dims:[nr,nz], type:' DOUBLE '} nrnz_int    = {dims:[nr,nz], type:' INT '} schema = {time:zero_double, $ vr:nrnz_double, $ vt:nrnz_double, $ vz:nrnz_double, $ dene:nrnz_double, $ ti:nrnz_double, $ te:nrnz_double, $ zeff:nrnz_double, $ mask:nrnz_int, $ data_source:zero_string} check_struct_schema,schema,plasma,err_status,desc = \"plasma parameters\" if err_status eq 1 then begin goto, GET_OUT endif if plasma.data_source eq '' then begin error, ' Invalid data source . An empty string is not a data source . ' err_status = 1 endif ;;Electron density plasma.dene = plasma.dene > 0. ;[1/cm&#94;3] ;;Zeff plasma.zeff = plasma.zeff > 1.0 ;;Electron temperature plasma.te = plasma.te > 0. ;[keV] ;;Ion temperature plasma.ti = plasma.ti > 0. ;[keV] if abs(plasma.time - inp.time) gt 0.02 then begin warn,' Plasma time and input time do not match' print,' Input time : ',inp.time print,' Plasma time : ',plasma.time endif plasma = create_struct(plasma, grid) GET_OUT: if err_status ne 0 then begin error,' Invalid plasma parameters . Exiting ... ' endif else begin success,' Plasma parameters are valid' endelse END PRO check_fields, inp, grid, fields, err_status ;+ Check if electromagnetic fields structure is valid ;+ ;+ Input Arguments: ;+     inp: Input structure ;+     grid: Interpolation grid structure ;+     fields: Electromagnetic fields structure ;+ ;+ Output Arguments: ;+     err_status: valid = 0, invalid = 1 ;+ ;+ Example Usage: ;+```idl ;+IDL> check_fields, inputs, grid, fields, err_status ;+``` ;+ err_status=0 info,' Checking magnetic equilibrium ... ' nr = grid.nr nz = grid.nz zero_string = {dims:0, type:' STRING '} zero_double = {dims:0, type:' DOUBLE '} nrnz_double = {dims:[nr,nz], type:' DOUBLE '} nrnz_int = {dims:[nr,nz], type:' INT '} schema = {time:zero_double, $ br:nrnz_double, $ bt:nrnz_double, $ bz:nrnz_double, $ er:nrnz_double, $ et:nrnz_double, $ ez:nrnz_double, $ mask:nrnz_int, $ data_source:zero_string} check_struct_schema,schema,fields,err_status, desc = \"electromagnetic fields\" if err_status eq 1 then begin goto, GET_OUT endif if fields.data_source eq '' then begin error, ' Invalid data source . An empty string is not a data source . ' err_status = 1 endif if abs(fields.time - inp.time) gt 0.02 then begin warn,' Electromagnetic fields time and input time do not match' print,' Input time : ',inp.time print,' Electromagnetic fields time : ',fields.time endif fields = create_struct(fields, grid) GET_OUT: if err_status ne 0 then begin error,' Invalid electromagnetic fields . Exiting ... ' endif else begin success,' Electromagnetic fields are valid' endelse END PRO check_dist, inp, grid, dist, err_status ;+ Check if distribution structure is valid ;+ ;+ Input Arguments: ;+     inp: Input structure ;+     grid: Interpolation grid structure ;+     dist: Fast-ion distribution structure ;+ ;+ Output Arguments: ;+     err_status: valid = 0, invalid = 1 ;+ ;+ Example Usage: ;+```idl ;+IDL> check_distribution, inputs, grid, dist, err_status ;+``` ;+ err_status = 0 info,' Checking fast - ion distribution' w = where(\"type\" eq strlowcase(TAG_names(dist)),nw) if nw eq 0 then begin error,' \"type\" is missing from the fast - ion distribution' err_status = 1 goto, GET_OUT endif dist_type = dist.type CASE dist_type OF 1: BEGIN print, ' Using a Guiding Center Fast - ion Density Function ' w = where(\"nenergy\" eq strlowcase(TAG_names(dist)),nw) if nw eq 0 then begin error,' \"nenergy\" is missing from the fast - ion distribution' err_status = 1 goto, GET_OUT endif w = where(\"npitch\" eq strlowcase(TAG_names(dist)),nw) if nw eq 0 then begin error,' \"npitch\" is missing from the fast - ion distribution' err_status = 1 goto, GET_OUT endif np =  dist.npitch nen = dist.nenergy nr = grid.nr nz = grid.nz zero_string = {dims:0, type:' STRING '} zero_int = {dims:0, type:' INT '} zero_double = {dims:0, type:' DOUBLE '} nrnz_double = {dims:[nr,nz], type:' DOUBLE '} schema = {type:zero_int, $ nenergy:zero_int, $ npitch:zero_int, $ energy:{dims:[nen], type:' DOUBLE '},$ pitch:{dims:[np], type:' DOUBLE '}, $ denf:nrnz_double, $ f:{dims:[nen,np,nr,nz], type:' DOUBLE '}, $ time:zero_double, $ data_source:zero_string} check_struct_schema,schema,dist,err_status, desc=\"fast-ion distribution\" if err_status eq 1 then begin goto, GET_OUT endif dist = create_struct(dist, grid) END 2: BEGIN print, ' Using Guiding Center Monte Carlo fast - ion distribution' w = where(\"nparticle\" eq strlowcase(TAG_names(dist)),nw) if nw eq 0 then begin error,' \"nparticle\" is missing from the fast - ion distribution' err_status = 1 goto, GET_OUT endif npart = dist.nparticle zero_int = {dims:0, type:' INT '} zero_long = {dims:0, type:' LONG '} zero_string = {dims:0, type:' STRING '} zero_double = {dims:0, type:' DOUBLE '} npart_double = {dims:[npart], type:' DOUBLE '} npart_int = {dims:[npart], type:' INT '} schema = {type:zero_int, $ nparticle:zero_long, $ nclass:zero_int, $ time:zero_double, $ energy:npart_double, $ pitch:npart_double, $ r:npart_double, $ z:npart_double, $ weight:npart_double, $ class:npart_int,$ data_source:zero_string} check_struct_schema,schema,dist,err_status, desc=\"fast-ion distribution\" if err_status eq 1 then begin goto, GET_OUT endif print,' Number of MC particles : ',npart END 3: BEGIN print, ' Using Full Orbit Monte Carlo fast - ion distribution' w = where(\"nparticle\" eq strlowcase(TAG_names(dist)),nw) if nw eq 0 then begin error,' \"nparticle\" is missing from the fast - ion distribution' err_status = 1 goto, GET_OUT endif npart = dist.nparticle zero_int = {dims:0, type:' INT '} zero_long = {dims:0, type:' LONG '} zero_string = {dims:0, type:' STRING '} zero_double = {dims:0, type:' DOUBLE '} npart_double = {dims:[npart], type:' DOUBLE '} npart_int = {dims:[npart], type:' INT '} schema = {type:zero_int, $ nparticle:zero_long, $ nclass:zero_int, $ time:zero_double, $ vr:npart_double, $ vt:npart_double, $ vz:npart_double, $ r:npart_double, $ z:npart_double, $ weight:npart_double, $ class:npart_int, $ data_source:zero_string} check_struct_schema,schema,dist,err_status, desc=\"fast-ion distribution\" if err_status eq 1 then begin goto, GET_OUT endif print,' Number of MC particles : ',npart END ELSE: BEGIN error,' Invalid distribution type . Expected '+ $ ' 1 ( Guiding Center Density Function ), '+ $ ' 2 ( Guiding Center Monte Carlo ), or '+ $ ' 3 ( Full Orbit Monte Carlo ) ' err_status = 1 goto, GET_OUT END ENDCASE if dist.data_source eq '' then begin error, ' Invalid data source . An empty string is not a data source . ' err_status = 1 endif if abs(dist.time - inp.time) gt 0.02 then begin warn,' Distribution time and input time do not match' print,' Input time : ',inp.time print,' Distribution time : ',dist.time endif GET_OUT: if err_status ne 0 then begin error,' Invalid fast - ion distribution . Exiting ... ' endif else begin success,' Fast - ion distribution is valid' endelse END PRO check_spec, inp, chords, err_status ;+ Check if spectral geometry structure is valid ;+ ;+ Input Arguments: ;+     inp: input structure ;+     chords: spectral geometry structure ;+ ;+ Output Arguments: ;+     err_status: valid = 0, invalid = 1 ;+ ;+ Example Usage: ;+```idl ;+IDL> check_spec, inputs, chords, err_status ;+``` ;+ err_status = 0 info,' Checking FIDA / BES inputs ... ' w = where(\"nchan\" eq strlowcase(TAG_NAMES(chords)),nw) if nw eq 0 then begin error,' \"nchan\" is missing from the FIDA / BES geometry' err_status = 1 goto, GET_OUT endif w = where(\"system\" eq strlowcase(TAG_NAMES(chords)),nw) if nw eq 0 then begin error,' \"system\" is missing from the FIDA / BES geometry' err_status = 1 goto, GET_OUT endif nchan = chords.nchan nsys = size(chords.system,/dim) zero_string = {dims:0, type:' STRING '} zero_int = {dims:0, type:' INT '} nchan_double = {dims:[nchan], type:' DOUBLE '} schema = {data_source:zero_string, $ nchan:zero_int, $ system:{dims:nsys,type:' STRING '}, $ lens:{dims:[3,nchan], type:' DOUBLE '}, $ axis:{dims:[3,nchan], type:' DOUBLE '}, $ sigma_pi:nchan_double, $ spot_size:nchan_double, $ radius:nchan_double} check_struct_schema,schema,chords,err_status, desc=\"FIDA/BES geometry\" if err_status eq 1 then begin goto, GET_OUT endif err_arr=intarr(nchan) cross_arr=intarr(nchan) uvw_lens = chords.lens uvw_axis = chords.axis ;;ROTATE CHORDS INTO BEAM GRID COORDINATES xyz_lens = uvw_to_xyz(inp.alpha,inp.beta,inp.gamma,uvw_lens,origin=inp.origin) xyz_axis = uvw_to_xyz(inp.alpha,inp.beta,inp.gamma,uvw_axis) ;; Calculate grid center rc and sides length dr dr = [inp.xmax-inp.xmin,inp.ymax-inp.ymin,inp.zmax-inp.zmin] rc = [inp.xmin,inp.ymin,inp.zmin] + 0.5*dr for i=0,nchan-1 do begin chan_str = strcompress(string(i),/remove_all) if abs(total(uvw_axis[*,i]&#94;2.0) - 1.0) gt 1d-5 then begin error,' Invalid optical axis at index '+chan_str+' . Expected norm ( axis ) == 1 ' print, total(uvw_axis[*,i]&#94;2.0) - 1.0 err_arr[i] = 1 endif ;; Check if viewing chord intersects beam grid aabb_intersect,rc,dr,xyz_lens[*,i],xyz_axis[*,i],length,r_enter,r_exit if length le 0.0 then begin warn,' Chord at index '+chan_str+' does not cross the beam grid' cross_arr[i] = 1 endif endfor w = where(cross_arr eq 0.0,nw,complement=ww,ncomplement=nww) print,f=' ( i3 , \" out of \" , i3 , \" chords crossed the beam grid\" ) ',nw,nchan if nw eq 0 then begin error,' No channels intersect the beam grid' err_status = 1 endif GET_OUT: if err_status ne 0 then begin error,' Invalid FIDA / BES geometry . Exiting ... ' endif else begin success,' FIDA / BES geometry is valid' endelse END PRO check_npa, inp, npa, err_status ;+ Check if NPA geometry structure is valid ;+ ;+ Input Arguments: ;+     inp: input structure ;+     npa: NPA geometry structure ;+ ;+ Output Arguments: ;+     err_status: valid = 0, invalid = 1 ;+ ;+ Example Usage: ;+```idl ;+IDL> check_npa, inputs, npa, err_status ;+``` ;+ err_status=0 info,' Checking NPA geometry ... ' w = where(\"nchan\" eq strlowcase(TAG_NAMES(npa)),nw) if nw eq 0 then begin error,' \"nchan\" is missing from the NPA geometry' err_status = 1 goto, GET_OUT endif w = where(\"system\" eq strlowcase(TAG_NAMES(npa)),nw) if nw eq 0 then begin error,' \"system\" is missing from the NPA geometry' err_status = 1 goto, GET_OUT endif nsys = size(npa.system,/dim) nchan = npa.nchan zero_string = {dims:0, type:' STRING '} zero_int = {dims:0, type:' INT '} schema = {data_source:zero_string, $ nchan:zero_int, $ system:{dims:nsys, type:' STRING '}, $ a_shape:{dims:[nchan], type:' INT '},$ d_shape:{dims:[nchan], type:' INT '}, $ a_tedge:{dims:[3,nchan], type:' DOUBLE '}, $ a_redge:{dims:[3,nchan], type:' DOUBLE '}, $ a_cent:{dims:[3,nchan], type:' DOUBLE '}, $ d_tedge:{dims:[3,nchan], type:' DOUBLE '}, $ d_redge:{dims:[3,nchan], type:' DOUBLE '}, $ d_cent:{dims:[3,nchan], type:' DOUBLE '}, $ radius:{dims:[nchan], type:' DOUBLE '} } check_struct_schema,schema,npa,err_status, desc=\"NPA geometry\" if err_status eq 1 then begin goto, GET_OUT endif ;; Check detector/aperture shape w = where(npa.d_shape gt 2,nw) if nw ne 0 then begin error,' Invalid detector shape . Expected 1 ( rectagular ) or 2 ( circular ) ' print,' Invalid indices : ', w err_status = 1 endif w = where(npa.a_shape gt 2,nw) if nw ne 0 then begin error,' Invalid aperture shape . Expected 1 ( rectagular ) or 2 ( circular ) ' print,' Invalid indices : ', w err_status = 1 endif ;; Calculate grid center rc and sides length dr dr = [inp.xmax-inp.xmin,inp.ymax-inp.ymin,inp.zmax-inp.zmin] rc = [inp.xmin,inp.ymin,inp.zmin] + 0.5*dr err_arr = dblarr(nchan) for i=0, nchan-1 do begin uvw_det = npa.d_cent[*,i] d_e1 = npa.d_redge[*,i] - uvw_det d_e2 = npa.d_tedge[*,i] - uvw_det uvw_aper = npa.a_cent[*,i] a_e1 = npa.a_redge[*,i] - uvw_aper a_e2 = npa.a_tedge[*,i] - uvw_aper ;;Rotate chords into beam grid coordinates xyz_aper = uvw_to_xyz(inp.alpha,inp.beta,inp.gamma,uvw_aper,origin=inp.origin) xyz_det  = uvw_to_xyz(inp.alpha,inp.beta,inp.gamma,uvw_det,origin=inp.origin) xyz_dir = xyz_aper - xyz_det xyz_dir = xyz_dir/sqrt(total(xyz_dir*xyz_dir)) ;; Check if npa chord intersects beam grid aabb_intersect,rc,dr,xyz_det,xyz_dir,length,r_enter,r_exit if length le 0.0 then begin err_arr[i] = 1 endif ;; Check that the detector and aperture point in the same direction d_e3 = crossp(d_e1,d_e2) a_e3 = crossp(a_e1,a_e2) dp = total(d_e3*a_e3) if dp le 0.0 then begin warn,' The dot product of the detector and aperture plane normal vectors is negative . The NPA definition may be incorrect . ' endif endfor w = where(err_arr eq 0.0,nw,complement=ww,ncomplement=nww) print,f=' ( i3 , \" out of \" , i3 , \" channels crossed the beam grid\" ) ',nw,nchan if nw eq 0 then begin error,' No channels intersect the beam grid' err_status = 1 endif if nww gt 0 then begin warn,' Some channels did not intersect the beam grid' print,' Number missed : ',nww print,' Missed indices : ' print,' ',ww endif GET_OUT: if err_status ne 0 then begin error,' Invalid NPA geometry . Exiting ... ' endif else begin success,' NPA geometry is valid' endelse END PRO write_namelist, filename, inputs ;+ Write namelist file ;+ ;+ Input Arguments: ;+     filename: Name of the namelist file ;+     inputs: Input structure ;+ ;+ Example Usage: ;+```idl ;+IDL> write_namelist, filename, inputs ;+``` ;+ info,' Writing namelist file ... ' spawn,'which git',git_command git_hash = '' if git_command ne '' then begin spawn,git_command+' --git - dir='+inputs.install_dir+' . git rev - parse HEAD ',git_hash,err_status endif fidasim_version = ' 1.0.0 ' openw,55,filename printf,55,' !! Created : ', systime() if git_hash ne '' then begin printf,55,' !! FIDASIM git commit : ',git_hash endif printf,55,' !! Comment : '+inputs.comment printf,55,'&fidasim_inputs' printf,55,'' printf,55,' !! FIDASIM version' printf,55,\"version = ' \"+fidasim_version+\" '    !! FIDASIM version number\" printf,55,'' printf,55,' !! Shot Info ' printf,55,f=' ( \"shot = \" , i6 , \"    !! Shot Number\" ) ',inputs.shot printf,55,f=' ( \"time = \" , 1 f8 .5 , \"    !! Time [s]\" ) ',inputs.time printf,55,\"runid = ' \" + inputs.runid + \" '    !! runID\" printf,55,\"result_dir = ' \" + inputs.result_dir+\" '    !! Result Directory\" printf,55,'' printf,55,' !! Input Files ' printf,55,\"tables_file = ' \" + inputs.tables_file+\" '    !! Atomic Tables File\" printf,55,\"equilibrium_file = ' \" + inputs.equilibrium_file +\" '    !! File containing plasma parameters and fields\" printf,55,\"geometry_file = ' \" + inputs.geometry_file +\" '    !! File containing NBI and diagnostic geometry\" printf,55,\"distribution_file = ' \" + inputs.distribution_file +\" '    !! File containing fast-ion distribution\" printf,55,\"neutrals_file = ' \" + inputs.neutrals_file +\" '    !! File containing the neutral density\" printf,55,'' printf,55,' !! Simulation Switches ' printf,55,f=' ( \"calc_bes = \" , i2 , \"    !! Calculate Beam Emission Spectra\" ) ',inputs.calc_bes printf,55,f=' ( \"calc_brems = \" , i2 , \"    !! Calculate Bremsstrahlung\" ) ',inputs.calc_brems printf,55,f=' ( \"calc_fida = \" , i2 , \"    !! Calculate FIDA Spectra\" ) ',inputs.calc_fida printf,55,f=' ( \"calc_npa = \" , i2 , \"   !! Calculate NPA\" ) ',inputs.calc_npa printf,55,f=' ( \"calc_birth = \" , i2 , \"    !! Calculate Birth Profile\" ) ',inputs.calc_birth printf,55,f=' ( \"calc_fida_wght = \" , i2 , \"    !! Calculate FIDA weights\" ) ',inputs.calc_fida_wght printf,55,f=' ( \"calc_npa_wght = \" , i2 , \"    !! Calculate NPA weights\" ) ',inputs.calc_npa_wght printf,55,f=' ( \"load_neutrals = \" , i2 , \"    !! Load neutrals from neutrals file\" ) ',inputs.load_neutrals printf,55,f=' ( \"dump_dcx = \" , i2 , \"    !! Dump DCX neutrals and spectra\" ) ',inputs.dump_dcx printf,55,f=' ( \"verbose = \" , i2 , \"    !! Verbose\" ) ',inputs.verbose printf,55,'' printf,55,' !! Monte Carlo Settings ' printf,55,f=' ( \"n_fida = \" , i9 , \"    !! Number of FIDA mc particles\" ) ',inputs.n_fida printf,55,f=' ( \"n_npa = \" , i9 , \"    !! Number of NPA mc particles\" ) ',inputs.n_npa printf,55,f=' ( \"n_nbi = \" , i9 , \"    !! Number of NBI mc particles\" ) ',inputs.n_nbi printf,55,f=' ( \"n_halo = \" , i9 , \"    !! Number of HALO mc particles\" ) ',inputs.n_halo printf,55,f=' ( \"n_dcx = \" , i9 , \"     !! Number of DCX mc particles\" ) ',inputs.n_dcx printf,55,f=' ( \"n_birth = \" , i9 , \"    !! Number of BIRTH mc particles\" ) ',inputs.n_birth printf,55,'' printf,55,' !! Neutral Beam Settings ' printf,55,f=' ( \"ab = \" , 1 f9 .5 , \"     !! Beam Species mass [amu]\" ) ',inputs.ab printf,55,f=' ( \"pinj = \" , 1 f9 .3 , \"     !! Beam Power [MW]\" ) ',inputs.pinj printf,55,f=' ( \"einj = \" , 1 f9 .3 , \"     !! Beam Energy [keV]\" ) ',inputs.einj printf,55,f=' ( \"species_mix(1) = \" , 1 f9 .5 , \"     !! Beam Species Mix (Full component)\" ) ',inputs.species_mix[0] printf,55,f=' ( \"species_mix(2) = \" , 1 f9 .5 , \"     !! Beam Species Mix (Half component)\" ) ',inputs.species_mix[1] printf,55,f=' ( \"species_mix(3) = \" , 1 f9 .5 , \"     !! Beam Species Mix (Third component)\" ) ',inputs.species_mix[2] printf,55,'' printf,55,' !! Plasma Settings ' printf,55,f=' ( \"ai = \" , 1 f9 .5 , \"     !! Ion Species mass [amu]\" ) ',inputs.ai printf,55,f=' ( \"impurity_charge = \" , i3 , \"     !! Impurity Charge\" ) ',inputs.impurity_charge printf,55,'' printf,55,' !! Beam Grid Settings ' printf,55,f=' ( \"nx = \" , i4 , \"    !! Number of cells in X direction (Into Plasma)\" ) ',inputs.nx printf,55,f=' ( \"ny = \" , i4 , \"    !! Number of cells in Y direction\" ) ',inputs.ny printf,55,f=' ( \"nz = \" , i4 , \"    !! Number of cells in Z direction\" ) ',inputs.nz printf,55,f=' ( \"xmin = \" , 1 f9 .3 , \"     !! Minimum X value [cm]\" ) ',inputs.xmin printf,55,f=' ( \"xmax = \" , 1 f9 .3 , \"     !! Maximum X value [cm]\" ) ',inputs.xmax printf,55,f=' ( \"ymin = \" , 1 f9 .3 , \"     !! Minimum Y value [cm]\" ) ',inputs.ymin printf,55,f=' ( \"ymax = \" , 1 f9 .3 , \"     !! Maximum Y value [cm]\" ) ',inputs.ymax printf,55,f=' ( \"zmin = \" , 1 f9 .3 , \"     !! Minimum Z value [cm]\" ) ',inputs.zmin printf,55,f=' ( \"zmax = \" , 1 f9 .3 , \"     !! Maximum Z value [cm]\" ) ',inputs.zmax printf,55,' !! Tait - Bryan Angles for z - y ` - x `` rotation' printf,55,f=' ( \"alpha = \" , 1 f9 .5 , \"     !! Rotation about z-axis [rad]\" ) ',inputs.alpha printf,55,f=' ( \"beta  = \" , 1 f9 .5 , \"     !! Rotation about y`-axis [rad]\" ) ',inputs.beta printf,55,f=' ( \"gamma = \" , 1 f9 .5 , \"     !! Rotation about x``-axis [rad]\" ) ',inputs.gamma printf,55,' !! Beam Grid origin in machine coordinates ( cartesian ) ' printf,55,f=' ( \"origin(1) = \" , 1 f9 .3 , \"     !! U value [cm]\" ) ',inputs.origin[0] printf,55,f=' ( \"origin(2) = \" , 1 f9 .3 , \"     !! V value [cm]\" ) ',inputs.origin[1] printf,55,f=' ( \"origin(3) = \" , 1 f9 .3 , \"     !! W value [cm]\" ) ',inputs.origin[2] printf,55,'' printf,55,' !! Wavelength Grid Settings ' printf,55,f=' ( \"nlambda = \" , 1 i5 , \"    !! Number of Wavelengths\" ) ',inputs.nlambda printf,55,f=' ( \"lambdamin = \" , 1 f9 .3 , \"    !! Minimum Wavelength [nm]\" ) ',inputs.lambdamin printf,55,f=' ( \"lambdamax = \" , 1 f9 .3 , \"    !! Maximum Wavelength [nm]\" ) ',inputs.lambdamax printf,55,'' printf,55,' !! Weight Function Settings ' printf,55,f=' ( \"ne_wght = \" , i9 , \"    !! Number of Energies for Weights\" ) ',inputs.ne_wght printf,55,f=' ( \"np_wght = \" , i9 , \"    !! Number of Pitches for Weights\" ) ',inputs.np_wght printf,55,f=' ( \"nphi_wght = \" , i9 , \"    !! Number of Gyro-angles for Weights\" ) ',inputs.nphi_wght printf,55,f=' ( \"emax_wght = \" , 1 f9 .2 , \"    !! Maximum Energy for Weights [keV]\" ) ',inputs.emax_wght printf,55,f=' ( \"nlambda_wght = \" , 1 i5 , \"    !! Number of Wavelengths for Weights \" ) ',$ inputs.nlambda_wght printf,55,f=' ( \"lambdamin_wght = \" , 1 f9 .3 , \"    !! Minimum Wavelength for Weights [nm]\" ) ',$ inputs.lambdamin_wght printf,55,f=' ( \"lambdamax_wght = \" , 1 f9 .3 , \"    !! Maximum Wavelength for Weights [nm]\" ) ',$ inputs.lambdamax_wght printf,55,'' printf,55,'/' printf,55,'' close,55 success,' Namelist file created : '+filename END PRO write_geometry, filename, nbi, spec=spec, npa=npa ;+ Write geometry values to a HDF5 file ;+ ;+ Input Arguments: ;+     filename: Name of the geometry file ;+     nbi: NBI geometry structure ;+ ;+ Keyword Arguments: ;+     spec: Spectral geometry structure ;+     npa: NPA geometry structure ;+ ;+ Example Usage: ;+```idl ;+IDL> write_geometry, filename, nbi, spec=spec, npa=npa ;+``` ;+ info,' Writing geometry file ... ' ;; Create attributes root_atts = {attribute,obj:'/', $ name:'description',$ data:' Geometric quantities for FIDASIM '} ;; NBI attributes nbi_desc = {attribute,obj:' / nbi', $ name:'description',$ data:' Neutral Beam Geometry '} nbi_cs = {attribute,obj:' / nbi', $ name:'coordinate_system',$ data:' Right - handed cartesian'} nbi_ds_desc = {attribute,obj:' / nbi / data_source', $ name:'description', $ data:' Source of the NBI geometry'} nbi_name_desc = {attribute,obj:' / nbi / name', $ name:'description', $ data:' Beam name'} nbi_src_desc = {attribute,obj:' / nbi / src', $ name:'description', $ data:' Position of the center of the beam source grid'} nbi_src_unit = {attribute,obj:' / nbi / src', $ name:'units', $ data:'cm'} nbi_axis_desc = {attribute,obj:' / nbi / axis', $ name:'description', $ data:' Axis of the beam centerline : Centerline ( t ) = src + axis * t '} nbi_axis_unit = {attribute,obj:' / nbi / axis', $ name:'units', $ data:'cm'} nbi_focy_desc = {attribute,obj:' / nbi / focy', $ name:'description', $ data:' Horizonal focal length of the beam'} nbi_focy_unit = {attribute,obj:' / nbi / focy', $ name:'units', $ data:'cm'} nbi_focz_desc = {attribute,obj:' / nbi / focz', $ name:'description', $ data:' Vertical focal length of the beam'} nbi_focz_unit = {attribute,obj:' / nbi / focz', $ name:'units', $ data:'cm'} nbi_divy_desc = {attribute,obj:' / nbi / divy', $ name:'description', $ data:' Horizonal divergences of the beam . One for each energy component'} nbi_divy_unit = {attribute,obj:' / nbi / divy', $ name:'units', $ data:'radians'} nbi_divz_desc = {attribute,obj:' / nbi / divz', $ name:'description', $ data:' Vertical divergences of the beam . One for each energy component'} nbi_divz_unit = {attribute,obj:' / nbi / divz', $ name:'units', $ data:'radians'} nbi_widy_desc = {attribute,obj:' / nbi / widy', $ name:'description', $ data:' Half width of the beam source grid'} nbi_widy_unit = {attribute,obj:' / nbi / widy', $ name:'units', $ data:'cm'} nbi_widz_desc = {attribute,obj:' / nbi / widz', $ name:'description', $ data:' Half height of the beam source grid'} nbi_widz_unit = {attribute,obj:' / nbi / widz', $ name:'units', $ data:'cm'} nbi_shape_desc = {attribute,obj:' / nbi / shape', $ name:'description', $ data:' Shape of the beam source grid : 1 = \"rectangular\" , 2 = \"circular\" '} nbi_atts = [nbi_desc, nbi_cs, nbi_ds_desc,nbi_name_desc, $ nbi_src_desc, nbi_src_unit, $ nbi_axis_desc, nbi_axis_unit, $ nbi_focy_desc, nbi_focy_unit, $ nbi_focz_desc, nbi_focz_unit, $ nbi_divy_desc, nbi_divy_unit, $ nbi_divz_desc, nbi_divz_unit, $ nbi_widy_desc, nbi_widy_unit, $ nbi_widz_desc, nbi_widz_unit, $ nbi_shape_desc] ;; Spectroscopic attributes spec_desc = {attribute,obj:' / spec', $ name:'description', $ data:' FIDA / BES Chord Geometry '} spec_cs = {attribute,obj:' / spec', $ name:'coordinate_system', $ data:' Right - handed cartesian'} spec_ds_desc = {attribute,obj:' / spec / data_source', $ name:'description', $ data:' Source of the chord geometry'} spec_nchan_desc = {attribute,obj:' / spec / nchan', $ name:'description', $ data:' Number of channels'} spec_system_desc = {attribute,obj:' / spec / system', $ name:'description', $ data:' Names of the different spectrocopic systems'} spec_lens_desc = {attribute,obj:' / spec / lens', $ name:'description', $ data:' Positions of the lenses'} spec_lens_unit = {attribute,obj:' / spec / lens', $ name:'units', $ data:'cm'} spec_axis_desc = {attribute,obj:' / spec / axis', $ name:'description', $ data:' Optical axis of the lines of sight : LOS ( t ) = lens + axis * t '} spec_axis_unit = {attribute,obj:' / spec / axis', $ name:'units', $ data:'cm'} spec_radius_desc = {attribute,obj:' / spec / radius', $ name:'description', $ data:' Line of sight radius at midplane or tangency point' } spec_radius_unit = {attribute,obj:' / spec / radius', $ name:'units', $ data:'cm'} spec_sigma_desc = {attribute,obj:' / spec / sigma_pi', $ name:'description', $ data:' Ratio of the intensities of the sigma and pi stark lines . Measured quantity'} spec_spot_desc = {attribute,obj:' / spec / spot_size', $ name:'description', $ data:' Radius of spot size'} spec_spot_unit = {attribute,obj:' / spec / spot_size', $ name:'units', $ data:'cm'} spec_atts = [spec_desc,spec_cs, spec_ds_desc, $ spec_nchan_desc, spec_system_desc, $ spec_lens_desc,spec_lens_unit, $ spec_axis_desc,spec_axis_unit, $ spec_radius_desc, spec_radius_unit, $ spec_sigma_desc, $ spec_spot_desc, spec_spot_unit] ;;NPA attributes npa_desc = {attribute,obj:' / npa', $ name:'description', $ data:' NPA Geometry '} npa_cs = {attribute,obj:' / npa', $ name:'coordinate_system', $ data:' Right - handed cartesian'} npa_ds_desc = {attribute,obj:' / npa / data_source', $ name:'description', $ data:' Source of the NPA geometry'} npa_nchan_desc = {attribute,obj:' / npa / nchan', $ name:'description', $ data:' Number of channels'} npa_system_desc = {attribute,obj:' / npa / system', $ name:'description', $ data:' Names of the different NPA systems'} npa_dshape_desc = {attribute,obj:' / npa / d_shape', $ name:'description', $ data:' Shape of the detector : 1 = \"rectangular\" , 2 = \"circular\" '} npa_dcent_desc = {attribute,obj:' / npa / d_cent', $ name:'description', $ data:' Center of the detector'} npa_dcent_unit = {attribute,obj:' / npa / d_cent', $ name:'units', $ data:'cm'} npa_dtedge_desc = {attribute,obj:' / npa / d_tedge', $ name:'description', $ data:' Center of the detectors top edge'} npa_dtedge_unit = {attribute,obj:' / npa / d_tedge', $ name:'units', $ data:'cm'} npa_dredge_desc = {attribute,obj:' / npa / d_redge', $ name:'description', $ data:' Center of the detectors right edge'} npa_dredge_unit = {attribute,obj:' / npa / d_redge', $ name:'units', $ data:'cm'} npa_ashape_desc = {attribute,obj:' / npa / a_shape', $ name:'description', $ data:' Shape of the aperture : 1 = \"rectangular\" , 2 = \"circular\" '} npa_acent_desc = {attribute,obj:' / npa / a_cent', $ name:'description', $ data:' Center of the aperture'} npa_acent_unit = {attribute,obj:' / npa / a_cent', $ name:'units', $ data:'cm'} npa_atedge_desc = {attribute,obj:' / npa / a_tedge', $ name:'description', $ data:' Center of the apertures top edge'} npa_atedge_unit = {attribute,obj:' / npa / a_tedge', $ name:'units', $ data:'cm'} npa_aredge_desc = {attribute,obj:' / npa / a_redge', $ name:'description', $ data:' Center of the apertures right edge'} npa_aredge_unit = {attribute,obj:' / npa / a_redge', $ name:'units', $ data:'cm'} npa_radius_desc = {attribute,obj:' / npa / radius', $ name:'description', $ data:' Line of sight radius at midplane or tangency point' } npa_radius_unit = {attribute,obj:' / npa / radius', $ name:'units', $ data:'cm'} npa_atts = [npa_desc, npa_cs, npa_ds_desc, $ npa_nchan_desc, npa_system_desc, $ npa_dshape_desc, npa_ashape_desc, $ npa_dcent_desc, npa_dcent_unit, $ npa_acent_desc, npa_acent_unit, $ npa_dtedge_desc, npa_dtedge_unit, $ npa_atedge_desc, npa_atedge_unit, $ npa_dredge_desc, npa_dredge_unit, $ npa_aredge_desc, npa_aredge_unit, $ npa_radius_desc, npa_radius_unit ] atts = [root_atts, nbi_atts] geom = {nbi:nbi} if keyword_set(spec) then begin geom = create_struct(geom, \"spec\", spec) atts = [atts, spec_atts] endif if keyword_set(npa) then begin geom = create_struct(geom, \"npa\", npa) atts = [atts,npa_atts] endif write_hdf5, geom, filename=filename, atts=atts, /clobber if file_test(filename) then begin success, ' Geometry file created : '+filename endif else begin error, ' Geometry file creation failed . ' endelse END PRO write_equilibrium, filename, plasma, fields ;+ Write MHD equilibrium values to a HDF5 file ;+ ;+ Input Arguments: ;+     filename: Name of the equilibrium file ;+     plasma: Plasma structure ;+     fields: Electromagnetic fields structure ;+ ;+ Example Usage: ;+```idl ;+IDL> write_equilibrium, filename, plasma, fields ;+``` ;+ info, ' Writing equilibrium file ... ' root_atts = {attribute,obj:'/', $ name:'description', $ data:' Plasma Parameters and Electromagnetic Fields for FIDASIM '} ;; Plasma Attributes plasma_desc = {attribute,obj:' / plasma', $ name:'description', $ data:' Plasma Parameters '} plasma_cs = {attribute,obj:' / plasma', $ name:'coordinate_system', $ data:' Cylindrical '} plasma_ds_desc = {attribute, obj:' / plasma / data_source', $ name:'description', $ data:' Source of the plasma parameters'} plasma_time_desc = {attribute,obj:' / plasma / time', $ name:'description', $ data:' Time '} plasma_time_unit = {attribute,obj:' / plasma / time', $ name:'units', $ data:'s'} plasma_dene_desc = {attribute,obj:' / plasma / dene', $ name:'description', $ data:' Electron Number Density : Dene ( r , z ) '} plasma_dene_unit = {attribute,obj:' / plasma / dene', $ name:'units', $ data:'cm&#94;- 3 '} plasma_te_desc = {attribute,obj:' / plasma / te', $ name:'description', $ data:' Electron Temperature : Te ( r , z ) '} plasma_te_unit = {attribute,obj:' / plasma / te', $ name:'units', $ data:'keV'} plasma_ti_desc = {attribute,obj:' / plasma / ti', $ name:'description', $ data:' Ion Temperature : Ti ( r , z ) '} plasma_ti_unit = {attribute,obj:' / plasma / ti', $ name:'units', $ data:'keV'} plasma_zeff_desc = {attribute,obj:' / plasma / zeff', $ name:'description', $ data:' Effective Nuclear Charge : Zeff ( r , z ) '} plasma_vr_desc = {attribute,obj:' / plasma / vr', $ name:'description', $ data:' Bulk plasma flow in the r - direction : Vr ( r , z ) '} plasma_vr_unit = {attribute,obj:' / plasma / vr', $ name:'units', $ data:'cm / s'} plasma_vt_desc = {attribute,obj:' / plasma / vt', $ name:'description', $ data:' Bulk plasma flow in the theta / torodial - direction : Vt ( r , z ) '} plasma_vt_unit = {attribute,obj:' / plasma / vt', $ name:'units', $ data:'cm / s'} plasma_vz_desc = {attribute,obj:' / plasma / vz', $ name:'description', $ data:' Bulk plasma flow in the z - direction : Vz ( r , z ) '} plasma_vz_unit = {attribute,obj:' / plasma / vz', $ name:'units', $ data:'cm / s'} plasma_nr_desc = {attribute,obj:' / plasma / nr', $ name:'description', $ data:' Number of R values'} plasma_nz_desc = {attribute,obj:' / plasma / nz', $ name:'description', $ data:' Number of Z values'} plasma_r_desc = {attribute,obj:' / plasma / r', $ name:'description', $ data:' Radius '} plasma_r_unit = {attribute,obj:' / plasma / r', $ name:'units', $ data:'cm'} plasma_z_desc = {attribute,obj:' / plasma / z', $ name:'description', $ data:' Z '} plasma_z_unit = {attribute,obj:' / plasma / z', $ name:'units', $ data:'cm'} plasma_r2d_desc = {attribute,obj:' / plasma / r2d', $ name:'description', $ data:' Radius grid : R ( r , z ) '} plasma_r2d_unit = {attribute,obj:' / plasma / r2d', $ name:'units', $ data:'cm'} plasma_z2d_desc = {attribute,obj:' / plasma / z2d', $ name:'description', $ data:' Z grid : Z ( r , z ) '} plasma_z2d_unit = {attribute,obj:' / plasma / z2d', $ name:'units', $ data:'cm'} plasma_mask_desc = {attribute,obj:' / plasma / mask',$ name:'description', $ data:' Boolean mask that indicates where' +$ ' the plasma parameters are well defined'} plasma_atts = [plasma_desc, plasma_cs, plasma_ds_desc, $ plasma_time_desc, plasma_time_unit, $ plasma_mask_desc, $ plasma_dene_desc, plasma_dene_unit, $ plasma_te_desc, plasma_te_unit, $ plasma_ti_desc, plasma_ti_unit, $ plasma_zeff_desc, $ plasma_vr_desc, plasma_vr_unit, $ plasma_vt_desc, plasma_vt_unit, $ plasma_vz_desc, plasma_vz_unit, $ plasma_nr_desc, plasma_nz_desc, $ plasma_r_desc, plasma_r_unit, $ plasma_z_desc, plasma_z_unit, $ plasma_r2d_desc, plasma_r2d_unit, $ plasma_z2d_desc, plasma_z2d_unit ] ;; Electromagnetic fields attributes fields_desc = {attribute,obj:' / fields', $ name:'description', $ data:' Electromagnetic Fields '} fields_cs = {attribute,obj:' / fields', $ name:'coordinate_system', $ data:' Cylindrical '} fields_ds_desc = {attribute,obj:' / fields / data_source', $ name:'description', $ data:' Source of the EM equilibrium'} fields_mask_desc = {attribute,obj:' / fields / mask',$ name:'description', $ data:' Boolean mask that indicates where' +$ ' the fields are well defined'} fields_time_desc = {attribute,obj:' / fields / time', $ name:'description', $ data:' Time '} fields_time_unit = {attribute,obj:' / fields / time', $ name:'units', $ data:'s'} fields_br_desc = {attribute,obj:' / fields / br', $ name:'description', $ data:' Magnetic field in the r - direction : Br ( r , z ) '} fields_br_unit = {attribute,obj:' / fields / br', $ name:'units', $ data:' T '} fields_bt_desc = {attribute,obj:' / fields / bt', $ name:'description', $ data:' Magnetic field in the theta / torodial - direction : Bt ( r , z ) '} fields_bt_unit = {attribute,obj:' / fields / bt', $ name:'units', $ data:' T '} fields_bz_desc = {attribute,obj:' / fields / bz', $ name:'description', $ data:' Magnetic field in the z - direction : Bz ( r , z ) '} fields_bz_unit = {attribute,obj:' / fields / bz', $ name:'units', $ data:' T '} fields_er_desc = {attribute,obj:' / fields / er', $ name:'description', $ data:' Electric field in the r - direction : Er ( r , z ) '} fields_er_unit = {attribute,obj:' / fields / er', $ name:'units', $ data:' V / m'} fields_et_desc = {attribute,obj:' / fields / et', $ name:'description', $ data:' Electric field in the theta / torodial - direction : Et ( r , z ) '} fields_et_unit = {attribute,obj:' / fields / et', $ name:'units', $ data:' V / m'} fields_ez_desc = {attribute,obj:' / fields / ez', $ name:'description', $ data:' Electric field in the z - direction : Ez ( r , z ) '} fields_ez_unit = {attribute,obj:' / fields / ez', $ name:'units', $ data:' V / m'} fields_nr_desc = {attribute,obj:' / fields / nr', $ name:'description', $ data:' Number of R values'} fields_nz_desc = {attribute,obj:' / fields / nz', $ name:'description', $ data:' Number of Z values'} fields_r_desc = {attribute,obj:' / fields / r', $ name:'description', $ data:' Radius '} fields_r_unit = {attribute,obj:' / fields / r', $ name:'units', $ data:'cm'} fields_z_desc = {attribute,obj:' / fields / z', $ name:'description', $ data:' Z '} fields_z_unit = {attribute,obj:' / fields / z', $ name:'units', $ data:'cm'} fields_r2d_desc = {attribute,obj:' / fields / r2d', $ name:'description', $ data:' Radius grid : R ( r , z ) '} fields_r2d_unit = {attribute,obj:' / fields / r2d', $ name:'units', $ data:'cm'} fields_z2d_desc = {attribute,obj:' / fields / z2d', $ name:'description', $ data:' Z grid : Z ( r , z ) '} fields_z2d_unit = {attribute,obj:' / fields / z2d', $ name:'units', $ data:'cm'} fields_atts = [fields_desc, fields_cs, fields_ds_desc, $ fields_mask_desc, $ fields_time_desc, fields_time_unit, $ fields_br_desc, fields_br_unit, $ fields_bt_desc, fields_bt_unit, $ fields_bz_desc, fields_bz_unit, $ fields_er_desc, fields_er_unit, $ fields_et_desc, fields_et_unit, $ fields_ez_desc, fields_ez_unit, $ fields_nr_desc, fields_nz_desc, $ fields_r_desc, fields_r_unit, $ fields_z_desc, fields_z_unit, $ fields_r2d_desc, fields_r2d_unit, $ fields_z2d_desc, fields_z2d_unit ] atts = [root_atts, plasma_atts, fields_atts] write_hdf5,[\"plasma\",\"fields\"],filename=filename, atts=atts, /clobber if file_test(filename) then begin success, ' Equilibrium file created : '+filename endif else begin error, ' Equilibrium file creation failed . ' endelse END PRO write_distribution, filename, distri ;+ Write fast-ion distribution to a HDF5 file ;+ ;+ Input Arguments: ;+     filename: Name of the distribution file ;+     distri: Fast-ion distribution structure ;+ ;+ Example Usage: ;+```idl ;+IDL> write_distribution, filename, distri ;+``` ;+ info, ' Writing fast - ion distribution file ... ' root_atts = {attribute,obj:'/', $ name:'description', $ data:' Fast - ion distribution for FIDASIM '} cs_desc = {attribute,obj:'/', $ name:'coordinate_system', $ data:' Cylindrical '} ds_desc = {attribute,obj:' / data_source', $ name:'description', $ data:' Source of the fast - ion distribution'} type_desc = {attribute,obj:' / type', $ name:'description', $ data:' Distribution type : '+ $ ' 1 = \"Guiding Center Density Function\" , '+ $ ' 2 = \"Guiding Center Monte Carlo\" , '+ $ ' 3 = \"Full Orbit Monte Carlo\" '} time_desc = {attribute,obj:' / time', $ name:'description', $ data:' Distribution time'} time_unit = {attribute,obj:' / time', $ name:'units', $ data:'s'} type = distri.type if type eq 1 then begin nen_desc = {attribute,obj:' / nenergy',$ name:'description', $ data:' Number of energy values'} np_desc = {attribute,obj:' / npitch', $ name:'description', $ data:' Number of pitch values'} energy_desc = {attribute,obj:' / energy', $ name:'description',$ data:' Energy '} energy_unit = {attribute,obj:' / energy', $ name:'units', $ data:'keV'} pitch_desc = {attribute,obj:' / pitch', $ name:'description',$ data:' Pitch : p = v_parallel / v w . r . t . the magnetic field'} f_desc = {attribute,obj:' / f', $ name:'description', $ data:' Fast - ion density function : F ( E , p , R , Z ) '} f_unit = {attribute,obj:' / f', $ name:'units', $ data:'fast - ions/ ( dE * dP * cm&#94; 3 ) '} denf_desc = {attribute,obj:' / denf', $ name:'description', $ data:' Fast - ion density : Denf ( r , z ) '} denf_unit = {attribute,obj:' / denf', $ name:'units', $ data:'cm&#94;- 3 '} nr_desc = {attribute,obj:' / nr', $ name:'description', $ data:' Number of R values'} nz_desc = {attribute,obj:' / nz', $ name:'description', $ data:' Number of Z values'} r_desc = {attribute,obj:' / r', $ name:'description', $ data:' Radius '} r_unit = {attribute,obj:' / r', $ name:'units', $ data:'cm'} z_desc = {attribute,obj:' / z', $ name:'description', $ data:' Z '} z_unit = {attribute,obj:' / z', $ name:'units', $ data:'cm'} r2d_desc = {attribute,obj:' / r2d', $ name:'description', $ data:' Radius grid : R ( r , z ) '} r2d_unit = {attribute,obj:' / r2d', $ name:'units', $ data:'cm'} z2d_desc = {attribute,obj:' / z2d', $ name:'description', $ data:' Z grid : Z ( r , z ) '} z2d_unit = {attribute,obj:' / z2d', $ name:'units', $ data:'cm'} atts = [root_atts, cs_desc, ds_desc, $ type_desc, time_desc,time_unit, $ nen_desc, np_desc, $ energy_desc, energy_unit, $ pitch_desc, $ f_desc, f_unit, $ denf_desc, denf_unit, $ nr_desc, nz_desc, $ r_desc, r_unit, $ z_desc, z_unit, $ r2d_desc, r2d_unit, $ z2d_desc, z2d_unit] endif else begin np_desc = {attribute,obj:' / nparticle', $ name:'description', $ data:' Number of MC particles'} nc_desc = {attribute,obj:' / nclass', $ name:'description', $ data:' Number of orbit classes'} r_desc = {attribute,obj:' / r', $ name:'description', $ data:' R position of a MC particle'} r_unit = {attribute,obj:' / r', $ name:'units', $ data:'cm'} z_desc = {attribute,obj:' / z', $ name:'description', $ data:' Z position of a MC particle'} z_unit = {attribute,obj:' / z', $ name:'units', $ data:'cm'} w_desc = {attribute,obj:' / weight', $ name:'description', $ data:' Weight of a MC particle : sum ( weight ) = # of fast - ions '} w_unit = {attribute,obj:' / weight', $ name:'units', $ data:'fast - ions / particle'} c_desc = {attribute,obj:' / class', $ name:'description', $ data:' Orbit class of a MC particle : class in Set ( 1 :nclass ) '} if type eq 2 then begin energy_desc = {attribute,obj:' / energy', $ name:'description', $ data:' Energy of a MC particle'} energy_unit = {attribute,obj:' / energy', $ name:'units', $ data:'keV'} pitch_desc = {attribute,obj:' / pitch', $ name:'description', $ data:' Pitch of a MC particle : p = v_parallel / v w . r . t . the magnetic field'} type_atts = [energy_desc,energy_unit,pitch_desc] endif else begin vr_desc = {attribute,obj:' / vr', $ name:'description', $ data:' Radial velocity of a MC particle'} vr_unit = {attribute,obj:' / vr', $ name:'units', $ data:'cm / s'} vt_desc = {attribute,obj:' / vt', $ name:'description', $ data:' Torodial velocity of a MC particle'} vt_unit = {attribute,obj:' / vt', $ name:'units', $ data:'cm / s'} vz_desc = {attribute,obj:' / vz', $ name:'description', $ data:' Z velocity of a MC particle'} vz_unit = {attribute,obj:' / vz', $ name:'units', $ data:'cm / s'} type_atts = [vr_desc,vr_unit,vt_desc,vt_unit,vz_desc,vz_unit] endelse atts = [root_atts, cs_desc, ds_desc, $ type_desc, time_desc,time_unit, $ np_desc, nc_desc, $ r_desc, r_unit, $ z_desc, z_unit, $ w_desc, w_unit, $ c_desc, type_atts] endelse write_hdf5, distri, filename=filename,atts=atts, /clobber if file_test(filename) then begin success, ' Distribution file created : '+filename endif else begin error, ' Distribution file creation failed . ' endelse END PRO prefida,inputs,grid,nbi,plasma,equil,fbm,spec=spec,npa=npa ;+ Checks FIDASIM inputs and writes FIDASIM input HDF5 files ;+ ;+ Input Arguments: ;+     inputs: Inputs structure ;+     grid: Interpolation grid structure ;+     nbi: Neutral beam geometry structure ;+     plasma: Plasma parameters structure ;+     equil: Electromagnetic fields structure ;+     fbm: Fast-ion distribution structure ;+ ;+ Keyword Arguments: ;+     spec: Spectral geometry structure ;+     npa: NPA geometry structure ;+ ;+ Example Usage ;+```idl ;+IDL> prefida, inputs, grid, nbi, plasma, equil, fbm, spec=spec, npa=npa ;+``` ;+ COMPILE_OPT DEFINT32 ;;CHECK INPUTS check_inputs,inputs,err_status if err_status ne 0 then goto, GET_OUT ;;MAKE DIRECTORIES IF THEY DONT EXIST if file_test(inputs.result_dir,/directory) eq 0 then begin file_mkdir,inputs.result_dir endif ;;CHECK INTERPOLATION GRID check_grid, grid, err_status if err_status ne 0 then goto, GET_OUT ;;CHECK BEAM INPUTS check_beam, inputs, nbi, err_status if err_status ne 0 then goto, GET_OUT ;;CHECK PLASMA PARAMETERS check_plasma, inputs, grid, plasma, err_status if err_status ne 0 then goto, GET_OUT ;;CHECK ELECTROMAGNETIC FIELDS check_fields, inputs, grid, equil, err_status if err_status ne 0 then goto, GET_OUT ;;CHECK FAST-ION DISTRIBUTION check_dist, inputs, grid, fbm, err_status if err_status ne 0 then goto, GET_OUT ;;CHECK FIDA/BES if keyword_set(spec) then begin check_spec, inputs, spec, err_status if err_status ne 0 then goto, GET_OUT endif ;;CHECK NPA if keyword_set(npa) then begin check_npa, inputs, npa, err_status if err_status ne 0 then goto, GET_OUT endif ;;WRITE FIDASIM INPUT FILES write_namelist, inputs.input_file, inputs ;;WRITE GEOMETRY FILE write_geometry, inputs.geometry_file, nbi, spec=spec, npa=npa ;;WRITE EQUILIBRIUM FILE write_equilibrium, inputs.equilibrium_file, plasma, equil ;;WRITE DISTRIBUTION FILE write_distribution, inputs.distribution_file, fbm print,'' print,'' success,' FIDASIM pre - processing completed' print, ' To run FIDASIM use the following command' print, inputs.install_dir+' / fidasim '+inputs.result_dir+'/'+inputs.runid+' _ inputs . dat' print,'' print,' ' GET_OUT : END","tags":""},{"title":"BeamGrid – Fortran Program ","loc":"type/beamgrid.html","text":"type, public :: BeamGrid Components Type Visibility Attributes Name Initial integer(kind=long), public :: nx integer(kind=long), public :: ny integer(kind=long), public :: nz real(kind=double), public :: xmin real(kind=double), public :: xmax real(kind=double), public :: ymin real(kind=double), public :: ymax real(kind=double), public :: zmin real(kind=double), public :: zmax real(kind=double), public :: alpha real(kind=double), public :: beta real(kind=double), public :: gamma real(kind=double), public :: drmin real(kind=double), public :: dv real(kind=double), public :: volume integer(kind=long), public :: ntrack integer(kind=long), public :: ngrid real(kind=double), public, dimension(3) :: origin real(kind=double), public, dimension(3) :: center real(kind=double), public, dimension(3) :: dr real(kind=double), public, dimension(3) :: lwh real(kind=double), public, dimension(3,3) :: basis real(kind=double), public, dimension(3,3) :: inv_basis real(kind=double), public, dimension(:), allocatable :: xc real(kind=double), public, dimension(:), allocatable :: yc real(kind=double), public, dimension(:), allocatable :: zc","tags":""},{"title":"InterpolationGrid – Fortran Program ","loc":"type/interpolationgrid.html","text":"type, public :: InterpolationGrid Components Type Visibility Attributes Name Initial integer(kind=long), public :: nr integer(kind=long), public :: nz real(kind=double), public :: dr real(kind=double), public :: dz real(kind=double), public :: da real(kind=double), public, dimension(:), allocatable :: r real(kind=double), public, dimension(:), allocatable :: z real(kind=double), public, dimension(:,:), allocatable :: r2d real(kind=double), public, dimension(:,:), allocatable :: z2d","tags":""},{"title":"Profiles – Fortran Program ","loc":"type/profiles.html","text":"type, public :: Profiles Inherited By type~~profiles~~InheritedByGraph type~profiles Profiles type~equilibrium Equilibrium type~profiles->type~equilibrium plasma type~localprofiles LocalProfiles type~profiles->type~localprofiles Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial real(kind=double), public :: dene = 0.d0 real(kind=double), public :: denp = 0.d0 real(kind=double), public :: denimp = 0.d0 real(kind=double), public :: denf = 0.d0 real(kind=double), public :: te = 0.d0 real(kind=double), public :: ti = 0.d0 real(kind=double), public :: zeff = 0.d0 real(kind=double), public :: vr = 0.d0 real(kind=double), public :: vt = 0.d0 real(kind=double), public :: vz = 0.d0","tags":""},{"title":"LocalProfiles – Fortran Program ","loc":"type/localprofiles.html","text":"type, public, extends( Profiles ) :: LocalProfiles type~~localprofiles~~InheritsGraph type~localprofiles LocalProfiles type~profiles Profiles type~profiles->type~localprofiles Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial logical, public :: in_plasma = .False. real(kind=double), public, dimension(3) :: pos = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: vrot = [0.d0, 0.d0, 0.d0]","tags":""},{"title":"EMFields – Fortran Program ","loc":"type/emfields.html","text":"type, public :: EMFields Inherited By type~~emfields~~InheritedByGraph type~emfields EMFields type~equilibrium Equilibrium type~emfields->type~equilibrium fields type~localemfields LocalEMFields type~emfields->type~localemfields Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial real(kind=double), public :: br = 0.d0 real(kind=double), public :: bt = 0.d0 real(kind=double), public :: bz = 0.d0 real(kind=double), public :: er = 0.d0 real(kind=double), public :: et = 0.d0 real(kind=double), public :: ez = 0.d0","tags":""},{"title":"LocalEMFields – Fortran Program ","loc":"type/localemfields.html","text":"type, public, extends( EMFields ) :: LocalEMFields type~~localemfields~~InheritsGraph type~localemfields LocalEMFields type~emfields EMFields type~emfields->type~localemfields Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial logical, public :: in_plasma = .False. real(kind=double), public :: b_abs = 0.d0 real(kind=double), public :: e_abs = 0.d0 real(kind=double), public, dimension(3) :: pos = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: a_norm = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: b_norm = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: c_norm = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: e_norm = [0.d0, 0.d0, 0.d0]","tags":""},{"title":"Equilibrium – Fortran Program ","loc":"type/equilibrium.html","text":"type, public :: Equilibrium type~~equilibrium~~InheritsGraph type~equilibrium Equilibrium type~profiles Profiles type~profiles->type~equilibrium plasma type~emfields EMFields type~emfields->type~equilibrium fields Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial type( EMFields ), public, dimension(:,:), allocatable :: fields type( Profiles ), public, dimension(:,:), allocatable :: plasma real(kind=double), public, dimension(:,:), allocatable :: mask","tags":""},{"title":"FastIonDistribution – Fortran Program ","loc":"type/fastiondistribution.html","text":"type, public :: FastIonDistribution Components Type Visibility Attributes Name Initial integer(kind=long), public :: nenergy integer(kind=long), public :: npitch real(kind=double), public :: dE real(kind=double), public :: dp real(kind=double), public :: emin real(kind=double), public :: emax real(kind=double), public :: e_range real(kind=double), public :: pmin real(kind=double), public :: pmax real(kind=double), public :: p_range real(kind=double), public, dimension(:), allocatable :: energy real(kind=double), public, dimension(:), allocatable :: pitch real(kind=double), public, dimension(:,:,:,:), allocatable :: f","tags":""},{"title":"FastIon – Fortran Program ","loc":"type/fastion.html","text":"type, public :: FastIon Inherited By type~~fastion~~InheritedByGraph type~fastion FastIon type~fastionparticles FastIonParticles type~fastion->type~fastionparticles fast_ion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial logical, public :: cross_grid = .False. real(kind=double), public :: r = 0.d0 real(kind=double), public :: z = 0.d0 real(kind=double), public :: phi_enter = 0.d0 real(kind=double), public :: delta_phi = 0.d0 real(kind=double), public :: energy = 0.d0 real(kind=double), public :: pitch = 0.d0 real(kind=double), public :: vabs = 0.d0 real(kind=double), public :: vr = 0.d0 real(kind=double), public :: vt = 0.d0 real(kind=double), public :: vz = 0.d0 real(kind=double), public :: weight = 0.d0 integer(kind=long), public :: class = 0","tags":""},{"title":"FastIonParticles – Fortran Program ","loc":"type/fastionparticles.html","text":"type, public :: FastIonParticles type~~fastionparticles~~InheritsGraph type~fastionparticles FastIonParticles type~fastion FastIon type~fastion->type~fastionparticles fast_ion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial logical, public :: guiding_center = .True. integer(kind=long), public :: nparticle = 0 integer(kind=long), public :: nclass = 1 type( FastIon ), public, dimension(:), allocatable :: fast_ion","tags":""},{"title":"NeutralBeam – Fortran Program ","loc":"type/neutralbeam.html","text":"type, public :: NeutralBeam Components Type Visibility Attributes Name Initial character(len=25), public :: name = '' integer, public :: shape real(kind=double), public :: widy real(kind=double), public :: widz real(kind=double), public :: focy real(kind=double), public :: focz real(kind=double), public :: einj real(kind=double), public :: pinj real(kind=double), public :: vinj real(kind=double), public :: alpha real(kind=double), public :: beta real(kind=double), public, dimension(3) :: divy real(kind=double), public, dimension(3) :: divz real(kind=double), public, dimension(3) :: species_mix real(kind=double), public, dimension(3) :: src real(kind=double), public, dimension(3) :: axis real(kind=double), public, dimension(3,3) :: basis real(kind=double), public, dimension(3,3) :: inv_basis","tags":""},{"title":"AtomicCrossSection – Fortran Program ","loc":"type/atomiccrosssection.html","text":"type, public :: AtomicCrossSection Inherited By type~~atomiccrosssection~~InheritedByGraph type~atomiccrosssection AtomicCrossSection type~atomictables AtomicTables type~atomiccrosssection->type~atomictables H_H_cx Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 real(kind=double), public :: logemin = 0.d0 real(kind=double), public :: logemax = 0.d0 integer, public :: n_max = nlevs integer, public :: m_max = nlevs real(kind=double), public :: dlogE = 0.d0 real(kind=double), public :: minlog_cross real(kind=double), public, dimension(:,:,:), allocatable :: log_cross","tags":""},{"title":"AtomicRates – Fortran Program ","loc":"type/atomicrates.html","text":"type, public :: AtomicRates Inherited By type~~atomicrates~~InheritedByGraph type~atomicrates AtomicRates type~atomictables AtomicTables type~atomicrates->type~atomictables H_H, H_e, H_Aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 real(kind=double), public :: logemin = 0.d0 real(kind=double), public :: logemax = 0.d0 integer, public :: ntemp = 1 real(kind=double), public :: logtmin = 0.d0 real(kind=double), public :: logtmax = 0.d0 integer, public :: n_max = nlevs integer, public :: m_max = nlevs real(kind=double), public :: dlogE = 0.d0 real(kind=double), public :: dlogT = 0.d0 real(kind=double), public :: minlog_pop = 0.d0 real(kind=double), public :: minlog_depop = 0.d0 real(kind=double), public, dimension(2) :: ab = 0.d0 real(kind=double), public, dimension(:,:,:,:,:), allocatable :: log_pop real(kind=double), public, dimension(:,:,:,:), allocatable :: log_depop","tags":""},{"title":"AtomicTables – Fortran Program ","loc":"type/atomictables.html","text":"type, public :: AtomicTables type~~atomictables~~InheritsGraph type~atomictables AtomicTables type~atomicrates AtomicRates type~atomicrates->type~atomictables H_H, H_e, H_Aq type~atomiccrosssection AtomicCrossSection type~atomiccrosssection->type~atomictables H_H_cx Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial type( AtomicCrossSection ), public :: H_H_cx type( AtomicRates ), public :: H_H type( AtomicRates ), public :: H_e type( AtomicRates ), public :: H_Aq real(kind=double), public, dimension(nlevs,nlevs) :: einstein","tags":""},{"title":"LineOfSight – Fortran Program ","loc":"type/lineofsight.html","text":"type, public :: LineOfSight Inherited By type~~lineofsight~~InheritedByGraph type~lineofsight LineOfSight type~spectralchords SpectralChords type~lineofsight->type~spectralchords los Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial real(kind=double), public :: sigma_pi = 1.d0 real(kind=double), public :: spot_size = 0.d0 real(kind=double), public, dimension(3) :: lens = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: axis = [0.d0, 0.d0, 0.d0]","tags":""},{"title":"SpectralChords – Fortran Program ","loc":"type/spectralchords.html","text":"type, public :: SpectralChords type~~spectralchords~~InheritsGraph type~spectralchords SpectralChords type~lineofsight LineOfSight type~lineofsight->type~spectralchords los Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 type( LineOfSight ), public, dimension(:), allocatable :: los real(kind=double), public, dimension(:), allocatable :: radius logical, public, dimension(:,:,:), allocatable :: los_inter real(kind=double), public, dimension(:,:,:,:), allocatable :: dlength","tags":""},{"title":"BoundedPlane – Fortran Program ","loc":"type/boundedplane.html","text":"type, public :: BoundedPlane Inherited By type~~boundedplane~~InheritedByGraph type~boundedplane BoundedPlane type~npadetector NPADetector type~boundedplane->type~npadetector detector, aperture type~npachords NPAChords type~npadetector->type~npachords det Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer, public :: shape = 0 real(kind=double), public :: hh = 0.d0 real(kind=double), public :: hw = 0.d0 real(kind=double), public, dimension(3) :: origin = 0.d0 real(kind=double), public, dimension(3,3) :: basis = 0.d0 real(kind=double), public, dimension(3,3) :: inv_basis = 0.d0","tags":""},{"title":"NPADetector – Fortran Program ","loc":"type/npadetector.html","text":"type, public :: NPADetector type~~npadetector~~InheritsGraph type~npadetector NPADetector type~boundedplane BoundedPlane type~boundedplane->type~npadetector detector, aperture Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Inherited By type~~npadetector~~InheritedByGraph type~npadetector NPADetector type~npachords NPAChords type~npadetector->type~npachords det Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial type( BoundedPlane ), public :: detector type( BoundedPlane ), public :: aperture","tags":""},{"title":"NPAProbability – Fortran Program ","loc":"type/npaprobability.html","text":"type, public :: NPAProbability Inherited By type~~npaprobability~~InheritedByGraph type~npaprobability NPAProbability type~npachords NPAChords type~npaprobability->type~npachords phit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial real(kind=double), public :: p = 0.d0 real(kind=double), public, dimension(3) :: eff_rd = [0.d0, 0.d0, 0.d0]","tags":""},{"title":"NPAChords – Fortran Program ","loc":"type/npachords.html","text":"type, public :: NPAChords type~~npachords~~InheritsGraph type~npachords NPAChords type~npadetector NPADetector type~npadetector->type~npachords det type~npaprobability NPAProbability type~npaprobability->type~npachords phit type~boundedplane BoundedPlane type~boundedplane->type~npadetector detector, aperture Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 type( NPADetector ), public, dimension(:), allocatable :: det real(kind=double), public, dimension(:), allocatable :: radius logical, public, dimension(:,:,:), allocatable :: hit type( NPAProbability ), public, dimension(:,:,:,:), allocatable :: phit","tags":""},{"title":"NPAParticle – Fortran Program ","loc":"type/npaparticle.html","text":"type, public :: NPAParticle Inherited By type~~npaparticle~~InheritedByGraph type~npaparticle NPAParticle type~nparesults NPAResults type~npaparticle->type~nparesults part Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer, public :: detector = 0 real(kind=double), public :: xi = 0.d0 real(kind=double), public :: yi = 0.d0 real(kind=double), public :: zi = 0.d0 real(kind=double), public :: xf = 0.d0 real(kind=double), public :: yf = 0.d0 real(kind=double), public :: zf = 0.d0 real(kind=double), public :: weight = 0.d0 real(kind=double), public :: energy = 0.d0 real(kind=double), public :: pitch = 0.d0","tags":""},{"title":"NPAResults – Fortran Program ","loc":"type/nparesults.html","text":"type, public :: NPAResults type~~nparesults~~InheritsGraph type~nparesults NPAResults type~npaparticle NPAParticle type~npaparticle->type~nparesults part Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=long), public :: nchan = 0 integer(kind=long), public :: npart = 0 integer(kind=long), public :: nmax = 1000000 integer(kind=long), public :: nloop = 1000 type( NPAParticle ), public, dimension(:), allocatable :: part real(kind=double), public, dimension(:), allocatable :: energy real(kind=double), public, dimension(:,:), allocatable :: flux","tags":""},{"title":"BirthProfile – Fortran Program ","loc":"type/birthprofile.html","text":"type, public :: BirthProfile Components Type Visibility Attributes Name Initial integer, public :: ind = 1 real(kind=double), public, dimension(:,:), allocatable :: ri real(kind=double), public, dimension(:,:), allocatable :: vi real(kind=double), public, dimension(:,:,:,:), allocatable :: dens","tags":""},{"title":"Spectra – Fortran Program ","loc":"type/spectra.html","text":"type, public :: Spectra Components Type Visibility Attributes Name Initial real(kind=double), public, dimension(:,:), allocatable :: brems real(kind=double), public, dimension(:,:,:), allocatable :: bes real(kind=double), public, dimension(:,:,:), allocatable :: fida","tags":""},{"title":"NeutralDensity – Fortran Program ","loc":"type/neutraldensity.html","text":"type, public :: NeutralDensity Components Type Visibility Attributes Name Initial real(kind=double), public, dimension(:,:,:,:,:), allocatable :: dens","tags":""},{"title":"FIDAWeights – Fortran Program ","loc":"type/fidaweights.html","text":"type, public :: FIDAWeights Components Type Visibility Attributes Name Initial real(kind=double), public, dimension(:,:), allocatable :: fida real(kind=double), public, dimension(:,:,:), allocatable :: mean_f real(kind=double), public, dimension(:,:,:,:), allocatable :: weight","tags":""},{"title":"NPAWeights – Fortran Program ","loc":"type/npaweights.html","text":"type, public :: NPAWeights Components Type Visibility Attributes Name Initial real(kind=double), public, dimension(:,:,:,:,:), allocatable :: attenuation real(kind=double), public, dimension(:,:,:,:,:), allocatable :: cx real(kind=double), public, dimension(:,:,:,:), allocatable :: emissivity real(kind=double), public, dimension(:,:,:), allocatable :: weight real(kind=double), public, dimension(:,:), allocatable :: flux","tags":""},{"title":"SimulationInputs – Fortran Program ","loc":"type/simulationinputs.html","text":"type, public :: SimulationInputs Components Type Visibility Attributes Name Initial integer(kind=long), public :: shot_number real(kind=double), public :: time character(len=120), public :: runid = '' character(len=10), public :: version = '' character(len=120), public :: result_dir = '' character(len=120), public :: tables_file = '' character(len=120), public :: geometry_file = '' character(len=120), public :: equilibrium_file = '' character(len=120), public :: distribution_file = '' character(len=120), public :: neutrals_file = '' integer(kind=long), public :: n_fida integer(kind=long), public :: n_npa integer(kind=long), public :: n_nbi integer(kind=long), public :: n_dcx integer(kind=long), public :: n_halo integer(kind=long), public :: n_birth integer(kind=long), public :: calc_spec integer(kind=long), public :: calc_brems integer(kind=long), public :: calc_bes integer(kind=long), public :: calc_fida integer(kind=long), public :: load_neutrals integer(kind=long), public :: calc_npa integer(kind=long), public :: calc_fida_wght integer(kind=long), public :: calc_npa_wght integer(kind=long), public :: calc_birth integer(kind=long), public :: dump_dcx integer(kind=long), public :: verbose real(kind=double), public :: ab integer(kind=long), public :: impurity_charge real(kind=double), public :: ai integer(kind=long), public :: dist_type integer(kind=long), public :: nlambda real(kind=double), public :: dlambda real(kind=double), public :: lambdamin real(kind=double), public :: lambdamax integer(kind=long), public :: ne_wght integer(kind=long), public :: np_wght integer(kind=long), public :: nphi_wght integer(kind=long), public :: nlambda_wght real(kind=double), public :: emax_wght real(kind=double), public :: lambdamin_wght real(kind=double), public :: lambdamax_wght","tags":""},{"title":"ParticleTrack – Fortran Program ","loc":"type/particletrack.html","text":"type, public :: ParticleTrack Components Type Visibility Attributes Name Initial real(kind=double), public :: time = 0.d0 real(kind=double), public :: flux = 0.d0 integer(kind=long), public, dimension(3) :: ind = [0, 0, 0] real(kind=double), public, dimension(3) :: pos = [0.d0, 0.d0, 0.d0]","tags":""},{"title":"rng_type – Fortran Program ","loc":"type/rng_type.html","text":"type, public :: rng_type Random Number Generator Derived Type Components Type Visibility Attributes Name Initial integer, public, dimension(ns) :: state","tags":""},{"title":"comabs – Fortran Program","loc":"proc/comabs.html","text":"public function comabs(ar, ai) Arguments Type Intent Optional Attributes Name real(kind=double) :: ar real(kind=double) :: ai Return Value real(kind=double) Calls proc~~comabs~~CallsGraph proc~comabs comabs proc~rswap RSWAP proc~comabs->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"outerprod – Fortran Program","loc":"proc/outerprod.html","text":"public function outerprod(a, b) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: a real(kind=double), intent(in), dimension(:) :: b Return Value real(kind=double),\n  dimension(size(a),size(b)) Called By proc~~outerprod~~CalledByGraph proc~outerprod outerprod proc~ludcmp ludcmp proc~ludcmp->proc~outerprod proc~matinv matinv proc~matinv->proc~ludcmp proc~colrad colrad proc~colrad->proc~matinv proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate var panprocouterprodCalledByGraph = svgPanZoom('#procouterprodCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"RSWAP – Fortran Program","loc":"proc/rswap.html","text":"public subroutine RSWAP(a, b) Arguments Type Intent Optional Attributes Name real(kind=double) :: a real(kind=double) :: b Called By proc~~rswap~~CalledByGraph proc~rswap RSWAP proc~comabs comabs proc~comabs->proc~rswap proc~elmhes elmhes proc~elmhes->proc~rswap proc~balance balance proc~balance->proc~rswap proc~balback balback proc~balback->proc~rswap proc~eigen eigen proc~eigen->proc~elmhes proc~eigen->proc~balance proc~eigen->proc~balback proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate var panprocrswapCalledByGraph = svgPanZoom('#procrswapCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: t","tags":""},{"title":"balance – Fortran Program","loc":"proc/balance.html","text":"public subroutine balance(n, mat, scal, low, high) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=double) :: mat (0:n,0:n) real(kind=double) :: scal (0:n) integer, intent(out) :: low integer, intent(out) :: high Calls proc~~balance~~CallsGraph proc~balance balance proc~rswap RSWAP proc~balance->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~balance~~CalledByGraph proc~balance balance proc~eigen eigen proc~eigen->proc~balance proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: basis = 2 real(kind=double), public :: b2 real(kind=double), public :: r real(kind=double), public :: c real(kind=double), public :: f real(kind=double), public :: g real(kind=double), public :: s integer, public :: m integer, public :: k integer, public :: i integer, public :: j integer, public :: iter","tags":""},{"title":"balback – Fortran Program","loc":"proc/balback.html","text":"public subroutine balback(n, low, high, scal, eivec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(in) :: scal (0:n) real(kind=double), intent(inout) :: eivec (0:n,0:n) Calls proc~~balback~~CallsGraph proc~balback balback proc~rswap RSWAP proc~balback->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~balback~~CalledByGraph proc~balback balback proc~eigen eigen proc~eigen->proc~balback proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: s integer, public :: i integer, public :: j integer, public :: k","tags":""},{"title":"elmhes – Fortran Program","loc":"proc/elmhes.html","text":"public subroutine elmhes(n, low, high, mat, perm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(inout) :: mat (0:n,0:n) integer, intent(out) :: perm (0:n) Calls proc~~elmhes~~CallsGraph proc~elmhes elmhes proc~rswap RSWAP proc~elmhes->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~elmhes~~CalledByGraph proc~elmhes elmhes proc~eigen eigen proc~eigen->proc~elmhes proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: m real(kind=double), public :: x real(kind=double), public :: y","tags":""},{"title":"elmtrans – Fortran Program","loc":"proc/elmtrans.html","text":"public subroutine elmtrans(n, low, high, mat, perm, h) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(in) :: mat (0:n,0:n) integer, intent(in) :: perm (0:n) real(kind=double), intent(out) :: h (0:n,0:n) Called By proc~~elmtrans~~CalledByGraph proc~elmtrans elmtrans proc~eigen eigen proc~eigen->proc~elmtrans proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k","tags":""},{"title":"Comdiv – Fortran Program","loc":"proc/comdiv.html","text":"public subroutine Comdiv(ar, ai, br, bi, cr, ci, rc) Arguments Type Intent Optional Attributes Name real(kind=double) :: ar real(kind=double) :: ai real(kind=double) :: br real(kind=double) :: bi real(kind=double) :: cr real(kind=double) :: ci integer :: rc Called By proc~~comdiv~~CalledByGraph proc~comdiv Comdiv proc~hqrvec hqrvec proc~hqrvec->proc~comdiv proc~hqr2 hqr2 proc~hqr2->proc~hqrvec proc~eigen eigen proc~eigen->proc~hqr2 proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate var panproccomdivCalledByGraph = svgPanZoom('#proccomdivCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: tmp","tags":""},{"title":"hqrvec – Fortran Program","loc":"proc/hqrvec.html","text":"public subroutine hqrvec(n, low, high, h, wr, wi, eivec, rc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double) :: h (0:n,0:n) real(kind=double), intent(in) :: wr (0:n) real(kind=double), intent(in) :: wi (0:n) real(kind=double), intent(out) :: eivec (0:n,0:n) integer :: rc Calls proc~~hqrvec~~CallsGraph proc~hqrvec hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~hqrvec~~CalledByGraph proc~hqrvec hqrvec proc~hqr2 hqr2 proc~hqr2->proc~hqrvec proc~eigen eigen proc~eigen->proc~hqr2 proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate var panprochqrvecCalledByGraph = svgPanZoom('#prochqrvecCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: m integer, public :: k integer, public :: na integer, public :: l integer, public :: code integer, public :: en real(kind=double), public :: p real(kind=double), public :: q real(kind=double), public :: r real(kind=double), public :: s real(kind=double), public :: t real(kind=double), public :: w real(kind=double), public :: x real(kind=double), public :: y real(kind=double), public :: z real(kind=double), public :: ra real(kind=double), public :: sa real(kind=double), public :: vr real(kind=double), public :: vi real(kind=double), public :: norm real(kind=double), public :: temp","tags":""},{"title":"hqr2 – Fortran Program","loc":"proc/hqr2.html","text":"public subroutine hqr2(n, low, high, h, wr, wi, eivec, cnt, rc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(out) :: h (0:n,0:n) real(kind=double), intent(out) :: wr (0:n) real(kind=double), intent(out) :: wi (0:n) real(kind=double), intent(out) :: eivec (0:n,0:n) integer, intent(out) :: cnt (0:n) integer, intent(out) :: rc Calls proc~~hqr2~~CallsGraph proc~hqr2 hqr2 proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~hqr2~~CalledByGraph proc~hqr2 hqr2 proc~eigen eigen proc~eigen->proc~hqr2 proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: en integer, public :: i integer, public :: j integer, public :: na integer, public :: iter integer, public :: l integer, public :: ll integer, public :: m integer, public :: k real(kind=double), public :: p real(kind=double), public :: q real(kind=double), public :: r real(kind=double), public :: s real(kind=double), public :: t real(kind=double), public :: w real(kind=double), public :: x real(kind=double), public :: y real(kind=double), public :: z","tags":""},{"title":"eigen – Fortran Program","loc":"proc/eigen.html","text":"public subroutine eigen(n, matrix, eigvec, eigval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=double), intent(in), dimension(n,n) :: matrix real(kind=double), intent(out), dimension(n,n) :: eigvec real(kind=double), intent(out), dimension(n) :: eigval Calls proc~~eigen~~CallsGraph proc~eigen eigen proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~eigen~~CalledByGraph proc~eigen eigen proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: mat (0:n,0:n) real(kind=double), public :: eivec (0:n,0:n) real(kind=double), public :: valre (0:n) real(kind=double), public :: valim (0:n) integer, public :: rc integer, public :: cnt (0:n) integer, public :: high integer, public :: low real(kind=double), public :: d (0:n) real(kind=double), public :: scale (0:n) integer, public :: perm (0:n)","tags":""},{"title":"swap – Fortran Program","loc":"proc/swap.html","text":"public subroutine swap(a, b) Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:) :: a real(kind=double), intent(inout), dimension(:) :: b Called By proc~~swap~~CalledByGraph proc~swap swap proc~ludcmp ludcmp proc~ludcmp->proc~swap proc~matinv matinv proc~matinv->proc~ludcmp proc~colrad colrad proc~colrad->proc~matinv proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate var panprocswapCalledByGraph = svgPanZoom('#procswapCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(size(a)) :: dum","tags":""},{"title":"ludcmp – Fortran Program","loc":"proc/ludcmp.html","text":"public subroutine ludcmp(a, indx, d) Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:,:) :: a integer, intent(out), dimension(:) :: indx real(kind=double), intent(out) :: d Calls proc~~ludcmp~~CallsGraph proc~ludcmp ludcmp proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~ludcmp~~CalledByGraph proc~ludcmp ludcmp proc~matinv matinv proc~matinv->proc~ludcmp proc~colrad colrad proc~colrad->proc~matinv proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(size(a,1)) :: vv integer, public, dimension(1) :: imaxloc integer, public :: j integer, public :: n integer, public :: imax","tags":""},{"title":"lubksb – Fortran Program","loc":"proc/lubksb.html","text":"public subroutine lubksb(a, indx, b) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a integer, intent(in), dimension(:) :: indx real(kind=double), intent(inout), dimension(:) :: b Called By proc~~lubksb~~CalledByGraph proc~lubksb lubksb proc~matinv matinv proc~matinv->proc~lubksb proc~colrad colrad proc~colrad->proc~matinv proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: n integer, public :: ii integer, public :: ll real(kind=double), public :: summ","tags":""},{"title":"matinv – Fortran Program","loc":"proc/matinv.html","text":"public subroutine matinv(a, b) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a real(kind=double), intent(out), dimension(:,:) :: b Calls proc~~matinv~~CallsGraph proc~matinv matinv proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~matinv~~CalledByGraph proc~matinv matinv proc~colrad colrad proc~colrad->proc~matinv proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(size(a,dim=1),size(a,dim=2)) :: ah real(kind=double), public, dimension(size(a,dim=1),size(a,dim=2)) :: y integer, public :: i integer, public :: N integer, public, dimension(size(a,dim=1)) :: indx real(kind=double), public :: d","tags":""},{"title":"pp_add – Fortran Program","loc":"proc/pp_add.html","text":"public function pp_add(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) Called By proc~~pp_add~~CalledByGraph proc~pp_add pp_add interface~operator(+) operator(+) interface~operator(+)->proc~pp_add Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"pp_subtract – Fortran Program","loc":"proc/pp_subtract.html","text":"public function pp_subtract(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) Called By proc~~pp_subtract~~CalledByGraph proc~pp_subtract pp_subtract interface~operator(-) operator(-) interface~operator(-)->proc~pp_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lplp_add – Fortran Program","loc":"proc/lplp_add.html","text":"public function lplp_add(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) Called By proc~~lplp_add~~CalledByGraph proc~lplp_add lplp_add interface~operator(+) operator(+) interface~operator(+)->proc~lplp_add Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lplp_subtract – Fortran Program","loc":"proc/lplp_subtract.html","text":"public function lplp_subtract(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) Called By proc~~lplp_subtract~~CalledByGraph proc~lplp_subtract lplp_subtract interface~operator(-) operator(-) interface~operator(-)->proc~lplp_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"ps_multiply – Fortran Program","loc":"proc/ps_multiply.html","text":"public function ps_multiply(p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( Profiles ) Called By proc~~ps_multiply~~CalledByGraph proc~ps_multiply ps_multiply interface~operator(*) operator(*) interface~operator(*)->proc~ps_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"sp_multiply – Fortran Program","loc":"proc/sp_multiply.html","text":"public function sp_multiply(real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) Called By proc~~sp_multiply~~CalledByGraph proc~sp_multiply sp_multiply interface~operator(*) operator(*) interface~operator(*)->proc~sp_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"ps_divide – Fortran Program","loc":"proc/ps_divide.html","text":"public function ps_divide(p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( Profiles ) Called By proc~~ps_divide~~CalledByGraph proc~ps_divide ps_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~ps_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lps_multiply – Fortran Program","loc":"proc/lps_multiply.html","text":"public function lps_multiply(p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalProfiles ) Called By proc~~lps_multiply~~CalledByGraph proc~lps_multiply lps_multiply interface~operator(*) operator(*) interface~operator(*)->proc~lps_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"slp_multiply – Fortran Program","loc":"proc/slp_multiply.html","text":"public function slp_multiply(real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) Called By proc~~slp_multiply~~CalledByGraph proc~slp_multiply slp_multiply interface~operator(*) operator(*) interface~operator(*)->proc~slp_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lps_divide – Fortran Program","loc":"proc/lps_divide.html","text":"public function lps_divide(p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalProfiles ) Called By proc~~lps_divide~~CalledByGraph proc~lps_divide lps_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~lps_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"ff_add – Fortran Program","loc":"proc/ff_add.html","text":"public function ff_add(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) Called By proc~~ff_add~~CalledByGraph proc~ff_add ff_add interface~operator(+) operator(+) interface~operator(+)->proc~ff_add Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"ff_subtract – Fortran Program","loc":"proc/ff_subtract.html","text":"public function ff_subtract(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) Called By proc~~ff_subtract~~CalledByGraph proc~ff_subtract ff_subtract interface~operator(-) operator(-) interface~operator(-)->proc~ff_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"fs_multiply – Fortran Program","loc":"proc/fs_multiply.html","text":"public function fs_multiply(p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( EMFields ) Called By proc~~fs_multiply~~CalledByGraph proc~fs_multiply fs_multiply interface~operator(*) operator(*) interface~operator(*)->proc~fs_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"sf_multiply – Fortran Program","loc":"proc/sf_multiply.html","text":"public function sf_multiply(real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) Called By proc~~sf_multiply~~CalledByGraph proc~sf_multiply sf_multiply interface~operator(*) operator(*) interface~operator(*)->proc~sf_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"fs_divide – Fortran Program","loc":"proc/fs_divide.html","text":"public function fs_divide(p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( EMFields ) Called By proc~~fs_divide~~CalledByGraph proc~fs_divide fs_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~fs_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lflf_add – Fortran Program","loc":"proc/lflf_add.html","text":"public function lflf_add(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) Called By proc~~lflf_add~~CalledByGraph proc~lflf_add lflf_add interface~operator(+) operator(+) interface~operator(+)->proc~lflf_add Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lflf_subtract – Fortran Program","loc":"proc/lflf_subtract.html","text":"public function lflf_subtract(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) Called By proc~~lflf_subtract~~CalledByGraph proc~lflf_subtract lflf_subtract interface~operator(-) operator(-) interface~operator(-)->proc~lflf_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lfs_multiply – Fortran Program","loc":"proc/lfs_multiply.html","text":"public function lfs_multiply(p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalEMFields ) Called By proc~~lfs_multiply~~CalledByGraph proc~lfs_multiply lfs_multiply interface~operator(*) operator(*) interface~operator(*)->proc~lfs_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"slf_multiply – Fortran Program","loc":"proc/slf_multiply.html","text":"public function slf_multiply(real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields ) Called By proc~~slf_multiply~~CalledByGraph proc~slf_multiply slf_multiply interface~operator(*) operator(*) interface~operator(*)->proc~slf_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lfs_divide – Fortran Program","loc":"proc/lfs_divide.html","text":"public function lfs_divide(p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalEMFields ) Called By proc~~lfs_divide~~CalledByGraph proc~lfs_divide lfs_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~lfs_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"cross_product – Fortran Program","loc":"proc/cross_product.html","text":"public function cross_product(u, v) result(s) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: u real(kind=double), intent(in), dimension(3) :: v Return Value real(kind=double),\n  dimension(3) Called By proc~~cross_product~~CalledByGraph proc~cross_product cross_product proc~plane_basis plane_basis proc~plane_basis->proc~cross_product proc~gyro_correction gyro_correction proc~gyro_correction->proc~cross_product proc~read_npa read_npa proc~read_npa->proc~plane_basis program~fidasim fidasim program~fidasim->proc~read_npa proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~gyro_correction proc~npa_mc->proc~gyro_correction proc~fida_weights_mc->proc~gyro_correction proc~mc_fastion mc_fastion proc~mc_fastion->proc~gyro_correction proc~fida_mc->proc~gyro_correction proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"normp – Fortran Program","loc":"proc/normp.html","text":"public function normp(u, p_in) result(n) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: u integer, intent(in), optional :: p_in Return Value real(kind=double) Called By proc~~normp~~CalledByGraph proc~normp normp proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~normp proc~get_fields get_fields proc~fida_weights_los->proc~get_fields proc~neut_rates neut_rates proc~fida_weights_los->proc~neut_rates proc~calc_perp_vectors calc_perp_vectors proc~fida_weights_los->proc~calc_perp_vectors proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~fida_weights_los->proc~store_fw_photons_at_chan proc~get_fields->proc~normp proc~get_fields->proc~calc_perp_vectors proc~npa_weights npa_weights proc~npa_weights->proc~normp proc~npa_weights->proc~get_fields proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~get_beam_cx_prob get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~attenuate->proc~normp proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~normp proc~neut_rates->proc~normp proc~read_chords read_chords proc~read_chords->proc~normp proc~spectrum spectrum proc~spectrum->proc~normp proc~plane_basis plane_basis proc~plane_basis->proc~normp proc~mc_nbi mc_nbi proc~mc_nbi->proc~normp proc~read_rates read_rates proc~read_rates->proc~normp proc~store_npa store_npa proc~store_npa->proc~normp proc~store_npa->proc~get_fields proc~calc_perp_vectors->proc~normp proc~read_npa read_npa proc~read_npa->proc~normp proc~read_npa->proc~plane_basis proc~get_beam_cx_prob->proc~normp proc~get_beam_cx_prob->proc~neut_rates program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~npa_weights program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_chords program~fidasim->proc~read_npa proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~ndmc ndmc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~read_tables read_tables program~fidasim->proc~read_tables proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~store_fw_photons->proc~store_fw_photons_at_chan proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~get_fields proc~store_bes_photons->proc~spectrum proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_fields proc~store_fida_photons->proc~get_fields proc~store_fida_photons->proc~spectrum proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_beam_cx_prob proc~fida_weights_mc->proc~store_fw_photons proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~store_npa proc~npa_mc->proc~get_beam_cx_prob proc~halo->proc~get_beam_cx_prob proc~halo->proc~store_bes_photons proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~ndmc->proc~mc_nbi proc~ndmc->proc~store_bes_photons proc~fida_f->proc~get_beam_cx_prob proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~npa_f->proc~attenuate proc~npa_f->proc~store_npa proc~npa_f->proc~get_beam_cx_prob proc~npa_f->proc~mc_fastion proc~store_fw_photons_at_chan->proc~spectrum proc~read_tables->proc~read_rates var panprocnormpCalledByGraph = svgPanZoom('#procnormpCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: p","tags":""},{"title":"in_boundary – Fortran Program","loc":"proc/in_boundary.html","text":"public function in_boundary(bplane, p) result(in_b) Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane real(kind=double), intent(in), dimension(3) :: p Return Value logical Called By proc~~in_boundary~~CalledByGraph proc~in_boundary in_boundary proc~hit_npa_detector hit_npa_detector proc~hit_npa_detector->proc~in_boundary proc~npa_weights npa_weights proc~npa_weights->proc~hit_npa_detector proc~read_npa read_npa proc~read_npa->proc~hit_npa_detector proc~npa_mc npa_mc proc~npa_mc->proc~hit_npa_detector proc~npa_f npa_f proc~npa_f->proc~hit_npa_detector program~fidasim fidasim program~fidasim->proc~npa_weights program~fidasim->proc~read_npa program~fidasim->proc~npa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: pp real(kind=double), public :: hh real(kind=double), public :: hw","tags":""},{"title":"print_banner – Fortran Program","loc":"proc/print_banner.html","text":"public subroutine print_banner() Arguments None Called By proc~~print_banner~~CalledByGraph proc~print_banner print_banner program~fidasim fidasim program~fidasim->proc~print_banner Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"fast_ion_assign – Fortran Program","loc":"proc/fast_ion_assign.html","text":"public subroutine fast_ion_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 Called By proc~~fast_ion_assign~~CalledByGraph proc~fast_ion_assign fast_ion_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~fast_ion_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"npa_part_assign – Fortran Program","loc":"proc/npa_part_assign.html","text":"public subroutine npa_part_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 Called By proc~~npa_part_assign~~CalledByGraph proc~npa_part_assign npa_part_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~npa_part_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"pp_assign – Fortran Program","loc":"proc/pp_assign.html","text":"public subroutine pp_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(out) :: p1 type( Profiles ), intent(in) :: p2 Called By proc~~pp_assign~~CalledByGraph proc~pp_assign pp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~pp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lpp_assign – Fortran Program","loc":"proc/lpp_assign.html","text":"public subroutine lpp_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: p1 type( Profiles ), intent(in) :: p2 Called By proc~~lpp_assign~~CalledByGraph proc~lpp_assign lpp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lpp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"plp_assign – Fortran Program","loc":"proc/plp_assign.html","text":"public subroutine plp_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(out) :: p1 type( LocalProfiles ), intent(in) :: p2 Called By proc~~plp_assign~~CalledByGraph proc~plp_assign plp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~plp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lplp_assign – Fortran Program","loc":"proc/lplp_assign.html","text":"public subroutine lplp_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: p1 type( LocalProfiles ), intent(in) :: p2 Called By proc~~lplp_assign~~CalledByGraph proc~lplp_assign lplp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lplp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"ff_assign – Fortran Program","loc":"proc/ff_assign.html","text":"public subroutine ff_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(out) :: p1 type( EMFields ), intent(in) :: p2 Called By proc~~ff_assign~~CalledByGraph proc~ff_assign ff_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~ff_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lff_assign – Fortran Program","loc":"proc/lff_assign.html","text":"public subroutine lff_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: p1 type( EMFields ), intent(in) :: p2 Called By proc~~lff_assign~~CalledByGraph proc~lff_assign lff_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lff_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"flf_assign – Fortran Program","loc":"proc/flf_assign.html","text":"public subroutine flf_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(out) :: p1 type( LocalEMFields ), intent(in) :: p2 Called By proc~~flf_assign~~CalledByGraph proc~flf_assign flf_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~flf_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"lflf_assign – Fortran Program","loc":"proc/lflf_assign.html","text":"public subroutine lflf_assign(p1, p2) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: p1 type( LocalEMFields ), intent(in) :: p2 Called By proc~~lflf_assign~~CalledByGraph proc~lflf_assign lflf_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lflf_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"read_inputs – Fortran Program","loc":"proc/read_inputs.html","text":"public subroutine read_inputs() Arguments None Called By proc~~read_inputs~~CalledByGraph proc~read_inputs read_inputs program~fidasim fidasim program~fidasim->proc~read_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=120), public :: runid character(len=120), public :: version character(len=120), public :: result_dir character(len=120), public :: tables_file character(len=120), public :: distribution_file character(len=120), public :: equilibrium_file character(len=120), public :: geometry_file character(len=120), public :: neutrals_file integer, public :: calc_brems integer, public :: calc_bes integer, public :: calc_fida integer, public :: calc_npa integer, public :: calc_birth integer, public :: calc_fida_wght integer, public :: calc_npa_wght integer, public :: load_neutrals integer, public :: verbose integer, public :: dump_dcx integer(kind=long), public :: shot integer(kind=long), public :: n_fida integer(kind=long), public :: n_npa integer(kind=long), public :: n_nbi integer(kind=long), public :: n_halo integer(kind=long), public :: n_dcx integer(kind=long), public :: n_birth integer(kind=long), public :: nlambda integer(kind=long), public :: ne_wght integer(kind=long), public :: np_wght integer(kind=long), public :: nphi_wght integer(kind=long), public :: nlambda_wght real(kind=double), public :: time real(kind=double), public :: lambdamin real(kind=double), public :: lambdamax real(kind=double), public :: emax_wght real(kind=double), public :: lambdamin_wght real(kind=double), public :: lambdamax_wght real(kind=double), public :: ai real(kind=double), public :: ab real(kind=double), public :: pinj real(kind=double), public :: einj real(kind=double), public :: species_mix (3) integer(kind=long), public :: impurity_charge integer(kind=long), public :: nx integer(kind=long), public :: ny integer(kind=long), public :: nz real(kind=double), public :: xmin real(kind=double), public :: xmax real(kind=double), public :: ymin real(kind=double), public :: ymax real(kind=double), public :: zmin real(kind=double), public :: zmax real(kind=double), public :: alpha real(kind=double), public :: beta real(kind=double), public :: gamma real(kind=double), public :: origin (3) logical, public :: exis logical, public :: error","tags":""},{"title":"make_beam_grid – Fortran Program","loc":"proc/make_beam_grid.html","text":"public subroutine make_beam_grid() Arguments None Calls proc~~make_beam_grid~~CallsGraph proc~make_beam_grid make_beam_grid proc~tb_zyx tb_zyx proc~make_beam_grid->proc~tb_zyx Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~make_beam_grid~~CalledByGraph proc~make_beam_grid make_beam_grid program~fidasim fidasim program~fidasim->proc~make_beam_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=long), public :: i real(kind=double), public :: dx real(kind=double), public :: dy real(kind=double), public :: dz","tags":""},{"title":"read_beam – Fortran Program","loc":"proc/read_beam.html","text":"public subroutine read_beam() Arguments None Calls proc~~read_beam~~CallsGraph proc~read_beam read_beam h5fclose_f h5fclose_f proc~read_beam->h5fclose_f h5gclose_f h5gclose_f proc~read_beam->h5gclose_f proc~uvw_to_xyz uvw_to_xyz proc~read_beam->proc~uvw_to_xyz h5open_f h5open_f proc~read_beam->h5open_f h5close_f h5close_f proc~read_beam->h5close_f proc~tb_zyx tb_zyx proc~read_beam->proc~tb_zyx proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_beam->proc~h5ltread_dataset_double_scalar_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_beam->proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_beam->h5ltread_dataset_string_f h5fopen_f h5fopen_f proc~read_beam->h5fopen_f h5gopen_f h5gopen_f proc~read_beam->h5gopen_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_beam->h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_beam~~CalledByGraph proc~read_beam read_beam program~fidasim fidasim program~fidasim->proc~read_beam Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(1) :: dims real(kind=double), public, dimension(3) :: uvw_src real(kind=double), public, dimension(3) :: uvw_axis real(kind=double), public, dimension(3) :: pos real(kind=double), public :: dis integer, public :: error","tags":""},{"title":"read_chords – Fortran Program","loc":"proc/read_chords.html","text":"public subroutine read_chords() Arguments None Calls proc~~read_chords~~CallsGraph proc~read_chords read_chords proc~line_basis line_basis proc~read_chords->proc~line_basis h5fclose_f h5fclose_f proc~read_chords->h5fclose_f h5gclose_f h5gclose_f proc~read_chords->h5gclose_f proc~uvw_to_xyz uvw_to_xyz proc~read_chords->proc~uvw_to_xyz h5open_f h5open_f proc~read_chords->h5open_f h5close_f h5close_f proc~read_chords->h5close_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_chords->proc~h5ltread_dataset_int_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_chords->h5ltpath_valid_f proc~randu randu proc~read_chords->proc~randu proc~track track proc~read_chords->proc~track h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_chords->h5ltread_dataset_string_f h5fopen_f h5fopen_f proc~read_chords->h5fopen_f proc~grid_intersect grid_intersect proc~read_chords->proc~grid_intersect h5gopen_f h5gopen_f proc~read_chords->h5gopen_f proc~normp normp proc~read_chords->proc~normp h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_chords->h5ltread_dataset_double_f proc~tb_zyx tb_zyx proc~line_basis->proc~tb_zyx h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~get_indices get_indices proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma interface~interpol interpol proc~in_plasma->interface~interpol proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocread_chordsCallsGraph = svgPanZoom('#procread_chordsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_chords~~CalledByGraph proc~read_chords read_chords program~fidasim fidasim program~fidasim->proc~read_chords Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(2) :: dims logical, public :: path_valid real(kind=double), public, dimension(:,:), allocatable :: lenses real(kind=double), public, dimension(:,:), allocatable :: axes real(kind=double), public, dimension(:), allocatable :: spot_size real(kind=double), public, dimension(:), allocatable :: sigma_pi real(kind=double), public :: r0 (3) real(kind=double), public :: v0 (3) real(kind=double), public :: r_enter (3) real(kind=double), public :: r_exit (3) real(kind=double), public :: xyz_lens (3) real(kind=double), public :: xyz_axis (3) real(kind=double), public :: length real(kind=double), public, dimension(3,3) :: basis real(kind=double), public, dimension(2) :: randomu real(kind=double), public :: theta real(kind=double), public :: sqrt_rho type( ParticleTrack ), public, dimension(beam_grid%ntrack) :: tracks character(len=20), public :: system = '' integer, public :: i integer, public :: j integer, public :: ic integer, public :: nc integer, public :: ncell integer, public :: ind (3) integer, public :: error","tags":""},{"title":"read_npa – Fortran Program","loc":"proc/read_npa.html","text":"public subroutine read_npa() Arguments None Calls proc~~read_npa~~CallsGraph proc~read_npa read_npa h5fclose_f h5fclose_f proc~read_npa->h5fclose_f h5gclose_f h5gclose_f proc~read_npa->h5gclose_f proc~uvw_to_xyz uvw_to_xyz proc~read_npa->proc~uvw_to_xyz h5open_f h5open_f proc~read_npa->h5open_f h5close_f h5close_f proc~read_npa->h5close_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_npa->proc~h5ltread_dataset_int_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_npa->h5ltpath_valid_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_npa->h5ltread_dataset_int_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_npa->h5ltread_dataset_string_f h5fopen_f h5fopen_f proc~read_npa->h5fopen_f proc~xyz_to_uvw xyz_to_uvw proc~read_npa->proc~xyz_to_uvw h5gopen_f h5gopen_f proc~read_npa->h5gopen_f proc~normp normp proc~read_npa->proc~normp proc~plane_basis plane_basis proc~read_npa->proc~plane_basis h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_npa->h5ltread_dataset_double_f proc~hit_npa_detector hit_npa_detector proc~read_npa->proc~hit_npa_detector proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~plane_basis->proc~normp proc~cross_product cross_product proc~plane_basis->proc~cross_product proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~plane_intercept plane_intercept proc~hit_npa_detector->proc~plane_intercept Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_npa~~CalledByGraph proc~read_npa read_npa program~fidasim fidasim program~fidasim->proc~read_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(2) :: dims logical, public :: path_valid real(kind=double), public, dimension(:,:), allocatable :: a_tedge real(kind=double), public, dimension(:,:), allocatable :: a_redge real(kind=double), public, dimension(:,:), allocatable :: a_cent real(kind=double), public, dimension(:,:), allocatable :: d_tedge real(kind=double), public, dimension(:,:), allocatable :: d_redge real(kind=double), public, dimension(:,:), allocatable :: d_cent integer, public, dimension(:), allocatable :: a_shape integer, public, dimension(:), allocatable :: d_shape character(len=20), public :: system = '' real(kind=double), public, dimension(3) :: xyz_a_tedge real(kind=double), public, dimension(3) :: xyz_a_redge real(kind=double), public, dimension(3) :: xyz_a_cent real(kind=double), public, dimension(3) :: xyz_d_tedge real(kind=double), public, dimension(3) :: xyz_d_redge real(kind=double), public, dimension(3) :: xyz_d_cent real(kind=double), public, dimension(3) :: eff_rd real(kind=double), public, dimension(3) :: rd real(kind=double), public, dimension(3) :: rd_d real(kind=double), public, dimension(3) :: r0 real(kind=double), public, dimension(3) :: r0_d real(kind=double), public, dimension(3) :: v0 real(kind=double), public, dimension(3,3) :: basis real(kind=double), public, dimension(3,3) :: inv_basis real(kind=double), public, dimension(50) :: xd real(kind=double), public, dimension(50) :: yd real(kind=double), public, dimension(:,:,:,:,:), allocatable :: effrd real(kind=double), public, dimension(:,:,:,:), allocatable :: phit real(kind=double), public :: total_prob real(kind=double), public :: hh real(kind=double), public :: hw real(kind=double), public :: dprob real(kind=double), public :: dx real(kind=double), public :: dy real(kind=double), public :: r integer, public :: ichan integer, public :: i integer, public :: j integer, public :: k integer, public :: ix integer, public :: iy integer, public :: d_index integer, public :: nd integer, public :: cnt integer, public :: error","tags":""},{"title":"read_equilibrium – Fortran Program","loc":"proc/read_equilibrium.html","text":"public subroutine read_equilibrium() Arguments None Calls proc~~read_equilibrium~~CallsGraph proc~read_equilibrium read_equilibrium h5fclose_f h5fclose_f proc~read_equilibrium->h5fclose_f h5gclose_f h5gclose_f proc~read_equilibrium->h5gclose_f h5open_f h5open_f proc~read_equilibrium->h5open_f h5close_f h5close_f proc~read_equilibrium->h5close_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_equilibrium->proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_equilibrium->h5ltread_dataset_int_f h5fopen_f h5fopen_f proc~read_equilibrium->h5fopen_f h5gopen_f h5gopen_f proc~read_equilibrium->h5gopen_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_equilibrium->h5ltread_dataset_double_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_equilibrium~~CalledByGraph proc~read_equilibrium read_equilibrium program~fidasim fidasim program~fidasim->proc~read_equilibrium Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(2) :: dims integer, public :: impc integer, public :: error integer, public, dimension(:,:), allocatable :: p_mask integer, public, dimension(:,:), allocatable :: f_mask","tags":""},{"title":"read_f – Fortran Program","loc":"proc/read_f.html","text":"public subroutine read_f(fid, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid integer, intent(out) :: error Calls proc~~read_f~~CallsGraph proc~read_f read_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_f->h5ltread_dataset_double_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_f->proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_f~~CalledByGraph proc~read_f read_f proc~read_distribution read_distribution proc~read_distribution->proc~read_f program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HSIZE_T), public, dimension(4) :: dims real(kind=double), public :: dummy (1)","tags":""},{"title":"read_mc – Fortran Program","loc":"proc/read_mc.html","text":"public subroutine read_mc(fid, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid integer, intent(out) :: error Calls proc~~read_mc~~CallsGraph proc~read_mc read_mc h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_mc->h5ltread_dataset_int_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_mc->h5ltread_dataset_double_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~uvw_to_xyz uvw_to_xyz proc~read_mc->proc~uvw_to_xyz proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_mc~~CalledByGraph proc~read_mc read_mc proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HSIZE_T), public, dimension(1) :: dims integer(kind=long), public :: i integer(kind=long), public :: ii integer(kind=long), public :: ir integer(kind=long), public :: iz integer(kind=long), public :: nphi real(kind=double), public :: phi real(kind=double), public :: xmin real(kind=double), public :: xmax real(kind=double), public :: ymin real(kind=double), public :: ymax real(kind=double), public :: zmin real(kind=double), public :: zmax real(kind=double), public :: phi_enter real(kind=double), public :: delta_phi real(kind=double), public, dimension(3) :: uvw real(kind=double), public, dimension(3) :: xyz integer(kind=long), public, dimension(1) :: minpos logical, public :: in_grid real(kind=double), public, dimension(:), allocatable :: weight real(kind=double), public, dimension(:), allocatable :: r real(kind=double), public, dimension(:), allocatable :: z real(kind=double), public, dimension(:), allocatable :: vr real(kind=double), public, dimension(:), allocatable :: vt real(kind=double), public, dimension(:), allocatable :: vz real(kind=double), public, dimension(:), allocatable :: energy real(kind=double), public, dimension(:), allocatable :: pitch integer(kind=long), public, dimension(:), allocatable :: orbit_class integer, public :: cnt integer, public :: num character(len=32), public :: dist_type_name = ''","tags":""},{"title":"read_distribution – Fortran Program","loc":"proc/read_distribution.html","text":"public subroutine read_distribution() Arguments None Calls proc~~read_distribution~~CallsGraph proc~read_distribution read_distribution proc~read_f read_f proc~read_distribution->proc~read_f h5fclose_f h5fclose_f proc~read_distribution->h5fclose_f h5open_f h5open_f proc~read_distribution->h5open_f h5close_f h5close_f proc~read_distribution->h5close_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_distribution->proc~h5ltread_dataset_int_scalar_f h5fopen_f h5fopen_f proc~read_distribution->h5fopen_f proc~read_mc read_mc proc~read_distribution->proc~read_mc proc~read_f->proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_f->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~read_mc->h5ltread_dataset_double_f proc~read_mc->h5ltread_dataset_int_f proc~uvw_to_xyz uvw_to_xyz proc~read_mc->proc~uvw_to_xyz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_distribution~~CalledByGraph proc~read_distribution read_distribution program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer, public :: error","tags":""},{"title":"read_cross – Fortran Program","loc":"proc/read_cross.html","text":"public subroutine read_cross(fid, grp, cross) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid character(len=*), intent(in) :: grp type( AtomicCrossSection ), intent(inout) :: cross Calls proc~~read_cross~~CallsGraph proc~read_cross read_cross h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_cross->h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_cross->proc~h5ltread_dataset_double_scalar_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_cross->proc~h5ltread_dataset_int_scalar_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_cross~~CalledByGraph proc~read_cross read_cross proc~read_tables read_tables proc~read_tables->proc~read_cross program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HSIZE_T), public, dimension(3) :: dim3 real(kind=double), public :: emin real(kind=double), public :: emax real(kind=double), public :: rmin integer, public :: i integer, public :: n_max integer, public :: m_max integer, public :: error real(kind=double), public, dimension(:,:,:), allocatable :: dummy3","tags":""},{"title":"read_rates – Fortran Program","loc":"proc/read_rates.html","text":"public subroutine read_rates(fid, grp, b_amu, t_amu, rates) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid character(len=*), intent(in) :: grp real(kind=double), intent(in), dimension(2) :: b_amu real(kind=double), intent(in) :: t_amu type( AtomicRates ), intent(inout) :: rates Calls proc~~read_rates~~CallsGraph proc~read_rates read_rates proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_rates->proc~h5ltread_dataset_double_scalar_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_rates->proc~h5ltread_dataset_int_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_rates->h5ltpath_valid_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_rates->h5ltget_dataset_ndims_f proc~normp normp proc~read_rates->proc~normp h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_rates->h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_rates~~CalledByGraph proc~read_rates read_rates proc~read_tables read_tables proc~read_tables->proc~read_rates program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(4) :: dim4 integer(kind=HSIZE_T), public, dimension(5) :: dim5 logical, public :: path_valid integer, public :: i integer, public :: j integer, public :: n integer, public :: n_max integer, public :: m_max integer, public :: error integer, public :: n_bt_amu integer, public :: tt_ind integer, public :: bt_ind integer, public :: drank real(kind=double), public :: emin real(kind=double), public :: emax real(kind=double), public :: tmin real(kind=double), public :: tmax real(kind=double), public :: rmin real(kind=double), public :: bt_min real(kind=double), public :: tt_min real(kind=double), public :: tt_dum real(kind=double), public :: bt_dum real(kind=double), public, dimension(2) :: bt_amu real(kind=double), public, dimension(2) :: tt_amu real(kind=double), public, dimension(:,:), allocatable :: dummy2 real(kind=double), public, dimension(:,:,:,:), allocatable :: dummy4 real(kind=double), public, dimension(:,:,:,:,:), allocatable :: dummy5","tags":""},{"title":"read_tables – Fortran Program","loc":"proc/read_tables.html","text":"public subroutine read_tables() Arguments None Calls proc~~read_tables~~CallsGraph proc~read_tables read_tables proc~read_cross read_cross proc~read_tables->proc~read_cross h5fclose_f h5fclose_f proc~read_tables->h5fclose_f h5open_f h5open_f proc~read_tables->h5open_f h5close_f h5close_f proc~read_tables->h5close_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_tables->proc~h5ltread_dataset_int_scalar_f h5fopen_f h5fopen_f proc~read_tables->h5fopen_f proc~read_rates read_rates proc~read_tables->proc~read_rates h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_tables->h5ltread_dataset_double_f proc~read_cross->proc~h5ltread_dataset_int_scalar_f proc~read_cross->h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_cross->proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~read_rates->proc~h5ltread_dataset_int_scalar_f proc~read_rates->h5ltread_dataset_double_f proc~read_rates->proc~h5ltread_dataset_double_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_rates->h5ltpath_valid_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_rates->h5ltget_dataset_ndims_f proc~normp normp proc~read_rates->proc~normp proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_tables~~CalledByGraph proc~read_tables read_tables program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer, public :: error integer, public :: n_max integer, public :: m_max character(len=4), public :: impname real(kind=double), public :: imp_amu real(kind=double), public, dimension(2) :: b_amu real(kind=double), public, dimension(:,:), allocatable :: dummy2","tags":""},{"title":"write_beam_grid – Fortran Program","loc":"proc/write_beam_grid.html","text":"public subroutine write_beam_grid(id, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id integer, intent(out) :: error Calls proc~~write_beam_grid~~CallsGraph proc~write_beam_grid write_beam_grid h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_beam_grid->h5ltmake_dataset_int_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_beam_grid->h5ltset_attribute_string_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f var panprocwrite_beam_gridCallsGraph = svgPanZoom('#procwrite_beam_gridCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_beam_grid~~CalledByGraph proc~write_beam_grid write_beam_grid proc~write_npa_weights write_npa_weights proc~write_npa_weights->proc~write_beam_grid proc~write_neutrals write_neutrals proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->proc~write_beam_grid proc~write_dcx write_dcx proc~write_dcx->proc~write_beam_grid proc~npa_weights npa_weights proc~npa_weights->proc~write_npa_weights program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_dcx program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(3) :: dims real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: u_grid real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: v_grid real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: w_grid real(kind=double), public :: xyz (3) real(kind=double), public :: uvw (3) integer, public :: i integer, public :: j integer, public :: k","tags":""},{"title":"write_birth_profile – Fortran Program","loc":"proc/write_birth_profile.html","text":"public subroutine write_birth_profile() Arguments None Calls proc~~write_birth_profile~~CallsGraph proc~write_birth_profile write_birth_profile h5fcreate_f h5fcreate_f proc~write_birth_profile->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_birth_profile->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_birth_profile->h5fclose_f h5open_f h5open_f proc~write_birth_profile->h5open_f h5close_f h5close_f proc~write_birth_profile->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_birth_profile->h5ltset_attribute_string_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~xyz_to_uvw xyz_to_uvw proc~write_birth_profile->proc~xyz_to_uvw proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~write_beam_grid->h5ltmake_dataset_int_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->proc~xyz_to_uvw h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f var panprocwrite_birth_profileCallsGraph = svgPanZoom('#procwrite_birth_profileCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_birth_profile~~CalledByGraph proc~write_birth_profile write_birth_profile program~fidasim fidasim program~fidasim->proc~write_birth_profile Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HSIZE_T), public, dimension(4) :: dim4 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(1) :: d integer, public :: error integer, public :: i character(len=120), public :: filename real(kind=double), public, dimension(:,:), allocatable :: ri real(kind=double), public, dimension(:,:), allocatable :: vi real(kind=double), public, dimension(3) :: xyz real(kind=double), public, dimension(3) :: uvw real(kind=double), public, dimension(3) :: v_uvw","tags":""},{"title":"write_dcx – Fortran Program","loc":"proc/write_dcx.html","text":"public subroutine write_dcx() Arguments None Calls proc~~write_dcx~~CallsGraph proc~write_dcx write_dcx h5fcreate_f h5fcreate_f proc~write_dcx->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_dcx->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_dcx->h5fclose_f h5open_f h5open_f proc~write_dcx->h5open_f h5close_f h5close_f proc~write_dcx->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_dcx->proc~write_beam_grid h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_dcx->h5ltset_attribute_string_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~write_beam_grid->h5ltmake_dataset_int_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f var panprocwrite_dcxCallsGraph = svgPanZoom('#procwrite_dcxCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_dcx~~CalledByGraph proc~write_dcx write_dcx program~fidasim fidasim program~fidasim->proc~write_dcx Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HSIZE_T), public, dimension(4) :: dims integer(kind=HSIZE_T), public, dimension(1) :: d integer, public :: error character(len=120), public :: filename integer, public :: i real(kind=double), public, dimension(:), allocatable :: lambda_arr real(kind=double), public, dimension(:,:), allocatable :: dcx_spec","tags":""},{"title":"write_neutrals – Fortran Program","loc":"proc/write_neutrals.html","text":"public subroutine write_neutrals() Arguments None Calls proc~~write_neutrals~~CallsGraph proc~write_neutrals write_neutrals h5fcreate_f h5fcreate_f proc~write_neutrals->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrals->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_neutrals->h5fclose_f h5open_f h5open_f proc~write_neutrals->h5open_f h5close_f h5close_f proc~write_neutrals->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrals->h5ltset_attribute_string_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~write_beam_grid->h5ltmake_dataset_int_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f var panprocwrite_neutralsCallsGraph = svgPanZoom('#procwrite_neutralsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_neutrals~~CalledByGraph proc~write_neutrals write_neutrals program~fidasim fidasim program~fidasim->proc~write_neutrals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HSIZE_T), public, dimension(4) :: dims integer(kind=HSIZE_T), public, dimension(1) :: d integer, public :: error","tags":""},{"title":"write_npa – Fortran Program","loc":"proc/write_npa.html","text":"public subroutine write_npa() Arguments None Calls proc~~write_npa~~CallsGraph proc~write_npa write_npa h5fcreate_f h5fcreate_f proc~write_npa->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_npa->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_npa->h5fclose_f h5gcreate_f h5gcreate_f proc~write_npa->h5gcreate_f h5gclose_f h5gclose_f proc~write_npa->h5gclose_f h5open_f h5open_f proc~write_npa->h5open_f h5close_f h5close_f proc~write_npa->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_npa->interface~h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_npa->interface~h5ltmake_compressed_dataset_int_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_npa->h5ltset_attribute_string_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f var panprocwrite_npaCallsGraph = svgPanZoom('#procwrite_npaCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_npa~~CalledByGraph proc~write_npa write_npa program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(1) :: d integer, public :: error integer, public, dimension(:), allocatable :: dcount real(kind=double), public, dimension(:,:), allocatable :: ri real(kind=double), public, dimension(:,:), allocatable :: rf integer, public :: i integer, public :: n character(len=120), public :: filename = ''","tags":""},{"title":"write_spectra – Fortran Program","loc":"proc/write_spectra.html","text":"public subroutine write_spectra() Arguments None Calls proc~~write_spectra~~CallsGraph proc~write_spectra write_spectra h5fcreate_f h5fcreate_f proc~write_spectra->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_spectra->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_spectra->h5fclose_f h5open_f h5open_f proc~write_spectra->h5open_f h5close_f h5close_f proc~write_spectra->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_spectra->h5ltset_attribute_string_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f var panprocwrite_spectraCallsGraph = svgPanZoom('#procwrite_spectraCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_spectra~~CalledByGraph proc~write_spectra write_spectra program~fidasim fidasim program~fidasim->proc~write_spectra Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HSIZE_T), public, dimension(3) :: dims integer(kind=HSIZE_T), public, dimension(1) :: d integer, public :: error character(len=120), public :: filename integer, public :: i real(kind=double), public, dimension(:), allocatable :: lambda_arr","tags":""},{"title":"write_fida_weights – Fortran Program","loc":"proc/write_fida_weights.html","text":"public subroutine write_fida_weights() Arguments None Calls proc~~write_fida_weights~~CallsGraph proc~write_fida_weights write_fida_weights h5fcreate_f h5fcreate_f proc~write_fida_weights->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_fida_weights->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_fida_weights->h5fclose_f h5open_f h5open_f proc~write_fida_weights->h5open_f h5close_f h5close_f proc~write_fida_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_fida_weights->h5ltset_attribute_string_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f var panprocwrite_fida_weightsCallsGraph = svgPanZoom('#procwrite_fida_weightsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_fida_weights~~CalledByGraph proc~write_fida_weights write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HSIZE_T), public, dimension(4) :: dim4 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(1) :: dim1 integer, public :: error character(len=120), public :: filename integer, public :: i integer, public :: ie integer, public :: ip integer, public :: ic real(kind=double), public, dimension(:), allocatable :: lambda_arr real(kind=double), public, dimension(:), allocatable :: ebarr real(kind=double), public, dimension(:), allocatable :: ptcharr real(kind=double), public, dimension(:,:), allocatable :: jacobian real(kind=double), public, dimension(:,:), allocatable :: e_grid real(kind=double), public, dimension(:,:), allocatable :: p_grid real(kind=double), public, dimension(:,:), allocatable :: vpa_grid real(kind=double), public, dimension(:,:), allocatable :: vpe_grid real(kind=double), public :: dlambda real(kind=double), public :: wtot real(kind=double), public :: dE real(kind=double), public :: dP","tags":""},{"title":"write_npa_weights – Fortran Program","loc":"proc/write_npa_weights.html","text":"public subroutine write_npa_weights() Arguments None Calls proc~~write_npa_weights~~CallsGraph proc~write_npa_weights write_npa_weights h5fcreate_f h5fcreate_f proc~write_npa_weights->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_npa_weights->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_npa_weights->h5fclose_f h5open_f h5open_f proc~write_npa_weights->h5open_f h5close_f h5close_f proc~write_npa_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_npa_weights->proc~write_beam_grid h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_npa_weights->h5ltset_attribute_string_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~write_beam_grid->h5ltmake_dataset_int_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f var panprocwrite_npa_weightsCallsGraph = svgPanZoom('#procwrite_npa_weightsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_npa_weights~~CalledByGraph proc~write_npa_weights write_npa_weights proc~npa_weights npa_weights proc~npa_weights->proc~write_npa_weights program~fidasim fidasim program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=120), public :: filename integer, public :: i real(kind=double), public, dimension(:), allocatable :: ebarr real(kind=double), public, dimension(:), allocatable :: ptcharr integer(kind=HID_T), public :: fid integer(kind=HSIZE_T), public, dimension(5) :: dim5 integer(kind=HSIZE_T), public, dimension(3) :: dim3 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(1) :: d integer, public :: error","tags":""},{"title":"read_neutrals – Fortran Program","loc":"proc/read_neutrals.html","text":"public subroutine read_neutrals() Arguments None Calls proc~~read_neutrals~~CallsGraph proc~read_neutrals read_neutrals h5fclose_f h5fclose_f proc~read_neutrals->h5fclose_f h5gclose_f h5gclose_f proc~read_neutrals->h5gclose_f h5open_f h5open_f proc~read_neutrals->h5open_f h5close_f h5close_f proc~read_neutrals->h5close_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_neutrals->proc~h5ltread_dataset_int_scalar_f h5fopen_f h5fopen_f proc~read_neutrals->h5fopen_f h5gopen_f h5gopen_f proc~read_neutrals->h5gopen_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_neutrals->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~read_neutrals~~CalledByGraph proc~read_neutrals read_neutrals program~fidasim fidasim program~fidasim->proc~read_neutrals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: fid integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(4) :: dims integer, public :: error integer, public :: nx integer, public :: ny integer, public :: nz logical, public :: exis","tags":""},{"title":"tb_zyx – Fortran Program","loc":"proc/tb_zyx.html","text":"public subroutine tb_zyx(alpha, beta, gamma, basis, inv_basis) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: alpha real(kind=double), intent(in) :: beta real(kind=double), intent(in) :: gamma real(kind=double), intent(out), dimension(3,3) :: basis real(kind=double), intent(out), optional dimension(3,3) :: inv_basis Called By proc~~tb_zyx~~CalledByGraph proc~tb_zyx tb_zyx proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~tb_zyx proc~line_basis line_basis proc~line_basis->proc~tb_zyx proc~read_beam read_beam proc~read_beam->proc~tb_zyx program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~read_beam proc~read_chords read_chords program~fidasim->proc~read_chords proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~read_chords->proc~line_basis proc~bremsstrahlung->proc~line_basis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: sa real(kind=double), public :: sb real(kind=double), public :: sg real(kind=double), public :: ca real(kind=double), public :: cb real(kind=double), public :: cg","tags":""},{"title":"line_basis – Fortran Program","loc":"proc/line_basis.html","text":"public subroutine line_basis(r0, v0, basis, inv_basis) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: r0 real(kind=double), intent(in), dimension(3) :: v0 real(kind=double), intent(out), dimension(3,3) :: basis real(kind=double), intent(out), optional dimension(3,3) :: inv_basis Calls proc~~line_basis~~CallsGraph proc~line_basis line_basis proc~tb_zyx tb_zyx proc~line_basis->proc~tb_zyx Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~line_basis~~CalledByGraph proc~line_basis line_basis proc~read_chords read_chords proc~read_chords->proc~line_basis proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~line_basis program~fidasim fidasim program~fidasim->proc~read_chords program~fidasim->proc~bremsstrahlung Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: rf real(kind=double), public :: alpha real(kind=double), public :: beta real(kind=double), public :: dis","tags":""},{"title":"plane_basis – Fortran Program","loc":"proc/plane_basis.html","text":"public subroutine plane_basis(center, redge, tedge, basis, inv_basis) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: center real(kind=double), intent(in), dimension(3) :: redge real(kind=double), intent(in), dimension(3) :: tedge real(kind=double), intent(out), dimension(3,3) :: basis real(kind=double), intent(out), optional dimension(3,3) :: inv_basis Calls proc~~plane_basis~~CallsGraph proc~plane_basis plane_basis proc~normp normp proc~plane_basis->proc~normp proc~cross_product cross_product proc~plane_basis->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~plane_basis~~CalledByGraph proc~plane_basis plane_basis proc~read_npa read_npa proc~read_npa->proc~plane_basis program~fidasim fidasim program~fidasim->proc~read_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: u1 real(kind=double), public, dimension(3) :: u2 real(kind=double), public, dimension(3) :: u3","tags":""},{"title":"plane_intercept – Fortran Program","loc":"proc/plane_intercept.html","text":"public subroutine plane_intercept(l0, l, p0, n, p, t) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: l0 real(kind=double), intent(in), dimension(3) :: l real(kind=double), intent(in), dimension(3) :: p0 real(kind=double), intent(in), dimension(3) :: n real(kind=double), intent(out), dimension(3) :: p real(kind=double), intent(out) :: t Called By proc~~plane_intercept~~CalledByGraph proc~plane_intercept plane_intercept proc~hit_npa_detector hit_npa_detector proc~hit_npa_detector->proc~plane_intercept proc~npa_weights npa_weights proc~npa_weights->proc~hit_npa_detector proc~read_npa read_npa proc~read_npa->proc~hit_npa_detector proc~npa_mc npa_mc proc~npa_mc->proc~hit_npa_detector proc~npa_f npa_f proc~npa_f->proc~hit_npa_detector program~fidasim fidasim program~fidasim->proc~npa_weights program~fidasim->proc~read_npa program~fidasim->proc~npa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"hit_npa_detector – Fortran Program","loc":"proc/hit_npa_detector.html","text":"public subroutine hit_npa_detector(r0, v0, d_index, rd) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: r0 real(kind=double), intent(in), dimension(3) :: v0 integer, intent(out) :: d_index real(kind=double), intent(out), optional dimension(3) :: rd Calls proc~~hit_npa_detector~~CallsGraph proc~hit_npa_detector hit_npa_detector proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~plane_intercept plane_intercept proc~hit_npa_detector->proc~plane_intercept Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~hit_npa_detector~~CalledByGraph proc~hit_npa_detector hit_npa_detector proc~npa_weights npa_weights proc~npa_weights->proc~hit_npa_detector proc~read_npa read_npa proc~read_npa->proc~hit_npa_detector proc~npa_mc npa_mc proc~npa_mc->proc~hit_npa_detector proc~npa_f npa_f proc~npa_f->proc~hit_npa_detector program~fidasim fidasim program~fidasim->proc~npa_weights program~fidasim->proc~read_npa program~fidasim->proc~npa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: d real(kind=double), public, dimension(3) :: a real(kind=double), public :: t_a real(kind=double), public :: t_d integer, public :: i integer, public :: ndet","tags":""},{"title":"xyz_to_uvw – Fortran Program","loc":"proc/xyz_to_uvw.html","text":"public subroutine xyz_to_uvw(xyz, uvw) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: xyz real(kind=double), intent(out), dimension(3) :: uvw Called By proc~~xyz_to_uvw~~CalledByGraph proc~xyz_to_uvw xyz_to_uvw proc~in_plasma in_plasma proc~in_plasma->proc~xyz_to_uvw proc~write_birth_profile write_birth_profile proc~write_birth_profile->proc~xyz_to_uvw proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~get_fields get_fields proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~in_plasma proc~get_ep_denf get_ep_denf proc~get_ep_denf->proc~xyz_to_uvw proc~get_ep_denf->proc~in_plasma proc~store_npa store_npa proc~store_npa->proc~xyz_to_uvw proc~store_npa->proc~get_fields proc~write_beam_grid->proc~xyz_to_uvw proc~read_npa read_npa proc~read_npa->proc~xyz_to_uvw proc~get_distribution get_distribution proc~get_distribution->proc~xyz_to_uvw proc~get_distribution->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~track proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~fida_f->proc~get_beam_cx_prob proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~read_chords read_chords proc~read_chords->proc~track proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~track proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~fida_weights_mc->proc~get_beam_cx_prob proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~store_bes_photons proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~read_npa program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~read_chords program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~write_neutrals write_neutrals program~fidasim->proc~write_neutrals proc~write_dcx write_dcx program~fidasim->proc~write_dcx proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_ep_denf proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~write_npa_weights write_npa_weights proc~npa_weights->proc~write_npa_weights proc~store_fida_photons->proc~get_fields proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_plasma proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_f->proc~get_plasma proc~npa_f->proc~store_npa proc~npa_f->proc~mc_fastion proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~bremsstrahlung->proc~get_plasma proc~attenuate->proc~get_plasma proc~mc_halo->proc~get_plasma proc~get_beam_cx_prob->proc~mc_halo proc~write_npa_weights->proc~write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_dcx->proc~write_beam_grid var panprocxyz_to_uvwCalledByGraph = svgPanZoom('#procxyz_to_uvwCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: origin real(kind=double), public, dimension(3,3) :: basis","tags":""},{"title":"uvw_to_xyz – Fortran Program","loc":"proc/uvw_to_xyz.html","text":"public subroutine uvw_to_xyz(uvw, xyz) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: uvw real(kind=double), intent(out), dimension(3) :: xyz Called By proc~~uvw_to_xyz~~CalledByGraph proc~uvw_to_xyz uvw_to_xyz proc~fida_mc fida_mc proc~fida_mc->proc~uvw_to_xyz proc~read_chords read_chords proc~read_chords->proc~uvw_to_xyz proc~read_mc read_mc proc~read_mc->proc~uvw_to_xyz proc~read_npa read_npa proc~read_npa->proc~uvw_to_xyz proc~npa_mc npa_mc proc~npa_mc->proc~uvw_to_xyz proc~read_beam read_beam proc~read_beam->proc~uvw_to_xyz program~fidasim fidasim program~fidasim->proc~fida_mc program~fidasim->proc~read_chords program~fidasim->proc~read_npa program~fidasim->proc~npa_mc program~fidasim->proc~read_beam proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_distribution->proc~read_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: origin real(kind=double), public, dimension(3) :: uvw_p real(kind=double), public, dimension(3,3) :: basis","tags":""},{"title":"grid_intersect – Fortran Program","loc":"proc/grid_intersect.html","text":"public subroutine grid_intersect(r0, v0, length, r_enter, r_exit, center_in, lwh_in) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: r0 real(kind=double), intent(in), dimension(3) :: v0 real(kind=double), intent(out) :: length real(kind=double), intent(out), dimension(3) :: r_enter real(kind=double), intent(out), dimension(3) :: r_exit real(kind=double), intent(in), optional dimension(3) :: center_in real(kind=double), intent(in), optional dimension(3) :: lwh_in Called By proc~~grid_intersect~~CalledByGraph proc~grid_intersect grid_intersect proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~grid_intersect proc~read_chords read_chords proc~read_chords->proc~grid_intersect proc~mc_nbi mc_nbi proc~mc_nbi->proc~grid_intersect program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_chords proc~ndmc ndmc program~fidasim->proc~ndmc proc~ndmc->proc~mc_nbi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3,6) :: ipnts real(kind=double), public, dimension(3) :: vi real(kind=double), public, dimension(3) :: center real(kind=double), public, dimension(3) :: lwh integer, public, dimension(6) :: side_inter integer, public, dimension(2) :: ind integer, public :: i integer, public :: j integer, public :: nunique integer, public :: ind1 integer, public :: ind2","tags":""},{"title":"get_indices – Fortran Program","loc":"proc/get_indices.html","text":"public subroutine get_indices(pos, ind) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: pos integer(kind=long), intent(out), dimension(3) :: ind Called By proc~~get_indices~~CalledByGraph proc~get_indices get_indices proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~get_indices proc~track track proc~track->proc~get_indices proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_indices proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~get_indices proc~npa_mc npa_mc proc~npa_mc->proc~get_indices proc~halo halo proc~halo->proc~store_bes_photons proc~halo->proc~track proc~dcx dcx proc~dcx->proc~store_bes_photons proc~dcx->proc~track proc~ndmc ndmc proc~ndmc->proc~store_bes_photons proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~npa_mc program~fidasim->proc~halo program~fidasim->proc~dcx program~fidasim->proc~ndmc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~read_chords read_chords program~fidasim->proc~read_chords proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_weights_los->proc~track proc~fida_mc->proc~track proc~fida_mc->proc~store_fida_photons proc~fida_f->proc~track proc~fida_f->proc~store_fida_photons proc~read_chords->proc~track proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~store_fw_photons Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: mini integer(kind=long), public, dimension(3) :: maxind integer, public :: i","tags":""},{"title":"get_position – Fortran Program","loc":"proc/get_position.html","text":"public subroutine get_position(ind, pos) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in), dimension(3) :: ind real(kind=double), intent(out), dimension(3) :: pos Called By proc~~get_position~~CalledByGraph proc~get_position get_position proc~get_plasma get_plasma proc~get_plasma->proc~get_position proc~get_ep_denf get_ep_denf proc~get_ep_denf->proc~get_position proc~get_fields get_fields proc~get_fields->proc~get_position proc~get_distribution get_distribution proc~get_distribution->proc~get_position proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_mc fida_mc proc~fida_mc->proc~get_plasma proc~fida_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~get_beam_cx_prob proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~attenuate attenuate proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~store_bes_photons proc~attenuate->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~npa_mc npa_mc proc~npa_mc->proc~get_plasma proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~mc_halo->proc~get_plasma program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_f program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields var panprocget_positionCalledByGraph = svgPanZoom('#procget_positionCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"track – Fortran Program","loc":"proc/track.html","text":"public subroutine track(rin, vin, tracks, ncell, los_intersect) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: rin real(kind=double), intent(in), dimension(3) :: vin type( ParticleTrack ), intent(inout), dimension(:) :: tracks integer(kind=long), intent(out) :: ncell logical, intent(out), optional :: los_intersect Calls proc~~track~~CallsGraph proc~track track proc~get_indices get_indices proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma interface~interpol interpol proc~in_plasma->interface~interpol proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panproctrackCallsGraph = svgPanZoom('#proctrackCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~track~~CalledByGraph proc~track track proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~track proc~fida_mc fida_mc proc~fida_mc->proc~track proc~fida_f fida_f proc~fida_f->proc~track proc~halo halo proc~halo->proc~track proc~read_chords read_chords proc~read_chords->proc~track proc~ndmc ndmc proc~ndmc->proc~track proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~track proc~dcx dcx proc~dcx->proc~track program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~read_chords program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: cc integer, public :: i integer, public :: ii integer, public :: mind integer, public, dimension(3) :: ind logical, public :: in_plasma1 logical, public :: in_plasma2 logical, public :: in_plasma_tmp logical, public :: los_inter real(kind=double), public :: dT real(kind=double), public :: dt1 real(kind=double), public :: inv_50 real(kind=double), public, dimension(3) :: dt_arr real(kind=double), public, dimension(3) :: dr real(kind=double), public, dimension(3) :: vn real(kind=double), public, dimension(3) :: inv_vn real(kind=double), public, dimension(3) :: ri real(kind=double), public, dimension(3) :: ri_tmp real(kind=double), public, dimension(3) :: ri_cell integer, public, dimension(3) :: sgn integer, public, dimension(3) :: gdims integer, public, dimension(1) :: minpos","tags":""},{"title":"interpol1D_coeff – Fortran Program","loc":"proc/interpol1d_coeff.html","text":"public subroutine interpol1D_coeff(xmin, dx, nx, xout, i, b1, b2, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: xmin real(kind=double), intent(in) :: dx integer, intent(in) :: nx real(kind=double), intent(in) :: xout integer, intent(out) :: i real(kind=double), intent(out) :: b1 real(kind=double), intent(out) :: b2 integer, intent(out), optional :: err Called By proc~~interpol1d_coeff~~CalledByGraph proc~interpol1d_coeff interpol1D_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr proc~interpol1d_coeff_arr->proc~interpol1d_coeff interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol1d_coeff interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->interface~interpol_coeff proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~in_plasma proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol2d_arr proc~in_plasma->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_ep_denf->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_distribution->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~track proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~colrad colrad proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~fida_f->proc~get_beam_cx_prob proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~colrad proc~read_chords read_chords proc~read_chords->proc~track proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~track proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~fida_weights_mc->proc~get_beam_cx_prob proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~store_bes_photons proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~read_chords program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_ep_denf proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~npa_f->proc~get_plasma proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_plasma proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~bremsstrahlung->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~mc_halo->proc~get_plasma proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~colrad->proc~get_rate_matrix var panprocinterpol1d_coeffCalledByGraph = svgPanZoom('#procinterpol1d_coeffCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: x1 real(kind=double), public :: xp integer, public :: err_status","tags":""},{"title":"interpol1D_coeff_arr – Fortran Program","loc":"proc/interpol1d_coeff_arr.html","text":"public subroutine interpol1D_coeff_arr(x, xout, i, b1, b2, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in) :: xout integer, intent(out) :: i real(kind=double), intent(out) :: b1 real(kind=double), intent(out) :: b2 integer, intent(out), optional :: err Calls proc~~interpol1d_coeff_arr~~CallsGraph proc~interpol1d_coeff_arr interpol1D_coeff_arr proc~interpol1d_coeff interpol1D_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~interpol1d_coeff_arr~~CalledByGraph proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->interface~interpol_coeff proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~in_plasma proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol2d_arr proc~in_plasma->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_ep_denf->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_distribution->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~track proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~colrad colrad proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~fida_f->proc~get_beam_cx_prob proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~colrad proc~read_chords read_chords proc~read_chords->proc~track proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~track proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~fida_weights_mc->proc~get_beam_cx_prob proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~store_bes_photons proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~read_chords program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_ep_denf proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~npa_f->proc~get_plasma proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_plasma proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~bremsstrahlung->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~mc_halo->proc~get_plasma proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~colrad->proc~get_rate_matrix var panprocinterpol1d_coeff_arrCalledByGraph = svgPanZoom('#procinterpol1d_coeff_arrCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: xmin real(kind=double), public :: dx integer, public :: sx integer, public :: err_status","tags":""},{"title":"interpol2D_coeff – Fortran Program","loc":"proc/interpol2d_coeff.html","text":"public subroutine interpol2D_coeff(xmin, dx, nx, ymin, dy, ny, xout, yout, i, j, b11, b12, b21, b22, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: xmin real(kind=double), intent(in) :: dx integer, intent(in) :: nx real(kind=double), intent(in) :: ymin real(kind=double), intent(in) :: dy integer, intent(in) :: ny real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout integer, intent(out) :: i integer, intent(out) :: j real(kind=double), intent(out) :: b11 real(kind=double), intent(out) :: b12 real(kind=double), intent(out) :: b21 real(kind=double), intent(out) :: b22 integer, intent(out), optional :: err Called By proc~~interpol2d_coeff~~CalledByGraph proc~interpol2d_coeff interpol2D_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr proc~interpol2d_coeff_arr->proc~interpol2d_coeff interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol2d_coeff interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->interface~interpol_coeff proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~in_plasma proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol2d_arr proc~in_plasma->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_ep_denf->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_distribution->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~track proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~colrad colrad proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~fida_f->proc~get_beam_cx_prob proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~colrad proc~read_chords read_chords proc~read_chords->proc~track proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~track proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~fida_weights_mc->proc~get_beam_cx_prob proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~store_bes_photons proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~read_chords program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_ep_denf proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~npa_f->proc~get_plasma proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_plasma proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~bremsstrahlung->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~mc_halo->proc~get_plasma proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~colrad->proc~get_rate_matrix var panprocinterpol2d_coeffCalledByGraph = svgPanZoom('#procinterpol2d_coeffCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: x1 real(kind=double), public :: x2 real(kind=double), public :: y1 real(kind=double), public :: y2 real(kind=double), public :: xp real(kind=double), public :: yp integer, public :: err_status","tags":""},{"title":"interpol2D_coeff_arr – Fortran Program","loc":"proc/interpol2d_coeff_arr.html","text":"public subroutine interpol2D_coeff_arr(x, y, xout, yout, i, j, b11, b12, b21, b22, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout integer, intent(out) :: i integer, intent(out) :: j real(kind=double), intent(out) :: b11 real(kind=double), intent(out) :: b12 real(kind=double), intent(out) :: b21 real(kind=double), intent(out) :: b22 integer, intent(out), optional :: err Calls proc~~interpol2d_coeff_arr~~CallsGraph proc~interpol2d_coeff_arr interpol2D_coeff_arr proc~interpol2d_coeff interpol2D_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~interpol2d_coeff_arr~~CalledByGraph proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->interface~interpol_coeff proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~in_plasma proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol2d_arr proc~in_plasma->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_ep_denf->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_distribution->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~track proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~colrad colrad proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~fida_f->proc~get_beam_cx_prob proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~colrad proc~read_chords read_chords proc~read_chords->proc~track proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~track proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~fida_weights_mc->proc~get_beam_cx_prob proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~store_bes_photons proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~read_chords program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_ep_denf proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~npa_f->proc~get_plasma proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_plasma proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~bremsstrahlung->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~mc_halo->proc~get_plasma proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~colrad->proc~get_rate_matrix var panprocinterpol2d_coeff_arrCalledByGraph = svgPanZoom('#procinterpol2d_coeff_arrCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: xmin real(kind=double), public :: ymin real(kind=double), public :: dx real(kind=double), public :: dy integer, public :: sx integer, public :: sy integer, public :: err_status","tags":""},{"title":"interpol1D_arr – Fortran Program","loc":"proc/interpol1d_arr.html","text":"public subroutine interpol1D_arr(x, y, xout, yout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in) :: xout real(kind=double), intent(out) :: yout integer, intent(out), optional :: err Calls proc~~interpol1d_arr~~CallsGraph proc~interpol1d_arr interpol1D_arr interface~interpol_coeff interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~interpol1d_arr~~CalledByGraph proc~interpol1d_arr interpol1D_arr interface~interpol interpol interface~interpol->proc~interpol1d_arr proc~in_plasma in_plasma proc~in_plasma->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_ep_denf->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_distribution->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_mc fida_mc proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~attenuate attenuate proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~attenuate->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~npa_mc npa_mc proc~npa_mc->proc~get_plasma proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~mc_halo->proc~get_plasma program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_f program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_chords read_chords program~fidasim->proc~read_chords proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~read_chords->proc~track proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields var panprocinterpol1d_arrCalledByGraph = svgPanZoom('#procinterpol1d_arrCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: b1 real(kind=double), public :: b2 integer, public :: i integer, public :: err_status","tags":""},{"title":"interpol2D_arr – Fortran Program","loc":"proc/interpol2d_arr.html","text":"public subroutine interpol2D_arr(x, y, z, xout, yout, zout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in), dimension(:,:) :: z real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout real(kind=double), intent(out) :: zout integer, intent(out), optional :: err Calls proc~~interpol2d_arr~~CallsGraph proc~interpol2d_arr interpol2D_arr interface~interpol_coeff interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~interpol2d_arr~~CalledByGraph proc~interpol2d_arr interpol2D_arr interface~interpol interpol interface~interpol->proc~interpol2d_arr proc~in_plasma in_plasma proc~in_plasma->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_ep_denf->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_distribution->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_mc fida_mc proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~attenuate attenuate proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~attenuate->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~npa_mc npa_mc proc~npa_mc->proc~get_plasma proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~mc_halo->proc~get_plasma program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_f program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_chords read_chords program~fidasim->proc~read_chords proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~read_chords->proc~track proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields var panprocinterpol2d_arrCalledByGraph = svgPanZoom('#procinterpol2d_arrCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: b11 real(kind=double), public :: b12 real(kind=double), public :: b21 real(kind=double), public :: b22 integer, public :: i integer, public :: j integer, public :: err_status","tags":""},{"title":"interpol2D_2D_arr – Fortran Program","loc":"proc/interpol2d_2d_arr.html","text":"public subroutine interpol2D_2D_arr(x, y, z, xout, yout, zout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in), dimension(:,:,:,:) :: z real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout real(kind=double), intent(out), dimension(:,:) :: zout integer, intent(out), optional :: err Calls proc~~interpol2d_2d_arr~~CallsGraph proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~interpol2d_2d_arr~~CalledByGraph proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr proc~in_plasma in_plasma proc~in_plasma->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_ep_denf->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_distribution->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_mc fida_mc proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~attenuate attenuate proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~attenuate->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~npa_mc npa_mc proc~npa_mc->proc~get_plasma proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~mc_halo->proc~get_plasma program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_f program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_chords read_chords program~fidasim->proc~read_chords proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~read_chords->proc~track proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields var panprocinterpol2d_2d_arrCalledByGraph = svgPanZoom('#procinterpol2d_2d_arrCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: b11 real(kind=double), public :: b12 real(kind=double), public :: b21 real(kind=double), public :: b22 integer, public :: i integer, public :: j integer, public :: err_status","tags":""},{"title":"in_plasma – Fortran Program","loc":"proc/in_plasma.html","text":"public subroutine in_plasma(xyz, inp) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: xyz logical, intent(out) :: inp Calls proc~~in_plasma~~CallsGraph proc~in_plasma in_plasma interface~interpol interpol proc~in_plasma->interface~interpol proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocin_plasmaCallsGraph = svgPanZoom('#procin_plasmaCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~in_plasma~~CalledByGraph proc~in_plasma in_plasma proc~get_plasma get_plasma proc~get_plasma->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~get_ep_denf get_ep_denf proc~get_ep_denf->proc~in_plasma proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_mc fida_mc proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~attenuate attenuate proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~attenuate->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~npa_mc npa_mc proc~npa_mc->proc~get_plasma proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~mc_halo->proc~get_plasma program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_f program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_chords read_chords program~fidasim->proc~read_chords proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~read_chords->proc~track proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields var panprocin_plasmaCalledByGraph = svgPanZoom('#procin_plasmaCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: uvw real(kind=double), public :: R real(kind=double), public :: W real(kind=double), public :: phi real(kind=double), public :: mask integer, public :: err","tags":""},{"title":"get_plasma – Fortran Program","loc":"proc/get_plasma.html","text":"public subroutine get_plasma(plasma, pos, ind) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: plasma real(kind=double), intent(in), optional dimension(3) :: pos integer(kind=long), intent(in), optional dimension(3) :: ind Calls proc~~get_plasma~~CallsGraph proc~get_plasma get_plasma proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_plasmaCallsGraph = svgPanZoom('#procget_plasmaCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_plasma~~CalledByGraph proc~get_plasma get_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_plasma proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_mc fida_mc proc~fida_mc->proc~get_plasma proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~get_beam_cx_prob proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~attenuate attenuate proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~attenuate->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_beam_cx_prob proc~npa_mc npa_mc proc~npa_mc->proc~get_plasma proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~mc_halo->proc~get_plasma program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_f program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: inp real(kind=double), public, dimension(3) :: xyz real(kind=double), public, dimension(3) :: uvw real(kind=double), public, dimension(3) :: vrot_uvw real(kind=double), public :: R real(kind=double), public :: W real(kind=double), public :: phi real(kind=double), public :: s real(kind=double), public :: c real(kind=double), public :: b11 real(kind=double), public :: b12 real(kind=double), public :: b21 real(kind=double), public :: b22 integer, public :: i integer, public :: j","tags":""},{"title":"calc_perp_vectors – Fortran Program","loc":"proc/calc_perp_vectors.html","text":"public subroutine calc_perp_vectors(b, a, c) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: b real(kind=double), intent(out), dimension(3) :: a real(kind=double), intent(out), dimension(3) :: c Calls proc~~calc_perp_vectors~~CallsGraph proc~calc_perp_vectors calc_perp_vectors proc~normp normp proc~calc_perp_vectors->proc~normp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~calc_perp_vectors~~CalledByGraph proc~calc_perp_vectors calc_perp_vectors proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~calc_perp_vectors proc~get_fields get_fields proc~fida_weights_los->proc~get_fields proc~get_fields->proc~calc_perp_vectors program~fidasim fidasim program~fidasim->proc~fida_weights_los proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~ndmc ndmc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_mc->proc~get_fields proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~get_fields proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_fields proc~store_npa store_npa proc~store_npa->proc~get_fields proc~npa_weights->proc~get_fields proc~store_fida_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~store_fw_photons proc~npa_mc->proc~get_fields proc~npa_mc->proc~store_npa proc~halo->proc~store_bes_photons proc~dcx->proc~store_bes_photons proc~ndmc->proc~store_bes_photons proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~npa_f->proc~mc_fastion proc~npa_f->proc~store_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: bnorm","tags":""},{"title":"get_fields – Fortran Program","loc":"proc/get_fields.html","text":"public subroutine get_fields(fields, pos, ind) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: fields real(kind=double), intent(in), optional dimension(3) :: pos integer(kind=long), intent(in), optional dimension(3) :: ind Calls proc~~get_fields~~CallsGraph proc~get_fields get_fields proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~normp normp proc~get_fields->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_fieldsCallsGraph = svgPanZoom('#procget_fieldsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_fields~~CalledByGraph proc~get_fields get_fields proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~get_fields proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_fields proc~store_npa store_npa proc~store_npa->proc~get_fields proc~npa_weights npa_weights proc~npa_weights->proc~get_fields proc~store_fida_photons->proc~get_fields proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~store_fw_photons proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~store_npa program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~ndmc ndmc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~halo->proc~store_bes_photons proc~dcx->proc~store_bes_photons proc~ndmc->proc~store_bes_photons proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~npa_f->proc~mc_fastion proc~npa_f->proc~store_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: inp real(kind=double), public, dimension(3) :: xyz real(kind=double), public, dimension(3) :: uvw real(kind=double), public, dimension(3) :: uvw_bfield real(kind=double), public, dimension(3) :: uvw_efield real(kind=double), public, dimension(3) :: xyz_bfield real(kind=double), public, dimension(3) :: xyz_efield real(kind=double), public :: R real(kind=double), public :: W real(kind=double), public :: phi real(kind=double), public :: s real(kind=double), public :: c real(kind=double), public :: b11 real(kind=double), public :: b12 real(kind=double), public :: b21 real(kind=double), public :: b22 integer, public :: i integer, public :: j","tags":""},{"title":"get_distribution – Fortran Program","loc":"proc/get_distribution.html","text":"public subroutine get_distribution(fbeam, pos, ind) Arguments Type Intent Optional Attributes Name real(kind=double), intent(out), dimension(:,:) :: fbeam real(kind=double), intent(in), optional dimension(3) :: pos integer(kind=long), intent(in), optional dimension(3) :: ind Calls proc~~get_distribution~~CallsGraph proc~get_distribution get_distribution proc~in_plasma in_plasma proc~get_distribution->proc~in_plasma interface~interpol interpol proc~get_distribution->interface~interpol proc~xyz_to_uvw xyz_to_uvw proc~get_distribution->proc~xyz_to_uvw proc~get_position get_position proc~get_distribution->proc~get_position proc~in_plasma->interface~interpol proc~in_plasma->proc~xyz_to_uvw proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_distributionCallsGraph = svgPanZoom('#procget_distributionCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_distribution~~CalledByGraph proc~get_distribution get_distribution proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: xyz real(kind=double), public, dimension(3) :: uvw real(kind=double), public :: R real(kind=double), public :: Z logical, public :: in_plasma1 integer, public :: err","tags":""},{"title":"get_ep_denf – Fortran Program","loc":"proc/get_ep_denf.html","text":"public subroutine get_ep_denf(energy, pitch, denf, pos, ind) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: energy real(kind=double), intent(in) :: pitch real(kind=double), intent(out) :: denf real(kind=double), intent(in), optional dimension(3) :: pos integer(kind=long), intent(in), optional dimension(3) :: ind Calls proc~~get_ep_denf~~CallsGraph proc~get_ep_denf get_ep_denf proc~in_plasma in_plasma proc~get_ep_denf->proc~in_plasma interface~interpol interpol proc~get_ep_denf->interface~interpol proc~xyz_to_uvw xyz_to_uvw proc~get_ep_denf->proc~xyz_to_uvw proc~get_position get_position proc~get_ep_denf->proc~get_position proc~in_plasma->interface~interpol proc~in_plasma->proc~xyz_to_uvw proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_ep_denfCallsGraph = svgPanZoom('#procget_ep_denfCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_ep_denf~~CalledByGraph proc~get_ep_denf get_ep_denf proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: xyz real(kind=double), public, dimension(3) :: uvw real(kind=double), public, dimension(fbm%nenergy,fbm%npitch) :: fbeam integer(kind=long), public, dimension(2) :: epi integer(kind=long), public, dimension(1) :: dummy real(kind=double), public :: R real(kind=double), public :: Z real(kind=double), public :: dE real(kind=double), public :: dp logical, public :: in_plasma1","tags":""},{"title":"store_neutrals – Fortran Program","loc":"proc/store_neutrals.html","text":"public subroutine store_neutrals(ind, neut_type, dens, store_iter) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in), dimension(3) :: ind integer, intent(in) :: neut_type real(kind=double), intent(in), dimension(:) :: dens logical, intent(in), optional :: store_iter Called By proc~~store_neutrals~~CalledByGraph proc~store_neutrals store_neutrals proc~halo halo proc~halo->proc~store_neutrals proc~dcx dcx proc~dcx->proc~store_neutrals proc~ndmc ndmc proc~ndmc->proc~store_neutrals program~fidasim fidasim program~fidasim->proc~halo program~fidasim->proc~dcx program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: iter","tags":""},{"title":"store_births – Fortran Program","loc":"proc/store_births.html","text":"public subroutine store_births(ind, neut_type, dflux) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in), dimension(3) :: ind integer(kind=long), intent(in) :: neut_type real(kind=double), intent(in) :: dflux Called By proc~~store_births~~CalledByGraph proc~store_births store_births proc~ndmc ndmc proc~ndmc->proc~store_births program~fidasim fidasim program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"store_npa – Fortran Program","loc":"proc/store_npa.html","text":"public subroutine store_npa(det, ri, rf, vn, flux) Arguments Type Intent Optional Attributes Name integer, intent(in) :: det real(kind=double), intent(in), dimension(3) :: ri real(kind=double), intent(in), dimension(3) :: rf real(kind=double), intent(in), dimension(3) :: vn real(kind=double), intent(in) :: flux Calls proc~~store_npa~~CallsGraph proc~store_npa store_npa proc~normp normp proc~store_npa->proc~normp proc~xyz_to_uvw xyz_to_uvw proc~store_npa->proc~xyz_to_uvw proc~get_fields get_fields proc~store_npa->proc~get_fields proc~get_fields->proc~normp proc~get_fields->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocstore_npaCallsGraph = svgPanZoom('#procstore_npaCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~store_npa~~CalledByGraph proc~store_npa store_npa proc~npa_mc npa_mc proc~npa_mc->proc~store_npa proc~npa_f npa_f proc~npa_f->proc~store_npa program~fidasim fidasim program~fidasim->proc~npa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( LocalEMFields ), public :: fields real(kind=double), public, dimension(3) :: uvw_ri real(kind=double), public, dimension(3) :: uvw_rf real(kind=double), public, dimension(3) :: vn_norm real(kind=double), public :: energy real(kind=double), public :: pitch integer(kind=long), public, dimension(1) :: ienergy type( NPAParticle ), public, dimension(:), allocatable :: parts","tags":""},{"title":"neut_rates – Fortran Program","loc":"proc/neut_rates.html","text":"public subroutine neut_rates(denn, vi, vn, rates) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(nlevs) :: denn real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(in), dimension(3) :: vn real(kind=double), intent(out), dimension(nlevs) :: rates Calls proc~~neut_rates~~CallsGraph proc~neut_rates neut_rates proc~normp normp proc~neut_rates->proc~normp interface~interpol_coeff interpol_coeff proc~neut_rates->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~neut_rates~~CalledByGraph proc~neut_rates neut_rates proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~neut_rates proc~get_beam_cx_prob get_beam_cx_prob proc~get_beam_cx_prob->proc~neut_rates program~fidasim fidasim program~fidasim->proc~fida_weights_los proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~halo halo program~fidasim->proc~halo proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~dcx dcx program~fidasim->proc~dcx proc~fida_mc->proc~get_beam_cx_prob proc~fida_f->proc~get_beam_cx_prob proc~halo->proc~get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob proc~dcx->proc~get_beam_cx_prob Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(nlevs,nlevs) :: neut real(kind=double), public :: eb real(kind=double), public :: b1 real(kind=double), public :: b2 real(kind=double), public :: dlogE real(kind=double), public :: logEmin real(kind=double), public :: logeb real(kind=double), public :: vrel integer, public :: ebi integer, public :: neb integer, public :: err","tags":""},{"title":"get_beam_cx_prob – Fortran Program","loc":"proc/get_beam_cx_prob.html","text":"public subroutine get_beam_cx_prob(ind, pos, v_ion, types, prob) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in), dimension(3) :: ind real(kind=double), intent(in), dimension(3) :: pos real(kind=double), intent(in), dimension(3) :: v_ion integer(kind=long), intent(in), dimension(:) :: types real(kind=double), intent(out), dimension(nlevs) :: prob Calls proc~~get_beam_cx_prob~~CallsGraph proc~get_beam_cx_prob get_beam_cx_prob proc~normp normp proc~get_beam_cx_prob->proc~normp proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~get_plasma get_plasma proc~mc_halo->proc~get_plasma proc~randu randu proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~neut_rates->proc~normp interface~interpol_coeff interpol_coeff proc~neut_rates->interface~interpol_coeff proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~rng_normal->proc~rng_uniform var panprocget_beam_cx_probCallsGraph = svgPanZoom('#procget_beam_cx_probCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_beam_cx_prob~~CalledByGraph proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc fida_mc proc~fida_mc->proc~get_beam_cx_prob proc~fida_f fida_f proc~fida_f->proc~get_beam_cx_prob proc~halo halo proc~halo->proc~get_beam_cx_prob proc~npa_f npa_f proc~npa_f->proc~get_beam_cx_prob proc~npa_weights npa_weights proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_beam_cx_prob proc~npa_mc npa_mc proc~npa_mc->proc~get_beam_cx_prob proc~dcx dcx proc~dcx->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~npa_f program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~dcx Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: ntypes integer, public :: i integer, public :: ii real(kind=double), public, dimension(nlevs) :: rates real(kind=double), public, dimension(nlevs) :: denn real(kind=double), public, dimension(3) :: vhalo real(kind=double), public, dimension(3) :: vnbi real(kind=double), public, dimension(3) :: vn","tags":""},{"title":"get_rate_matrix – Fortran Program","loc":"proc/get_rate_matrix.html","text":"public subroutine get_rate_matrix(plasma, i_type, eb, rmat) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma integer, intent(in) :: i_type real(kind=double), intent(in) :: eb real(kind=double), intent(out), dimension(nlevs,nlevs) :: rmat Calls proc~~get_rate_matrix~~CallsGraph proc~get_rate_matrix get_rate_matrix interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_rate_matrix~~CalledByGraph proc~get_rate_matrix get_rate_matrix proc~colrad colrad proc~colrad->proc~get_rate_matrix proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: logEmin real(kind=double), public :: dlogE real(kind=double), public :: logeb real(kind=double), public :: logTmin real(kind=double), public :: dlogT real(kind=double), public :: logti real(kind=double), public :: logte integer, public :: neb integer, public :: nt real(kind=double), public :: b11 real(kind=double), public :: b12 real(kind=double), public :: b21 real(kind=double), public :: b22 real(kind=double), public :: dene real(kind=double), public :: denp real(kind=double), public :: denimp real(kind=double), public, dimension(nlevs,nlevs) :: H_H_pop real(kind=double), public, dimension(nlevs,nlevs) :: H_e_pop real(kind=double), public, dimension(nlevs,nlevs) :: H_Aq_pop real(kind=double), public, dimension(nlevs) :: H_H_depop real(kind=double), public, dimension(nlevs) :: H_e_depop real(kind=double), public, dimension(nlevs) :: H_Aq_depop integer, public :: ebi integer, public :: tii integer, public :: tei integer, public :: n integer, public :: err_status","tags":""},{"title":"colrad – Fortran Program","loc":"proc/colrad.html","text":"public subroutine colrad(plasma, i_type, vn, dt, states, dens, photons) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma integer, intent(in) :: i_type real(kind=double), intent(in), dimension(:) :: vn real(kind=double), intent(in) :: dt real(kind=double), intent(inout), dimension(:) :: states real(kind=double), intent(out), dimension(nlevs) :: dens real(kind=double), intent(out) :: photons Calls proc~~colrad~~CallsGraph proc~colrad colrad proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~colrad~~CalledByGraph proc~colrad colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate proc~npa_f->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(nlevs,nlevs) :: matrix real(kind=double), public :: b_amu real(kind=double), public :: vnet_square real(kind=double), public :: eb real(kind=double), public, dimension(nlevs,nlevs) :: eigvec real(kind=double), public, dimension(nlevs,nlevs) :: eigvec_inv real(kind=double), public, dimension(nlevs) :: eigval real(kind=double), public, dimension(nlevs) :: coef real(kind=double), public, dimension(nlevs) :: exp_eigval_dt real(kind=double), public :: iflux integer, public :: n","tags":""},{"title":"attenuate – Fortran Program","loc":"proc/attenuate.html","text":"public subroutine attenuate(ri, rf, vi, states, dstep_in) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: ri real(kind=double), intent(in), dimension(3) :: rf real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(inout), dimension(nlevs) :: states real(kind=double), intent(in), optional :: dstep_in Calls proc~~attenuate~~CallsGraph proc~attenuate attenuate proc~get_plasma get_plasma proc~attenuate->proc~get_plasma proc~normp normp proc~attenuate->proc~normp proc~colrad colrad proc~attenuate->proc~colrad proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv var panprocattenuateCallsGraph = svgPanZoom('#procattenuateCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~attenuate~~CalledByGraph proc~attenuate attenuate proc~npa_weights npa_weights proc~npa_weights->proc~attenuate proc~npa_mc npa_mc proc~npa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~npa_weights program~fidasim->proc~npa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( LocalProfiles ), public :: plasma real(kind=double), public :: photons real(kind=double), public :: vabs real(kind=double), public :: dt real(kind=double), public :: dstep real(kind=double), public :: dis real(kind=double), public :: max_dis real(kind=double), public, dimension(3) :: r0 real(kind=double), public, dimension(nlevs) :: dens","tags":""},{"title":"spectrum – Fortran Program","loc":"proc/spectrum.html","text":"public subroutine spectrum(vecp, vi, fields, sigma_pi, photons, dlength, lambda, intensity) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: vecp real(kind=double), intent(in), dimension(3) :: vi type( LocalEMFields ), intent(in) :: fields real(kind=double), intent(in) :: sigma_pi real(kind=double), intent(in) :: photons real(kind=double), intent(in) :: dlength real(kind=double), intent(out), dimension(n_stark) :: lambda real(kind=double), intent(out), dimension(n_stark) :: intensity Calls proc~~spectrum~~CallsGraph proc~spectrum spectrum proc~normp normp proc~spectrum->proc~normp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~spectrum~~CalledByGraph proc~spectrum spectrum proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~spectrum proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~spectrum proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons_at_chan->proc~spectrum proc~halo halo proc~halo->proc~store_bes_photons proc~dcx dcx proc~dcx->proc~store_bes_photons proc~ndmc ndmc proc~ndmc->proc~store_bes_photons program~fidasim fidasim program~fidasim->proc~halo program~fidasim->proc~dcx program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_f->proc~store_fida_photons proc~fida_mc->proc~store_fida_photons proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~store_fw_photons_at_chan proc~fida_weights_los->proc~store_fw_photons_at_chan proc~fida_weights_mc->proc~store_fw_photons Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: vp real(kind=double), public, dimension(3) :: vn real(kind=double), public, dimension(3) :: bfield real(kind=double), public, dimension(3) :: efield real(kind=double), public :: E real(kind=double), public :: cos_los_Efield real(kind=double), public :: lambda_shifted integer, public, parameter, dimension(n_stark) :: stark_sign = +1*stark_sigma-1*stark_pi","tags":""},{"title":"store_bes_photons – Fortran Program","loc":"proc/store_bes_photons.html","text":"public subroutine store_bes_photons(pos, vi, photons, neut_type) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: pos real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(in) :: photons integer, intent(in) :: neut_type Calls proc~~store_bes_photons~~CallsGraph proc~store_bes_photons store_bes_photons proc~get_indices get_indices proc~store_bes_photons->proc~get_indices proc~spectrum spectrum proc~store_bes_photons->proc~spectrum proc~get_fields get_fields proc~store_bes_photons->proc~get_fields proc~normp normp proc~spectrum->proc~normp proc~get_fields->proc~normp proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocstore_bes_photonsCallsGraph = svgPanZoom('#procstore_bes_photonsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~store_bes_photons~~CalledByGraph proc~store_bes_photons store_bes_photons proc~halo halo proc~halo->proc~store_bes_photons proc~dcx dcx proc~dcx->proc~store_bes_photons proc~ndmc ndmc proc~ndmc->proc~store_bes_photons program~fidasim fidasim program~fidasim->proc~halo program~fidasim->proc~dcx program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(n_stark) :: lambda real(kind=double), public, dimension(n_stark) :: intensity real(kind=double), public :: dlength real(kind=double), public :: sigma_pi type( LocalEMFields ), public :: fields integer(kind=long), public, dimension(3) :: ind real(kind=double), public, dimension(3) :: vp integer, public :: ichan integer, public :: i integer, public :: bin","tags":""},{"title":"store_fida_photons – Fortran Program","loc":"proc/store_fida_photons.html","text":"public subroutine store_fida_photons(pos, vi, photons, orbit_class) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: pos real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(in) :: photons integer, intent(in), optional :: orbit_class Calls proc~~store_fida_photons~~CallsGraph proc~store_fida_photons store_fida_photons proc~get_indices get_indices proc~store_fida_photons->proc~get_indices proc~spectrum spectrum proc~store_fida_photons->proc~spectrum proc~get_fields get_fields proc~store_fida_photons->proc~get_fields proc~normp normp proc~spectrum->proc~normp proc~get_fields->proc~normp proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocstore_fida_photonsCallsGraph = svgPanZoom('#procstore_fida_photonsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~store_fida_photons~~CalledByGraph proc~store_fida_photons store_fida_photons proc~fida_f fida_f proc~fida_f->proc~store_fida_photons proc~fida_mc fida_mc proc~fida_mc->proc~store_fida_photons program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(n_stark) :: lambda real(kind=double), public, dimension(n_stark) :: intensity real(kind=double), public :: dlength real(kind=double), public :: sigma_pi type( LocalEMFields ), public :: fields integer(kind=long), public, dimension(3) :: ind real(kind=double), public, dimension(3) :: vp integer, public :: ichan integer, public :: i integer, public :: bin integer, public :: iclass","tags":""},{"title":"store_fw_photons_at_chan – Fortran Program","loc":"proc/store_fw_photons_at_chan.html","text":"public subroutine store_fw_photons_at_chan(ichan, eind, pind, vp, vi, fields, dlength, sigma_pi, denf, photons) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan integer, intent(in) :: eind integer, intent(in) :: pind real(kind=double), intent(in), dimension(3) :: vp real(kind=double), intent(in), dimension(3) :: vi type( LocalEMFields ), intent(in) :: fields real(kind=double), intent(in) :: dlength real(kind=double), intent(in) :: sigma_pi real(kind=double), intent(in) :: denf real(kind=double), intent(in) :: photons Calls proc~~store_fw_photons_at_chan~~CallsGraph proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum proc~normp normp proc~spectrum->proc~normp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~store_fw_photons_at_chan~~CalledByGraph proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~store_fw_photons_at_chan proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~store_fw_photons_at_chan proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~store_fw_photons program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(n_stark) :: lambda real(kind=double), public, dimension(n_stark) :: intensity real(kind=double), public :: dlambda real(kind=double), public :: intens_fac integer, public :: i integer, public :: bin","tags":""},{"title":"store_fw_photons – Fortran Program","loc":"proc/store_fw_photons.html","text":"public subroutine store_fw_photons(eind, pind, pos, vi, denf, photons) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eind integer, intent(in) :: pind real(kind=double), intent(in), dimension(3) :: pos real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(in) :: denf real(kind=double), intent(in) :: photons Calls proc~~store_fw_photons~~CallsGraph proc~store_fw_photons store_fw_photons proc~get_indices get_indices proc~store_fw_photons->proc~get_indices proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons->proc~store_fw_photons_at_chan proc~get_fields get_fields proc~store_fw_photons->proc~get_fields proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum proc~normp normp proc~get_fields->proc~normp proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~get_position get_position proc~get_fields->proc~get_position proc~spectrum->proc~normp proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocstore_fw_photonsCallsGraph = svgPanZoom('#procstore_fw_photonsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~store_fw_photons~~CalledByGraph proc~store_fw_photons store_fw_photons proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~store_fw_photons program~fidasim fidasim program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: dlength real(kind=double), public :: sigma_pi type( LocalEMFields ), public :: fields integer(kind=long), public, dimension(3) :: ind real(kind=double), public, dimension(3) :: vp integer, public :: ichan","tags":""},{"title":"get_nlaunch – Fortran Program","loc":"proc/get_nlaunch.html","text":"public subroutine get_nlaunch(nr_markers, papprox, papprox_tot, nlaunch) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in) :: nr_markers real(kind=double), intent(in), dimension(:,:,:) :: papprox real(kind=double), intent(in) :: papprox_tot real(kind=double), intent(out), dimension(:,:,:) :: nlaunch Calls proc~~get_nlaunch~~CallsGraph proc~get_nlaunch get_nlaunch proc~randu randu proc~get_nlaunch->proc~randu proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_nlaunch~~CalledByGraph proc~get_nlaunch get_nlaunch proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_nlaunch proc~fida_f fida_f proc~fida_f->proc~get_nlaunch proc~halo halo proc~halo->proc~get_nlaunch proc~dcx dcx proc~dcx->proc~get_nlaunch proc~npa_f npa_f proc~npa_f->proc~get_nlaunch program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~dcx program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: cc real(kind=double), public, dimension(:), allocatable :: randomu","tags":""},{"title":"pitch_to_vec – Fortran Program","loc":"proc/pitch_to_vec.html","text":"public subroutine pitch_to_vec(pitch, gyroangle, fields, vi_norm) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: pitch real(kind=double), intent(in) :: gyroangle type( LocalEMFields ), intent(in) :: fields real(kind=double), intent(out), dimension(3) :: vi_norm Called By proc~~pitch_to_vec~~CalledByGraph proc~pitch_to_vec pitch_to_vec proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~pitch_to_vec proc~npa_mc npa_mc proc~npa_mc->proc~pitch_to_vec proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~pitch_to_vec proc~mc_fastion mc_fastion proc~mc_fastion->proc~pitch_to_vec proc~fida_mc fida_mc proc~fida_mc->proc~pitch_to_vec program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~npa_mc program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public :: sinus","tags":""},{"title":"gyro_correction – Fortran Program","loc":"proc/gyro_correction.html","text":"public subroutine gyro_correction(vi, fields, r_gyro) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: vi type( LocalEMFields ), intent(in) :: fields real(kind=double), intent(out), dimension(3) :: r_gyro Calls proc~~gyro_correction~~CallsGraph proc~gyro_correction gyro_correction proc~cross_product cross_product proc~gyro_correction->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~gyro_correction~~CalledByGraph proc~gyro_correction gyro_correction proc~npa_weights npa_weights proc~npa_weights->proc~gyro_correction proc~npa_mc npa_mc proc~npa_mc->proc~gyro_correction proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~gyro_correction proc~mc_fastion mc_fastion proc~mc_fastion->proc~gyro_correction proc~fida_mc fida_mc proc~fida_mc->proc~gyro_correction program~fidasim fidasim program~fidasim->proc~npa_weights program~fidasim->proc~npa_mc program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: vxB real(kind=double), public :: one_over_omega","tags":""},{"title":"mc_fastion – Fortran Program","loc":"proc/mc_fastion.html","text":"public subroutine mc_fastion(ind, ri, vi, at_guiding_center) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind real(kind=double), intent(out), dimension(3) :: ri real(kind=double), intent(out), dimension(3) :: vi logical, intent(in), optional :: at_guiding_center Calls proc~~mc_fastion~~CallsGraph proc~mc_fastion mc_fastion proc~get_fields get_fields proc~mc_fastion->proc~get_fields proc~pitch_to_vec pitch_to_vec proc~mc_fastion->proc~pitch_to_vec proc~randu randu proc~mc_fastion->proc~randu proc~gyro_correction gyro_correction proc~mc_fastion->proc~gyro_correction interface~randind randind proc~mc_fastion->interface~randind proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~normp normp proc~get_fields->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~get_position get_position proc~get_fields->proc~get_position proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~cross_product cross_product proc~gyro_correction->proc~cross_product proc~randind_w_2 randind_w_2 interface~randind->proc~randind_w_2 proc~randind_w_1 randind_w_1 interface~randind->proc~randind_w_1 proc~randind_n randind_n interface~randind->proc~randind_n proc~get_distribution->proc~in_plasma proc~get_distribution->proc~xyz_to_uvw proc~get_distribution->proc~get_position interface~interpol interpol proc~get_distribution->interface~interpol proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~randind_w_2->proc~randu proc~ind2sub ind2sub proc~randind_w_2->proc~ind2sub proc~randind_w_1->proc~randu proc~randind_n->proc~randu var panprocmc_fastionCallsGraph = svgPanZoom('#procmc_fastionCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~mc_fastion~~CalledByGraph proc~mc_fastion mc_fastion proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( LocalEMFields ), public :: fields real(kind=double), public, dimension(fbm%nenergy,fbm%npitch) :: fbeam real(kind=double), public, dimension(3) :: r_gyro real(kind=double), public, dimension(3) :: rp real(kind=double), public :: eb real(kind=double), public :: ptch integer, public :: ii integer, public :: ienergy integer, public :: ipitch real(kind=double), public :: vabs real(kind=double), public :: phi real(kind=double), public, dimension(3) :: randomu3 real(kind=double), public, dimension(4) :: randomu4 integer, public, dimension(1) :: minpos integer, public, dimension(2,1) :: ep_ind real(kind=double), public, dimension(1) :: max_fbm logical, public :: use_inverse_sampler","tags":""},{"title":"mc_halo – Fortran Program","loc":"proc/mc_halo.html","text":"public subroutine mc_halo(ind, vhalo, ri, plasma_in) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind real(kind=double), intent(out), dimension(3) :: vhalo real(kind=double), intent(out), optional dimension(3) :: ri type( LocalProfiles ), intent(in), optional :: plasma_in Calls proc~~mc_halo~~CallsGraph proc~mc_halo mc_halo proc~get_plasma get_plasma proc~mc_halo->proc~get_plasma proc~randu randu proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~rng_normal->proc~rng_uniform var panprocmc_haloCallsGraph = svgPanZoom('#procmc_haloCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~mc_halo~~CalledByGraph proc~mc_halo mc_halo proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~mc_halo proc~get_beam_cx_prob get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~halo halo proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~dcx dcx proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~halo program~fidasim->proc~dcx proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~fida_mc->proc~get_beam_cx_prob proc~fida_f->proc~get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( LocalProfiles ), public :: plasma real(kind=double), public, dimension(3) :: random3","tags":""},{"title":"mc_nbi – Fortran Program","loc":"proc/mc_nbi.html","text":"public subroutine mc_nbi(vnbi, efrac, rnbi) Arguments Type Intent Optional Attributes Name real(kind=double), intent(out), dimension(3) :: vnbi integer, intent(in) :: efrac real(kind=double), intent(out), dimension(3) :: rnbi Calls proc~~mc_nbi~~CallsGraph proc~mc_nbi mc_nbi proc~normp normp proc~mc_nbi->proc~normp proc~randu randu proc~mc_nbi->proc~randu proc~grid_intersect grid_intersect proc~mc_nbi->proc~grid_intersect proc~randn randn proc~mc_nbi->proc~randn proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~mc_nbi~~CalledByGraph proc~mc_nbi mc_nbi proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=double), public, dimension(3) :: r_exit real(kind=double), public, dimension(3) :: uvw_src real(kind=double), public, dimension(3) :: xyz_src real(kind=double), public, dimension(3) :: uvw_ray real(kind=double), public, dimension(3) :: xyz_ray real(kind=double), public, dimension(2) :: randomu real(kind=double), public, dimension(2) :: randomn real(kind=double), public :: length real(kind=double), public :: sqrt_rho real(kind=double), public :: theta","tags":""},{"title":"ndmc – Fortran Program","loc":"proc/ndmc.html","text":"public subroutine ndmc() Arguments None Calls proc~~ndmc~~CallsGraph proc~ndmc ndmc proc~store_neutrals store_neutrals proc~ndmc->proc~store_neutrals proc~get_plasma get_plasma proc~ndmc->proc~get_plasma proc~colrad colrad proc~ndmc->proc~colrad proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons proc~track track proc~ndmc->proc~track proc~store_births store_births proc~ndmc->proc~store_births proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~randu randu proc~ndmc->proc~randu interface~randind randind proc~ndmc->interface~randind proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~get_indices get_indices proc~store_bes_photons->proc~get_indices proc~spectrum spectrum proc~store_bes_photons->proc~spectrum proc~get_fields get_fields proc~store_bes_photons->proc~get_fields proc~track->proc~in_plasma proc~track->proc~get_indices proc~mc_nbi->proc~randu proc~normp normp proc~mc_nbi->proc~normp proc~grid_intersect grid_intersect proc~mc_nbi->proc~grid_intersect proc~randn randn proc~mc_nbi->proc~randn omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~randind_w_2 randind_w_2 interface~randind->proc~randind_w_2 proc~randind_w_1 randind_w_1 interface~randind->proc~randind_w_1 proc~randind_n randind_n interface~randind->proc~randind_n proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~spectrum->proc~normp proc~get_fields->proc~in_plasma proc~get_fields->interface~interpol_coeff proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~get_position proc~get_fields->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~calc_perp_vectors->proc~normp proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~randn->omp_get_thread_num proc~rng_normal->proc~rng_uniform proc~randind_w_2->proc~randu proc~ind2sub ind2sub proc~randind_w_2->proc~ind2sub proc~randind_w_1->proc~randu proc~randind_n->proc~randu var panprocndmcCallsGraph = svgPanZoom('#procndmcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~ndmc~~CalledByGraph proc~ndmc ndmc program~fidasim fidasim program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: neut_type real(kind=double), public :: nlaunch real(kind=double), public :: nneutrals real(kind=double), public, dimension(3) :: vnbi real(kind=double), public, dimension(3) :: rnbi integer, public :: jj integer, public :: ii integer, public :: kk integer, public :: ncell type( ParticleTrack ), public, dimension(beam_grid%ntrack) :: tracks integer, public, dimension(3) :: nl_birth type( LocalProfiles ), public :: plasma real(kind=double), public, dimension(nlevs) :: states real(kind=double), public, dimension(nlevs) :: dens real(kind=double), public :: photons real(kind=double), public :: iflux integer(kind=long), public, dimension(3) :: ind real(kind=double), public, dimension(1) :: randomu integer, public, dimension(1) :: randi","tags":""},{"title":"bremsstrahlung – Fortran Program","loc":"proc/bremsstrahlung.html","text":"public subroutine bremsstrahlung() Arguments None Calls proc~~bremsstrahlung~~CallsGraph proc~bremsstrahlung bremsstrahlung proc~get_plasma get_plasma proc~bremsstrahlung->proc~get_plasma proc~normp normp proc~bremsstrahlung->proc~normp proc~randu randu proc~bremsstrahlung->proc~randu proc~line_basis line_basis proc~bremsstrahlung->proc~line_basis proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~tb_zyx tb_zyx proc~line_basis->proc~tb_zyx proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocbremsstrahlungCallsGraph = svgPanZoom('#procbremsstrahlungCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bremsstrahlung~~CalledByGraph proc~bremsstrahlung bremsstrahlung program~fidasim fidasim program~fidasim->proc~bremsstrahlung Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( LocalProfiles ), public :: plasma integer, public :: i integer, public :: ichan integer, public :: nc integer, public :: ic real(kind=double), public :: dlength real(kind=double), public :: gaunt real(kind=double), public :: max_length real(kind=double), public :: spot_size real(kind=double), public :: theta real(kind=double), public :: sqrt_rho real(kind=double), public, dimension(2) :: randomu real(kind=double), public, dimension(3) :: vi real(kind=double), public, dimension(3) :: xyz real(kind=double), public, dimension(3) :: r0 real(kind=double), public, dimension(3,3) :: basis real(kind=double), public, dimension(:), allocatable :: lambda_arr real(kind=double), public, dimension(:), allocatable :: brems","tags":""},{"title":"dcx – Fortran Program","loc":"proc/dcx.html","text":"public subroutine dcx() Arguments None Calls proc~~dcx~~CallsGraph proc~dcx dcx proc~get_nlaunch get_nlaunch proc~dcx->proc~get_nlaunch proc~store_neutrals store_neutrals proc~dcx->proc~store_neutrals proc~get_plasma get_plasma proc~dcx->proc~get_plasma proc~colrad colrad proc~dcx->proc~colrad proc~store_bes_photons store_bes_photons proc~dcx->proc~store_bes_photons proc~track track proc~dcx->proc~track proc~get_beam_cx_prob get_beam_cx_prob proc~dcx->proc~get_beam_cx_prob proc~mc_halo mc_halo proc~dcx->proc~mc_halo proc~randu randu proc~get_nlaunch->proc~randu proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~get_indices get_indices proc~store_bes_photons->proc~get_indices proc~spectrum spectrum proc~store_bes_photons->proc~spectrum proc~get_fields get_fields proc~store_bes_photons->proc~get_fields proc~track->proc~in_plasma proc~track->proc~get_indices proc~get_beam_cx_prob->proc~mc_halo proc~normp normp proc~get_beam_cx_prob->proc~normp proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~spectrum->proc~normp proc~get_fields->proc~in_plasma proc~get_fields->interface~interpol_coeff proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~get_position proc~get_fields->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~calc_perp_vectors->proc~normp proc~neut_rates->interface~interpol_coeff proc~neut_rates->proc~normp proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocdcxCallsGraph = svgPanZoom('#procdcxCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~dcx~~CalledByGraph proc~dcx dcx program~fidasim fidasim program~fidasim->proc~dcx Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: idcx real(kind=double), public, dimension(3) :: ri real(kind=double), public, dimension(3) :: vihalo integer, public, dimension(3) :: ind integer, public, dimension(3) :: neut_types = [1, 2, 3] type( LocalProfiles ), public :: plasma real(kind=double), public, dimension(nlevs) :: denn real(kind=double), public, dimension(nlevs) :: prob real(kind=double), public, dimension(nlevs) :: states integer, public :: ncell type( ParticleTrack ), public, dimension(beam_grid%ntrack) :: tracks integer, public :: jj real(kind=double), public :: tot_denn real(kind=double), public :: photons real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: papprox real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: nlaunch real(kind=double), public :: papprox_tot real(kind=double), public :: ccnt real(kind=double), public :: inv_ng","tags":""},{"title":"halo – Fortran Program","loc":"proc/halo.html","text":"public subroutine halo() Arguments None Calls proc~~halo~~CallsGraph proc~halo halo proc~get_nlaunch get_nlaunch proc~halo->proc~get_nlaunch proc~store_neutrals store_neutrals proc~halo->proc~store_neutrals proc~get_plasma get_plasma proc~halo->proc~get_plasma proc~colrad colrad proc~halo->proc~colrad proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~track track proc~halo->proc~track proc~get_beam_cx_prob get_beam_cx_prob proc~halo->proc~get_beam_cx_prob proc~mc_halo mc_halo proc~halo->proc~mc_halo proc~randu randu proc~get_nlaunch->proc~randu proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~get_indices get_indices proc~store_bes_photons->proc~get_indices proc~spectrum spectrum proc~store_bes_photons->proc~spectrum proc~get_fields get_fields proc~store_bes_photons->proc~get_fields proc~track->proc~in_plasma proc~track->proc~get_indices proc~get_beam_cx_prob->proc~mc_halo proc~normp normp proc~get_beam_cx_prob->proc~normp proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~spectrum->proc~normp proc~get_fields->proc~in_plasma proc~get_fields->interface~interpol_coeff proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~get_position proc~get_fields->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~calc_perp_vectors->proc~normp proc~neut_rates->interface~interpol_coeff proc~neut_rates->proc~normp proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprochaloCallsGraph = svgPanZoom('#prochaloCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~halo~~CalledByGraph proc~halo halo program~fidasim fidasim program~fidasim->proc~halo Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: ihalo real(kind=double), public, dimension(3) :: ri real(kind=double), public, dimension(3) :: vihalo integer, public, dimension(3) :: ind type( LocalProfiles ), public :: plasma real(kind=double), public, dimension(nlevs) :: denn real(kind=double), public, dimension(nlevs) :: prob real(kind=double), public, dimension(nlevs) :: states integer, public :: ncell type( ParticleTrack ), public, dimension(beam_grid%ntrack) :: tracks integer, public :: jj real(kind=double), public :: tot_denn real(kind=double), public :: photons real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: papprox real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: nlaunch real(kind=double), public :: papprox_tot real(kind=double), public :: ccnt real(kind=double), public :: inv_ng integer, public :: hh real(kind=double), public :: dcx_dens real(kind=double), public :: halo_iteration_dens integer, public :: s1type integer, public :: s2type","tags":""},{"title":"fida_f – Fortran Program","loc":"proc/fida_f.html","text":"public subroutine fida_f() Arguments None Calls proc~~fida_f~~CallsGraph proc~fida_f fida_f proc~get_nlaunch get_nlaunch proc~fida_f->proc~get_nlaunch proc~get_plasma get_plasma proc~fida_f->proc~get_plasma proc~colrad colrad proc~fida_f->proc~colrad proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~track track proc~fida_f->proc~track proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~get_beam_cx_prob get_beam_cx_prob proc~fida_f->proc~get_beam_cx_prob proc~randu randu proc~get_nlaunch->proc~randu proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~mc_fastion->proc~randu proc~get_fields get_fields proc~mc_fastion->proc~get_fields proc~pitch_to_vec pitch_to_vec proc~mc_fastion->proc~pitch_to_vec proc~gyro_correction gyro_correction proc~mc_fastion->proc~gyro_correction interface~randind randind proc~mc_fastion->interface~randind proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution proc~track->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~store_fida_photons->proc~get_fields proc~store_fida_photons->proc~get_indices proc~spectrum spectrum proc~store_fida_photons->proc~spectrum proc~normp normp proc~get_beam_cx_prob->proc~normp proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~get_fields->proc~in_plasma proc~get_fields->interface~interpol_coeff proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~get_position proc~get_fields->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~cross_product cross_product proc~gyro_correction->proc~cross_product proc~randind_w_2 randind_w_2 interface~randind->proc~randind_w_2 proc~randind_w_1 randind_w_1 interface~randind->proc~randind_w_1 proc~randind_n randind_n interface~randind->proc~randind_n proc~get_distribution->proc~in_plasma proc~get_distribution->proc~xyz_to_uvw proc~get_distribution->proc~get_position proc~get_distribution->interface~interpol proc~calc_perp_vectors->proc~normp proc~randind_w_2->proc~randu proc~ind2sub ind2sub proc~randind_w_2->proc~ind2sub proc~randind_w_1->proc~randu proc~randind_n->proc~randu proc~spectrum->proc~normp proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~neut_rates->interface~interpol_coeff proc~neut_rates->proc~normp proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocfida_fCallsGraph = svgPanZoom('#procfida_fCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fida_f~~CalledByGraph proc~fida_f fida_f program~fidasim fidasim program~fidasim->proc~fida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer(kind=8), public :: iion integer(kind=8), public :: ip real(kind=double), public, dimension(3) :: ri real(kind=double), public, dimension(3) :: vi integer, public, dimension(3) :: ind integer, public, dimension(4) :: neut_types = [1, 2, 3, 4] logical, public :: los_intersect type( LocalProfiles ), public :: plasma real(kind=double), public, dimension(nlevs) :: prob integer, public :: ncell integer, public :: jj type( ParticleTrack ), public, dimension(beam_grid%ntrack) :: tracks real(kind=double), public :: photons real(kind=double), public, dimension(nlevs) :: states real(kind=double), public, dimension(nlevs) :: denn integer(kind=8), public :: pcnt real(kind=double), public :: papprox_tot real(kind=double), public :: inv_maxcnt real(kind=double), public :: cnt integer, public, dimension(3,beam_grid%ngrid) :: pcell real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: papprox real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: nlaunch","tags":""},{"title":"fida_mc – Fortran Program","loc":"proc/fida_mc.html","text":"public subroutine fida_mc() Arguments None Calls proc~~fida_mc~~CallsGraph proc~fida_mc fida_mc proc~get_fields get_fields proc~fida_mc->proc~get_fields proc~uvw_to_xyz uvw_to_xyz proc~fida_mc->proc~uvw_to_xyz proc~get_plasma get_plasma proc~fida_mc->proc~get_plasma proc~colrad colrad proc~fida_mc->proc~colrad proc~pitch_to_vec pitch_to_vec proc~fida_mc->proc~pitch_to_vec proc~randu randu proc~fida_mc->proc~randu proc~track track proc~fida_mc->proc~track proc~gyro_correction gyro_correction proc~fida_mc->proc~gyro_correction proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~normp normp proc~get_fields->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~get_position get_position proc~get_fields->proc~get_position proc~get_plasma->proc~in_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~track->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~cross_product cross_product proc~gyro_correction->proc~cross_product proc~store_fida_photons->proc~get_fields proc~store_fida_photons->proc~get_indices proc~spectrum spectrum proc~store_fida_photons->proc~spectrum proc~get_beam_cx_prob->proc~normp proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~spectrum->proc~normp proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~neut_rates->interface~interpol_coeff proc~neut_rates->proc~normp proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocfida_mcCallsGraph = svgPanZoom('#procfida_mcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fida_mc~~CalledByGraph proc~fida_mc fida_mc program~fidasim fidasim program~fidasim->proc~fida_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: iion integer, public :: iphi type( FastIon ), public :: fast_ion type( LocalEMFields ), public :: fields type( LocalProfiles ), public :: plasma real(kind=double), public :: phi real(kind=double), public :: theta real(kind=double), public, dimension(3) :: ri real(kind=double), public, dimension(3) :: vi real(kind=double), public, dimension(3) :: vi_norm real(kind=double), public, dimension(nlevs) :: denn real(kind=double), public, dimension(nlevs) :: prob real(kind=double), public, dimension(nlevs) :: states integer, public :: ncell type( ParticleTrack ), public, dimension(beam_grid%ntrack) :: tracks logical, public :: los_intersect integer, public :: jj real(kind=double), public :: photons integer, public, dimension(4) :: neut_types = [1, 2, 3, 4] real(kind=double), public, dimension(3) :: xyz real(kind=double), public, dimension(3) :: uvw real(kind=double), public, dimension(3) :: r_gyro real(kind=double), public, dimension(3) :: uvw_vi real(kind=double), public :: s real(kind=double), public :: c real(kind=double), public :: maxcnt real(kind=double), public :: inv_maxcnt real(kind=double), public :: cnt real(kind=double), public, dimension(2) :: randomu integer(kind=long), public :: nlaunch","tags":""},{"title":"npa_f – Fortran Program","loc":"proc/npa_f.html","text":"public subroutine npa_f() Arguments None Calls proc~~npa_f~~CallsGraph proc~npa_f npa_f proc~get_nlaunch get_nlaunch proc~npa_f->proc~get_nlaunch proc~get_plasma get_plasma proc~npa_f->proc~get_plasma proc~mc_fastion mc_fastion proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~attenuate attenuate proc~npa_f->proc~attenuate proc~get_beam_cx_prob get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~hit_npa_detector hit_npa_detector proc~npa_f->proc~hit_npa_detector proc~randu randu proc~get_nlaunch->proc~randu proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~mc_fastion->proc~randu proc~get_fields get_fields proc~mc_fastion->proc~get_fields proc~pitch_to_vec pitch_to_vec proc~mc_fastion->proc~pitch_to_vec proc~gyro_correction gyro_correction proc~mc_fastion->proc~gyro_correction interface~randind randind proc~mc_fastion->interface~randind proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution proc~store_npa->proc~xyz_to_uvw proc~store_npa->proc~get_fields proc~normp normp proc~store_npa->proc~normp proc~attenuate->proc~get_plasma proc~attenuate->proc~normp proc~colrad colrad proc~attenuate->proc~colrad proc~get_beam_cx_prob->proc~normp proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~plane_intercept plane_intercept proc~hit_npa_detector->proc~plane_intercept proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~get_fields->proc~in_plasma proc~get_fields->interface~interpol_coeff proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~get_position proc~get_fields->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~cross_product cross_product proc~gyro_correction->proc~cross_product proc~randind_w_2 randind_w_2 interface~randind->proc~randind_w_2 proc~randind_w_1 randind_w_1 interface~randind->proc~randind_w_1 proc~randind_n randind_n interface~randind->proc~randind_n proc~get_distribution->proc~in_plasma proc~get_distribution->proc~xyz_to_uvw proc~get_distribution->proc~get_position proc~get_distribution->interface~interpol proc~calc_perp_vectors->proc~normp proc~randind_w_2->proc~randu proc~ind2sub ind2sub proc~randind_w_2->proc~ind2sub proc~randind_w_1->proc~randu proc~randind_n->proc~randu proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~neut_rates->interface~interpol_coeff proc~neut_rates->proc~normp proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocnpa_fCallsGraph = svgPanZoom('#procnpa_fCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~npa_f~~CalledByGraph proc~npa_f npa_f program~fidasim fidasim program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: iion integer, public :: det integer, public :: ip real(kind=double), public, dimension(3) :: ri real(kind=double), public, dimension(3) :: rf real(kind=double), public, dimension(3) :: vi integer, public, dimension(3) :: ind integer, public, dimension(3,beam_grid%ngrid) :: pcell type( LocalProfiles ), public :: plasma integer, public, dimension(4) :: neut_types = [1, 2, 3, 4] real(kind=double), public, dimension(nlevs) :: prob real(kind=double), public, dimension(nlevs) :: states real(kind=double), public :: flux integer, public :: inpa integer, public :: pcnt real(kind=double), public :: papprox_tot real(kind=double), public :: maxcnt real(kind=double), public :: cnt real(kind=double), public :: inv_maxcnt real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: papprox real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: nlaunch","tags":""},{"title":"npa_mc – Fortran Program","loc":"proc/npa_mc.html","text":"public subroutine npa_mc() Arguments None Calls proc~~npa_mc~~CallsGraph proc~npa_mc npa_mc proc~store_npa store_npa proc~npa_mc->proc~store_npa proc~get_fields get_fields proc~npa_mc->proc~get_fields proc~uvw_to_xyz uvw_to_xyz proc~npa_mc->proc~uvw_to_xyz proc~get_plasma get_plasma proc~npa_mc->proc~get_plasma proc~pitch_to_vec pitch_to_vec proc~npa_mc->proc~pitch_to_vec proc~randu randu proc~npa_mc->proc~randu proc~gyro_correction gyro_correction proc~npa_mc->proc~gyro_correction proc~get_indices get_indices proc~npa_mc->proc~get_indices proc~attenuate attenuate proc~npa_mc->proc~attenuate proc~get_beam_cx_prob get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob proc~hit_npa_detector hit_npa_detector proc~npa_mc->proc~hit_npa_detector proc~store_npa->proc~get_fields proc~normp normp proc~store_npa->proc~normp proc~xyz_to_uvw xyz_to_uvw proc~store_npa->proc~xyz_to_uvw proc~get_fields->proc~normp proc~get_fields->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_position get_position proc~get_fields->proc~get_position proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~in_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~get_position proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~cross_product cross_product proc~gyro_correction->proc~cross_product proc~attenuate->proc~get_plasma proc~attenuate->proc~normp proc~colrad colrad proc~attenuate->proc~colrad proc~get_beam_cx_prob->proc~normp proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~plane_intercept plane_intercept proc~hit_npa_detector->proc~plane_intercept proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~neut_rates->proc~normp proc~neut_rates->interface~interpol_coeff proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocnpa_mcCallsGraph = svgPanZoom('#procnpa_mcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~npa_mc~~CalledByGraph proc~npa_mc npa_mc program~fidasim fidasim program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: iion integer, public :: iphi type( FastIon ), public :: fast_ion type( LocalEMFields ), public :: fields type( LocalProfiles ), public :: plasma real(kind=double), public :: phi real(kind=double), public :: theta real(kind=double), public, dimension(3) :: ri real(kind=double), public, dimension(3) :: rf real(kind=double), public, dimension(3) :: vi real(kind=double), public, dimension(3) :: vi_norm integer, public :: det real(kind=double), public, dimension(nlevs) :: prob real(kind=double), public, dimension(nlevs) :: states real(kind=double), public :: flux integer, public, dimension(4) :: neut_types = [1, 2, 3, 4] integer, public, dimension(3) :: ind real(kind=double), public, dimension(3) :: xyz real(kind=double), public, dimension(3) :: uvw real(kind=double), public, dimension(3) :: r_gyro real(kind=double), public, dimension(3) :: uvw_vi real(kind=double), public :: s real(kind=double), public :: c real(kind=double), public :: maxcnt real(kind=double), public :: inv_maxcnt real(kind=double), public :: cnt real(kind=double), public, dimension(2) :: randomu integer(kind=long), public :: nlaunch","tags":""},{"title":"fida_weights_mc – Fortran Program","loc":"proc/fida_weights_mc.html","text":"public subroutine fida_weights_mc() Arguments None Calls proc~~fida_weights_mc~~CallsGraph proc~fida_weights_mc fida_weights_mc proc~get_nlaunch get_nlaunch proc~fida_weights_mc->proc~get_nlaunch proc~write_fida_weights write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~get_fields get_fields proc~fida_weights_mc->proc~get_fields proc~get_plasma get_plasma proc~fida_weights_mc->proc~get_plasma proc~colrad colrad proc~fida_weights_mc->proc~colrad proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~pitch_to_vec pitch_to_vec proc~fida_weights_mc->proc~pitch_to_vec proc~randu randu proc~fida_weights_mc->proc~randu proc~track track proc~fida_weights_mc->proc~track proc~gyro_correction gyro_correction proc~fida_weights_mc->proc~gyro_correction proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons interface~randind randind proc~fida_weights_mc->interface~randind proc~get_beam_cx_prob get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~get_nlaunch->proc~randu h5fcreate_f h5fcreate_f proc~write_fida_weights->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_fida_weights->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_fida_weights->h5fclose_f h5open_f h5open_f proc~write_fida_weights->h5open_f h5close_f h5close_f proc~write_fida_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_fida_weights->h5ltset_attribute_string_f proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~normp normp proc~get_fields->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~get_position get_position proc~get_fields->proc~get_position proc~get_plasma->proc~in_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~get_ep_denf->proc~in_plasma proc~get_ep_denf->proc~xyz_to_uvw proc~get_ep_denf->proc~get_position interface~interpol interpol proc~get_ep_denf->interface~interpol proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~track->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~cross_product cross_product proc~gyro_correction->proc~cross_product proc~store_fw_photons->proc~get_fields proc~store_fw_photons->proc~get_indices proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons->proc~store_fw_photons_at_chan proc~randind_w_2 randind_w_2 interface~randind->proc~randind_w_2 proc~randind_w_1 randind_w_1 interface~randind->proc~randind_w_1 proc~randind_n randind_n interface~randind->proc~randind_n proc~get_beam_cx_prob->proc~normp proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum proc~spectrum->proc~normp proc~randind_w_2->proc~randu proc~ind2sub ind2sub proc~randind_w_2->proc~ind2sub proc~randind_w_1->proc~randu proc~randind_n->proc~randu proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~neut_rates->interface~interpol_coeff proc~neut_rates->proc~normp proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocfida_weights_mcCallsGraph = svgPanZoom('#procfida_weights_mcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fida_weights_mc~~CalledByGraph proc~fida_weights_mc fida_weights_mc program~fidasim fidasim program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer(kind=8), public :: iion integer(kind=8), public :: ip real(kind=double), public, dimension(3) :: ri real(kind=double), public, dimension(3) :: r_gyro real(kind=double), public, dimension(3) :: vi real(kind=double), public, dimension(3) :: vi_norm integer, public, dimension(3) :: ind integer, public, dimension(4) :: neut_types = [1, 2, 3, 4] logical, public :: los_intersect type( LocalProfiles ), public :: plasma type( LocalEMFields ), public :: fields real(kind=double), public, dimension(nlevs) :: prob integer, public :: ncell integer, public :: jj integer, public :: kk type( ParticleTrack ), public, dimension(beam_grid%ntrack) :: tracks real(kind=double), public :: photons real(kind=double), public, dimension(nlevs) :: states real(kind=double), public, dimension(nlevs) :: denn integer, public :: nwav real(kind=double), public :: etov2 real(kind=double), public :: energy real(kind=double), public :: pitch real(kind=double), public :: phi real(kind=double), public :: dE real(kind=double), public :: dP real(kind=double), public :: dEdP real(kind=double), public, dimension(:), allocatable :: ebarr real(kind=double), public, dimension(:), allocatable :: ptcharr integer, public, dimension(1) :: ienergy integer, public, dimension(1) :: ipitch real(kind=double), public, dimension(3) :: randomu3 integer(kind=8), public :: pcnt real(kind=double), public :: papprox_tot real(kind=double), public :: inv_maxcnt real(kind=double), public :: cnt real(kind=double), public :: fbm_denf real(kind=double), public :: phase_area integer, public, dimension(3,beam_grid%ngrid) :: pcell real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: papprox real(kind=double), public, dimension(beam_grid%nx,beam_grid%ny,beam_grid%nz) :: nlaunch","tags":""},{"title":"fida_weights_los – Fortran Program","loc":"proc/fida_weights_los.html","text":"public subroutine fida_weights_los() Arguments None Calls proc~~fida_weights_los~~CallsGraph proc~fida_weights_los fida_weights_los proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~fida_weights_los->proc~store_fw_photons_at_chan proc~write_fida_weights write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~get_fields get_fields proc~fida_weights_los->proc~get_fields proc~get_plasma get_plasma proc~fida_weights_los->proc~get_plasma proc~colrad colrad proc~fida_weights_los->proc~colrad proc~get_ep_denf get_ep_denf proc~fida_weights_los->proc~get_ep_denf proc~pitch_to_vec pitch_to_vec proc~fida_weights_los->proc~pitch_to_vec proc~neut_rates neut_rates proc~fida_weights_los->proc~neut_rates proc~track track proc~fida_weights_los->proc~track proc~grid_intersect grid_intersect proc~fida_weights_los->proc~grid_intersect proc~normp normp proc~fida_weights_los->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~fida_weights_los->proc~calc_perp_vectors proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum h5fcreate_f h5fcreate_f proc~write_fida_weights->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_fida_weights->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_fida_weights->h5fclose_f h5open_f h5open_f proc~write_fida_weights->h5open_f h5close_f h5close_f proc~write_fida_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_fida_weights->h5ltset_attribute_string_f proc~get_fields->proc~normp proc~get_fields->proc~calc_perp_vectors proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~get_position get_position proc~get_fields->proc~get_position proc~get_plasma->proc~in_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~get_ep_denf->proc~in_plasma proc~get_ep_denf->proc~xyz_to_uvw proc~get_ep_denf->proc~get_position interface~interpol interpol proc~get_ep_denf->interface~interpol proc~neut_rates->proc~normp proc~neut_rates->interface~interpol_coeff proc~track->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~calc_perp_vectors->proc~normp proc~mc_halo->proc~get_plasma proc~randu randu proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~spectrum->proc~normp proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocfida_weights_losCallsGraph = svgPanZoom('#procfida_weights_losCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fida_weights_los~~CalledByGraph proc~fida_weights_los fida_weights_los program~fidasim fidasim program~fidasim->proc~fida_weights_los Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( LocalProfiles ), public :: plasma type( LocalProfiles ), public :: plasma_cell type( LocalEMFields ), public :: fields type( LocalEMFields ), public :: fields_cell real(kind=double), public :: denf real(kind=double), public :: wght real(kind=double), public :: wght_tot real(kind=double), public :: photons real(kind=double), public :: length type( ParticleTrack ), public, dimension(beam_grid%ntrack) :: tracks integer, public :: nwav integer(kind=long), public :: i integer(kind=long), public :: j integer(kind=long), public :: k integer(kind=long), public :: ienergy integer(kind=long), public :: ipitch integer(kind=long), public :: igyro integer(kind=long), public :: icell integer(kind=long), public :: ichan real(kind=double), public, dimension(:), allocatable :: ebarr real(kind=double), public, dimension(:), allocatable :: ptcharr real(kind=double), public, dimension(:), allocatable :: phiarr real(kind=double), public, dimension(:,:), allocatable :: mean_f real(kind=double), public, dimension(3) :: vi real(kind=double), public, dimension(3) :: vi_norm real(kind=double), public, dimension(3) :: vp real(kind=double), public, dimension(3) :: vnbi_f real(kind=double), public, dimension(3) :: vnbi_h real(kind=double), public, dimension(3) :: vnbi_t real(kind=double), public, dimension(3) :: vhalo real(kind=double), public, dimension(3) :: r_enter real(kind=double), public, dimension(3) :: r_exit real(kind=double), public :: vabs real(kind=double), public :: dE real(kind=double), public :: dP real(kind=double), public, dimension(nlevs) :: fdens real(kind=double), public, dimension(nlevs) :: hdens real(kind=double), public, dimension(nlevs) :: tdens real(kind=double), public, dimension(nlevs) :: halodens real(kind=double), public, dimension(nlevs) :: rates real(kind=double), public, dimension(nlevs) :: states real(kind=double), public, dimension(nlevs) :: denn real(kind=double), public :: dt real(kind=double), public :: max_dens real(kind=double), public :: dlength real(kind=double), public :: sigma_pi real(kind=double), public :: eb real(kind=double), public :: ptch real(kind=double), public :: phi integer, public, dimension(3) :: ind real(kind=double), public, dimension(3) :: ri integer(kind=long), public :: ncell real(kind=double), public :: etov2 real(kind=double), public :: dEdP","tags":""},{"title":"npa_weights – Fortran Program","loc":"proc/npa_weights.html","text":"public subroutine npa_weights() Arguments None Calls proc~~npa_weights~~CallsGraph proc~npa_weights npa_weights proc~get_fields get_fields proc~npa_weights->proc~get_fields proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~get_ep_denf get_ep_denf proc~npa_weights->proc~get_ep_denf proc~write_npa_weights write_npa_weights proc~npa_weights->proc~write_npa_weights proc~gyro_correction gyro_correction proc~npa_weights->proc~gyro_correction proc~normp normp proc~npa_weights->proc~normp proc~get_beam_cx_prob get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~hit_npa_detector hit_npa_detector proc~npa_weights->proc~hit_npa_detector proc~get_fields->proc~normp proc~in_plasma in_plasma proc~get_fields->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_fields->interface~interpol_coeff proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~get_position get_position proc~get_fields->proc~get_position proc~attenuate->proc~normp proc~get_plasma get_plasma proc~attenuate->proc~get_plasma proc~colrad colrad proc~attenuate->proc~colrad proc~get_ep_denf->proc~in_plasma proc~get_ep_denf->proc~xyz_to_uvw proc~get_ep_denf->proc~get_position interface~interpol interpol proc~get_ep_denf->interface~interpol h5fcreate_f h5fcreate_f proc~write_npa_weights->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_npa_weights->h5ltmake_dataset_int_f h5fclose_f h5fclose_f proc~write_npa_weights->h5fclose_f h5open_f h5open_f proc~write_npa_weights->h5open_f h5close_f h5close_f proc~write_npa_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_npa_weights->proc~write_beam_grid h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_npa_weights->h5ltset_attribute_string_f proc~cross_product cross_product proc~gyro_correction->proc~cross_product proc~get_beam_cx_prob->proc~normp proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~plane_intercept plane_intercept proc~hit_npa_detector->proc~plane_intercept proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~calc_perp_vectors->proc~normp proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~get_plasma->proc~in_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~write_beam_grid->proc~xyz_to_uvw proc~write_beam_grid->h5ltmake_dataset_int_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~mc_halo->proc~get_plasma proc~randu randu proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~neut_rates->proc~normp proc~neut_rates->interface~interpol_coeff proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocnpa_weightsCallsGraph = svgPanZoom('#procnpa_weightsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~npa_weights~~CalledByGraph proc~npa_weights npa_weights program~fidasim fidasim program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( LocalEMFields ), public :: fields real(kind=double), public :: pitch real(kind=double), public :: pcxa integer(kind=long), public :: det integer(kind=long), public :: ii integer(kind=long), public :: jj integer(kind=long), public :: kk integer(kind=long), public :: i integer(kind=long), public :: ic integer, public, dimension(1) :: ipitch real(kind=double), public, dimension(3) :: vi real(kind=double), public, dimension(3) :: vi_norm real(kind=double), public :: vabs real(kind=double), public :: fbm_denf real(kind=double), public :: dE real(kind=double), public :: dP real(kind=double), public :: ccnt real(kind=double), public, dimension(nlevs) :: pcx real(kind=double), public, dimension(nlevs) :: states real(kind=double), public, dimension(nlevs) :: states_i integer, public, dimension(4) :: neut_types = [1, 2, 3, 4] real(kind=double), public, dimension(3) :: pos real(kind=double), public, dimension(3) :: dpos real(kind=double), public, dimension(3) :: r_gyro integer(kind=long), public :: ichan real(kind=double), public, dimension(:), allocatable :: ebarr real(kind=double), public, dimension(:), allocatable :: ptcharr","tags":""},{"title":"assignment(=) – Fortran Program","loc":"interface/assignment(=).html","text":"public interface assignment(=) Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~lpp_assign lpp_assign interface~assignment(=)->proc~lpp_assign proc~plp_assign plp_assign interface~assignment(=)->proc~plp_assign proc~lff_assign lff_assign interface~assignment(=)->proc~lff_assign proc~pp_assign pp_assign interface~assignment(=)->proc~pp_assign proc~flf_assign flf_assign interface~assignment(=)->proc~flf_assign proc~fast_ion_assign fast_ion_assign interface~assignment(=)->proc~fast_ion_assign proc~npa_part_assign npa_part_assign interface~assignment(=)->proc~npa_part_assign proc~lplp_assign lplp_assign interface~assignment(=)->proc~lplp_assign proc~lflf_assign lflf_assign interface~assignment(=)->proc~lflf_assign proc~ff_assign ff_assign interface~assignment(=)->proc~ff_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public subroutine pp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(out) :: p1 type( Profiles ), intent(in) :: p2 public subroutine lpp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: p1 type( Profiles ), intent(in) :: p2 public subroutine plp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(out) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine lplp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine ff_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(out) :: p1 type( EMFields ), intent(in) :: p2 public subroutine lff_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: p1 type( EMFields ), intent(in) :: p2 public subroutine flf_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(out) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine lflf_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine fast_ion_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 public subroutine npa_part_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2","tags":""},{"title":"operator(+) – Fortran Program","loc":"interface/operator(+).html","text":"public interface operator(+) Calls interface~~operator(+)~~CallsGraph interface~operator(+) operator(+) proc~lflf_add lflf_add interface~operator(+)->proc~lflf_add proc~ff_add ff_add interface~operator(+)->proc~ff_add proc~lplp_add lplp_add interface~operator(+)->proc~lplp_add proc~pp_add pp_add interface~operator(+)->proc~pp_add Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public function pp_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields )","tags":""},{"title":"operator(-) – Fortran Program","loc":"interface/operator(-).html","text":"public interface operator(-) Calls interface~~operator(-)~~CallsGraph interface~operator(-) operator(-) proc~pp_subtract pp_subtract interface~operator(-)->proc~pp_subtract proc~lplp_subtract lplp_subtract interface~operator(-)->proc~lplp_subtract proc~ff_subtract ff_subtract interface~operator(-)->proc~ff_subtract proc~lflf_subtract lflf_subtract interface~operator(-)->proc~lflf_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public function pp_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields )","tags":""},{"title":"operator(*) – Fortran Program","loc":"interface/operator(*).html","text":"public interface operator(*) Calls interface~~operator(*)~~CallsGraph interface~operator(*) operator(*) proc~fs_multiply fs_multiply interface~operator(*)->proc~fs_multiply proc~lfs_multiply lfs_multiply interface~operator(*)->proc~lfs_multiply proc~sp_multiply sp_multiply interface~operator(*)->proc~sp_multiply proc~sf_multiply sf_multiply interface~operator(*)->proc~sf_multiply proc~slf_multiply slf_multiply interface~operator(*)->proc~slf_multiply proc~lps_multiply lps_multiply interface~operator(*)->proc~lps_multiply proc~ps_multiply ps_multiply interface~operator(*)->proc~ps_multiply proc~slp_multiply slp_multiply interface~operator(*)->proc~slp_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public function sp_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) public function ps_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function slp_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) public function sf_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) public function fs_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function slf_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields )","tags":""},{"title":"operator(/) – Fortran Program","loc":"interface/operator(SLASH).html","text":"public interface operator(/) Calls interface~~operator(SLASH)~~CallsGraph interface~operator(SLASH) operator(/) proc~ps_divide ps_divide interface~operator(SLASH)->proc~ps_divide proc~lfs_divide lfs_divide interface~operator(SLASH)->proc~lfs_divide proc~lps_divide lps_divide interface~operator(SLASH)->proc~lps_divide proc~fs_divide fs_divide interface~operator(SLASH)->proc~fs_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public function ps_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function fs_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalEMFields )","tags":""},{"title":"interpol_coeff – Fortran Program","loc":"interface/interpol_coeff.html","text":"public interface interpol_coeff Calls interface~~interpol_coeff~~CallsGraph interface~interpol_coeff interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~interpol_coeff~~CalledByGraph interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->interface~interpol_coeff proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~in_plasma proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol2d_arr proc~in_plasma->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_ep_denf->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_distribution->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~track proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~colrad colrad proc~fida_weights_los->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~colrad proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~fida_f->proc~get_beam_cx_prob proc~fida_f->proc~colrad proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~colrad proc~read_chords read_chords proc~read_chords->proc~track proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~track proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~fida_weights_mc->proc~get_beam_cx_prob proc~fida_weights_mc->proc~colrad proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~store_bes_photons proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~read_chords program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_ep_denf proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~npa_f->proc~get_plasma proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_plasma proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~bremsstrahlung->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~mc_halo->proc~get_plasma proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~colrad->proc~get_rate_matrix var paninterfaceinterpol_coeffCalledByGraph = svgPanZoom('#interfaceinterpol_coeffCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public subroutine interpol1D_coeff (xmin, dx, nx, xout, i, b1, b2, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: xmin real(kind=double), intent(in) :: dx integer, intent(in) :: nx real(kind=double), intent(in) :: xout integer, intent(out) :: i real(kind=double), intent(out) :: b1 real(kind=double), intent(out) :: b2 integer, intent(out), optional :: err public subroutine interpol1D_coeff_arr (x, xout, i, b1, b2, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in) :: xout integer, intent(out) :: i real(kind=double), intent(out) :: b1 real(kind=double), intent(out) :: b2 integer, intent(out), optional :: err public subroutine interpol2D_coeff (xmin, dx, nx, ymin, dy, ny, xout, yout, i, j, b11, b12, b21, b22, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: xmin real(kind=double), intent(in) :: dx integer, intent(in) :: nx real(kind=double), intent(in) :: ymin real(kind=double), intent(in) :: dy integer, intent(in) :: ny real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout integer, intent(out) :: i integer, intent(out) :: j real(kind=double), intent(out) :: b11 real(kind=double), intent(out) :: b12 real(kind=double), intent(out) :: b21 real(kind=double), intent(out) :: b22 integer, intent(out), optional :: err public subroutine interpol2D_coeff_arr (x, y, xout, yout, i, j, b11, b12, b21, b22, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout integer, intent(out) :: i integer, intent(out) :: j real(kind=double), intent(out) :: b11 real(kind=double), intent(out) :: b12 real(kind=double), intent(out) :: b21 real(kind=double), intent(out) :: b22 integer, intent(out), optional :: err","tags":""},{"title":"interpol – Fortran Program","loc":"interface/interpol.html","text":"public interface interpol Calls interface~~interpol~~CallsGraph interface~interpol interpol proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~interpol~~CalledByGraph interface~interpol interpol proc~in_plasma in_plasma proc~in_plasma->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_ep_denf->proc~in_plasma proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_distribution->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_mc fida_mc proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~attenuate attenuate proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons proc~attenuate->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~npa_mc npa_mc proc~npa_mc->proc~get_plasma proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~mc_halo->proc~get_plasma program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_f program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_chords read_chords program~fidasim->proc~read_chords proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~read_chords->proc~track proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~store_npa->proc~get_fields proc~store_fida_photons->proc~get_fields var paninterfaceinterpolCalledByGraph = svgPanZoom('#interfaceinterpolCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public subroutine interpol1D_arr (x, y, xout, yout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in) :: xout real(kind=double), intent(out) :: yout integer, intent(out), optional :: err public subroutine interpol2D_arr (x, y, z, xout, yout, zout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in), dimension(:,:) :: z real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout real(kind=double), intent(out) :: zout integer, intent(out), optional :: err public subroutine interpol2D_2D_arr (x, y, z, xout, yout, zout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in), dimension(:,:,:,:) :: z real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout real(kind=double), intent(out), dimension(:,:) :: zout integer, intent(out), optional :: err","tags":""},{"title":"check_compression_availability – Fortran Program","loc":"proc/check_compression_availability.html","text":"public subroutine check_compression_availability() Arguments None Description Checks whether dataset compression is available Calls proc~~check_compression_availability~~CallsGraph proc~check_compression_availability check_compression_availability h5open_f h5open_f proc~check_compression_availability->h5open_f h5close_f h5close_f proc~check_compression_availability->h5close_f h5zget_filter_info_f h5zget_filter_info_f proc~check_compression_availability->h5zget_filter_info_f h5zfilter_avail_f h5zfilter_avail_f proc~check_compression_availability->h5zfilter_avail_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~check_compression_availability~~CalledByGraph proc~check_compression_availability check_compression_availability program~generate_tables generate_tables program~generate_tables->proc~check_compression_availability program~fidasim fidasim program~fidasim->proc~check_compression_availability Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: shuffle_avail logical, public :: gzip_avail integer, public :: gzip_info integer, public :: shuf_info integer, public :: filter_info_both integer, public :: error","tags":""},{"title":"h5ltread_dataset_int_scalar_f – Fortran Program","loc":"proc/h5ltread_dataset_int_scalar_f.html","text":"public subroutine h5ltread_dataset_int_scalar_f(loc_id, dset_name, x, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a scalar 32-bit integer Calls proc~~h5ltread_dataset_int_scalar_f~~CallsGraph proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltread_dataset_int_scalar_f~~CalledByGraph proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_tables read_tables proc~read_tables->proc~h5ltread_dataset_int_scalar_f proc~read_cross read_cross proc~read_tables->proc~read_cross proc~read_rates read_rates proc~read_tables->proc~read_rates proc~read_cross->proc~h5ltread_dataset_int_scalar_f proc~read_rates->proc~h5ltread_dataset_int_scalar_f proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~h5ltread_dataset_int_scalar_f proc~read_f read_f proc~read_f->proc~h5ltread_dataset_int_scalar_f proc~read_distribution read_distribution proc~read_distribution->proc~h5ltread_dataset_int_scalar_f proc~read_distribution->proc~read_f proc~read_mc read_mc proc~read_distribution->proc~read_mc proc~read_chords read_chords proc~read_chords->proc~h5ltread_dataset_int_scalar_f proc~read_neutrals read_neutrals proc~read_neutrals->proc~h5ltread_dataset_int_scalar_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~read_npa read_npa proc~read_npa->proc~h5ltread_dataset_int_scalar_f proc~read_beam read_beam proc~read_beam->proc~h5ltread_dataset_int_scalar_f program~fidasim fidasim program~fidasim->proc~read_tables program~fidasim->proc~read_equilibrium program~fidasim->proc~read_distribution program~fidasim->proc~read_chords program~fidasim->proc~read_neutrals program~fidasim->proc~read_npa program~fidasim->proc~read_beam Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HSIZE_T), public, dimension(1) :: dims (1) = 1 integer, public, dimension(1) :: dummy","tags":""},{"title":"h5ltread_dataset_double_scalar_f – Fortran Program","loc":"proc/h5ltread_dataset_double_scalar_f.html","text":"public subroutine h5ltread_dataset_double_scalar_f(loc_id, dset_name, x, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create real(kind=double), intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a scalar 64-bit float Calls proc~~h5ltread_dataset_double_scalar_f~~CallsGraph proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltread_dataset_double_scalar_f~~CalledByGraph proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_cross read_cross proc~read_cross->proc~h5ltread_dataset_double_scalar_f proc~read_rates read_rates proc~read_rates->proc~h5ltread_dataset_double_scalar_f proc~read_beam read_beam proc~read_beam->proc~h5ltread_dataset_double_scalar_f proc~read_tables read_tables proc~read_tables->proc~read_cross proc~read_tables->proc~read_rates program~fidasim fidasim program~fidasim->proc~read_beam program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HSIZE_T), public, dimension(1) :: dims (1) = 1 real(kind=double), public, dimension(1) :: dummy","tags":""},{"title":"h5ltmake_compressed_dataset_double_f_1 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_double_f_1.html","text":"public subroutine h5ltmake_compressed_dataset_double_f_1(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 1 Calls proc~~h5ltmake_compressed_dataset_double_f_1~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_1~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx program~fidasim->proc~write_spectra program~fidasim->proc~write_npa proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_1CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_1CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_double_f_2 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_double_f_2.html","text":"public subroutine h5ltmake_compressed_dataset_double_f_2(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 2 Calls proc~~h5ltmake_compressed_dataset_double_f_2~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_2~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx program~fidasim->proc~write_spectra program~fidasim->proc~write_npa proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_2CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_2CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_double_f_3 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_double_f_3.html","text":"public subroutine h5ltmake_compressed_dataset_double_f_3(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 3 Calls proc~~h5ltmake_compressed_dataset_double_f_3~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_3~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx program~fidasim->proc~write_spectra program~fidasim->proc~write_npa proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_3CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_3CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_double_f_4 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_double_f_4.html","text":"public subroutine h5ltmake_compressed_dataset_double_f_4(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 4 Calls proc~~h5ltmake_compressed_dataset_double_f_4~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_4~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx program~fidasim->proc~write_spectra program~fidasim->proc~write_npa proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_4CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_4CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_double_f_5 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_double_f_5.html","text":"public subroutine h5ltmake_compressed_dataset_double_f_5(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 5 Calls proc~~h5ltmake_compressed_dataset_double_f_5~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_5~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx program~fidasim->proc~write_spectra program~fidasim->proc~write_npa proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_5CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_5CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_double_f_6 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_double_f_6.html","text":"public subroutine h5ltmake_compressed_dataset_double_f_6(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 6 Calls proc~~h5ltmake_compressed_dataset_double_f_6~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_6~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx program~fidasim->proc~write_spectra program~fidasim->proc~write_npa proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_6CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_6CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_double_f_7 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_double_f_7.html","text":"public subroutine h5ltmake_compressed_dataset_double_f_7(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 7 Calls proc~~h5ltmake_compressed_dataset_double_f_7~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_7~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx program~fidasim->proc~write_spectra program~fidasim->proc~write_npa proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_7CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_7CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_int_f_1 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_int_f_1.html","text":"public subroutine h5ltmake_compressed_dataset_int_f_1(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 1 Calls proc~~h5ltmake_compressed_dataset_int_f_1~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_1~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_int_f_2 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_int_f_2.html","text":"public subroutine h5ltmake_compressed_dataset_int_f_2(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 2 Calls proc~~h5ltmake_compressed_dataset_int_f_2~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_2~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_int_f_3 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_int_f_3.html","text":"public subroutine h5ltmake_compressed_dataset_int_f_3(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 3 Calls proc~~h5ltmake_compressed_dataset_int_f_3~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_3~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_int_f_4 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_int_f_4.html","text":"public subroutine h5ltmake_compressed_dataset_int_f_4(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 4 Calls proc~~h5ltmake_compressed_dataset_int_f_4~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_4~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_int_f_5 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_int_f_5.html","text":"public subroutine h5ltmake_compressed_dataset_int_f_5(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 5 Calls proc~~h5ltmake_compressed_dataset_int_f_5~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_5~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_int_f_6 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_int_f_6.html","text":"public subroutine h5ltmake_compressed_dataset_int_f_6(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 6 Calls proc~~h5ltmake_compressed_dataset_int_f_6~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_6~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_int_f_7 – Fortran Program","loc":"proc/h5ltmake_compressed_dataset_int_f_7.html","text":"public subroutine h5ltmake_compressed_dataset_int_f_7(loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 7 Calls proc~~h5ltmake_compressed_dataset_int_f_7~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_7~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=HID_T), public :: did integer(kind=HID_T), public :: sid integer(kind=HID_T), public :: plist_id","tags":""},{"title":"h5ltmake_compressed_dataset_double_f – Fortran Program","loc":"interface/h5ltmake_compressed_dataset_double_f.html","text":"public interface h5ltmake_compressed_dataset_double_f Write a compressed datasets of 64-bit floats Calls interface~~h5ltmake_compressed_dataset_double_f~~CallsGraph interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f var paninterfaceh5ltmake_compressed_dataset_double_fCallsGraph = svgPanZoom('#interfaceh5ltmake_compressed_dataset_double_fCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~h5ltmake_compressed_dataset_double_f~~CalledByGraph interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx program~fidasim->proc~write_spectra program~fidasim->proc~write_npa proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var paninterfaceh5ltmake_compressed_dataset_double_fCalledByGraph = svgPanZoom('#interfaceh5ltmake_compressed_dataset_double_fCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public subroutine h5ltmake_compressed_dataset_double_f_1 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 1 public subroutine h5ltmake_compressed_dataset_double_f_2 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 2 public subroutine h5ltmake_compressed_dataset_double_f_3 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 3 public subroutine h5ltmake_compressed_dataset_double_f_4 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 4 public subroutine h5ltmake_compressed_dataset_double_f_5 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 5 public subroutine h5ltmake_compressed_dataset_double_f_6 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 6 public subroutine h5ltmake_compressed_dataset_double_f_7 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 7","tags":""},{"title":"h5ltmake_compressed_dataset_int_f – Fortran Program","loc":"interface/h5ltmake_compressed_dataset_int_f.html","text":"public interface h5ltmake_compressed_dataset_int_f Write a compressed dataset of 32-bit integers Calls interface~~h5ltmake_compressed_dataset_int_f~~CallsGraph interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~h5ltmake_compressed_dataset_int_f~~CalledByGraph interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public subroutine h5ltmake_compressed_dataset_int_f_1 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 1 public subroutine h5ltmake_compressed_dataset_int_f_2 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 2 public subroutine h5ltmake_compressed_dataset_int_f_3 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 3 public subroutine h5ltmake_compressed_dataset_int_f_4 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 4 public subroutine h5ltmake_compressed_dataset_int_f_5 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 5 public subroutine h5ltmake_compressed_dataset_int_f_6 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 6 public subroutine h5ltmake_compressed_dataset_int_f_7 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 7","tags":""},{"title":"rng_uniform – Fortran Program","loc":"proc/rng_uniform.html","text":"public function rng_uniform(self) result(u) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Uniform random deviate Description Generate a uniformally-distributed random number in the range [0,1) Called By proc~~rng_uniform~~CalledByGraph proc~rng_uniform rng_uniform proc~randu randu proc~randu->proc~rng_uniform proc~rng_normal rng_normal proc~rng_normal->proc~rng_uniform proc~randind_w_2 randind_w_2 proc~randind_w_2->proc~randu proc~get_nlaunch get_nlaunch proc~get_nlaunch->proc~randu proc~fida_mc fida_mc proc~fida_mc->proc~randu proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~randind_w_1 randind_w_1 proc~randind_w_1->proc~randu proc~mc_fastion mc_fastion proc~mc_fastion->proc~randu interface~randind randind proc~mc_fastion->interface~randind proc~randind_n randind_n proc~randind_n->proc~randu proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~randu proc~read_chords read_chords proc~read_chords->proc~randu proc~mc_nbi mc_nbi proc~mc_nbi->proc~randu proc~randn randn proc~mc_nbi->proc~randn proc~ndmc ndmc proc~ndmc->proc~randu proc~ndmc->proc~mc_nbi proc~ndmc->interface~randind proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~randu proc~fida_weights_mc->proc~get_nlaunch proc~fida_weights_mc->interface~randind proc~fida_weights_mc->proc~get_beam_cx_prob proc~npa_mc npa_mc proc~npa_mc->proc~randu proc~npa_mc->proc~get_beam_cx_prob proc~mc_halo mc_halo proc~mc_halo->proc~randu proc~mc_halo->proc~randn interface~randind->proc~randind_w_2 interface~randind->proc~randind_w_1 interface~randind->proc~randind_n proc~fida_f fida_f proc~fida_f->proc~get_nlaunch proc~fida_f->proc~mc_fastion proc~fida_f->proc~get_beam_cx_prob proc~halo halo proc~halo->proc~get_nlaunch proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~dcx dcx proc~dcx->proc~get_nlaunch proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~npa_f npa_f proc~npa_f->proc~get_nlaunch proc~npa_f->proc~mc_fastion proc~npa_f->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~fida_mc program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_chords program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~dcx program~fidasim->proc~npa_f proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~npa_weights->proc~get_beam_cx_prob proc~randn->proc~rng_normal var panprocrng_uniformCalledByGraph = svgPanZoom('#procrng_uniformCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: iy integer, public :: k","tags":""},{"title":"rng_normal – Fortran Program","loc":"proc/rng_normal.html","text":"public function rng_normal(self) result(n) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Normal random deviate Description Generate a normally-distributed random number with mean 0 and standard deviation 1 Calls proc~~rng_normal~~CallsGraph proc~rng_normal rng_normal proc~rng_uniform rng_uniform proc~rng_normal->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~rng_normal~~CalledByGraph proc~rng_normal rng_normal proc~randn randn proc~randn->proc~rng_normal proc~mc_nbi mc_nbi proc~mc_nbi->proc~randn proc~mc_halo mc_halo proc~mc_halo->proc~randn proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~ndmc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~fida_weights_los->proc~mc_halo proc~get_beam_cx_prob get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~fida_f->proc~get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public :: s = 0.449871d0 real(kind=Float64), public :: t = 0.386595d0 real(kind=Float64), public :: a = 0.196000d0 real(kind=Float64), public :: b = 0.254720d0 real(kind=Float64), public :: r1 = 0.27597d0 real(kind=Float64), public :: r2 = 0.27846d0 real(kind=Float64), public :: u real(kind=Float64), public :: v real(kind=Float64), public :: x real(kind=Float64), public :: y real(kind=Float64), public :: q","tags":""},{"title":"rng_init – Fortran Program","loc":"proc/rng_init.html","text":"public subroutine rng_init(self, seed) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator integer, intent(in) :: seed Initial Seed Value Description Procedure to initialize a random number generator with a seed Called By proc~~rng_init~~CalledByGraph proc~rng_init rng_init program~fidasim fidasim program~fidasim->proc~rng_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"randu – Fortran Program","loc":"proc/randu.html","text":"public subroutine randu(randomu) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomu Array of uniform random deviates Description Generate an array of uniformally-distributed random deviates Calls proc~~randu~~CallsGraph proc~randu randu proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~randu~~CalledByGraph proc~randu randu proc~randind_w_2 randind_w_2 proc~randind_w_2->proc~randu proc~get_nlaunch get_nlaunch proc~get_nlaunch->proc~randu proc~fida_mc fida_mc proc~fida_mc->proc~randu proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~randind_w_1 randind_w_1 proc~randind_w_1->proc~randu proc~mc_fastion mc_fastion proc~mc_fastion->proc~randu interface~randind randind proc~mc_fastion->interface~randind proc~randind_n randind_n proc~randind_n->proc~randu proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~randu proc~read_chords read_chords proc~read_chords->proc~randu proc~mc_nbi mc_nbi proc~mc_nbi->proc~randu proc~ndmc ndmc proc~ndmc->proc~randu proc~ndmc->proc~mc_nbi proc~ndmc->interface~randind proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~randu proc~fida_weights_mc->proc~get_nlaunch proc~fida_weights_mc->interface~randind proc~fida_weights_mc->proc~get_beam_cx_prob proc~npa_mc npa_mc proc~npa_mc->proc~randu proc~npa_mc->proc~get_beam_cx_prob proc~mc_halo mc_halo proc~mc_halo->proc~randu interface~randind->proc~randind_w_2 interface~randind->proc~randind_w_1 interface~randind->proc~randind_n proc~fida_f fida_f proc~fida_f->proc~get_nlaunch proc~fida_f->proc~mc_fastion proc~fida_f->proc~get_beam_cx_prob proc~halo halo proc~halo->proc~get_nlaunch proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~dcx dcx proc~dcx->proc~get_nlaunch proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~npa_f npa_f proc~npa_f->proc~get_nlaunch proc~npa_f->proc~mc_fastion proc~npa_f->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~fida_mc program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_chords program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_mc program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~dcx program~fidasim->proc~npa_f proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_los->proc~mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~npa_weights->proc~get_beam_cx_prob var panprocranduCalledByGraph = svgPanZoom('#procranduCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: thread_id","tags":""},{"title":"randn – Fortran Program","loc":"proc/randn.html","text":"public subroutine randn(randomn) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomn Array of normal random deviates Description Generate an array of normally-distributed random deviates Calls proc~~randn~~CallsGraph proc~randn randn proc~rng_normal rng_normal proc~randn->proc~rng_normal omp_get_thread_num omp_get_thread_num proc~randn->omp_get_thread_num proc~rng_uniform rng_uniform proc~rng_normal->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~randn~~CalledByGraph proc~randn randn proc~mc_nbi mc_nbi proc~mc_nbi->proc~randn proc~mc_halo mc_halo proc~mc_halo->proc~randn proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~ndmc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~fida_weights_los->proc~mc_halo proc~get_beam_cx_prob get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~fida_f->proc~get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: thread_id","tags":""},{"title":"randind_n – Fortran Program","loc":"proc/randind_n.html","text":"private subroutine randind_n(n, randomi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates Description Generate a array of uniformally-distributed random integers in the range [1, n] Calls proc~~randind_n~~CallsGraph proc~randind_n randind_n proc~randu randu proc~randind_n->proc~randu proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~randind_n~~CalledByGraph proc~randind_n randind_n interface~randind randind interface~randind->proc~randind_n proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~randind proc~mc_fastion mc_fastion proc~mc_fastion->interface~randind proc~ndmc ndmc proc~ndmc->interface~randind program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i real(kind=Float64), public, dimension(1) :: randomu","tags":""},{"title":"randind_w_1 – Fortran Program","loc":"proc/randind_w_1.html","text":"private subroutine randind_w_1(w, randomi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices Description Generate an array of random indices of an 1D array distributed according to w Calls proc~~randind_w_1~~CallsGraph proc~randind_w_1 randind_w_1 proc~randu randu proc~randind_w_1->proc~randu proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~randind_w_1~~CalledByGraph proc~randind_w_1 randind_w_1 interface~randind randind interface~randind->proc~randind_w_1 proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~randind proc~mc_fastion mc_fastion proc~mc_fastion->interface~randind proc~ndmc ndmc proc~ndmc->interface~randind program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=Float64), public :: dum real(kind=Float64), public :: cdf_val real(kind=Float64), public :: w_tot real(kind=Float64), public, dimension(1) :: randomu","tags":""},{"title":"ind2sub – Fortran Program","loc":"proc/ind2sub.html","text":"public subroutine ind2sub(dims, ind, subs) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimensions of array integer, intent(in) :: ind Linear index integer, intent(out), dimension(:) :: subs Subscripts corresponding to the linear index Description Calculate the subscripts subs into an array with dimensions dims given the corresponding linear index ind Called By proc~~ind2sub~~CalledByGraph proc~ind2sub ind2sub proc~randind_w_2 randind_w_2 proc~randind_w_2->proc~ind2sub interface~randind randind interface~randind->proc~randind_w_2 proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~randind proc~mc_fastion mc_fastion proc~mc_fastion->interface~randind proc~ndmc ndmc proc~ndmc->interface~randind program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ndims integer, public :: ind1 integer, public :: ind2","tags":""},{"title":"randind_w_2 – Fortran Program","loc":"proc/randind_w_2.html","text":"private subroutine randind_w_2(w, randomi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts Description Generate an array of random subscripts of an 2D array distributed according to w Calls proc~~randind_w_2~~CallsGraph proc~randind_w_2 randind_w_2 proc~randu randu proc~randind_w_2->proc~randu proc~ind2sub ind2sub proc~randind_w_2->proc~ind2sub proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~randind_w_2~~CalledByGraph proc~randind_w_2 randind_w_2 interface~randind randind interface~randind->proc~randind_w_2 proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~randind proc~mc_fastion mc_fastion proc~mc_fastion->interface~randind proc~ndmc ndmc proc~ndmc->interface~randind program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public, dimension(2) :: subs real(kind=Float64), public :: dum real(kind=Float64), public :: cdf_val real(kind=Float64), public :: w_tot real(kind=Float64), public, dimension(1) :: randomu","tags":""},{"title":"randind – Fortran Program","loc":"interface/randind.html","text":"public interface randind Procedure for generating a random array index/subscripts Calls interface~~randind~~CallsGraph interface~randind randind proc~randind_w_2 randind_w_2 interface~randind->proc~randind_w_2 proc~randind_w_1 randind_w_1 interface~randind->proc~randind_w_1 proc~randind_n randind_n interface~randind->proc~randind_n proc~randu randu proc~randind_w_2->proc~randu proc~ind2sub ind2sub proc~randind_w_2->proc~ind2sub proc~randind_w_1->proc~randu proc~randind_n->proc~randu proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~randind~~CalledByGraph interface~randind randind proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~randind proc~mc_fastion mc_fastion proc~mc_fastion->interface~randind proc~ndmc ndmc proc~ndmc->interface~randind program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine randind_n (n, randomi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates Description Generate a array of uniformally-distributed random integers in the range [1, n] private subroutine randind_w_1 (w, randomi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices Description Generate an array of random indices of an 1D array distributed according to w private subroutine randind_w_2 (w, randomi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts Description Generate an array of random subscripts of an 2D array distributed according to w","tags":""},{"title":"p_cx_1_janev – Fortran Program","loc":"proc/p_cx_1_janev.html","text":"public function p_cx_1_janev(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_1_janev~~CalledByGraph proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_2 proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_janevCalledByGraph = svgPanZoom('#procp_cx_1_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: a = [3.2345d0, 2.3588d2, 2.3713d0, 3.8371d-2, 3.8068d-6, 1.1832d-10] real(kind=Float64), public, parameter :: n = 1.d0 real(kind=Float64), public :: Ehat","tags":""},{"title":"p_cx_2_janev – Fortran Program","loc":"proc/p_cx_2_janev.html","text":"public function p_cx_2_janev(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_2_janev~~CalledByGraph proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_2 proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_2_janevCalledByGraph = svgPanZoom('#procp_cx_2_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: a = [9.2750d-1, 6.5040d3, 2.0699d1, 1.3405d-2, 3.0842d-6, 1.1832d-10] real(kind=Float64), public, parameter :: n = 2.d0 real(kind=Float64), public :: Ehat","tags":""},{"title":"p_cx_3_janev – Fortran Program","loc":"proc/p_cx_3_janev.html","text":"public function p_cx_3_janev(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_3_janev~~CalledByGraph proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_2 proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_3_janevCalledByGraph = svgPanZoom('#procp_cx_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: a = [3.7271d-1, 2.7645d6, 1.4857d3, 1.5720d-3, 3.0842d-6, 1.1832d-10] real(kind=Float64), public, parameter :: n = 3.d0 real(kind=Float64), public :: Ehat","tags":""},{"title":"p_cx_4_janev – Fortran Program","loc":"proc/p_cx_4_janev.html","text":"public function p_cx_4_janev(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_4_janev~~CalledByGraph proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_2 proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_4_janevCalledByGraph = svgPanZoom('#procp_cx_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: a = [2.1336d-1, 1.0000d10, 1.3426d6, 1.8184d-3, 3.0842d-6, 1.1832d-10] real(kind=Float64), public, parameter :: n = 4.d0 real(kind=Float64), public :: Ehat","tags":""},{"title":"p_cx_janev – Fortran Program","loc":"proc/p_cx_janev.html","text":"public function p_cx_janev(Erel, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: n Return Value real(kind=Float64) Calls proc~~p_cx_janev~~CallsGraph proc~p_cx_janev p_cx_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_cx_janev~~CalledByGraph proc~p_cx_janev p_cx_janev proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_2 proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_janevCalledByGraph = svgPanZoom('#procp_cx_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i","tags":""},{"title":"p_cx_1_1_adas – Fortran Program","loc":"proc/p_cx_1_1_adas.html","text":"public function p_cx_1_1_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_1_1_adas~~CalledByGraph proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_1_adasCalledByGraph = svgPanZoom('#procp_cx_1_1_adasCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(7) :: a = [-3.496092687d2, 4.724931484d2, -2.720493064d2, 8.158564625d1, -1.339790721d1, 1.138706949d0, -3.914774156d-2] real(kind=Float64), public :: e real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"p_cx_1_2_adas – Fortran Program","loc":"proc/p_cx_1_2_adas.html","text":"public function p_cx_1_2_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_1_2_adas~~CalledByGraph proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx_n->proc~p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h proc~p_cx_3->proc~p_cx_1 var panprocp_cx_1_2_adasCalledByGraph = svgPanZoom('#procp_cx_1_2_adasCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(9) :: a = [-4.036239511d3, 6.941235312d3, -5.186974866d3, 2.194885201d3, -5.765960509d2, 9.653534186d1, -1.008066138d1, 6.010731909d-1, -1.567417031d-2] real(kind=Float64), public :: e real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"p_cx_1_3_adas – Fortran Program","loc":"proc/p_cx_1_3_adas.html","text":"public function p_cx_1_3_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_1_3_adas~~CalledByGraph proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_3_adasCalledByGraph = svgPanZoom('#procp_cx_1_3_adasCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(10) :: a = [7.037287586d4, -1.479161477d5, 1.370120708d5, -7.343180122d4, 2.509832081d4, -5.674317075d3, 8.487767749d2, -8.102284612d1, 4.480007503d0, -1.093512342d-1] real(kind=Float64), public :: e real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"p_cx_1_4_adas – Fortran Program","loc":"proc/p_cx_1_4_adas.html","text":"public function p_cx_1_4_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_1_4_adas~~CalledByGraph proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_4_adasCalledByGraph = svgPanZoom('#procp_cx_1_4_adasCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(10) :: a = [6.826447557d4, -1.431980004d5, 1.323968679d5, -7.083995050d4, 2.417608863d4, -5.458418789d3, 8.154875237d2, -7.776012846d1, 4.295431731d0, -1.047567211d-1] real(kind=Float64), public :: e real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"p_cx_1 – Fortran Program","loc":"proc/p_cx_1.html","text":"public function p_cx_1(Erel, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~p_cx_1~~CallsGraph proc~p_cx_1 p_cx_1 proc~p_cx_janev p_cx_janev proc~p_cx_1->proc~p_cx_janev proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_cx_1~~CalledByGraph proc~p_cx_1 p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public :: norm_fac","tags":""},{"title":"p_cx_2_2_adas – Fortran Program","loc":"proc/p_cx_2_2_adas.html","text":"public function p_cx_2_2_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_2_2_adas~~CalledByGraph proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(11) :: a2s = [-1.896015167d6, 4.431727330d6, -4.627815357d6, 2.843068107d6, -1.137952956d6, 3.100801094d5, -5.825744660d4, 7.452319142d3, -6.212350647d2, 3.047712749d1, -6.682658463d-1] real(kind=Float64), public, parameter, dimension(11) :: a2p = [-1.614213508d5, 3.772469288d5, -3.924736424d5, 2.393127027d5, -9.470300966d4, 2.541276100d4, -4.682860453d3, 5.851219013d2, -4.744504549d1, 2.254460913d0, -4.767235839d-2] real(kind=Float64), public, parameter :: n = 2.d0 real(kind=Float64), public :: e real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: sigma2s real(kind=Float64), public :: sigma2p","tags":""},{"title":"p_cx_2_3_adas – Fortran Program","loc":"proc/p_cx_2_3_adas.html","text":"public function p_cx_2_3_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_2_3_adas~~CalledByGraph proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(11) :: a2s = [-3.513030327d5, 9.281116596d5, -1.086843398d6, 7.437325055d5, -3.296609685d5, 9.897503768d4, -2.039707143d4, 2.850670244d3, -2.587092857d2, 1.377382945d1, -3.268306303d-1] real(kind=Float64), public, parameter, dimension(11) :: a2p = [-1.901264631d5, 5.124716103d5, -6.101921504d5, 4.234717934d5, -1.899866398d5, 5.764464326d4, -1.199087959d4, 1.689900512d3, -1.545334374d2, 8.285001228d0, -1.978656474d-1] real(kind=Float64), public, parameter :: n = 2.d0 real(kind=Float64), public :: ee real(kind=Float64), public :: l real(kind=Float64), public :: sigma2s real(kind=Float64), public :: sigma2p","tags":""},{"title":"p_cx_2 – Fortran Program","loc":"proc/p_cx_2.html","text":"public function p_cx_2(Erel, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~p_cx_2~~CallsGraph proc~p_cx_2 p_cx_2 proc~m_spread m_spread proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_janev p_cx_janev proc~p_cx_2->proc~p_cx_janev proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_cx_2~~CalledByGraph proc~p_cx_2 p_cx_2 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: n2 = 4.d0 integer, public :: i real(kind=Float64), public :: En real(kind=Float64), public :: Em real(kind=Float64), public :: sigma_n real(kind=Float64), public :: norm_fac","tags":""},{"title":"p_cx_3_2_adas – Fortran Program","loc":"proc/p_cx_3_2_adas.html","text":"public function p_cx_3_2_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_3_2_adas~~CalledByGraph proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(11) :: a = [-1.149224555d6, 2.750368877d6, -2.942222842d6, 1.852584954d6, -7.603284323d5, 2.125284465d5, -4.097580431d4, 5.380901722d3, -4.606297192d2, 2.321345254d1, -5.230186707d-1] real(kind=Float64), public, parameter :: n = 3.0 real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"p_cx_3_3_adas – Fortran Program","loc":"proc/p_cx_3_3_adas.html","text":"public function p_cx_3_3_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_3_3_adas~~CalledByGraph proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(10) :: a = [-4.302808608d4, 9.499298161d4, -9.264698488d4, 5.236947172d4, -1.890479538d4, 4.519068626d3, -7.152485009d2, 7.227063167d1, -4.230036444d0, 1.092702525d-1] real(kind=Float64), public, parameter :: n = 3.0 real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"p_cx_3_4_adas – Fortran Program","loc":"proc/p_cx_3_4_adas.html","text":"public function p_cx_3_4_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_3_4_adas~~CalledByGraph proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(9) :: a = [1.705303425d4, -3.316878090d4, 2.792556433d4, -1.330264490d4, 3.921666688d3, -7.327555138d2, 8.476342861d1, -5.551987930d0, 1.577120745d-1] real(kind=Float64), public, parameter :: n = 3.0 real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"p_cx_3_5_adas – Fortran Program","loc":"proc/p_cx_3_5_adas.html","text":"public function p_cx_3_5_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_3_5_adas~~CalledByGraph proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(11) :: a = [-2.786268232d2, 4.269683825d4, -8.973561028d4, 8.365732310d4, -4.524587937d4, 1.563630402d4, -3.580391824d3, 5.432527332d2, -5.267599631d1, 2.962329657d0, -7.362649692d-2] real(kind=Float64), public, parameter :: n = 3.0 real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"p_cx_3_6inf_adas – Fortran Program","loc":"proc/p_cx_3_6inf_adas.html","text":"public function p_cx_3_6inf_adas(Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) Called By proc~~p_cx_3_6inf_adas~~CalledByGraph proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(11) :: a = [7.146969470d5, -1.665413326d6, 1.735840441d6, -1.065792786d6, 4.269334710d5, -1.165954977d5, 2.198700496d4, -2.827160468d3, 2.372409350d2, -1.173264972d1, 2.596865877d-1] real(kind=Float64), public, parameter :: n = 3.0 real(kind=Float64), public :: ee real(kind=Float64), public :: fac real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"p_cx_3 – Fortran Program","loc":"proc/p_cx_3.html","text":"public function p_cx_3(Erel, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~p_cx_3~~CallsGraph proc~p_cx_3 p_cx_3 proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_janev p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_1 p_cx_1 proc~p_cx_3->proc~p_cx_1 proc~m_spread m_spread proc~p_cx_3->proc~m_spread proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_cx_3~~CalledByGraph proc~p_cx_3 p_cx_3 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: n2 = 9.d0 real(kind=Float64), public :: eb real(kind=Float64), public :: En real(kind=Float64), public :: Em real(kind=Float64), public :: sigma_m6 real(kind=Float64), public :: norm_fac real(kind=Float64), public, dimension(m_max) :: sigma1","tags":""},{"title":"p_cx_n – Fortran Program","loc":"proc/p_cx_n.html","text":"public function p_cx_n(Erel, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~p_cx_n~~CallsGraph proc~p_cx_n p_cx_n proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_cx_n~~CalledByGraph proc~p_cx_n p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(m_max) :: sigma2 real(kind=Float64), public, dimension(m_max) :: sigma3 real(kind=Float64), public :: sigma_n real(kind=Float64), public :: e real(kind=Float64), public :: norm_fac","tags":""},{"title":"p_cx_n_m – Fortran Program","loc":"proc/p_cx_n_m.html","text":"public function p_cx_n_m(Erel, n, m) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) Calls proc~~p_cx_n_m~~CallsGraph proc~p_cx_n_m p_cx_n_m proc~p_cx_n p_cx_n proc~p_cx_n_m->proc~p_cx_n proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m_max = 12 real(kind=Float64), public, dimension(12) :: sigma_m","tags":""},{"title":"p_cx – Fortran Program","loc":"proc/p_cx.html","text":"public function p_cx(Erel, n_max, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: n_max integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max,n_max) Calls proc~~p_cx~~CallsGraph proc~p_cx p_cx proc~p_cx_n p_cx_n proc~p_cx->proc~p_cx_n proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_cx~~CalledByGraph proc~p_cx p_cx proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(12,12) :: sigma_full integer, public :: n integer, public :: m","tags":""},{"title":"p_ioniz_1_omullane – Fortran Program","loc":"proc/p_ioniz_1_omullane.html","text":"public function p_ioniz_1_omullane(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_ioniz_1_omullane~~CalledByGraph proc~p_ioniz_1_omullane p_ioniz_1_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_1_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: b = [2.0160d-3, 3.7154d0, 3.9890d-2, 3.1413d-1, 2.1254d0, 6.3990d3, 6.1897d1, 9.2731d3] real(kind=Float64), public, parameter :: n2 = 1.d0 real(kind=Float64), public :: Ehat real(kind=Float64), public :: p1 real(kind=Float64), public :: p2 real(kind=Float64), public :: p3","tags":""},{"title":"p_ioniz_2_omullane – Fortran Program","loc":"proc/p_ioniz_2_omullane.html","text":"public function p_ioniz_2_omullane(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_ioniz_2_omullane~~CalledByGraph proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: b = [3.9330d-3, 1.8188d0, 1.8870d-2, 6.7489d-3, 1.3768d0, 6.8852d2, 9.6435d1, 5.6515d23] real(kind=Float64), public, parameter :: n2 = 4.d0 real(kind=Float64), public :: Ehat real(kind=Float64), public :: p1 real(kind=Float64), public :: p2 real(kind=Float64), public :: p3","tags":""},{"title":"p_ioniz_3_omullane – Fortran Program","loc":"proc/p_ioniz_3_omullane.html","text":"public function p_ioniz_3_omullane(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_ioniz_3_omullane~~CalledByGraph proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: b = [1.1076d-2, 1.6197d0, 6.7154d-3, 5.1188d-3, 1.8549d0, 2.3696d2, 7.8286d1, 1.0926d23] real(kind=Float64), public, parameter :: n2 = 9.d0 real(kind=Float64), public :: Ehat real(kind=Float64), public :: p1 real(kind=Float64), public :: p2 real(kind=Float64), public :: p3","tags":""},{"title":"p_ioniz_4_omullane – Fortran Program","loc":"proc/p_ioniz_4_omullane.html","text":"public function p_ioniz_4_omullane(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_ioniz_4_omullane~~CalledByGraph proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: b = [1.1033d-2, 1.6281d0, 5.5955d-3, 7.2023d-3, 1.7358d0, 2.2755d2, 8.6339d1, 3.9151d29] real(kind=Float64), public, parameter :: n2 = 16.d0 real(kind=Float64), public :: Ehat real(kind=Float64), public :: p1 real(kind=Float64), public :: p2 real(kind=Float64), public :: p3","tags":""},{"title":"p_ioniz_5_omullane – Fortran Program","loc":"proc/p_ioniz_5_omullane.html","text":"public function p_ioniz_5_omullane(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_ioniz_5_omullane~~CalledByGraph proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: b = [1.1297d-2, 1.8685d0, 1.5038d-2, 1.1195d-1, 1.0538d0, 8.6096d2, 8.9939d1, 1.9249d4] real(kind=Float64), public, parameter :: n2 = 25.d0 real(kind=Float64), public :: Ehat real(kind=Float64), public :: p1 real(kind=Float64), public :: p2 real(kind=Float64), public :: p3","tags":""},{"title":"p_ioniz_n – Fortran Program","loc":"proc/p_ioniz_n.html","text":"public function p_ioniz_n(eb, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n Return Value real(kind=Float64) Calls proc~~p_ioniz_n~~CallsGraph proc~p_ioniz_n p_ioniz_n proc~p_ioniz_1_omullane p_ioniz_1_omullane proc~p_ioniz_n->proc~p_ioniz_1_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_ioniz_n~~CalledByGraph proc~p_ioniz_n p_ioniz_n proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"p_ioniz – Fortran Program","loc":"proc/p_ioniz.html","text":"public function p_ioniz(eb, n_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n_max Return Value real(kind=Float64),\n  dimension(n_max) Calls proc~~p_ioniz~~CallsGraph proc~p_ioniz p_ioniz proc~p_ioniz_n p_ioniz_n proc~p_ioniz->proc~p_ioniz_n proc~p_ioniz_1_omullane p_ioniz_1_omullane proc~p_ioniz_n->proc~p_ioniz_1_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_ioniz~~CalledByGraph proc~p_ioniz p_ioniz proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i","tags":""},{"title":"p_excit_1_2_janev – Fortran Program","loc":"proc/p_excit_1_2_janev.html","text":"public function p_excit_1_2_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_1_2_janev~~CalledByGraph proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_2_janevCalledByGraph = svgPanZoom('#procp_excit_1_2_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(10) :: a = [34.433d0, 8.5476d0, 7.8501d0, -9.2217d0, 1.8020d-2, 1.6931d0, 1.9422d-3, 2.9068d0, 44.507d0, 0.56870d0]","tags":""},{"title":"p_excit_1_3_janev – Fortran Program","loc":"proc/p_excit_1_3_janev.html","text":"public function p_excit_1_3_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_1_3_janev~~CalledByGraph proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_3_janevCalledByGraph = svgPanZoom('#procp_excit_1_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: b = [6.1950d0, 5.5162d-3, 0.29114d0, -4.5264d0, 6.0311d0, -2.0679d0, 35.773d0, 0.54818d0]","tags":""},{"title":"p_excit_1_4_janev – Fortran Program","loc":"proc/p_excit_1_4_janev.html","text":"public function p_excit_1_4_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_1_4_janev~~CalledByGraph proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_4_janevCalledByGraph = svgPanZoom('#procp_excit_1_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: b = [2.0661d0, 5.1335d-4, 0.28953d0, -2.2849d0, 0.11528d0, -4.8970d0, 34.975d0, 0.91213d0]","tags":""},{"title":"p_excit_1_5_janev – Fortran Program","loc":"proc/p_excit_1_5_janev.html","text":"public function p_excit_1_5_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_1_5_janev~~CalledByGraph proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_5_janevCalledByGraph = svgPanZoom('#procp_excit_1_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: b = [1.2449d0, 3.0826d-4, 0.31063d0, -2.4161d0, 0.024664d0, -6.3726d0, 32.291d0, 0.21176d0]","tags":""},{"title":"p_excit_1_6_janev – Fortran Program","loc":"proc/p_excit_1_6_janev.html","text":"public function p_excit_1_6_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_1_6_janev~~CalledByGraph proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_6_janevCalledByGraph = svgPanZoom('#procp_excit_1_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: b = [0.63771d0, 3.2949d-4, 0.25757d0, -2.2950d0, 0.050796d0, -5.5986d0, 37.174d0, 0.39265d0]","tags":""},{"title":"p_excit_1_janev – Fortran Program","loc":"proc/p_excit_1_janev.html","text":"public function p_excit_1_janev(eb, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~p_excit_1_janev~~CallsGraph proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_1_janev~~CalledByGraph proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m","tags":""},{"title":"p_excit_2_3_janev – Fortran Program","loc":"proc/p_excit_2_3_janev.html","text":"public function p_excit_2_3_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_2_3_janev~~CalledByGraph proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_3_janevCalledByGraph = svgPanZoom('#procp_excit_2_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: c = [394.51d0, 0.013597d0, 0.16565d0, -0.8949d0, 21.606d0, 0.62426d0]","tags":""},{"title":"p_excit_2_4_janev – Fortran Program","loc":"proc/p_excit_2_4_janev.html","text":"public function p_excit_2_4_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_2_4_janev~~CalledByGraph proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_4_janevCalledByGraph = svgPanZoom('#procp_excit_2_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: c = [50.744d0, 0.014398d0, 0.31584d0, -1.4799d0, 19.416d0, 4.0262d0]","tags":""},{"title":"p_excit_2_5_janev – Fortran Program","loc":"proc/p_excit_2_5_janev.html","text":"public function p_excit_2_5_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_2_5_janev~~CalledByGraph proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_5_janevCalledByGraph = svgPanZoom('#procp_excit_2_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: c = [18.264d0, 0.013701d0, 0.31711d0, -1.4775d0, 18.973d0, 2.9056d0]","tags":""},{"title":"p_excit_2_6_janev – Fortran Program","loc":"proc/p_excit_2_6_janev.html","text":"public function p_excit_2_6_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Calls proc~~p_excit_2_6_janev~~CallsGraph proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_6_janev~~CalledByGraph proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_6_janevCalledByGraph = svgPanZoom('#procp_excit_2_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 4.61d-1","tags":""},{"title":"p_excit_2_7_janev – Fortran Program","loc":"proc/p_excit_2_7_janev.html","text":"public function p_excit_2_7_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Calls proc~~p_excit_2_7_janev~~CallsGraph proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_7_janev~~CalledByGraph proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_7_janevCalledByGraph = svgPanZoom('#procp_excit_2_7_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 2.475d-1","tags":""},{"title":"p_excit_2_8_janev – Fortran Program","loc":"proc/p_excit_2_8_janev.html","text":"public function p_excit_2_8_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Calls proc~~p_excit_2_8_janev~~CallsGraph proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_8_janev~~CalledByGraph proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_8_janevCalledByGraph = svgPanZoom('#procp_excit_2_8_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 1.465d-1","tags":""},{"title":"p_excit_2_9_janev – Fortran Program","loc":"proc/p_excit_2_9_janev.html","text":"public function p_excit_2_9_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Calls proc~~p_excit_2_9_janev~~CallsGraph proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_9_janev~~CalledByGraph proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_9_janevCalledByGraph = svgPanZoom('#procp_excit_2_9_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 9.2d-2","tags":""},{"title":"p_excit_2_10_janev – Fortran Program","loc":"proc/p_excit_2_10_janev.html","text":"public function p_excit_2_10_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Calls proc~~p_excit_2_10_janev~~CallsGraph proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_10_janev~~CalledByGraph proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_10_janevCalledByGraph = svgPanZoom('#procp_excit_2_10_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 6.05d-2","tags":""},{"title":"p_excit_2_janev – Fortran Program","loc":"proc/p_excit_2_janev.html","text":"public function p_excit_2_janev(eb, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~p_excit_2_janev~~CallsGraph proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_janev~~CalledByGraph proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m","tags":""},{"title":"p_excit_3_4_janev – Fortran Program","loc":"proc/p_excit_3_4_janev.html","text":"public function p_excit_3_4_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_3_4_janev~~CalledByGraph proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_4_janevCalledByGraph = svgPanZoom('#procp_excit_3_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: c = [1247.5d0, 0.068781d0, 0.521176d0, -1.2722d0, 11.319d0, 2.6235d0]","tags":""},{"title":"p_excit_3_5_janev – Fortran Program","loc":"proc/p_excit_3_5_janev.html","text":"public function p_excit_3_5_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_3_5_janev~~CalledByGraph proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_5_janevCalledByGraph = svgPanZoom('#procp_excit_3_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: c = [190.59d0, 0.073307d0, 0.54177d0, -1.2894d0, 11.096d0, 2.9098d0]","tags":""},{"title":"p_excit_3_6_janev – Fortran Program","loc":"proc/p_excit_3_6_janev.html","text":"public function p_excit_3_6_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~p_excit_3_6_janev~~CalledByGraph proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_6_janevCalledByGraph = svgPanZoom('#procp_excit_3_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: c = [63.494d0, 0.077953d0, 0.53461d0, -1.2881d0, 11.507d0, 4.3417d0]","tags":""},{"title":"p_excit_3_7_janev – Fortran Program","loc":"proc/p_excit_3_7_janev.html","text":"public function p_excit_3_7_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Calls proc~~p_excit_3_7_janev~~CallsGraph proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_7_janev~~CalledByGraph proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_7_janevCalledByGraph = svgPanZoom('#procp_excit_3_7_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 4.67d-1","tags":""},{"title":"p_excit_3_8_janev – Fortran Program","loc":"proc/p_excit_3_8_janev.html","text":"public function p_excit_3_8_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Calls proc~~p_excit_3_8_janev~~CallsGraph proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_8_janev~~CalledByGraph proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_8_janevCalledByGraph = svgPanZoom('#procp_excit_3_8_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 2.545d-1","tags":""},{"title":"p_excit_3_9_janev – Fortran Program","loc":"proc/p_excit_3_9_janev.html","text":"public function p_excit_3_9_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Calls proc~~p_excit_3_9_janev~~CallsGraph proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_9_janev~~CalledByGraph proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_9_janevCalledByGraph = svgPanZoom('#procp_excit_3_9_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 1.54d-1","tags":""},{"title":"p_excit_3_10_janev – Fortran Program","loc":"proc/p_excit_3_10_janev.html","text":"public function p_excit_3_10_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Calls proc~~p_excit_3_10_janev~~CallsGraph proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_10_janev~~CalledByGraph proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_10_janevCalledByGraph = svgPanZoom('#procp_excit_3_10_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 1.0d-1","tags":""},{"title":"p_excit_3_janev – Fortran Program","loc":"proc/p_excit_3_janev.html","text":"public function p_excit_3_janev(eb, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~p_excit_3_janev~~CallsGraph proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_janev~~CalledByGraph proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m","tags":""},{"title":"p_excit_n – Fortran Program","loc":"proc/p_excit_n.html","text":"public function p_excit_n(eb, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~p_excit_n~~CallsGraph proc~p_excit_n p_excit_n proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit_n~~CalledByGraph proc~p_excit_n p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m real(kind=Float64), public :: nf real(kind=Float64), public :: mf real(kind=Float64), public :: Etil real(kind=Float64), public :: s real(kind=Float64), public :: D real(kind=Float64), public :: A real(kind=Float64), public :: G real(kind=Float64), public :: L real(kind=Float64), public :: F real(kind=Float64), public :: y real(kind=Float64), public :: zpl real(kind=Float64), public :: zmi real(kind=Float64), public :: C2pl real(kind=Float64), public :: C2mi real(kind=Float64), public :: H","tags":""},{"title":"p_excit_n_m – Fortran Program","loc":"proc/p_excit_n_m.html","text":"public function p_excit_n_m(eb, n, m) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) Calls proc~~p_excit_n_m~~CallsGraph proc~p_excit_n_m p_excit_n_m proc~p_excit_n p_excit_n proc~p_excit_n_m->proc~p_excit_n proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(12) :: sigma_m","tags":""},{"title":"p_excit – Fortran Program","loc":"proc/p_excit.html","text":"public function p_excit(eb, n_max, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n_max integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max,n_max) Calls proc~~p_excit~~CallsGraph proc~p_excit p_excit proc~p_excit_n p_excit_n proc~p_excit->proc~p_excit_n proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~p_excit~~CalledByGraph proc~p_excit p_excit proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(12,12) :: sigma_full integer, public :: n integer, public :: m","tags":""},{"title":"e_ioniz_1_janev – Fortran Program","loc":"proc/e_ioniz_1_janev.html","text":"public function e_ioniz_1_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~e_ioniz_1_janev~~CalledByGraph proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n e_ioniz_n proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: n = 1 real(kind=Float64), public, parameter, dimension(6) :: A = [0.18450d0, -0.032226d0, -0.034539d0, 1.4003d0, -2.8115d0, 2.2986d0] real(kind=Float64), public :: Edn2 real(kind=Float64), public :: e real(kind=Float64), public :: x real(kind=Float64), public :: s","tags":""},{"title":"e_ioniz_2_janev – Fortran Program","loc":"proc/e_ioniz_2_janev.html","text":"public function e_ioniz_2_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~e_ioniz_2_janev~~CalledByGraph proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n e_ioniz_n proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: n = 2 real(kind=Float64), public, parameter, dimension(6) :: A = [0.14784d0, 0.0080871d0, -0.062270d0, 1.9414d0, -2.1980d0, 0.95894d0] real(kind=Float64), public :: Edn2 real(kind=Float64), public :: e real(kind=Float64), public :: x real(kind=Float64), public :: s","tags":""},{"title":"e_ioniz_3_janev – Fortran Program","loc":"proc/e_ioniz_3_janev.html","text":"public function e_ioniz_3_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~e_ioniz_3_janev~~CalledByGraph proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n e_ioniz_n proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: n = 3 real(kind=Float64), public, parameter, dimension(6) :: A = [0.058463d0, -0.051272d0, 0.85310d0, -0.57014d0, 0.76684d0, 0.00d0] real(kind=Float64), public :: Edn2 real(kind=Float64), public :: e real(kind=Float64), public :: x real(kind=Float64), public :: s","tags":""},{"title":"e_ioniz_n – Fortran Program","loc":"proc/e_ioniz_n.html","text":"public function e_ioniz_n(eb, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n Return Value real(kind=Float64) Calls proc~~e_ioniz_n~~CallsGraph proc~e_ioniz_n e_ioniz_n proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~e_ioniz_n~~CalledByGraph proc~e_ioniz_n e_ioniz_n proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public :: rn real(kind=Float64), public :: xn real(kind=Float64), public :: Edn2 real(kind=Float64), public :: g0 real(kind=Float64), public :: g1 real(kind=Float64), public :: g2 real(kind=Float64), public :: An real(kind=Float64), public :: b real(kind=Float64), public :: Bn","tags":""},{"title":"e_ioniz – Fortran Program","loc":"proc/e_ioniz.html","text":"public function e_ioniz(eb, n_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n_max Return Value real(kind=Float64),\n  dimension(n_max) Calls proc~~e_ioniz~~CallsGraph proc~e_ioniz e_ioniz proc~e_ioniz_n e_ioniz_n proc~e_ioniz->proc~e_ioniz_n proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~e_ioniz~~CalledByGraph proc~e_ioniz e_ioniz proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i","tags":""},{"title":"e_excit_1_2_janev – Fortran Program","loc":"proc/e_excit_1_2_janev.html","text":"public function e_excit_1_2_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~e_excit_1_2_janev~~CalledByGraph proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_2_janevCalledByGraph = svgPanZoom('#proce_excit_1_2_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: sigma0 = 5.984d0 real(kind=Float64), public, parameter :: deltaE = 10.2d0 real(kind=Float64), public, parameter :: a = 0.228d0 real(kind=Float64), public, parameter :: b = 0.1865d0 real(kind=Float64), public, parameter :: c = 0.5025d0 real(kind=Float64), public, parameter, dimension(6) :: An = [4.4979d0, 1.4182d0, -20.877d0, 49.735d0, -46.249d0, 17.442d0] real(kind=Float64), public :: ecoll real(kind=Float64), public :: x real(kind=Float64), public :: s","tags":""},{"title":"e_excit_1_3_janev – Fortran Program","loc":"proc/e_excit_1_3_janev.html","text":"public function e_excit_1_3_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~e_excit_1_3_janev~~CalledByGraph proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_3_janevCalledByGraph = svgPanZoom('#proce_excit_1_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: sigma0 = 5.984d0 real(kind=Float64), public, parameter :: deltaE = 12.09d0 real(kind=Float64), public, parameter :: alpha = 0.38277d0 real(kind=Float64), public, parameter, dimension(5) :: A = [0.75448d0, 0.42956d0, -0.58288d0, 1.0693d0, 0.d0] real(kind=Float64), public :: ecoll real(kind=Float64), public :: x real(kind=Float64), public :: s","tags":""},{"title":"e_excit_1_4_janev – Fortran Program","loc":"proc/e_excit_1_4_janev.html","text":"public function e_excit_1_4_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~e_excit_1_4_janev~~CalledByGraph proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_4_janevCalledByGraph = svgPanZoom('#proce_excit_1_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: sigma0 = 5.984d0 real(kind=Float64), public, parameter :: deltaE = 12.75d0 real(kind=Float64), public, parameter :: alpha = 0.41844d0 real(kind=Float64), public, parameter, dimension(5) :: A = [0.24300d0, 0.24846d0, 0.19701d0, 0.d0, 0.d0] real(kind=Float64), public :: ecoll real(kind=Float64), public :: x real(kind=Float64), public :: s","tags":""},{"title":"e_excit_1_5_janev – Fortran Program","loc":"proc/e_excit_1_5_janev.html","text":"public function e_excit_1_5_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~e_excit_1_5_janev~~CalledByGraph proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_5_janevCalledByGraph = svgPanZoom('#proce_excit_1_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: sigma0 = 5.984d0 real(kind=Float64), public, parameter :: deltaE = 13.06d0 real(kind=Float64), public, parameter :: alpha = 0.45929d0 real(kind=Float64), public, parameter, dimension(5) :: A = [0.11508d0, 0.13092d0, 0.23581d0, 0.d0, 0.d0] real(kind=Float64), public :: ecoll real(kind=Float64), public :: x real(kind=Float64), public :: s","tags":""},{"title":"e_excit_f – Fortran Program","loc":"proc/e_excit_f.html","text":"public function e_excit_f(n, m) result(fnm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) Called By proc~~e_excit_f~~CalledByGraph proc~e_excit_f e_excit_f proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_f proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(3) :: g real(kind=Float64), public :: x real(kind=Float64), public :: nf real(kind=Float64), public :: mf real(kind=Float64), public :: gs","tags":""},{"title":"e_excit_1_janev – Fortran Program","loc":"proc/e_excit_1_janev.html","text":"public function e_excit_1_janev(eb, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~e_excit_1_janev~~CallsGraph proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_f e_excit_f proc~e_excit_1_janev->proc~e_excit_f Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~e_excit_1_janev~~CalledByGraph proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m real(kind=Float64), public :: x real(kind=Float64), public :: y real(kind=Float64), public :: A real(kind=Float64), public :: B real(kind=Float64), public :: deltaE","tags":""},{"title":"e_excit_2_3_janev – Fortran Program","loc":"proc/e_excit_2_3_janev.html","text":"public function e_excit_2_3_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~e_excit_2_3_janev~~CalledByGraph proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: sigma0 = 5.984d0 real(kind=Float64), public, parameter :: deltaE = 1.8888d0 real(kind=Float64), public, parameter :: alpha = 1.3196d0 real(kind=Float64), public, parameter, dimension(5) :: A = [38.906d0, 5.2373d0, 119.25d0, -595.39d0, 816.71d0] real(kind=Float64), public :: ecoll real(kind=Float64), public :: x real(kind=Float64), public :: s","tags":""},{"title":"e_excit_n – Fortran Program","loc":"proc/e_excit_n.html","text":"public function e_excit_n(eb, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~e_excit_n~~CallsGraph proc~e_excit_n e_excit_n proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~e_excit_n~~CalledByGraph proc~e_excit_n e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m real(kind=Float64), public :: nf real(kind=Float64), public :: mf real(kind=Float64), public :: x real(kind=Float64), public :: y real(kind=Float64), public :: A real(kind=Float64), public :: B real(kind=Float64), public :: bn real(kind=Float64), public :: r real(kind=Float64), public :: deltaE","tags":""},{"title":"e_excit_n_m – Fortran Program","loc":"proc/e_excit_n_m.html","text":"public function e_excit_n_m(eb, n, m) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) Calls proc~~e_excit_n_m~~CallsGraph proc~e_excit_n_m e_excit_n_m proc~e_excit_n e_excit_n proc~e_excit_n_m->proc~e_excit_n proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(12) :: sigma_m","tags":""},{"title":"e_excit – Fortran Program","loc":"proc/e_excit.html","text":"public function e_excit(eb, n_max, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n_max integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(n_max,m_max) Calls proc~~e_excit~~CallsGraph proc~e_excit e_excit proc~e_excit_n e_excit_n proc~e_excit->proc~e_excit_n proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~e_excit~~CalledByGraph proc~e_excit e_excit proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(12,12) :: sigma_full integer, public :: n","tags":""},{"title":"B5_cx_1_adas – Fortran Program","loc":"proc/b5_cx_1_adas.html","text":"public function B5_cx_1_adas(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~b5_cx_1_adas~~CalledByGraph proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(7) :: A = [1.174052518d3, -1.793561728d3, 1.117522436d3, -3.679435571d2, 6.750816878d1, -6.542029074d0, 2.614113716d-1] real(kind=Float64), public :: e real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"B5_cx_2_adas – Fortran Program","loc":"proc/b5_cx_2_adas.html","text":"public function B5_cx_2_adas(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~b5_cx_2_adas~~CalledByGraph proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(10) :: A = [6.603246818d1, -3.072575676d2, 5.030801019d2, -4.585636345d2, 2.568666393d2, -9.185150382d1, 2.100012584d1, -2.964174788d0, 2.346396110d-1, -7.943766873d-3] real(kind=Float64), public :: e real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"C6_cx_1_adas – Fortran Program","loc":"proc/c6_cx_1_adas.html","text":"public function C6_cx_1_adas(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~c6_cx_1_adas~~CalledByGraph proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(7) :: A = [2.007882674d2, -3.546893286d2, 2.381542403d2, -8.355431742d1, 1.617519888d1, -1.638152470d0, 6.768953863d-2] real(kind=Float64), public :: e real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"C6_cx_2_adas – Fortran Program","loc":"proc/c6_cx_2_adas.html","text":"public function C6_cx_2_adas(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~c6_cx_2_adas~~CalledByGraph proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(11) :: A = [9.151879441d5, -2.134573133d6, 2.223792624d6, -1.362648703d6, 5.438401343d5, -1.477110500d5, 2.764972254d4, -3.522105245d3, 2.921934171d2, -1.425552507d1, 3.106007048d-1] real(kind=Float64), public :: e real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"C6_cx_3_adas – Fortran Program","loc":"proc/c6_cx_3_adas.html","text":"public function C6_cx_3_adas(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~c6_cx_3_adas~~CalledByGraph proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(11) :: A = [9.208877916d5, -2.147294379d6, 2.236451628d6, -1.370042347d6, 5.466461899d5, -1.484338816d5, 2.777765778d4, -3.537459450d3, 2.933884362d2, -1.430994136d1, 3.117002878d-1] real(kind=Float64), public :: e real(kind=Float64), public :: l real(kind=Float64), public :: p","tags":""},{"title":"Aq_cx_n_adas – Fortran Program","loc":"proc/aq_cx_n_adas.html","text":"public function Aq_cx_n_adas(eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) Calls proc~~aq_cx_n_adas~~CallsGraph proc~aq_cx_n_adas Aq_cx_n_adas proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_cx_n_adas~~CalledByGraph proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"B5_cx_1_janev – Fortran Program","loc":"proc/b5_cx_1_janev.html","text":"public function B5_cx_1_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~b5_cx_1_janev~~CalledByGraph proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocb5_cx_1_janevCalledByGraph = svgPanZoom('#procb5_cx_1_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(11) :: A = [31.226d0, 1.1442d0, 4.8372d-8, 3.0961d-10, 4.7205d0, 6.2844d-7, 3.1297d0, 0.12556d0, 0.30098d0, 5.9607d-2, -0.57923d0]","tags":""},{"title":"C6_cx_1_janev – Fortran Program","loc":"proc/c6_cx_1_janev.html","text":"public function C6_cx_1_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~c6_cx_1_janev~~CalledByGraph proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocc6_cx_1_janevCalledByGraph = svgPanZoom('#procc6_cx_1_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(11) :: A = [418.18d0, 2.1585d0, 3.4808d-4, 5.3333d-9, 4.6556d0, 0.33755d0, 0.81736d0, 0.27874d0, 1.8003d-6, 7.1033d-2, 0.53261d0]","tags":""},{"title":"Aq_cx_n_janev – Fortran Program","loc":"proc/aq_cx_n_janev.html","text":"public function Aq_cx_n_janev(eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) Calls proc~~aq_cx_n_janev~~CallsGraph proc~aq_cx_n_janev Aq_cx_n_janev proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_cx_n_janev~~CalledByGraph proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 1.507d5 real(kind=Float64), public, parameter :: B = 1.974d-5 real(kind=Float64), public :: etil real(kind=Float64), public :: nf real(kind=Float64), public :: qf","tags":""},{"title":"Aq_cx_n – Fortran Program","loc":"proc/aq_cx_n.html","text":"public function Aq_cx_n(eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) Calls proc~~aq_cx_n~~CallsGraph proc~aq_cx_n Aq_cx_n proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_cx_n~~CalledByGraph proc~aq_cx_n Aq_cx_n proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"Aq_cx – Fortran Program","loc":"proc/aq_cx.html","text":"public function Aq_cx(eb, q, n_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n_max Return Value real(kind=Float64),\n  dimension(n_max) Calls proc~~aq_cx~~CallsGraph proc~aq_cx Aq_cx proc~aq_cx_n Aq_cx_n proc~aq_cx->proc~aq_cx_n proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_cx~~CalledByGraph proc~aq_cx Aq_cx proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: n","tags":""},{"title":"B5_ioniz_1_janev – Fortran Program","loc":"proc/b5_ioniz_1_janev.html","text":"public function B5_ioniz_1_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~b5_ioniz_1_janev~~CalledByGraph proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: A = [351.52d0, 233.63d0, 3.2952d3, 5.3787d-6, 1.8834d-2, -2.2064d0, 7.2074d0, -3.78664d0]","tags":""},{"title":"C6_ioniz_1_janev – Fortran Program","loc":"proc/c6_ioniz_1_janev.html","text":"public function C6_ioniz_1_janev(eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~c6_ioniz_1_janev~~CalledByGraph proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(8) :: A = [438.36d0, 327.10d0, 1.4444d5, 3.5212d-3, 8.3031d-3, -0.63731d0, 1.9116d4, -3.1003d0]","tags":""},{"title":"Aq_ioniz_n_janev – Fortran Program","loc":"proc/aq_ioniz_n_janev.html","text":"public function Aq_ioniz_n_janev(eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) Called By proc~~aq_ioniz_n_janev~~CalledByGraph proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: M = 0.283d0 real(kind=Float64), public, parameter :: B = 4.04d0 real(kind=Float64), public, parameter :: c = 137.d0 real(kind=Float64), public, parameter :: g = 0.662d0 real(kind=Float64), public, parameter :: lambda = 0.76d0 real(kind=Float64), public :: nf real(kind=Float64), public :: qf real(kind=Float64), public :: u real(kind=Float64), public :: v real(kind=Float64), public :: sigma_b","tags":""},{"title":"Aq_ioniz_n – Fortran Program","loc":"proc/aq_ioniz_n.html","text":"public function Aq_ioniz_n(eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) Calls proc~~aq_ioniz_n~~CallsGraph proc~aq_ioniz_n Aq_ioniz_n proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_ioniz_n~~CalledByGraph proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"Aq_ioniz – Fortran Program","loc":"proc/aq_ioniz.html","text":"public function Aq_ioniz(eb, q, n_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n_max Return Value real(kind=Float64),\n  dimension(n_max) Calls proc~~aq_ioniz~~CallsGraph proc~aq_ioniz Aq_ioniz proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz->proc~aq_ioniz_n proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_ioniz~~CalledByGraph proc~aq_ioniz Aq_ioniz proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: n","tags":""},{"title":"Aq_excit_1_2_janev – Fortran Program","loc":"proc/aq_excit_1_2_janev.html","text":"public function Aq_excit_1_2_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_1_2_janev~~CalledByGraph proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_2_janevCalledByGraph = svgPanZoom('#procaq_excit_1_2_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [38.738d0, 37.033d0, 0.39862d0, 7.7582d-5, 0.25402d0, -2.7418d0] real(kind=Float64), public :: Etil real(kind=Float64), public :: xsi real(kind=Float64), public :: qf","tags":""},{"title":"Aq_excit_1_3_janev – Fortran Program","loc":"proc/aq_excit_1_3_janev.html","text":"public function Aq_excit_1_3_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_1_3_janev~~CalledByGraph proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_3_janevCalledByGraph = svgPanZoom('#procaq_excit_1_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [4.3619d0, 57.451d0, 21.001d0, 2.3292d-4, 0.083130d0, -2.2364d0] real(kind=Float64), public :: Etil real(kind=Float64), public :: xsi real(kind=Float64), public :: qf","tags":""},{"title":"Aq_excit_1_4_janev – Fortran Program","loc":"proc/aq_excit_1_4_janev.html","text":"public function Aq_excit_1_4_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_1_4_janev~~CalledByGraph proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_4_janevCalledByGraph = svgPanZoom('#procaq_excit_1_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [1.3730d0, 60.710d0, 31.797d0, 2.0207d-4, 0.082513d0, -2.3055d0] real(kind=Float64), public :: Etil real(kind=Float64), public :: xsi real(kind=Float64), public :: qf","tags":""},{"title":"Aq_excit_1_5_janev – Fortran Program","loc":"proc/aq_excit_1_5_janev.html","text":"public function Aq_excit_1_5_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_1_5_janev~~CalledByGraph proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_5_janevCalledByGraph = svgPanZoom('#procaq_excit_1_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [0.56565d0, 67.333d0, 55.290d0, 2.1595d-4, 0.081624d0, -2.1971d0] real(kind=Float64), public :: Etil real(kind=Float64), public :: xsi real(kind=Float64), public :: qf","tags":""},{"title":"Aq_excit_1_janev – Fortran Program","loc":"proc/aq_excit_1_janev.html","text":"public function Aq_excit_1_janev(eb, q, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~aq_excit_1_janev~~CallsGraph proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_1_janev~~CalledByGraph proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m","tags":""},{"title":"Aq_excit_2_3_janev – Fortran Program","loc":"proc/aq_excit_2_3_janev.html","text":"public function Aq_excit_2_3_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_2_3_janev~~CalledByGraph proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_3_janevCalledByGraph = svgPanZoom('#procaq_excit_2_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [358.03d0, 25.283d0, 1.4726d0, 0.014398d0, 0.12207d0, -0.86210d0] real(kind=Float64), public :: etil real(kind=Float64), public :: qf real(kind=Float64), public :: xsi","tags":""},{"title":"Aq_excit_2_4_janev – Fortran Program","loc":"proc/aq_excit_2_4_janev.html","text":"public function Aq_excit_2_4_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_2_4_janev~~CalledByGraph proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_4_janevCalledByGraph = svgPanZoom('#procaq_excit_2_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [50.744d0, 19.416d0, 4.0262d0, 0.014398d0, 0.31584d0, -1.4799d0] real(kind=Float64), public :: etil real(kind=Float64), public :: qf real(kind=Float64), public :: xsi","tags":""},{"title":"Aq_excit_2_5_janev – Fortran Program","loc":"proc/aq_excit_2_5_janev.html","text":"public function Aq_excit_2_5_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_2_5_janev~~CalledByGraph proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_5_janevCalledByGraph = svgPanZoom('#procaq_excit_2_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [18.264d0, 18.973d0, 2.9056d0, 0.013701d0, 0.31711d0, -1.4775d0] real(kind=Float64), public :: etil real(kind=Float64), public :: qf real(kind=Float64), public :: xsi","tags":""},{"title":"Aq_excit_2_6_janev – Fortran Program","loc":"proc/aq_excit_2_6_janev.html","text":"public function Aq_excit_2_6_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Calls proc~~aq_excit_2_6_janev~~CallsGraph proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_6_janev~~CalledByGraph proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_6_janevCalledByGraph = svgPanZoom('#procaq_excit_2_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 0.4610d0 real(kind=Float64), public :: hi","tags":""},{"title":"Aq_excit_2_7_janev – Fortran Program","loc":"proc/aq_excit_2_7_janev.html","text":"public function Aq_excit_2_7_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Calls proc~~aq_excit_2_7_janev~~CallsGraph proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_7_janev~~CalledByGraph proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_7_janevCalledByGraph = svgPanZoom('#procaq_excit_2_7_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 0.2475d0 real(kind=Float64), public :: hi","tags":""},{"title":"Aq_excit_2_8_janev – Fortran Program","loc":"proc/aq_excit_2_8_janev.html","text":"public function Aq_excit_2_8_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Calls proc~~aq_excit_2_8_janev~~CallsGraph proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_8_janev~~CalledByGraph proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_8_janevCalledByGraph = svgPanZoom('#procaq_excit_2_8_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 0.1465d0 real(kind=Float64), public :: hi","tags":""},{"title":"Aq_excit_2_9_janev – Fortran Program","loc":"proc/aq_excit_2_9_janev.html","text":"public function Aq_excit_2_9_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Calls proc~~aq_excit_2_9_janev~~CallsGraph proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_9_janev~~CalledByGraph proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_9_janevCalledByGraph = svgPanZoom('#procaq_excit_2_9_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 0.092d0 real(kind=Float64), public :: hi","tags":""},{"title":"Aq_excit_2_10_janev – Fortran Program","loc":"proc/aq_excit_2_10_janev.html","text":"public function Aq_excit_2_10_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Calls proc~~aq_excit_2_10_janev~~CallsGraph proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_10_janev~~CalledByGraph proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_10_janevCalledByGraph = svgPanZoom('#procaq_excit_2_10_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 0.0605d0 real(kind=Float64), public :: hi","tags":""},{"title":"Aq_excit_2_janev – Fortran Program","loc":"proc/aq_excit_2_janev.html","text":"public function Aq_excit_2_janev(eb, q, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~aq_excit_2_janev~~CallsGraph proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_janev~~CalledByGraph proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m","tags":""},{"title":"Aq_excit_3_4_janev – Fortran Program","loc":"proc/aq_excit_3_4_janev.html","text":"public function Aq_excit_3_4_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_3_4_janev~~CalledByGraph proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_4_janevCalledByGraph = svgPanZoom('#procaq_excit_3_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [1247.5d0, 11.319d0, 2.6235d0, 0.068781d0, 0.521176d0, -1.2722d0] real(kind=Float64), public :: Etil real(kind=Float64), public :: qf real(kind=Float64), public :: xsi","tags":""},{"title":"Aq_excit_3_5_janev – Fortran Program","loc":"proc/aq_excit_3_5_janev.html","text":"public function Aq_excit_3_5_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_3_5_janev~~CalledByGraph proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_5_janevCalledByGraph = svgPanZoom('#procaq_excit_3_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [190.59d0, 11.096d0, 2.9098d0, 0.073307d0, 0.54177d0, -1.2894d0] real(kind=Float64), public :: Etil real(kind=Float64), public :: qf real(kind=Float64), public :: xsi","tags":""},{"title":"Aq_excit_3_6_janev – Fortran Program","loc":"proc/aq_excit_3_6_janev.html","text":"public function Aq_excit_3_6_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Called By proc~~aq_excit_3_6_janev~~CalledByGraph proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_6_janevCalledByGraph = svgPanZoom('#procaq_excit_3_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter, dimension(6) :: A = [63.494d0, 11.507d0, 4.3417d0, 0.077953d0, 0.53461d0, -1.2881d0] real(kind=Float64), public :: Etil real(kind=Float64), public :: qf real(kind=Float64), public :: xsi","tags":""},{"title":"Aq_excit_3_7_janev – Fortran Program","loc":"proc/aq_excit_3_7_janev.html","text":"public function Aq_excit_3_7_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Calls proc~~aq_excit_3_7_janev~~CallsGraph proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_7_janev~~CalledByGraph proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_7_janevCalledByGraph = svgPanZoom('#procaq_excit_3_7_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 0.4670d0 real(kind=Float64), public :: hi","tags":""},{"title":"Aq_excit_3_8_janev – Fortran Program","loc":"proc/aq_excit_3_8_janev.html","text":"public function Aq_excit_3_8_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Calls proc~~aq_excit_3_8_janev~~CallsGraph proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_8_janev~~CalledByGraph proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_8_janevCalledByGraph = svgPanZoom('#procaq_excit_3_8_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 0.2545d0 real(kind=Float64), public :: hi","tags":""},{"title":"Aq_excit_3_9_janev – Fortran Program","loc":"proc/aq_excit_3_9_janev.html","text":"public function Aq_excit_3_9_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Calls proc~~aq_excit_3_9_janev~~CallsGraph proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_9_janev~~CalledByGraph proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_9_janevCalledByGraph = svgPanZoom('#procaq_excit_3_9_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 0.1540d0 real(kind=Float64), public :: hi","tags":""},{"title":"Aq_excit_3_10_janev – Fortran Program","loc":"proc/aq_excit_3_10_janev.html","text":"public function Aq_excit_3_10_janev(eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) Calls proc~~aq_excit_3_10_janev~~CallsGraph proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_10_janev~~CalledByGraph proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_10_janevCalledByGraph = svgPanZoom('#procaq_excit_3_10_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: A = 0.1d0 real(kind=Float64), public :: hi","tags":""},{"title":"Aq_excit_3_janev – Fortran Program","loc":"proc/aq_excit_3_janev.html","text":"public function Aq_excit_3_janev(eb, q, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~aq_excit_3_janev~~CallsGraph proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_janev~~CalledByGraph proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m","tags":""},{"title":"Aq_excit_n_janev – Fortran Program","loc":"proc/aq_excit_n_janev.html","text":"public function Aq_excit_n_janev(eb, q, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Called By proc~~aq_excit_n_janev~~CalledByGraph proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m real(kind=Float64), public :: nf real(kind=Float64), public :: mf real(kind=Float64), public :: qf real(kind=Float64), public :: etil real(kind=Float64), public :: hi real(kind=Float64), public :: s real(kind=Float64), public :: D real(kind=Float64), public :: A real(kind=Float64), public :: G real(kind=Float64), public :: L real(kind=Float64), public :: F real(kind=Float64), public :: H real(kind=Float64), public :: y real(kind=Float64), public :: zpl real(kind=Float64), public :: zmi real(kind=Float64), public :: C2pl real(kind=Float64), public :: C2mi","tags":""},{"title":"Aq_excit_n – Fortran Program","loc":"proc/aq_excit_n.html","text":"public function Aq_excit_n(eb, q, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) Calls proc~~aq_excit_n~~CallsGraph proc~aq_excit_n Aq_excit_n proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_n~~CalledByGraph proc~aq_excit_n Aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":""},{"title":"Aq_excit_n_m – Fortran Program","loc":"proc/aq_excit_n_m.html","text":"public function Aq_excit_n_m(eb, q, n, m) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) Calls proc~~aq_excit_n_m~~CallsGraph proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n Aq_excit_n proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(12) :: sigma_m","tags":""},{"title":"Aq_excit – Fortran Program","loc":"proc/aq_excit.html","text":"public function Aq_excit(eb, q, n_max, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n_max integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(n_max, m_max) Calls proc~~aq_excit~~CallsGraph proc~aq_excit Aq_excit proc~aq_excit_n Aq_excit_n proc~aq_excit->proc~aq_excit_n proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~aq_excit~~CalledByGraph proc~aq_excit Aq_excit proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(12,12) :: sigma_full integer, public :: n integer, public :: m","tags":""},{"title":"simpsons_rule – Fortran Program","loc":"proc/simpsons_rule.html","text":"public function simpsons_rule(f, dx) result(I) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: f real(kind=Float64), intent(in) :: dx Return Value real(kind=Float64) Called By proc~~simpsons_rule~~CalledByGraph proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n bt_maxwellian_q_n proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_n_m bt_maxwellian_n_m proc~bt_maxwellian_n_m->proc~simpsons_rule proc~bt_maxwellian_n bt_maxwellian_n proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m proc~bt_maxwellian_q_n_m->proc~simpsons_rule interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bt_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: s integer, public :: ii","tags":""},{"title":"m_spread – Fortran Program","loc":"proc/m_spread.html","text":"public subroutine m_spread(n, m_max, sigma_tot, sigma) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m_max real(kind=Float64), intent(in) :: sigma_tot real(kind=Float64), intent(inout), dimension(m_max) :: sigma Called By proc~~m_spread~~CalledByGraph proc~m_spread m_spread proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~m_spread proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~m_spread proc~p_cx_n p_cx_n proc~p_cx_n->proc~m_spread proc~p_cx_n->proc~p_cx_2 proc~p_cx_n->proc~p_cx_3 proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public :: En real(kind=Float64), public :: Em real(kind=Float64), public :: norm_fac real(kind=Float64), public, dimension(m_max) :: sigma_m integer, public :: m","tags":""},{"title":"bt_maxwellian_n – Fortran Program","loc":"proc/bt_maxwellian_n.html","text":"public subroutine bt_maxwellian_n(fn, T, eb, am, ab, n, rate) Arguments Type Intent Optional Attributes Name public function fn(a, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n real(kind=Float64), intent(out) :: rate Calls proc~~bt_maxwellian_n~~CallsGraph proc~bt_maxwellian_n bt_maxwellian_n proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bt_maxwellian_n~~CalledByGraph proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_n proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bt_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: dxc integer, public :: n_vr real(kind=Float64), public :: vr_max real(kind=Float64), public :: dvr real(kind=Float64), public, dimension(32) :: vr real(kind=Float64), public, dimension(32) :: fr integer, public :: n_vz real(kind=Float64), public :: vz_max real(kind=Float64), public :: dvz real(kind=Float64), public, dimension(62) :: vz real(kind=Float64), public, dimension(62) :: fz real(kind=Float64), public :: T_per_amu real(kind=Float64), public :: eb_per_amu real(kind=Float64), public :: ared real(kind=Float64), public :: sig real(kind=Float64), public :: sig_eff real(kind=Float64), public :: zb real(kind=Float64), public :: u2_to_erel real(kind=Float64), public :: u2 real(kind=Float64), public :: erel real(kind=Float64), public :: v_therm real(kind=Float64), public :: dE integer, public :: i integer, public :: j","tags":""},{"title":"bt_maxwellian_q_n – Fortran Program","loc":"proc/bt_maxwellian_q_n.html","text":"public subroutine bt_maxwellian_q_n(fqn, q, T, eb, am, ab, n, rate) Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n real(kind=Float64), intent(out) :: rate Calls proc~~bt_maxwellian_q_n~~CallsGraph proc~bt_maxwellian_q_n bt_maxwellian_q_n proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bt_maxwellian_q_n~~CalledByGraph proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bt_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: n_vr real(kind=Float64), public :: vr_max real(kind=Float64), public :: dvr real(kind=Float64), public, dimension(32) :: vr real(kind=Float64), public, dimension(32) :: fr integer, public :: n_vz real(kind=Float64), public :: vz_max real(kind=Float64), public :: dvz real(kind=Float64), public, dimension(62) :: vz real(kind=Float64), public, dimension(62) :: fz real(kind=Float64), public :: T_per_amu real(kind=Float64), public :: eb_per_amu real(kind=Float64), public :: ared real(kind=Float64), public :: sig real(kind=Float64), public :: sig_eff real(kind=Float64), public :: zb real(kind=Float64), public :: u2_to_erel real(kind=Float64), public :: u2 real(kind=Float64), public :: erel real(kind=Float64), public :: v_therm real(kind=Float64), public :: dE integer, public :: i integer, public :: j","tags":""},{"title":"bt_maxwellian_n_m – Fortran Program","loc":"proc/bt_maxwellian_n_m.html","text":"public subroutine bt_maxwellian_n_m(fnm, T, eb, am, ab, n, m, rate, deexcit) Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n integer, intent(in) :: m real(kind=Float64), intent(out) :: rate logical, intent(in), optional :: deexcit Calls proc~~bt_maxwellian_n_m~~CallsGraph proc~bt_maxwellian_n_m bt_maxwellian_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bt_maxwellian_n_m~~CalledByGraph proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bt_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: dxc integer, public :: n_vr real(kind=Float64), public :: vr_max real(kind=Float64), public :: dvr real(kind=Float64), public, dimension(32) :: vr real(kind=Float64), public, dimension(32) :: fr integer, public :: n_vz real(kind=Float64), public :: vz_max real(kind=Float64), public :: dvz real(kind=Float64), public, dimension(62) :: vz real(kind=Float64), public, dimension(62) :: fz real(kind=Float64), public :: T_per_amu real(kind=Float64), public :: eb_per_amu real(kind=Float64), public :: ared real(kind=Float64), public :: sig real(kind=Float64), public :: sig_eff real(kind=Float64), public :: zb real(kind=Float64), public :: u2_to_erel real(kind=Float64), public :: u2 real(kind=Float64), public :: erel real(kind=Float64), public :: dE real(kind=Float64), public :: factor real(kind=Float64), public :: En real(kind=Float64), public :: Em real(kind=Float64), public :: v_therm integer, public :: i integer, public :: j","tags":""},{"title":"bt_maxwellian_q_n_m – Fortran Program","loc":"proc/bt_maxwellian_q_n_m.html","text":"public subroutine bt_maxwellian_q_n_m(fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n integer, intent(in) :: m real(kind=Float64), intent(out) :: rate logical, intent(in), optional :: deexcit Calls proc~~bt_maxwellian_q_n_m~~CallsGraph proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bt_maxwellian_q_n_m~~CalledByGraph proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bt_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: dxc integer, public :: n_vr real(kind=Float64), public :: vr_max real(kind=Float64), public :: dvr real(kind=Float64), public, dimension(32) :: vr real(kind=Float64), public, dimension(32) :: fr integer, public :: n_vz real(kind=Float64), public :: vz_max real(kind=Float64), public :: dvz real(kind=Float64), public, dimension(62) :: vz real(kind=Float64), public, dimension(62) :: fz real(kind=Float64), public :: T_per_amu real(kind=Float64), public :: eb_per_amu real(kind=Float64), public :: ared real(kind=Float64), public :: sig real(kind=Float64), public :: sig_eff real(kind=Float64), public :: zb real(kind=Float64), public :: u2_to_erel real(kind=Float64), public :: u2 real(kind=Float64), public :: erel real(kind=Float64), public :: dE real(kind=Float64), public :: factor real(kind=Float64), public :: En real(kind=Float64), public :: Em real(kind=Float64), public :: v_therm integer, public :: i integer, public :: j","tags":""},{"title":"write_einstein – Fortran Program","loc":"proc/write_einstein.html","text":"public subroutine write_einstein(id, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id integer, intent(in) :: n_max integer, intent(in) :: m_max Calls proc~~write_einstein~~CallsGraph proc~write_einstein write_einstein h5gcreate_f h5gcreate_f proc~write_einstein->h5gcreate_f h5gclose_f h5gclose_f proc~write_einstein->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_einstein->h5ltset_attribute_string_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_einstein->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f var panprocwrite_einsteinCallsGraph = svgPanZoom('#procwrite_einsteinCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_einstein~~CalledByGraph proc~write_einstein write_einstein program~generate_tables generate_tables program~generate_tables->proc~write_einstein Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(n_max,m_max) :: ein integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(1) :: dim1 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer, public :: error","tags":""},{"title":"write_bb_H_H – Fortran Program","loc":"proc/write_bb_h_h.html","text":"public subroutine write_bb_H_H(id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max Calls proc~~write_bb_h_h~~CallsGraph proc~write_bb_h_h write_bb_H_H h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_h_h->h5ltmake_dataset_int_f h5gcreate_f h5gcreate_f proc~write_bb_h_h->h5gcreate_f proc~p_ioniz p_ioniz proc~write_bb_h_h->proc~p_ioniz h5gclose_f h5gclose_f proc~write_bb_h_h->h5gclose_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~p_cx p_cx proc~write_bb_h_h->proc~p_cx proc~p_excit p_excit proc~write_bb_h_h->proc~p_excit h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_h_h->h5ltmake_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_h_h->h5ltset_attribute_string_f proc~p_ioniz_n p_ioniz_n proc~p_ioniz->proc~p_ioniz_n proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~p_cx_n p_cx_n proc~p_cx->proc~p_cx_n proc~p_excit_n p_excit_n proc~p_excit->proc~p_excit_n proc~p_ioniz_1_omullane p_ioniz_1_omullane proc~p_ioniz_n->proc~p_ioniz_1_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev var panprocwrite_bb_h_hCallsGraph = svgPanZoom('#procwrite_bb_h_hCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_bb_h_h~~CalledByGraph proc~write_bb_h_h write_bb_H_H program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public :: emin real(kind=Float64), public :: emax integer, public :: nenergy real(kind=Float64), public :: eb real(kind=Float64), public :: dlogE real(kind=Float64), public, dimension(:), allocatable :: ebarr real(kind=Float64), public, dimension(:,:), allocatable :: ioniz real(kind=Float64), public, dimension(:,:,:), allocatable :: cx real(kind=Float64), public, dimension(:,:,:), allocatable :: excit integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(1) :: dim1 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(3) :: dim3 integer, public :: i integer, public :: cnt integer, public :: error logical, public :: exis","tags":""},{"title":"write_bb_H_e – Fortran Program","loc":"proc/write_bb_h_e.html","text":"public subroutine write_bb_H_e(id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max Calls proc~~write_bb_h_e~~CallsGraph proc~write_bb_h_e write_bb_H_e h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_h_e->h5ltmake_dataset_int_f proc~e_ioniz e_ioniz proc~write_bb_h_e->proc~e_ioniz h5gcreate_f h5gcreate_f proc~write_bb_h_e->h5gcreate_f h5gclose_f h5gclose_f proc~write_bb_h_e->h5gclose_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_h_e->h5ltmake_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_h_e->h5ltset_attribute_string_f proc~e_excit e_excit proc~write_bb_h_e->proc~e_excit proc~e_ioniz_n e_ioniz_n proc~e_ioniz->proc~e_ioniz_n proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~e_excit_n e_excit_n proc~e_excit->proc~e_excit_n proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev var panprocwrite_bb_h_eCallsGraph = svgPanZoom('#procwrite_bb_h_eCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_bb_h_e~~CalledByGraph proc~write_bb_h_e write_bb_H_e program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public :: emin real(kind=Float64), public :: emax integer, public :: nenergy real(kind=Float64), public :: eb real(kind=Float64), public :: dlogE real(kind=Float64), public, dimension(:), allocatable :: ebarr real(kind=Float64), public, dimension(:,:), allocatable :: ioniz real(kind=Float64), public, dimension(:,:,:), allocatable :: excit integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(1) :: dim1 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(3) :: dim3 integer, public :: i integer, public :: cnt integer, public :: error logical, public :: exis","tags":""},{"title":"write_bb_H_Aq – Fortran Program","loc":"proc/write_bb_h_aq.html","text":"public subroutine write_bb_H_Aq(id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max Calls proc~~write_bb_h_aq~~CallsGraph proc~write_bb_h_aq write_bb_H_Aq h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_h_aq->h5ltmake_dataset_int_f h5gcreate_f h5gcreate_f proc~write_bb_h_aq->h5gcreate_f proc~aq_cx Aq_cx proc~write_bb_h_aq->proc~aq_cx h5gclose_f h5gclose_f proc~write_bb_h_aq->h5gclose_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~aq_excit Aq_excit proc~write_bb_h_aq->proc~aq_excit h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_h_aq->h5ltmake_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_h_aq->h5ltset_attribute_string_f proc~aq_ioniz Aq_ioniz proc~write_bb_h_aq->proc~aq_ioniz proc~aq_cx_n Aq_cx_n proc~aq_cx->proc~aq_cx_n proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~aq_excit_n Aq_excit_n proc~aq_excit->proc~aq_excit_n proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz->proc~aq_ioniz_n proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev var panprocwrite_bb_h_aqCallsGraph = svgPanZoom('#procwrite_bb_h_aqCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_bb_h_aq~~CalledByGraph proc~write_bb_h_aq write_bb_H_Aq program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: q real(kind=Float64), public :: emin real(kind=Float64), public :: emax integer, public :: nenergy real(kind=Float64), public :: eb real(kind=Float64), public :: dlogE real(kind=Float64), public, dimension(:), allocatable :: ebarr real(kind=Float64), public, dimension(:,:), allocatable :: cx real(kind=Float64), public, dimension(:,:), allocatable :: ioniz real(kind=Float64), public, dimension(:,:,:), allocatable :: excit integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(1) :: dim1 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(3) :: dim3 character(len=10), public :: aname character(len=5), public :: asym integer, public :: i integer, public :: cnt integer, public :: error logical, public :: exis","tags":""},{"title":"write_bt_H_H – Fortran Program","loc":"proc/write_bt_h_h.html","text":"public subroutine write_bt_H_H(id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max Calls proc~~write_bt_h_h~~CallsGraph proc~write_bt_h_h write_bt_H_H h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_h->h5ltmake_dataset_int_f h5gcreate_f h5gcreate_f proc~write_bt_h_h->h5gcreate_f h5gclose_f h5gclose_f proc~write_bt_h_h->h5gclose_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f interface~bt_maxwellian bt_maxwellian proc~write_bt_h_h->interface~bt_maxwellian h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_h->h5ltmake_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_h_h->h5ltset_attribute_string_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule var panprocwrite_bt_h_hCallsGraph = svgPanZoom('#procwrite_bt_h_hCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_bt_h_h~~CalledByGraph proc~write_bt_h_h write_bt_H_H program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public :: emin real(kind=Float64), public :: emax integer, public :: nenergy real(kind=Float64), public :: tmin real(kind=Float64), public :: tmax integer, public :: ntemp real(kind=Float64), public :: eb real(kind=Float64), public :: dlogE real(kind=Float64), public, dimension(:), allocatable :: ebarr real(kind=Float64), public :: ti real(kind=Float64), public :: dlogT real(kind=Float64), public, dimension(:), allocatable :: tarr real(kind=Float64), public, dimension(:,:,:,:), allocatable :: ioniz real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: excit real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: cx integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(1) :: dim1 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(3) :: dim3 integer(kind=HSIZE_T), public, dimension(4) :: dim4 integer(kind=HSIZE_T), public, dimension(5) :: dim5 integer, public :: ie integer, public :: it integer, public :: ia integer, public :: n integer, public :: m integer, public :: error integer, public :: cnt real(kind=Float64), public :: rate integer, public, parameter :: n_bt_amu = 4 real(kind=Float64), public, dimension(2,n_bt_amu) :: a logical, public :: exis","tags":""},{"title":"write_bt_H_e – Fortran Program","loc":"proc/write_bt_h_e.html","text":"public subroutine write_bt_H_e(id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max Calls proc~~write_bt_h_e~~CallsGraph proc~write_bt_h_e write_bt_H_e h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_e->h5ltmake_dataset_int_f h5gcreate_f h5gcreate_f proc~write_bt_h_e->h5gcreate_f h5gclose_f h5gclose_f proc~write_bt_h_e->h5gclose_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f interface~bt_maxwellian bt_maxwellian proc~write_bt_h_e->interface~bt_maxwellian h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_e->h5ltmake_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_h_e->h5ltset_attribute_string_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule var panprocwrite_bt_h_eCallsGraph = svgPanZoom('#procwrite_bt_h_eCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_bt_h_e~~CalledByGraph proc~write_bt_h_e write_bt_H_e program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=Float64), public :: emin real(kind=Float64), public :: emax integer, public :: nenergy real(kind=Float64), public :: tmin real(kind=Float64), public :: tmax integer, public :: ntemp real(kind=Float64), public :: eb real(kind=Float64), public :: dlogE real(kind=Float64), public, dimension(:), allocatable :: ebarr real(kind=Float64), public :: ti real(kind=Float64), public :: dlogT real(kind=Float64), public, dimension(:), allocatable :: tarr real(kind=Float64), public, dimension(:,:,:,:), allocatable :: ioniz real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: excit integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(1) :: dim1 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(3) :: dim3 integer(kind=HSIZE_T), public, dimension(4) :: dim4 integer(kind=HSIZE_T), public, dimension(5) :: dim5 integer, public :: ie integer, public :: it integer, public :: ia integer, public :: n integer, public :: m integer, public :: error integer, public :: cnt real(kind=Float64), public :: rate integer, public, parameter :: n_bt_amu = 2 real(kind=Float64), public, dimension(2,n_bt_amu) :: a logical, public :: exis","tags":""},{"title":"write_bt_H_Aq – Fortran Program","loc":"proc/write_bt_h_aq.html","text":"public subroutine write_bt_H_Aq(id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max Calls proc~~write_bt_h_aq~~CallsGraph proc~write_bt_h_aq write_bt_H_Aq h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_aq->h5ltmake_dataset_int_f h5gcreate_f h5gcreate_f proc~write_bt_h_aq->h5gcreate_f h5gclose_f h5gclose_f proc~write_bt_h_aq->h5gclose_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f interface~bt_maxwellian bt_maxwellian proc~write_bt_h_aq->interface~bt_maxwellian h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_aq->h5ltmake_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_h_aq->h5ltset_attribute_string_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule var panprocwrite_bt_h_aqCallsGraph = svgPanZoom('#procwrite_bt_h_aqCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_bt_h_aq~~CalledByGraph proc~write_bt_h_aq write_bt_H_Aq program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: q real(kind=Float64), public :: mass real(kind=Float64), public :: emin real(kind=Float64), public :: emax integer, public :: nenergy real(kind=Float64), public :: tmin real(kind=Float64), public :: tmax integer, public :: ntemp real(kind=Float64), public :: eb real(kind=Float64), public :: dlogE real(kind=Float64), public, dimension(:), allocatable :: ebarr real(kind=Float64), public :: ti real(kind=Float64), public :: dlogT real(kind=Float64), public, dimension(:), allocatable :: tarr real(kind=Float64), public, dimension(:,:,:,:), allocatable :: ioniz real(kind=Float64), public, dimension(:,:,:,:), allocatable :: cx real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: excit integer(kind=HID_T), public :: gid integer(kind=HSIZE_T), public, dimension(1) :: dim1 integer(kind=HSIZE_T), public, dimension(2) :: dim2 integer(kind=HSIZE_T), public, dimension(3) :: dim3 integer(kind=HSIZE_T), public, dimension(4) :: dim4 integer(kind=HSIZE_T), public, dimension(5) :: dim5 integer, public :: ie integer, public :: it integer, public :: ia integer, public :: n integer, public :: m integer, public :: error integer, public :: cnt real(kind=Float64), public :: rate integer, public, parameter :: n_bt_amu = 2 real(kind=Float64), public, dimension(2,n_bt_amu) :: a character(len=10), public :: aname character(len=5), public :: asym logical, public :: exis","tags":""},{"title":"bt_maxwellian – Fortran Program","loc":"interface/bt_maxwellian.html","text":"public interface bt_maxwellian Calls interface~~bt_maxwellian~~CallsGraph interface~bt_maxwellian bt_maxwellian proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~bt_maxwellian~~CalledByGraph interface~bt_maxwellian bt_maxwellian proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bt_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public subroutine bt_maxwellian_n (fn, T, eb, am, ab, n, rate) Arguments Type Intent Optional Attributes Name public function fn(a, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n real(kind=Float64), intent(out) :: rate public subroutine bt_maxwellian_n_m (fnm, T, eb, am, ab, n, m, rate, deexcit) Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n integer, intent(in) :: m real(kind=Float64), intent(out) :: rate logical, intent(in), optional :: deexcit public subroutine bt_maxwellian_q_n (fqn, q, T, eb, am, ab, n, rate) Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n real(kind=Float64), intent(out) :: rate public subroutine bt_maxwellian_q_n_m (fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n integer, intent(in) :: m real(kind=Float64), intent(out) :: rate logical, intent(in), optional :: deexcit","tags":""},{"title":"eigensystem – Fortran Program","loc":"module/eigensystem.html","text":"Used By module~~eigensystem~~UsedByGraph module~eigensystem eigensystem module~simulation simulation module~eigensystem->module~simulation program~fidasim fidasim module~simulation->program~fidasim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: long = kind(int(1)) integer, public, parameter :: float = kind(1.e0) integer, public, parameter :: double = kind(1.d0) real(kind=double), public, parameter :: ONE = 1.d0 real(kind=double), public, parameter :: TWO = 2.d0 real(kind=double), public, parameter :: ZERO = 0.d0 real(kind=double), public, parameter :: XMACH_EPS = 2.22d-16 integer, public, parameter :: MAXIT = 50 Functions public function comabs (ar, ai) Arguments Type Intent Optional Attributes Name real(kind=double) :: ar real(kind=double) :: ai Return Value real(kind=double) public function outerprod (a, b) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: a real(kind=double), intent(in), dimension(:) :: b Return Value real(kind=double),\n  dimension(size(a),size(b)) Subroutines public subroutine RSWAP (a, b) Arguments Type Intent Optional Attributes Name real(kind=double) :: a real(kind=double) :: b public subroutine balance (n, mat, scal, low, high) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=double) :: mat (0:n,0:n) real(kind=double) :: scal (0:n) integer, intent(out) :: low integer, intent(out) :: high public subroutine balback (n, low, high, scal, eivec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(in) :: scal (0:n) real(kind=double), intent(inout) :: eivec (0:n,0:n) public subroutine elmhes (n, low, high, mat, perm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(inout) :: mat (0:n,0:n) integer, intent(out) :: perm (0:n) public subroutine elmtrans (n, low, high, mat, perm, h) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(in) :: mat (0:n,0:n) integer, intent(in) :: perm (0:n) real(kind=double), intent(out) :: h (0:n,0:n) public subroutine Comdiv (ar, ai, br, bi, cr, ci, rc) Arguments Type Intent Optional Attributes Name real(kind=double) :: ar real(kind=double) :: ai real(kind=double) :: br real(kind=double) :: bi real(kind=double) :: cr real(kind=double) :: ci integer :: rc public subroutine hqrvec (n, low, high, h, wr, wi, eivec, rc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double) :: h (0:n,0:n) real(kind=double), intent(in) :: wr (0:n) real(kind=double), intent(in) :: wi (0:n) real(kind=double), intent(out) :: eivec (0:n,0:n) integer :: rc public subroutine hqr2 (n, low, high, h, wr, wi, eivec, cnt, rc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(out) :: h (0:n,0:n) real(kind=double), intent(out) :: wr (0:n) real(kind=double), intent(out) :: wi (0:n) real(kind=double), intent(out) :: eivec (0:n,0:n) integer, intent(out) :: cnt (0:n) integer, intent(out) :: rc public subroutine eigen (n, matrix, eigvec, eigval) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=double), intent(in), dimension(n,n) :: matrix real(kind=double), intent(out), dimension(n,n) :: eigvec real(kind=double), intent(out), dimension(n) :: eigval public subroutine swap (a, b) Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:) :: a real(kind=double), intent(inout), dimension(:) :: b public subroutine ludcmp (a, indx, d) Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:,:) :: a integer, intent(out), dimension(:) :: indx real(kind=double), intent(out) :: d public subroutine lubksb (a, indx, b) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a integer, intent(in), dimension(:) :: indx real(kind=double), intent(inout), dimension(:) :: b public subroutine matinv (a, b) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a real(kind=double), intent(out), dimension(:,:) :: b","tags":""},{"title":"simulation – Fortran Program","loc":"module/simulation.html","text":"Uses: H5LT HDF5 hdf5_extra eigensystem parallel_rng module~~simulation~~UsesGraph module~simulation simulation H5LT H5LT H5LT->module~simulation module~hdf5_extra hdf5_extra H5LT->module~hdf5_extra HDF5 HDF5 HDF5->module~simulation HDF5->module~hdf5_extra module~eigensystem eigensystem module~eigensystem->module~simulation module~parallel_rng parallel_rng module~parallel_rng->module~simulation module~hdf5_extra->module~simulation omp_lib omp_lib omp_lib->module~parallel_rng Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~simulation~~UsedByGraph module~simulation simulation program~fidasim fidasim module~simulation->program~fidasim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: long = 4 integer, public, parameter :: long64 = 8 integer, public, parameter :: float = 4 integer, public, parameter :: double = 8 character(len=120), public :: namelist_file integer, public, parameter :: nbif_type = 1 integer, public, parameter :: nbih_type = 2 integer, public, parameter :: nbit_type = 3 integer, public, parameter :: halo_type = 4 integer, public, parameter :: fida_type = 5 integer, public, parameter :: brems_type = 6 integer, public, parameter :: ntypes = 6 integer, public, parameter :: beam_ion = 1 integer, public, parameter :: thermal_ion = 2 real(kind=double), public, parameter :: e_amu = 5.485799093287202d-4 real(kind=double), public, parameter :: H_1_amu = 1.00782504d0 real(kind=double), public, parameter :: H_2_amu = 2.0141017778d0 real(kind=double), public, parameter :: B5_amu = 10.81d0 real(kind=double), public, parameter :: C6_amu = 12.011d0 real(kind=double), public, parameter :: mass_u = 1.6605402d-27 real(kind=double), public, parameter :: e0 = 1.60217733d-19 real(kind=double), public, parameter :: pi = 3.14159265358979323846264d0 real(kind=double), public, parameter :: c0 = 2.99792458d+08 real(kind=double), public, parameter :: h_planck = 4.135667516d-15 real(kind=double), public, parameter :: lambda0 = 6561.d0 real(kind=double), public, parameter :: v2_to_E_per_amu = mass_u/(2.*e0*1.d3)*1.d-4 integer, public, parameter :: n_stark = 15 real(kind=double), public, parameter, dimension(n_stark) :: stark_wavel = [-2.20200d-06, -1.65200d-06, -1.37700d-06, -1.10200d-06, -8.26400d-07, -5.51000d-07, -2.75600d-07, 0.00000d0, 2.75700d-07, 5.51500d-07, 8.27400d-07, 1.10300d-06, 1.38000d-06, 1.65600d-06, 2.20900d-06] real(kind=double), public, parameter, dimension(n_stark) :: stark_intens = [1.000d0, 18.00d0, 16.00d0, 1681.d0, 2304.d0, 729.0d0, 1936.d0, 5490.d0, 1936.d0, 729.0d0, 2304.d0, 1681.d0, 16.00d0, 18.00d0, 1.000d0] integer, public, parameter, dimension(n_stark) :: stark_pi = [1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1] integer, public, parameter, dimension(n_stark) :: stark_sigma = 1-stark_pi integer, public, parameter :: nlevs = 6 real(kind=double), public, parameter :: n_halo_neutrate = 20. real(kind=double), public :: colrad_threshold = 1.d6 real(kind=double), public, dimension(ntypes) :: halo_iter_dens = 0.d0 integer, public :: nbi_outside = 0 type( BeamGrid ), public :: beam_grid type( InterpolationGrid ), public :: inter_grid type( FastIonDistribution ), public :: fbm type( FastIonParticles ), public :: particles type( Equilibrium ), public :: equil type( NeutralBeam ), public :: nbi type( AtomicTables ), public :: tables type( NPAResults ), public :: npa type( SpectralChords ), public :: spec_chords type( NPAChords ), public :: npa_chords type( SimulationInputs ), public :: inputs type( BirthProfile ), public :: birth type( NeutralDensity ), public :: neut type( Spectra ), public :: spec type( FIDAWeights ), public :: fweight type( NPAWeights ), public :: nweight Interfaces public interface assignment(=) public subroutine pp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(out) :: p1 type( Profiles ), intent(in) :: p2 public subroutine lpp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: p1 type( Profiles ), intent(in) :: p2 public subroutine plp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(out) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine lplp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine ff_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(out) :: p1 type( EMFields ), intent(in) :: p2 public subroutine lff_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: p1 type( EMFields ), intent(in) :: p2 public subroutine flf_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(out) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine lflf_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine fast_ion_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 public subroutine npa_part_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 public interface operator(+) public function pp_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public interface operator(-) public function pp_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public interface operator(*) public function sp_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) public function ps_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function slp_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) public function sf_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) public function fs_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function slf_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields ) public interface operator(/) public function ps_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function fs_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalEMFields ) public interface interpol_coeff public subroutine interpol1D_coeff (xmin, dx, nx, xout, i, b1, b2, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: xmin real(kind=double), intent(in) :: dx integer, intent(in) :: nx real(kind=double), intent(in) :: xout integer, intent(out) :: i real(kind=double), intent(out) :: b1 real(kind=double), intent(out) :: b2 integer, intent(out), optional :: err public subroutine interpol1D_coeff_arr (x, xout, i, b1, b2, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in) :: xout integer, intent(out) :: i real(kind=double), intent(out) :: b1 real(kind=double), intent(out) :: b2 integer, intent(out), optional :: err public subroutine interpol2D_coeff (xmin, dx, nx, ymin, dy, ny, xout, yout, i, j, b11, b12, b21, b22, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: xmin real(kind=double), intent(in) :: dx integer, intent(in) :: nx real(kind=double), intent(in) :: ymin real(kind=double), intent(in) :: dy integer, intent(in) :: ny real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout integer, intent(out) :: i integer, intent(out) :: j real(kind=double), intent(out) :: b11 real(kind=double), intent(out) :: b12 real(kind=double), intent(out) :: b21 real(kind=double), intent(out) :: b22 integer, intent(out), optional :: err public subroutine interpol2D_coeff_arr (x, y, xout, yout, i, j, b11, b12, b21, b22, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout integer, intent(out) :: i integer, intent(out) :: j real(kind=double), intent(out) :: b11 real(kind=double), intent(out) :: b12 real(kind=double), intent(out) :: b21 real(kind=double), intent(out) :: b22 integer, intent(out), optional :: err public interface interpol public subroutine interpol1D_arr (x, y, xout, yout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in) :: xout real(kind=double), intent(out) :: yout integer, intent(out), optional :: err public subroutine interpol2D_arr (x, y, z, xout, yout, zout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in), dimension(:,:) :: z real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout real(kind=double), intent(out) :: zout integer, intent(out), optional :: err public subroutine interpol2D_2D_arr (x, y, z, xout, yout, zout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in), dimension(:,:,:,:) :: z real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout real(kind=double), intent(out), dimension(:,:) :: zout integer, intent(out), optional :: err Derived Types type, public :: BeamGrid Components Type Visibility Attributes Name Initial integer(kind=long), public :: nx integer(kind=long), public :: ny integer(kind=long), public :: nz real(kind=double), public :: xmin real(kind=double), public :: xmax real(kind=double), public :: ymin real(kind=double), public :: ymax real(kind=double), public :: zmin real(kind=double), public :: zmax real(kind=double), public :: alpha real(kind=double), public :: beta real(kind=double), public :: gamma real(kind=double), public :: drmin real(kind=double), public :: dv real(kind=double), public :: volume integer(kind=long), public :: ntrack integer(kind=long), public :: ngrid real(kind=double), public, dimension(3) :: origin real(kind=double), public, dimension(3) :: center real(kind=double), public, dimension(3) :: dr real(kind=double), public, dimension(3) :: lwh real(kind=double), public, dimension(3,3) :: basis real(kind=double), public, dimension(3,3) :: inv_basis real(kind=double), public, dimension(:), allocatable :: xc real(kind=double), public, dimension(:), allocatable :: yc real(kind=double), public, dimension(:), allocatable :: zc type, public :: InterpolationGrid Components Type Visibility Attributes Name Initial integer(kind=long), public :: nr integer(kind=long), public :: nz real(kind=double), public :: dr real(kind=double), public :: dz real(kind=double), public :: da real(kind=double), public, dimension(:), allocatable :: r real(kind=double), public, dimension(:), allocatable :: z real(kind=double), public, dimension(:,:), allocatable :: r2d real(kind=double), public, dimension(:,:), allocatable :: z2d type, public :: Profiles Components Type Visibility Attributes Name Initial real(kind=double), public :: dene = 0.d0 real(kind=double), public :: denp = 0.d0 real(kind=double), public :: denimp = 0.d0 real(kind=double), public :: denf = 0.d0 real(kind=double), public :: te = 0.d0 real(kind=double), public :: ti = 0.d0 real(kind=double), public :: zeff = 0.d0 real(kind=double), public :: vr = 0.d0 real(kind=double), public :: vt = 0.d0 real(kind=double), public :: vz = 0.d0 type, public, extends( Profiles ) :: LocalProfiles Components Type Visibility Attributes Name Initial logical, public :: in_plasma = .False. real(kind=double), public, dimension(3) :: pos = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: vrot = [0.d0, 0.d0, 0.d0] type, public :: EMFields Components Type Visibility Attributes Name Initial real(kind=double), public :: br = 0.d0 real(kind=double), public :: bt = 0.d0 real(kind=double), public :: bz = 0.d0 real(kind=double), public :: er = 0.d0 real(kind=double), public :: et = 0.d0 real(kind=double), public :: ez = 0.d0 type, public, extends( EMFields ) :: LocalEMFields Components Type Visibility Attributes Name Initial logical, public :: in_plasma = .False. real(kind=double), public :: b_abs = 0.d0 real(kind=double), public :: e_abs = 0.d0 real(kind=double), public, dimension(3) :: pos = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: a_norm = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: b_norm = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: c_norm = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: e_norm = [0.d0, 0.d0, 0.d0] type, public :: Equilibrium Components Type Visibility Attributes Name Initial type( EMFields ), public, dimension(:,:), allocatable :: fields type( Profiles ), public, dimension(:,:), allocatable :: plasma real(kind=double), public, dimension(:,:), allocatable :: mask type, public :: FastIonDistribution Components Type Visibility Attributes Name Initial integer(kind=long), public :: nenergy integer(kind=long), public :: npitch real(kind=double), public :: dE real(kind=double), public :: dp real(kind=double), public :: emin real(kind=double), public :: emax real(kind=double), public :: e_range real(kind=double), public :: pmin real(kind=double), public :: pmax real(kind=double), public :: p_range real(kind=double), public, dimension(:), allocatable :: energy real(kind=double), public, dimension(:), allocatable :: pitch real(kind=double), public, dimension(:,:,:,:), allocatable :: f type, public :: FastIon Components Type Visibility Attributes Name Initial logical, public :: cross_grid = .False. real(kind=double), public :: r = 0.d0 real(kind=double), public :: z = 0.d0 real(kind=double), public :: phi_enter = 0.d0 real(kind=double), public :: delta_phi = 0.d0 real(kind=double), public :: energy = 0.d0 real(kind=double), public :: pitch = 0.d0 real(kind=double), public :: vabs = 0.d0 real(kind=double), public :: vr = 0.d0 real(kind=double), public :: vt = 0.d0 real(kind=double), public :: vz = 0.d0 real(kind=double), public :: weight = 0.d0 integer(kind=long), public :: class = 0 type, public :: FastIonParticles Components Type Visibility Attributes Name Initial logical, public :: guiding_center = .True. integer(kind=long), public :: nparticle = 0 integer(kind=long), public :: nclass = 1 type( FastIon ), public, dimension(:), allocatable :: fast_ion type, public :: NeutralBeam Components Type Visibility Attributes Name Initial character(len=25), public :: name = '' integer, public :: shape real(kind=double), public :: widy real(kind=double), public :: widz real(kind=double), public :: focy real(kind=double), public :: focz real(kind=double), public :: einj real(kind=double), public :: pinj real(kind=double), public :: vinj real(kind=double), public :: alpha real(kind=double), public :: beta real(kind=double), public, dimension(3) :: divy real(kind=double), public, dimension(3) :: divz real(kind=double), public, dimension(3) :: species_mix real(kind=double), public, dimension(3) :: src real(kind=double), public, dimension(3) :: axis real(kind=double), public, dimension(3,3) :: basis real(kind=double), public, dimension(3,3) :: inv_basis type, public :: AtomicCrossSection Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 real(kind=double), public :: logemin = 0.d0 real(kind=double), public :: logemax = 0.d0 integer, public :: n_max = nlevs integer, public :: m_max = nlevs real(kind=double), public :: dlogE = 0.d0 real(kind=double), public :: minlog_cross real(kind=double), public, dimension(:,:,:), allocatable :: log_cross type, public :: AtomicRates Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 real(kind=double), public :: logemin = 0.d0 real(kind=double), public :: logemax = 0.d0 integer, public :: ntemp = 1 real(kind=double), public :: logtmin = 0.d0 real(kind=double), public :: logtmax = 0.d0 integer, public :: n_max = nlevs integer, public :: m_max = nlevs real(kind=double), public :: dlogE = 0.d0 real(kind=double), public :: dlogT = 0.d0 real(kind=double), public :: minlog_pop = 0.d0 real(kind=double), public :: minlog_depop = 0.d0 real(kind=double), public, dimension(2) :: ab = 0.d0 real(kind=double), public, dimension(:,:,:,:,:), allocatable :: log_pop real(kind=double), public, dimension(:,:,:,:), allocatable :: log_depop type, public :: AtomicTables Components Type Visibility Attributes Name Initial type( AtomicCrossSection ), public :: H_H_cx type( AtomicRates ), public :: H_H type( AtomicRates ), public :: H_e type( AtomicRates ), public :: H_Aq real(kind=double), public, dimension(nlevs,nlevs) :: einstein type, public :: LineOfSight Components Type Visibility Attributes Name Initial real(kind=double), public :: sigma_pi = 1.d0 real(kind=double), public :: spot_size = 0.d0 real(kind=double), public, dimension(3) :: lens = [0.d0, 0.d0, 0.d0] real(kind=double), public, dimension(3) :: axis = [0.d0, 0.d0, 0.d0] type, public :: SpectralChords Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 type( LineOfSight ), public, dimension(:), allocatable :: los real(kind=double), public, dimension(:), allocatable :: radius logical, public, dimension(:,:,:), allocatable :: los_inter real(kind=double), public, dimension(:,:,:,:), allocatable :: dlength type, public :: BoundedPlane Components Type Visibility Attributes Name Initial integer, public :: shape = 0 real(kind=double), public :: hh = 0.d0 real(kind=double), public :: hw = 0.d0 real(kind=double), public, dimension(3) :: origin = 0.d0 real(kind=double), public, dimension(3,3) :: basis = 0.d0 real(kind=double), public, dimension(3,3) :: inv_basis = 0.d0 type, public :: NPADetector Components Type Visibility Attributes Name Initial type( BoundedPlane ), public :: detector type( BoundedPlane ), public :: aperture type, public :: NPAProbability Components Type Visibility Attributes Name Initial real(kind=double), public :: p = 0.d0 real(kind=double), public, dimension(3) :: eff_rd = [0.d0, 0.d0, 0.d0] type, public :: NPAChords Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 type( NPADetector ), public, dimension(:), allocatable :: det real(kind=double), public, dimension(:), allocatable :: radius logical, public, dimension(:,:,:), allocatable :: hit type( NPAProbability ), public, dimension(:,:,:,:), allocatable :: phit type, public :: NPAParticle Components Type Visibility Attributes Name Initial integer, public :: detector = 0 real(kind=double), public :: xi = 0.d0 real(kind=double), public :: yi = 0.d0 real(kind=double), public :: zi = 0.d0 real(kind=double), public :: xf = 0.d0 real(kind=double), public :: yf = 0.d0 real(kind=double), public :: zf = 0.d0 real(kind=double), public :: weight = 0.d0 real(kind=double), public :: energy = 0.d0 real(kind=double), public :: pitch = 0.d0 type, public :: NPAResults Components Type Visibility Attributes Name Initial integer(kind=long), public :: nchan = 0 integer(kind=long), public :: npart = 0 integer(kind=long), public :: nmax = 1000000 integer(kind=long), public :: nloop = 1000 type( NPAParticle ), public, dimension(:), allocatable :: part real(kind=double), public, dimension(:), allocatable :: energy real(kind=double), public, dimension(:,:), allocatable :: flux type, public :: BirthProfile Components Type Visibility Attributes Name Initial integer, public :: ind = 1 real(kind=double), public, dimension(:,:), allocatable :: ri real(kind=double), public, dimension(:,:), allocatable :: vi real(kind=double), public, dimension(:,:,:,:), allocatable :: dens type, public :: Spectra Components Type Visibility Attributes Name Initial real(kind=double), public, dimension(:,:), allocatable :: brems real(kind=double), public, dimension(:,:,:), allocatable :: bes real(kind=double), public, dimension(:,:,:), allocatable :: fida type, public :: NeutralDensity Components Type Visibility Attributes Name Initial real(kind=double), public, dimension(:,:,:,:,:), allocatable :: dens type, public :: FIDAWeights Components Type Visibility Attributes Name Initial real(kind=double), public, dimension(:,:), allocatable :: fida real(kind=double), public, dimension(:,:,:), allocatable :: mean_f real(kind=double), public, dimension(:,:,:,:), allocatable :: weight type, public :: NPAWeights Components Type Visibility Attributes Name Initial real(kind=double), public, dimension(:,:,:,:,:), allocatable :: attenuation real(kind=double), public, dimension(:,:,:,:,:), allocatable :: cx real(kind=double), public, dimension(:,:,:,:), allocatable :: emissivity real(kind=double), public, dimension(:,:,:), allocatable :: weight real(kind=double), public, dimension(:,:), allocatable :: flux type, public :: SimulationInputs Components Type Visibility Attributes Name Initial integer(kind=long), public :: shot_number real(kind=double), public :: time character(len=120), public :: runid = '' character(len=10), public :: version = '' character(len=120), public :: result_dir = '' character(len=120), public :: tables_file = '' character(len=120), public :: geometry_file = '' character(len=120), public :: equilibrium_file = '' character(len=120), public :: distribution_file = '' character(len=120), public :: neutrals_file = '' integer(kind=long), public :: n_fida integer(kind=long), public :: n_npa integer(kind=long), public :: n_nbi integer(kind=long), public :: n_dcx integer(kind=long), public :: n_halo integer(kind=long), public :: n_birth integer(kind=long), public :: calc_spec integer(kind=long), public :: calc_brems integer(kind=long), public :: calc_bes integer(kind=long), public :: calc_fida integer(kind=long), public :: load_neutrals integer(kind=long), public :: calc_npa integer(kind=long), public :: calc_fida_wght integer(kind=long), public :: calc_npa_wght integer(kind=long), public :: calc_birth integer(kind=long), public :: dump_dcx integer(kind=long), public :: verbose real(kind=double), public :: ab integer(kind=long), public :: impurity_charge real(kind=double), public :: ai integer(kind=long), public :: dist_type integer(kind=long), public :: nlambda real(kind=double), public :: dlambda real(kind=double), public :: lambdamin real(kind=double), public :: lambdamax integer(kind=long), public :: ne_wght integer(kind=long), public :: np_wght integer(kind=long), public :: nphi_wght integer(kind=long), public :: nlambda_wght real(kind=double), public :: emax_wght real(kind=double), public :: lambdamin_wght real(kind=double), public :: lambdamax_wght type, public :: ParticleTrack Components Type Visibility Attributes Name Initial real(kind=double), public :: time = 0.d0 real(kind=double), public :: flux = 0.d0 integer(kind=long), public, dimension(3) :: ind = [0, 0, 0] real(kind=double), public, dimension(3) :: pos = [0.d0, 0.d0, 0.d0] Functions public function pp_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function pp_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function lplp_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ps_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( Profiles ) public function sp_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) public function ps_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function slp_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) public function lps_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function ff_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function ff_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function fs_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( EMFields ) public function sf_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) public function fs_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( EMFields ) public function lflf_add (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public function lflf_subtract (p1, p2) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public function lfs_multiply (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function slf_multiply (real_scalar, p1) result(p3) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields ) public function lfs_divide (p1, real_scalar) result(p3) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=double), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function cross_product (u, v) result(s) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: u real(kind=double), intent(in), dimension(3) :: v Return Value real(kind=double),\n  dimension(3) public function normp (u, p_in) result(n) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: u integer, intent(in), optional :: p_in Return Value real(kind=double) public function in_boundary (bplane, p) result(in_b) Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane real(kind=double), intent(in), dimension(3) :: p Return Value logical Subroutines public subroutine print_banner () Arguments None public subroutine fast_ion_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 public subroutine npa_part_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 public subroutine pp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(out) :: p1 type( Profiles ), intent(in) :: p2 public subroutine lpp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: p1 type( Profiles ), intent(in) :: p2 public subroutine plp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( Profiles ), intent(out) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine lplp_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine ff_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(out) :: p1 type( EMFields ), intent(in) :: p2 public subroutine lff_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: p1 type( EMFields ), intent(in) :: p2 public subroutine flf_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( EMFields ), intent(out) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine lflf_assign (p1, p2) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine read_inputs () Arguments None public subroutine make_beam_grid () Arguments None public subroutine read_beam () Arguments None public subroutine read_chords () Arguments None public subroutine read_npa () Arguments None public subroutine read_equilibrium () Arguments None public subroutine read_f (fid, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid integer, intent(out) :: error public subroutine read_mc (fid, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid integer, intent(out) :: error public subroutine read_distribution () Arguments None public subroutine read_cross (fid, grp, cross) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid character(len=*), intent(in) :: grp type( AtomicCrossSection ), intent(inout) :: cross public subroutine read_rates (fid, grp, b_amu, t_amu, rates) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid character(len=*), intent(in) :: grp real(kind=double), intent(in), dimension(2) :: b_amu real(kind=double), intent(in) :: t_amu type( AtomicRates ), intent(inout) :: rates public subroutine read_tables () Arguments None public subroutine write_beam_grid (id, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id integer, intent(out) :: error public subroutine write_birth_profile () Arguments None public subroutine write_dcx () Arguments None public subroutine write_neutrals () Arguments None public subroutine write_npa () Arguments None public subroutine write_spectra () Arguments None public subroutine write_fida_weights () Arguments None public subroutine write_npa_weights () Arguments None public subroutine read_neutrals () Arguments None public subroutine tb_zyx (alpha, beta, gamma, basis, inv_basis) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: alpha real(kind=double), intent(in) :: beta real(kind=double), intent(in) :: gamma real(kind=double), intent(out), dimension(3,3) :: basis real(kind=double), intent(out), optional dimension(3,3) :: inv_basis public subroutine line_basis (r0, v0, basis, inv_basis) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: r0 real(kind=double), intent(in), dimension(3) :: v0 real(kind=double), intent(out), dimension(3,3) :: basis real(kind=double), intent(out), optional dimension(3,3) :: inv_basis public subroutine plane_basis (center, redge, tedge, basis, inv_basis) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: center real(kind=double), intent(in), dimension(3) :: redge real(kind=double), intent(in), dimension(3) :: tedge real(kind=double), intent(out), dimension(3,3) :: basis real(kind=double), intent(out), optional dimension(3,3) :: inv_basis public subroutine plane_intercept (l0, l, p0, n, p, t) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: l0 real(kind=double), intent(in), dimension(3) :: l real(kind=double), intent(in), dimension(3) :: p0 real(kind=double), intent(in), dimension(3) :: n real(kind=double), intent(out), dimension(3) :: p real(kind=double), intent(out) :: t public subroutine hit_npa_detector (r0, v0, d_index, rd) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: r0 real(kind=double), intent(in), dimension(3) :: v0 integer, intent(out) :: d_index real(kind=double), intent(out), optional dimension(3) :: rd public subroutine xyz_to_uvw (xyz, uvw) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: xyz real(kind=double), intent(out), dimension(3) :: uvw public subroutine uvw_to_xyz (uvw, xyz) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: uvw real(kind=double), intent(out), dimension(3) :: xyz public subroutine grid_intersect (r0, v0, length, r_enter, r_exit, center_in, lwh_in) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: r0 real(kind=double), intent(in), dimension(3) :: v0 real(kind=double), intent(out) :: length real(kind=double), intent(out), dimension(3) :: r_enter real(kind=double), intent(out), dimension(3) :: r_exit real(kind=double), intent(in), optional dimension(3) :: center_in real(kind=double), intent(in), optional dimension(3) :: lwh_in public subroutine get_indices (pos, ind) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: pos integer(kind=long), intent(out), dimension(3) :: ind public subroutine get_position (ind, pos) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in), dimension(3) :: ind real(kind=double), intent(out), dimension(3) :: pos public subroutine track (rin, vin, tracks, ncell, los_intersect) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: rin real(kind=double), intent(in), dimension(3) :: vin type( ParticleTrack ), intent(inout), dimension(:) :: tracks integer(kind=long), intent(out) :: ncell logical, intent(out), optional :: los_intersect public subroutine interpol1D_coeff (xmin, dx, nx, xout, i, b1, b2, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: xmin real(kind=double), intent(in) :: dx integer, intent(in) :: nx real(kind=double), intent(in) :: xout integer, intent(out) :: i real(kind=double), intent(out) :: b1 real(kind=double), intent(out) :: b2 integer, intent(out), optional :: err public subroutine interpol1D_coeff_arr (x, xout, i, b1, b2, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in) :: xout integer, intent(out) :: i real(kind=double), intent(out) :: b1 real(kind=double), intent(out) :: b2 integer, intent(out), optional :: err public subroutine interpol2D_coeff (xmin, dx, nx, ymin, dy, ny, xout, yout, i, j, b11, b12, b21, b22, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: xmin real(kind=double), intent(in) :: dx integer, intent(in) :: nx real(kind=double), intent(in) :: ymin real(kind=double), intent(in) :: dy integer, intent(in) :: ny real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout integer, intent(out) :: i integer, intent(out) :: j real(kind=double), intent(out) :: b11 real(kind=double), intent(out) :: b12 real(kind=double), intent(out) :: b21 real(kind=double), intent(out) :: b22 integer, intent(out), optional :: err public subroutine interpol2D_coeff_arr (x, y, xout, yout, i, j, b11, b12, b21, b22, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout integer, intent(out) :: i integer, intent(out) :: j real(kind=double), intent(out) :: b11 real(kind=double), intent(out) :: b12 real(kind=double), intent(out) :: b21 real(kind=double), intent(out) :: b22 integer, intent(out), optional :: err public subroutine interpol1D_arr (x, y, xout, yout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in) :: xout real(kind=double), intent(out) :: yout integer, intent(out), optional :: err public subroutine interpol2D_arr (x, y, z, xout, yout, zout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in), dimension(:,:) :: z real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout real(kind=double), intent(out) :: zout integer, intent(out), optional :: err public subroutine interpol2D_2D_arr (x, y, z, xout, yout, zout, err) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: x real(kind=double), intent(in), dimension(:) :: y real(kind=double), intent(in), dimension(:,:,:,:) :: z real(kind=double), intent(in) :: xout real(kind=double), intent(in) :: yout real(kind=double), intent(out), dimension(:,:) :: zout integer, intent(out), optional :: err public subroutine in_plasma (xyz, inp) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: xyz logical, intent(out) :: inp public subroutine get_plasma (plasma, pos, ind) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: plasma real(kind=double), intent(in), optional dimension(3) :: pos integer(kind=long), intent(in), optional dimension(3) :: ind public subroutine calc_perp_vectors (b, a, c) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: b real(kind=double), intent(out), dimension(3) :: a real(kind=double), intent(out), dimension(3) :: c public subroutine get_fields (fields, pos, ind) Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: fields real(kind=double), intent(in), optional dimension(3) :: pos integer(kind=long), intent(in), optional dimension(3) :: ind public subroutine get_distribution (fbeam, pos, ind) Arguments Type Intent Optional Attributes Name real(kind=double), intent(out), dimension(:,:) :: fbeam real(kind=double), intent(in), optional dimension(3) :: pos integer(kind=long), intent(in), optional dimension(3) :: ind public subroutine get_ep_denf (energy, pitch, denf, pos, ind) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: energy real(kind=double), intent(in) :: pitch real(kind=double), intent(out) :: denf real(kind=double), intent(in), optional dimension(3) :: pos integer(kind=long), intent(in), optional dimension(3) :: ind public subroutine store_neutrals (ind, neut_type, dens, store_iter) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in), dimension(3) :: ind integer, intent(in) :: neut_type real(kind=double), intent(in), dimension(:) :: dens logical, intent(in), optional :: store_iter public subroutine store_births (ind, neut_type, dflux) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in), dimension(3) :: ind integer(kind=long), intent(in) :: neut_type real(kind=double), intent(in) :: dflux public subroutine store_npa (det, ri, rf, vn, flux) Arguments Type Intent Optional Attributes Name integer, intent(in) :: det real(kind=double), intent(in), dimension(3) :: ri real(kind=double), intent(in), dimension(3) :: rf real(kind=double), intent(in), dimension(3) :: vn real(kind=double), intent(in) :: flux public subroutine neut_rates (denn, vi, vn, rates) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(nlevs) :: denn real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(in), dimension(3) :: vn real(kind=double), intent(out), dimension(nlevs) :: rates public subroutine get_beam_cx_prob (ind, pos, v_ion, types, prob) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in), dimension(3) :: ind real(kind=double), intent(in), dimension(3) :: pos real(kind=double), intent(in), dimension(3) :: v_ion integer(kind=long), intent(in), dimension(:) :: types real(kind=double), intent(out), dimension(nlevs) :: prob public subroutine get_rate_matrix (plasma, i_type, eb, rmat) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma integer, intent(in) :: i_type real(kind=double), intent(in) :: eb real(kind=double), intent(out), dimension(nlevs,nlevs) :: rmat public subroutine colrad (plasma, i_type, vn, dt, states, dens, photons) Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma integer, intent(in) :: i_type real(kind=double), intent(in), dimension(:) :: vn real(kind=double), intent(in) :: dt real(kind=double), intent(inout), dimension(:) :: states real(kind=double), intent(out), dimension(nlevs) :: dens real(kind=double), intent(out) :: photons public subroutine attenuate (ri, rf, vi, states, dstep_in) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: ri real(kind=double), intent(in), dimension(3) :: rf real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(inout), dimension(nlevs) :: states real(kind=double), intent(in), optional :: dstep_in public subroutine spectrum (vecp, vi, fields, sigma_pi, photons, dlength, lambda, intensity) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: vecp real(kind=double), intent(in), dimension(3) :: vi type( LocalEMFields ), intent(in) :: fields real(kind=double), intent(in) :: sigma_pi real(kind=double), intent(in) :: photons real(kind=double), intent(in) :: dlength real(kind=double), intent(out), dimension(n_stark) :: lambda real(kind=double), intent(out), dimension(n_stark) :: intensity public subroutine store_bes_photons (pos, vi, photons, neut_type) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: pos real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(in) :: photons integer, intent(in) :: neut_type public subroutine store_fida_photons (pos, vi, photons, orbit_class) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: pos real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(in) :: photons integer, intent(in), optional :: orbit_class public subroutine store_fw_photons_at_chan (ichan, eind, pind, vp, vi, fields, dlength, sigma_pi, denf, photons) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan integer, intent(in) :: eind integer, intent(in) :: pind real(kind=double), intent(in), dimension(3) :: vp real(kind=double), intent(in), dimension(3) :: vi type( LocalEMFields ), intent(in) :: fields real(kind=double), intent(in) :: dlength real(kind=double), intent(in) :: sigma_pi real(kind=double), intent(in) :: denf real(kind=double), intent(in) :: photons public subroutine store_fw_photons (eind, pind, pos, vi, denf, photons) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eind integer, intent(in) :: pind real(kind=double), intent(in), dimension(3) :: pos real(kind=double), intent(in), dimension(3) :: vi real(kind=double), intent(in) :: denf real(kind=double), intent(in) :: photons public subroutine get_nlaunch (nr_markers, papprox, papprox_tot, nlaunch) Arguments Type Intent Optional Attributes Name integer(kind=long), intent(in) :: nr_markers real(kind=double), intent(in), dimension(:,:,:) :: papprox real(kind=double), intent(in) :: papprox_tot real(kind=double), intent(out), dimension(:,:,:) :: nlaunch public subroutine pitch_to_vec (pitch, gyroangle, fields, vi_norm) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in) :: pitch real(kind=double), intent(in) :: gyroangle type( LocalEMFields ), intent(in) :: fields real(kind=double), intent(out), dimension(3) :: vi_norm public subroutine gyro_correction (vi, fields, r_gyro) Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(3) :: vi type( LocalEMFields ), intent(in) :: fields real(kind=double), intent(out), dimension(3) :: r_gyro public subroutine mc_fastion (ind, ri, vi, at_guiding_center) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind real(kind=double), intent(out), dimension(3) :: ri real(kind=double), intent(out), dimension(3) :: vi logical, intent(in), optional :: at_guiding_center public subroutine mc_halo (ind, vhalo, ri, plasma_in) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind real(kind=double), intent(out), dimension(3) :: vhalo real(kind=double), intent(out), optional dimension(3) :: ri type( LocalProfiles ), intent(in), optional :: plasma_in public subroutine mc_nbi (vnbi, efrac, rnbi) Arguments Type Intent Optional Attributes Name real(kind=double), intent(out), dimension(3) :: vnbi integer, intent(in) :: efrac real(kind=double), intent(out), dimension(3) :: rnbi public subroutine ndmc () Arguments None public subroutine bremsstrahlung () Arguments None public subroutine dcx () Arguments None public subroutine halo () Arguments None public subroutine fida_f () Arguments None public subroutine fida_mc () Arguments None public subroutine npa_f () Arguments None public subroutine npa_mc () Arguments None public subroutine fida_weights_mc () Arguments None public subroutine fida_weights_los () Arguments None public subroutine npa_weights () Arguments None","tags":""},{"title":"hdf5_extra – Fortran Program","loc":"module/hdf5_extra.html","text":"Uses: H5LT HDF5 module~~hdf5_extra~~UsesGraph module~hdf5_extra hdf5_extra H5LT H5LT H5LT->module~hdf5_extra HDF5 HDF5 HDF5->module~hdf5_extra Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A library of helpful HDF5 routines Used By module~~hdf5_extra~~UsedByGraph module~hdf5_extra hdf5_extra program~generate_tables generate_tables module~hdf5_extra->program~generate_tables module~atomic_tables atomic_tables module~hdf5_extra->module~atomic_tables program~fidasim fidasim module~hdf5_extra->program~fidasim module~simulation simulation module~hdf5_extra->module~simulation module~atomic_tables->program~generate_tables module~simulation->program~fidasim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: long = 4 integer, private, parameter :: long64 = 8 integer, private, parameter :: float = 4 integer, private, parameter :: double = 8 logical, private :: compress_data = .True. Interfaces public interface h5ltmake_compressed_dataset_double_f Write a compressed datasets of 64-bit floats public subroutine h5ltmake_compressed_dataset_double_f_1 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 1 public subroutine h5ltmake_compressed_dataset_double_f_2 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 2 public subroutine h5ltmake_compressed_dataset_double_f_3 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 3 public subroutine h5ltmake_compressed_dataset_double_f_4 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 4 public subroutine h5ltmake_compressed_dataset_double_f_5 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 5 public subroutine h5ltmake_compressed_dataset_double_f_6 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 6 public subroutine h5ltmake_compressed_dataset_double_f_7 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 7 public interface h5ltmake_compressed_dataset_int_f Write a compressed dataset of 32-bit integers public subroutine h5ltmake_compressed_dataset_int_f_1 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 1 public subroutine h5ltmake_compressed_dataset_int_f_2 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 2 public subroutine h5ltmake_compressed_dataset_int_f_3 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 3 public subroutine h5ltmake_compressed_dataset_int_f_4 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 4 public subroutine h5ltmake_compressed_dataset_int_f_5 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 5 public subroutine h5ltmake_compressed_dataset_int_f_6 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 6 public subroutine h5ltmake_compressed_dataset_int_f_7 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 7 Subroutines public subroutine check_compression_availability () Arguments None Description Checks whether dataset compression is available public subroutine h5ltread_dataset_int_scalar_f (loc_id, dset_name, x, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a scalar 32-bit integer public subroutine h5ltread_dataset_double_scalar_f (loc_id, dset_name, x, error) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create real(kind=double), intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a scalar 64-bit float public subroutine h5ltmake_compressed_dataset_double_f_1 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 1 public subroutine h5ltmake_compressed_dataset_double_f_2 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 2 public subroutine h5ltmake_compressed_dataset_double_f_3 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 3 public subroutine h5ltmake_compressed_dataset_double_f_4 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 4 public subroutine h5ltmake_compressed_dataset_double_f_5 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 5 public subroutine h5ltmake_compressed_dataset_double_f_6 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 6 public subroutine h5ltmake_compressed_dataset_double_f_7 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 64-bit float dataset of dimension 7 public subroutine h5ltmake_compressed_dataset_int_f_1 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 1 public subroutine h5ltmake_compressed_dataset_int_f_2 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 2 public subroutine h5ltmake_compressed_dataset_int_f_3 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 3 public subroutine h5ltmake_compressed_dataset_int_f_4 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 4 public subroutine h5ltmake_compressed_dataset_int_f_5 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 5 public subroutine h5ltmake_compressed_dataset_int_f_6 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 6 public subroutine h5ltmake_compressed_dataset_int_f_7 (loc_id, dset_name, rank, dims, buf, error) Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Description Write a compressed 32-bit integer dataset of dimension 7","tags":""},{"title":"parallel_rng – Fortran Program","loc":"module/parallel_rng.html","text":"Uses: omp_lib module~~parallel_rng~~UsesGraph module~parallel_rng parallel_rng omp_lib omp_lib omp_lib->module~parallel_rng Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A basic parallel random number generator library Used By module~~parallel_rng~~UsedByGraph module~parallel_rng parallel_rng module~simulation simulation module~parallel_rng->module~simulation program~fidasim fidasim module~simulation->program~fidasim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: Int64 = kind(int8(1)) integer, private, parameter :: Float32 = kind(1.e0) integer, private, parameter :: Float64 = kind(1.d0) integer, private, parameter :: IA = 16807 integer, private, parameter :: IM = 2147483647 integer, private, parameter :: IQ = 127773 integer, private, parameter :: IR = 2836 integer, private, parameter :: ns = 2 type( rng_type ), public, dimension(:), allocatable :: rng Interfaces public interface randind Procedure for generating a random array index/subscripts private subroutine randind_n (n, randomi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates Description Generate a array of uniformally-distributed random integers in the range [1, n] private subroutine randind_w_1 (w, randomi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices Description Generate an array of random indices of an 1D array distributed according to w private subroutine randind_w_2 (w, randomi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts Description Generate an array of random subscripts of an 2D array distributed according to w Derived Types type, public :: rng_type Components Type Visibility Attributes Name Initial integer, public, dimension(ns) :: state Description Random Number Generator Derived Type Functions public function rng_uniform (self) result(u) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Uniform random deviate Description Generate a uniformally-distributed random number in the range [0,1) public function rng_normal (self) result(n) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Normal random deviate Description Generate a normally-distributed random number with mean 0 and standard deviation 1 Subroutines public subroutine rng_init (self, seed) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator integer, intent(in) :: seed Initial Seed Value Description Procedure to initialize a random number generator with a seed public subroutine randu (randomu) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomu Array of uniform random deviates Description Generate an array of uniformally-distributed random deviates public subroutine randn (randomn) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomn Array of normal random deviates Description Generate an array of normally-distributed random deviates private subroutine randind_n (n, randomi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates Description Generate a array of uniformally-distributed random integers in the range [1, n] private subroutine randind_w_1 (w, randomi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices Description Generate an array of random indices of an 1D array distributed according to w public subroutine ind2sub (dims, ind, subs) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimensions of array integer, intent(in) :: ind Linear index integer, intent(out), dimension(:) :: subs Subscripts corresponding to the linear index Description Calculate the subscripts subs into an array with dimensions dims given the corresponding linear index ind private subroutine randind_w_2 (w, randomi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts Description Generate an array of random subscripts of an 2D array distributed according to w","tags":""},{"title":"atomic_tables – Fortran Program","loc":"module/atomic_tables.html","text":"Uses: H5LT HDF5 hdf5_extra module~~atomic_tables~~UsesGraph module~atomic_tables atomic_tables H5LT H5LT H5LT->module~atomic_tables module~hdf5_extra hdf5_extra H5LT->module~hdf5_extra HDF5 HDF5 HDF5->module~atomic_tables HDF5->module~hdf5_extra module~hdf5_extra->module~atomic_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~atomic_tables~~UsedByGraph module~atomic_tables atomic_tables program~generate_tables generate_tables module~atomic_tables->program~generate_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: Int32 = 4 integer, private, parameter :: Int64 = 8 integer, private, parameter :: Float32 = 4 integer, private, parameter :: Float64 = 8 real(kind=Float64), public, parameter :: PI = 3.14159265d0 real(kind=Float64), public, parameter :: e_amu = 5.485799093287202d-4 real(kind=Float64), public, parameter :: H1_amu = 1.00782504d0 real(kind=Float64), public, parameter :: H2_amu = 2.0141017778d0 real(kind=Float64), public, parameter :: B_amu = 10.81d0 real(kind=Float64), public, parameter :: C_amu = 12.011d0 integer, public, parameter :: B_q = 5 integer, public, parameter :: C_q = 6 real(kind=Float64), public, parameter, dimension(15,15) :: EINSTEIN = reshape([0.d0, 4.699d8, 5.575d7, 1.278d7, 4.125d6, 1.644d6, 7.568d5, 3.869d5, 2.143d5, 1.263d5, 7.834d4, 5.066d4, 3.393d4, 2.341d4, 1.657d4, 0.d0, 0.d0, 4.410d7, 8.419d6, 2.530d6, 9.732d5, 4.389d5, 2.215d5, 1.216d5, 7.122d4, 4.397d4, 2.834d4, 1.893d4, 1.303d4, 9.210d3, 0.d0, 0.d0, 0.d0, 8.986d6, 2.201d6, 7.783d5, 3.358d5, 1.651d5, 8.905d4, 5.156d4, 3.156d4, 2.021d4, 1.343d4, 9.211d3, 6.490d3, 0.d0, 0.d0, 0.d0, 0.d0, 2.699d6, 7.711d5, 3.041d5, 1.424d5, 7.459d4, 4.235d4, 2.556d4, 1.620d4, 1.069d4, 7.288d3, 5.110d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.025d6, 3.253d5, 1.388d5, 6.908d4, 3.800d4, 2.246d4, 1.402d4, 9.148d3, 6.185d3, 4.308d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 4.561d5, 1.561d5, 7.065d4, 3.688d4, 2.110d4, 1.288d4, 8.271d3, 5.526d3, 3.815d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 2.272d5, 8.237d4, 3.905d4, 2.117d4, 1.250d4, 7.845d3, 5.156d3, 3.516d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.233d5, 4.676d4, 2.301d4, 1.287d4, 7.804d3, 5.010d3, 3.359d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 7.141d4, 2.812d4, 1.427d4, 8.192d3, 5.080d3, 3.325d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 4.377d4, 1.774d4, 9.231d3, 5.417d3, 3.324d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 2.799d4, 1.163d4, 6.186d3, 3.699d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.857d4, 7.884d3, 4.271d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.271d4, 5.496d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 8.933d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0], [15, 15]) Interfaces public interface bt_maxwellian public subroutine bt_maxwellian_n (fn, T, eb, am, ab, n, rate) Arguments Type Intent Optional Attributes Name public function fn(a, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n real(kind=Float64), intent(out) :: rate public subroutine bt_maxwellian_n_m (fnm, T, eb, am, ab, n, m, rate, deexcit) Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n integer, intent(in) :: m real(kind=Float64), intent(out) :: rate logical, intent(in), optional :: deexcit public subroutine bt_maxwellian_q_n (fqn, q, T, eb, am, ab, n, rate) Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n real(kind=Float64), intent(out) :: rate public subroutine bt_maxwellian_q_n_m (fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n integer, intent(in) :: m real(kind=Float64), intent(out) :: rate logical, intent(in), optional :: deexcit Functions public function p_cx_1_janev (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_2_janev (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_3_janev (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_4_janev (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_janev (Erel, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: n Return Value real(kind=Float64) public function p_cx_1_1_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_1_2_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_1_3_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_1_4_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_1 (Erel, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function p_cx_2_2_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_2_3_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_2 (Erel, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function p_cx_3_2_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_3_3_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_3_4_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_3_5_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_3_6inf_adas (Erel) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Return Value real(kind=Float64) public function p_cx_3 (Erel, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function p_cx_n (Erel, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function p_cx_n_m (Erel, n, m) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) public function p_cx (Erel, n_max, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel integer, intent(in) :: n_max integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max,n_max) public function p_ioniz_1_omullane (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_ioniz_2_omullane (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_ioniz_3_omullane (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_ioniz_4_omullane (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_ioniz_5_omullane (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_ioniz_n (eb, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n Return Value real(kind=Float64) public function p_ioniz (eb, n_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n_max Return Value real(kind=Float64),\n  dimension(n_max) public function p_excit_1_2_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_1_3_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_1_4_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_1_5_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_1_6_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_1_janev (eb, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function p_excit_2_3_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_2_4_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_2_5_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_2_6_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_2_7_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_2_8_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_2_9_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_2_10_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_2_janev (eb, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function p_excit_3_4_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_3_5_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_3_6_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_3_7_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_3_8_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_3_9_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_3_10_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function p_excit_3_janev (eb, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function p_excit_n (eb, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function p_excit_n_m (eb, n, m) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) public function p_excit (eb, n_max, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n_max integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max,n_max) public function e_ioniz_1_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function e_ioniz_2_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function e_ioniz_3_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function e_ioniz_n (eb, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n Return Value real(kind=Float64) public function e_ioniz (eb, n_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n_max Return Value real(kind=Float64),\n  dimension(n_max) public function e_excit_1_2_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function e_excit_1_3_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function e_excit_1_4_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function e_excit_1_5_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function e_excit_f (n, m) result(fnm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) public function e_excit_1_janev (eb, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function e_excit_2_3_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function e_excit_n (eb, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function e_excit_n_m (eb, n, m) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) public function e_excit (eb, n_max, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: n_max integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(n_max,m_max) public function B5_cx_1_adas (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function B5_cx_2_adas (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function C6_cx_1_adas (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function C6_cx_2_adas (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function C6_cx_3_adas (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function Aq_cx_n_adas (eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) public function B5_cx_1_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function C6_cx_1_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function Aq_cx_n_janev (eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) public function Aq_cx_n (eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) public function Aq_cx (eb, q, n_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n_max Return Value real(kind=Float64),\n  dimension(n_max) public function B5_ioniz_1_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function C6_ioniz_1_janev (eb) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function Aq_ioniz_n_janev (eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) public function Aq_ioniz_n (eb, q, n) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n Return Value real(kind=Float64) public function Aq_ioniz (eb, q, n_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n_max Return Value real(kind=Float64),\n  dimension(n_max) public function Aq_excit_1_2_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_1_3_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_1_4_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_1_5_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_1_janev (eb, q, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function Aq_excit_2_3_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_2_4_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_2_5_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_2_6_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_2_7_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_2_8_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_2_9_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_2_10_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_2_janev (eb, q, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function Aq_excit_3_4_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_3_5_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_3_6_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_3_7_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_3_8_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_3_9_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_3_10_janev (eb, q) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q Return Value real(kind=Float64) public function Aq_excit_3_janev (eb, q, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function Aq_excit_n_janev (eb, q, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function Aq_excit_n (eb, q, n, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(m_max) public function Aq_excit_n_m (eb, q, n, m) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n integer, intent(in) :: m Return Value real(kind=Float64) public function Aq_excit (eb, q, n_max, m_max) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb integer, intent(in) :: q integer, intent(in) :: n_max integer, intent(in) :: m_max Return Value real(kind=Float64),\n  dimension(n_max, m_max) public function simpsons_rule (f, dx) result(I) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: f real(kind=Float64), intent(in) :: dx Return Value real(kind=Float64) Subroutines public subroutine m_spread (n, m_max, sigma_tot, sigma) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m_max real(kind=Float64), intent(in) :: sigma_tot real(kind=Float64), intent(inout), dimension(m_max) :: sigma public subroutine bt_maxwellian_n (fn, T, eb, am, ab, n, rate) Arguments Type Intent Optional Attributes Name public function fn(a, b) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n real(kind=Float64), intent(out) :: rate public subroutine bt_maxwellian_q_n (fqn, q, T, eb, am, ab, n, rate) Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n real(kind=Float64), intent(out) :: rate public subroutine bt_maxwellian_n_m (fnm, T, eb, am, ab, n, m, rate, deexcit) Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n integer, intent(in) :: m real(kind=Float64), intent(out) :: rate logical, intent(in), optional :: deexcit public subroutine bt_maxwellian_q_n_m (fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q real(kind=Float64), intent(in) :: T real(kind=Float64), intent(in) :: eb real(kind=Float64), intent(in) :: am real(kind=Float64), intent(in) :: ab integer, intent(in) :: n integer, intent(in) :: m real(kind=Float64), intent(out) :: rate logical, intent(in), optional :: deexcit public subroutine write_einstein (id, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id integer, intent(in) :: n_max integer, intent(in) :: m_max public subroutine write_bb_H_H (id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max public subroutine write_bb_H_e (id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max public subroutine write_bb_H_Aq (id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max public subroutine write_bt_H_H (id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max public subroutine write_bt_H_e (id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max public subroutine write_bt_H_Aq (id, namelist_file, n_max, m_max) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id character(len=*), intent(in) :: namelist_file integer, intent(in) :: n_max integer, intent(in) :: m_max","tags":""},{"title":"fidasim – Fortran Program","loc":"program/fidasim.html","text":"Uses: simulation hdf5_extra omp_lib program~~fidasim~~UsesGraph program~fidasim fidasim omp_lib omp_lib omp_lib->program~fidasim module~parallel_rng parallel_rng omp_lib->module~parallel_rng module~hdf5_extra hdf5_extra module~hdf5_extra->program~fidasim module~simulation simulation module~hdf5_extra->module~simulation module~simulation->program~fidasim H5LT H5LT H5LT->module~hdf5_extra H5LT->module~simulation HDF5 HDF5 HDF5->module~hdf5_extra HDF5->module~simulation module~eigensystem eigensystem module~eigensystem->module~simulation module~parallel_rng->module~simulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Calls program~~fidasim~~CallsGraph program~fidasim fidasim proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~halo halo program~fidasim->proc~halo proc~npa_f npa_f program~fidasim->proc~npa_f proc~make_beam_grid make_beam_grid program~fidasim->proc~make_beam_grid proc~rng_init rng_init program~fidasim->proc~rng_init proc~ndmc ndmc program~fidasim->proc~ndmc proc~check_compression_availability check_compression_availability program~fidasim->proc~check_compression_availability proc~read_npa read_npa program~fidasim->proc~read_npa proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~dcx dcx program~fidasim->proc~dcx proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~read_neutrals read_neutrals program~fidasim->proc~read_neutrals proc~write_dcx write_dcx program~fidasim->proc~write_dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~write_npa write_npa program~fidasim->proc~write_npa proc~read_tables read_tables program~fidasim->proc~read_tables proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~write_neutrals write_neutrals program~fidasim->proc~write_neutrals proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~read_inputs read_inputs program~fidasim->proc~read_inputs proc~write_spectra write_spectra program~fidasim->proc~write_spectra proc~read_beam read_beam program~fidasim->proc~read_beam proc~print_banner print_banner program~fidasim->proc~print_banner omp_get_num_procs omp_get_num_procs program~fidasim->omp_get_num_procs proc~write_birth_profile write_birth_profile program~fidasim->proc~write_birth_profile omp_set_num_threads omp_set_num_threads program~fidasim->omp_set_num_threads proc~read_chords read_chords program~fidasim->proc~read_chords h5fclose_f h5fclose_f proc~read_equilibrium->h5fclose_f h5gclose_f h5gclose_f proc~read_equilibrium->h5gclose_f h5open_f h5open_f proc~read_equilibrium->h5open_f h5close_f h5close_f proc~read_equilibrium->h5close_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_equilibrium->proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_equilibrium->h5ltread_dataset_int_f h5fopen_f h5fopen_f proc~read_equilibrium->h5fopen_f h5gopen_f h5gopen_f proc~read_equilibrium->h5gopen_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_equilibrium->h5ltread_dataset_double_f proc~get_nlaunch get_nlaunch proc~halo->proc~get_nlaunch proc~store_neutrals store_neutrals proc~halo->proc~store_neutrals proc~get_plasma get_plasma proc~halo->proc~get_plasma proc~colrad colrad proc~halo->proc~colrad proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~track track proc~halo->proc~track proc~get_beam_cx_prob get_beam_cx_prob proc~halo->proc~get_beam_cx_prob proc~mc_halo mc_halo proc~halo->proc~mc_halo proc~npa_f->proc~get_nlaunch proc~npa_f->proc~get_plasma proc~npa_f->proc~get_beam_cx_prob proc~mc_fastion mc_fastion proc~npa_f->proc~mc_fastion proc~store_npa store_npa proc~npa_f->proc~store_npa proc~attenuate attenuate proc~npa_f->proc~attenuate proc~hit_npa_detector hit_npa_detector proc~npa_f->proc~hit_npa_detector proc~tb_zyx tb_zyx proc~make_beam_grid->proc~tb_zyx proc~ndmc->proc~store_neutrals proc~ndmc->proc~get_plasma proc~ndmc->proc~colrad proc~ndmc->proc~store_bes_photons proc~ndmc->proc~track proc~randu randu proc~ndmc->proc~randu interface~randind randind proc~ndmc->interface~randind proc~store_births store_births proc~ndmc->proc~store_births proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~check_compression_availability->h5open_f proc~check_compression_availability->h5close_f h5zget_filter_info_f h5zget_filter_info_f proc~check_compression_availability->h5zget_filter_info_f h5zfilter_avail_f h5zfilter_avail_f proc~check_compression_availability->h5zfilter_avail_f proc~read_npa->h5fclose_f proc~read_npa->h5gclose_f proc~read_npa->h5open_f proc~read_npa->h5close_f proc~read_npa->proc~h5ltread_dataset_int_scalar_f proc~read_npa->h5ltread_dataset_int_f proc~read_npa->h5fopen_f proc~read_npa->h5gopen_f proc~read_npa->h5ltread_dataset_double_f proc~xyz_to_uvw xyz_to_uvw proc~read_npa->proc~xyz_to_uvw proc~normp normp proc~read_npa->proc~normp proc~read_npa->proc~hit_npa_detector proc~uvw_to_xyz uvw_to_xyz proc~read_npa->proc~uvw_to_xyz h5ltpath_valid_f h5ltpath_valid_f proc~read_npa->h5ltpath_valid_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_npa->h5ltread_dataset_string_f proc~plane_basis plane_basis proc~read_npa->proc~plane_basis proc~npa_mc->proc~get_plasma proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~randu proc~get_indices get_indices proc~npa_mc->proc~get_indices proc~get_fields get_fields proc~npa_mc->proc~get_fields proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~npa_mc->proc~hit_npa_detector proc~pitch_to_vec pitch_to_vec proc~npa_mc->proc~pitch_to_vec proc~gyro_correction gyro_correction proc~npa_mc->proc~gyro_correction proc~npa_mc->proc~uvw_to_xyz proc~dcx->proc~get_nlaunch proc~dcx->proc~store_neutrals proc~dcx->proc~get_plasma proc~dcx->proc~colrad proc~dcx->proc~store_bes_photons proc~dcx->proc~track proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~mc_halo proc~fida_mc->proc~get_plasma proc~fida_mc->proc~colrad proc~fida_mc->proc~track proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~randu proc~fida_mc->proc~get_fields proc~fida_mc->proc~pitch_to_vec proc~fida_mc->proc~gyro_correction proc~fida_mc->proc~uvw_to_xyz proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~fida_f->proc~get_nlaunch proc~fida_f->proc~get_plasma proc~fida_f->proc~colrad proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~fida_f->proc~mc_fastion proc~fida_f->proc~store_fida_photons proc~read_neutrals->h5fclose_f proc~read_neutrals->h5gclose_f proc~read_neutrals->h5open_f proc~read_neutrals->h5close_f proc~read_neutrals->proc~h5ltread_dataset_int_scalar_f proc~read_neutrals->h5fopen_f proc~read_neutrals->h5gopen_f proc~read_neutrals->h5ltread_dataset_double_f proc~write_dcx->h5fclose_f proc~write_dcx->h5open_f proc~write_dcx->h5close_f h5fcreate_f h5fcreate_f proc~write_dcx->h5fcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_dcx->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_dcx->proc~write_beam_grid h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_dcx->h5ltset_attribute_string_f proc~npa_weights->proc~get_beam_cx_prob proc~npa_weights->proc~get_fields proc~npa_weights->proc~normp proc~npa_weights->proc~attenuate proc~npa_weights->proc~hit_npa_detector proc~npa_weights->proc~gyro_correction proc~get_ep_denf get_ep_denf proc~npa_weights->proc~get_ep_denf proc~write_npa_weights write_npa_weights proc~npa_weights->proc~write_npa_weights proc~fida_weights_mc->proc~get_nlaunch proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~colrad proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~get_beam_cx_prob proc~fida_weights_mc->proc~randu proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~pitch_to_vec proc~fida_weights_mc->proc~gyro_correction proc~fida_weights_mc->interface~randind proc~fida_weights_mc->proc~get_ep_denf proc~write_fida_weights write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~write_npa->h5fclose_f proc~write_npa->h5gclose_f proc~write_npa->h5open_f proc~write_npa->h5close_f proc~write_npa->h5fcreate_f proc~write_npa->h5ltmake_dataset_int_f proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_npa->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_npa->h5gcreate_f interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_npa->interface~h5ltmake_compressed_dataset_int_f proc~read_tables->h5fclose_f proc~read_tables->h5open_f proc~read_tables->h5close_f proc~read_tables->proc~h5ltread_dataset_int_scalar_f proc~read_tables->h5fopen_f proc~read_tables->h5ltread_dataset_double_f proc~read_cross read_cross proc~read_tables->proc~read_cross proc~read_rates read_rates proc~read_tables->proc~read_rates proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~colrad proc~fida_weights_los->proc~track proc~fida_weights_los->proc~mc_halo proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~normp proc~calc_perp_vectors calc_perp_vectors proc~fida_weights_los->proc~calc_perp_vectors proc~neut_rates neut_rates proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~pitch_to_vec proc~grid_intersect grid_intersect proc~fida_weights_los->proc~grid_intersect proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~write_fida_weights proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~fida_weights_los->proc~store_fw_photons_at_chan proc~read_distribution->h5fclose_f proc~read_distribution->h5open_f proc~read_distribution->h5close_f proc~read_distribution->proc~h5ltread_dataset_int_scalar_f proc~read_distribution->h5fopen_f proc~read_f read_f proc~read_distribution->proc~read_f proc~read_mc read_mc proc~read_distribution->proc~read_mc proc~write_neutrals->h5fclose_f proc~write_neutrals->h5open_f proc~write_neutrals->h5close_f proc~write_neutrals->h5fcreate_f proc~write_neutrals->h5ltmake_dataset_int_f proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_neutrals->h5ltset_attribute_string_f proc~bremsstrahlung->proc~get_plasma proc~bremsstrahlung->proc~randu proc~bremsstrahlung->proc~normp proc~line_basis line_basis proc~bremsstrahlung->proc~line_basis proc~write_spectra->h5fclose_f proc~write_spectra->h5open_f proc~write_spectra->h5close_f proc~write_spectra->h5fcreate_f proc~write_spectra->h5ltmake_dataset_int_f proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra->h5ltset_attribute_string_f proc~read_beam->h5fclose_f proc~read_beam->h5gclose_f proc~read_beam->h5open_f proc~read_beam->h5close_f proc~read_beam->proc~h5ltread_dataset_int_scalar_f proc~read_beam->h5fopen_f proc~read_beam->h5gopen_f proc~read_beam->h5ltread_dataset_double_f proc~read_beam->proc~tb_zyx proc~read_beam->proc~uvw_to_xyz proc~read_beam->h5ltread_dataset_string_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_beam->proc~h5ltread_dataset_double_scalar_f proc~write_birth_profile->h5fclose_f proc~write_birth_profile->h5open_f proc~write_birth_profile->h5close_f proc~write_birth_profile->proc~xyz_to_uvw proc~write_birth_profile->h5fcreate_f proc~write_birth_profile->h5ltmake_dataset_int_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->proc~write_beam_grid proc~write_birth_profile->h5ltset_attribute_string_f proc~read_chords->h5fclose_f proc~read_chords->h5gclose_f proc~read_chords->h5open_f proc~read_chords->h5close_f proc~read_chords->proc~h5ltread_dataset_int_scalar_f proc~read_chords->h5fopen_f proc~read_chords->h5gopen_f proc~read_chords->h5ltread_dataset_double_f proc~read_chords->proc~track proc~read_chords->proc~randu proc~read_chords->proc~normp proc~read_chords->proc~grid_intersect proc~read_chords->proc~uvw_to_xyz proc~read_chords->h5ltpath_valid_f proc~read_chords->h5ltread_dataset_string_f proc~read_chords->proc~line_basis proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~get_nlaunch->proc~randu proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~get_plasma->interface~interpol_coeff proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~store_bes_photons->proc~get_indices proc~spectrum spectrum proc~store_bes_photons->proc~spectrum proc~store_bes_photons->proc~get_fields proc~track->proc~in_plasma proc~track->proc~get_indices proc~get_beam_cx_prob->proc~mc_halo proc~get_beam_cx_prob->proc~normp proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~in_plasma->proc~xyz_to_uvw interface~interpol interpol proc~in_plasma->interface~interpol proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~lubksb lubksb proc~matinv->proc~lubksb proc~get_rate_matrix->interface~interpol_coeff proc~balance balance proc~eigen->proc~balance proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~elmhes->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~spectrum->proc~normp proc~get_fields->proc~in_plasma proc~get_fields->interface~interpol_coeff proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~get_position proc~get_fields->proc~normp proc~get_fields->proc~calc_perp_vectors proc~calc_perp_vectors->proc~normp proc~neut_rates->interface~interpol_coeff proc~neut_rates->proc~normp proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform proc~mc_fastion->proc~randu proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~pitch_to_vec proc~mc_fastion->proc~gyro_correction proc~mc_fastion->interface~randind proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution proc~store_npa->proc~xyz_to_uvw proc~store_npa->proc~get_fields proc~store_npa->proc~normp proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~attenuate->proc~normp proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~plane_intercept plane_intercept proc~hit_npa_detector->proc~plane_intercept proc~cross_product cross_product proc~gyro_correction->proc~cross_product proc~randind_w_2 randind_w_2 interface~randind->proc~randind_w_2 proc~randind_w_1 randind_w_1 interface~randind->proc~randind_w_1 proc~randind_n randind_n interface~randind->proc~randind_n proc~get_distribution->proc~in_plasma proc~get_distribution->proc~xyz_to_uvw proc~get_distribution->proc~get_position proc~get_distribution->interface~interpol proc~randind_w_2->proc~randu proc~ind2sub ind2sub proc~randind_w_2->proc~ind2sub proc~randind_w_1->proc~randu proc~randind_n->proc~randu proc~mc_nbi->proc~randu proc~mc_nbi->proc~normp proc~mc_nbi->proc~randn proc~mc_nbi->proc~grid_intersect proc~plane_basis->proc~normp proc~plane_basis->proc~cross_product proc~store_fida_photons->proc~get_indices proc~store_fida_photons->proc~spectrum proc~store_fida_photons->proc~get_fields proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~write_beam_grid->h5gclose_f proc~write_beam_grid->proc~xyz_to_uvw proc~write_beam_grid->h5ltmake_dataset_int_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->h5gcreate_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~get_ep_denf->proc~in_plasma proc~get_ep_denf->proc~xyz_to_uvw proc~get_ep_denf->proc~get_position proc~get_ep_denf->interface~interpol proc~write_npa_weights->h5fclose_f proc~write_npa_weights->h5open_f proc~write_npa_weights->h5close_f proc~write_npa_weights->h5fcreate_f proc~write_npa_weights->h5ltmake_dataset_int_f proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_npa_weights->h5ltset_attribute_string_f proc~write_fida_weights->h5fclose_f proc~write_fida_weights->h5open_f proc~write_fida_weights->h5close_f proc~write_fida_weights->h5fcreate_f proc~write_fida_weights->h5ltmake_dataset_int_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights->h5ltset_attribute_string_f proc~store_fw_photons->proc~get_indices proc~store_fw_photons->proc~get_fields proc~store_fw_photons->proc~store_fw_photons_at_chan proc~store_fw_photons_at_chan->proc~spectrum proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f proc~read_cross->proc~h5ltread_dataset_int_scalar_f proc~read_cross->h5ltread_dataset_double_f proc~read_cross->proc~h5ltread_dataset_double_scalar_f proc~read_rates->proc~h5ltread_dataset_int_scalar_f proc~read_rates->h5ltread_dataset_double_f proc~read_rates->proc~normp proc~read_rates->h5ltpath_valid_f proc~read_rates->proc~h5ltread_dataset_double_scalar_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_rates->h5ltget_dataset_ndims_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f proc~read_f->proc~h5ltread_dataset_int_scalar_f proc~read_f->h5ltread_dataset_double_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~read_mc->h5ltread_dataset_int_f proc~read_mc->h5ltread_dataset_double_f proc~read_mc->proc~uvw_to_xyz proc~line_basis->proc~tb_zyx var panprogramfidasimCallsGraph = svgPanZoom('#programfidasimCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=3) :: arg = '' integer, dimension(8) :: time_arr integer, dimension(8) :: time_start integer, dimension(8) :: time_end integer :: i integer :: narg integer :: nthreads integer :: max_threads integer :: hour integer :: minu integer :: sec","tags":""},{"title":"generate_tables – Fortran Program","loc":"program/generate_tables.html","text":"Uses: atomic_tables H5LT HDF5 hdf5_extra omp_lib program~~generate_tables~~UsesGraph program~generate_tables generate_tables omp_lib omp_lib omp_lib->program~generate_tables module~atomic_tables atomic_tables module~atomic_tables->program~generate_tables HDF5 HDF5 HDF5->program~generate_tables HDF5->module~atomic_tables module~hdf5_extra hdf5_extra HDF5->module~hdf5_extra H5LT H5LT H5LT->program~generate_tables H5LT->module~atomic_tables H5LT->module~hdf5_extra module~hdf5_extra->program~generate_tables module~hdf5_extra->module~atomic_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Calls program~~generate_tables~~CallsGraph program~generate_tables generate_tables proc~write_bt_h_h write_bt_H_H program~generate_tables->proc~write_bt_h_h h5fcreate_f h5fcreate_f program~generate_tables->h5fcreate_f omp_get_num_procs omp_get_num_procs program~generate_tables->omp_get_num_procs proc~write_bb_h_e write_bb_H_e program~generate_tables->proc~write_bb_h_e h5gcreate_f h5gcreate_f program~generate_tables->h5gcreate_f proc~write_bb_h_aq write_bb_H_Aq program~generate_tables->proc~write_bb_h_aq h5open_f h5open_f program~generate_tables->h5open_f h5gclose_f h5gclose_f program~generate_tables->h5gclose_f h5fclose_f h5fclose_f program~generate_tables->h5fclose_f h5close_f h5close_f program~generate_tables->h5close_f omp_set_num_threads omp_set_num_threads program~generate_tables->omp_set_num_threads proc~write_bt_h_aq write_bt_H_Aq program~generate_tables->proc~write_bt_h_aq proc~write_bb_h_h write_bb_H_H program~generate_tables->proc~write_bb_h_h proc~check_compression_availability check_compression_availability program~generate_tables->proc~check_compression_availability h5ltset_attribute_string_f h5ltset_attribute_string_f program~generate_tables->h5ltset_attribute_string_f proc~write_einstein write_einstein program~generate_tables->proc~write_einstein proc~write_bt_h_e write_bt_H_e program~generate_tables->proc~write_bt_h_e proc~write_bt_h_h->h5gcreate_f proc~write_bt_h_h->h5gclose_f proc~write_bt_h_h->h5ltset_attribute_string_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_h->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f interface~bt_maxwellian bt_maxwellian proc~write_bt_h_h->interface~bt_maxwellian h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_h->h5ltmake_dataset_double_f proc~write_bb_h_e->h5gcreate_f proc~write_bb_h_e->h5gclose_f proc~write_bb_h_e->h5ltset_attribute_string_f proc~write_bb_h_e->h5ltmake_dataset_int_f proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e->h5ltmake_dataset_double_f proc~e_ioniz e_ioniz proc~write_bb_h_e->proc~e_ioniz proc~e_excit e_excit proc~write_bb_h_e->proc~e_excit proc~write_bb_h_aq->h5gcreate_f proc~write_bb_h_aq->h5gclose_f proc~write_bb_h_aq->h5ltset_attribute_string_f proc~write_bb_h_aq->h5ltmake_dataset_int_f proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq->h5ltmake_dataset_double_f proc~aq_cx Aq_cx proc~write_bb_h_aq->proc~aq_cx proc~aq_excit Aq_excit proc~write_bb_h_aq->proc~aq_excit proc~aq_ioniz Aq_ioniz proc~write_bb_h_aq->proc~aq_ioniz proc~write_bt_h_aq->h5gcreate_f proc~write_bt_h_aq->h5gclose_f proc~write_bt_h_aq->h5ltset_attribute_string_f proc~write_bt_h_aq->h5ltmake_dataset_int_f proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq->interface~bt_maxwellian proc~write_bt_h_aq->h5ltmake_dataset_double_f proc~write_bb_h_h->h5gcreate_f proc~write_bb_h_h->h5gclose_f proc~write_bb_h_h->h5ltset_attribute_string_f proc~write_bb_h_h->h5ltmake_dataset_int_f proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h->h5ltmake_dataset_double_f proc~p_ioniz p_ioniz proc~write_bb_h_h->proc~p_ioniz proc~p_cx p_cx proc~write_bb_h_h->proc~p_cx proc~p_excit p_excit proc~write_bb_h_h->proc~p_excit proc~check_compression_availability->h5open_f proc~check_compression_availability->h5close_f h5zget_filter_info_f h5zget_filter_info_f proc~check_compression_availability->h5zget_filter_info_f h5zfilter_avail_f h5zfilter_avail_f proc~check_compression_availability->h5zfilter_avail_f proc~write_einstein->h5gcreate_f proc~write_einstein->h5gclose_f proc~write_einstein->h5ltset_attribute_string_f proc~write_einstein->h5ltmake_dataset_int_f proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e->h5gcreate_f proc~write_bt_h_e->h5gclose_f proc~write_bt_h_e->h5ltset_attribute_string_f proc~write_bt_h_e->h5ltmake_dataset_int_f proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e->interface~bt_maxwellian proc~write_bt_h_e->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule proc~e_ioniz_n e_ioniz_n proc~e_ioniz->proc~e_ioniz_n proc~e_excit_n e_excit_n proc~e_excit->proc~e_excit_n proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~aq_cx_n Aq_cx_n proc~aq_cx->proc~aq_cx_n proc~aq_excit_n Aq_excit_n proc~aq_excit->proc~aq_excit_n proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz->proc~aq_ioniz_n proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~p_ioniz_n p_ioniz_n proc~p_ioniz->proc~p_ioniz_n proc~p_cx_n p_cx_n proc~p_cx->proc~p_cx_n proc~p_excit_n p_excit_n proc~p_excit->proc~p_excit_n proc~p_ioniz_1_omullane p_ioniz_1_omullane proc~p_ioniz_n->proc~p_ioniz_1_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_4_janev p_cx_4_janev proc~p_cx_janev->proc~p_cx_4_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev var panprogramgenerate_tablesCallsGraph = svgPanZoom('#programgenerate_tablesCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=200) :: namelist_file character(len=3) :: arg character(len=200) :: tables_file = '' integer :: n_max integer :: m_max integer, dimension(8) :: time_arr integer, dimension(8) :: time_start integer, dimension(8) :: time_end integer :: hour integer :: minu integer :: sec integer :: argc integer :: max_threads integer :: nthreads integer(kind=HID_T) :: fid integer(kind=HID_T) :: gid integer :: error logical :: exis","tags":""}]}