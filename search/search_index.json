{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 This document describes how to use the collection of matlab functions and scripts, collectively called the Tokamak System toolbox or simply TokSys, which provides tools for tokamak system modeling and simulation, model validation, data analysis, and control design. Help If any description is incorrect or confusing, please contact Mike Walker at walker@fusion.gat.com . This document focuses on the description of those portions of TokSys that are applicable to plasma shape and position control design, testing, and data analysis because the methods for those applications have been largely standardized. However, TokSys also contains a number of tools relevant for other control development and analysis tasks, both general (e.g. data access and signal processing) and specific (e.g., for control of NTMs, RWMs, ONFR, etc.). All models produced using the tools described in this document use the convention that a positive toroidal current is a counter-clockwise current flow when viewed from above. Conductor voltages V are assumed connected such that V>0 causes coil currents Icoil to increase (in the absence of plasma). All data contained in the models described in this document use MKS units by default, i.e. Amps for current, Webers for flux, and Tesla for magnetic field. However, there is an option provided in some of the model calculation tools to produce data objects with currents in Mega-Amp-turns. Any talks or publications containing results derived from the use of the TokSys toolset should contain an attribution for GA TokSys. Linearized plasma models for boundary control development \u00b6 The model building environment consists of matlab functions and scripts to perform the following major functions: - Construct tokamak data objects such as conductor resistances, mutual inductances, and other Green functions, which are all defined by the device geometry in the absence of plasma. - Read in a plasma equilibrium around which a linearized model will be generated. - Combine the tokamak information in (a) with the specified plasma in (b) to generate the linearized model (See equation 1). - Compare the derived linearized model with experimentally measured data, as part of a model validation process. The TokSys toolbox has been used to derive models for the ITER, EAST, KSTAR, NSTX, MAST-U, DIII-D, SST-1, and Pegasus tokamaks, and the proposed Fusion Development Facility (FDF), among others. The developed models have been validated on DIII-D and NSTX and have been used to develop plasma controllers on DIII-D, ITER, EAST, KSTAR and Pegasus. Although even unvalidated or partially-validated models have proven very useful for developing and testing control software, use in a model-based control design requires that a real model-validation effort must be undertaken and completed before such controllers can be used with confidence in controlling plasmas. Model validation must include testing of individual component models, not just the final integrated model. Large integrated models are virtually never correct the first time used (or the 2nd, 3rd, ...) and typically cannot be made correct without identifying the source(s) of model discrepancy. Identifying sources of model discrepancy requires investigating individual components of the model. The development and use of a common toolset for multiple devices has significant advantages beyond the obvious issue of software re-use. In all cases, the models generated are first principles physics models, constructed without any \"tuning\" or \"fudge factors\", except for use of direct measurements of certain quantities such as coil resistance or inductance. Validation of this type of model versus experimental data on existing devices provides confidence in both the modeling approach and the model implementation when using the tools to extrapolate to model generation for devices that do not yet exist. Section 3 describes the modeling approach used by TokSys. Section 4 provides an overview of the organization and structure of the many modeling, analysis, and design functions. Section 5 provides instructions for how to make the Toksys tools available in your Matlab session. Section 6 provides a high-level summary list of device-independent modeling and analysis functions that are available when the Toksys tools are available in your session. Section 7 describes the process of constructing plasma response models, outlined in steps (a) through (c) above. Section 8 describes how the core set of generic modeling tools are used and expanded upon for modeling specific tokamaks and plasmas. Section 9 describes the process used for validation of TokSys models and the TokSys tools available to support this process. Section 10 describes a methodology employed to connect simulations constructed using TokSys models with a version of the real-time plasma control system (PCS), for those devices whose PCS is derived from the DIII-D PCS. Section 11 provides further details for some of the modeling tools. This section will be expanded in future versions of this document. Plasma Control Modeling Approach \u00b6 The set of modeling tools in this toolbox automate the majority of the process of generating dynamic models for the tokamak and plasma poloidal field systems involved in plasma shape, position, and plasma current control. Key products of the model development process are linear models of the form \\[\\begin{equation} \\begin{aligned} \\dot{I} &= \\mathbf{A}I + \\mathbf{B}v + \\mathbf{F}w \\\\\\ y &= \\mathbf{C}I + \\mathbf{D}v + \\mathbf{H}w \\end{aligned} \\label{eq:dynamics} \\end{equation}\\] that represent the dynamics of evolution of currents in toroidal conductors (control coils, passive structure, and plasma) within the tokamak and include the effect of the nonstationary plasma on these dynamics. Here, \\(I\\) represents the toroidal currents in coils, passive conductors, and the bulk plasma, \\(v\\) represents coil power supply voltages, \\(y\\) represents magnetic measurements such as flux, field, or current, and \\(w\\) represents disturbance inputs which can be used to model the effect of changes in \\(\\beta_p\\) , \\(l_i\\) , or of noise. The matrices \\(\\mathbf{A} = -(\\mathbf{M}^*)^{-1}\\mathbf{R}\\) and \\(\\mathbf{B} = (\\mathbf{M}^*)^{-1}\\mathbf{V}\\) are computed from the conductor resistance matrix \\(\\mathbf{R}\\) , a plasma-modified mutual inductance matrix \\(\\mathbf{M}^*\\) (see [2]), and a matrix \\(\\mathbf{V}\\) that maps power supply source voltages into voltages applied to control coils. The matrix \\(\\mathbf{C}\\) is given primarily by the Green functions from currents to magnetic diagnostics, and \\(\\mathbf{D}\\) is usually 0. We refer to the first equation in \\(\\eqref{eq:dynamics}\\) as the \"dynamics equation\" because it describes how the dynamical system defined by the collection of toroidal conductor and plasma currents evolves. We refer to the second equation in \\(\\eqref{eq:dynamics}\\) as the \"output equation\" because it defines how the multiple magnetic diagnostics (B-probes, flux loops, coil and vessel Rogowskis, etc) depend on the toroidal currents and input voltages. The most basic and most mature plasma model construction method we use is based on the rigid plasma model approach described in [2]. Alternatives to this approach, including a nonrigid linear model [3] or nonlinear models [4] have also been integrated in this environment. Use of the nonrigid model requires only small variations from use of the rigid model, so we will confine the discussion in this document primarily to rigid plasma model development. Note Use of the nonlinear models will not be described here. TokSys Toolbox File Structure \u00b6 The TokSys toolbox consists of a large collection of matlab functions organized into separate Linux directories according to similar functionality. There are three types of matlab files used for modeling: TokSys Matlab functions and models, generically applicable to any tokamak. Device-specific matlab functions and models, which invoke the TokSys modeling tools. General Matlab functions, which are invoked by both of the above. A TokSys installation consists of all three of these function sets plus additional tools for other related modeling and analysis purposes. The directory structure for such an installation is illustrated below. Figure 1: Illustration of TokSys installation directory structure The TokSys general modeling functions and generic matlab functions are located under the matlab path in the above figure. Device-specific functions are located under the tokamaks path. In addition to these two sets of directories, the TokSys toolset sits \"on top\" of the ITER PCSSP (Plasma Control System Simulation Platform) toolset, whose directories are structured similarly (see below). Figure 2: Illustration of PCSSP installation directory structure Codes and models specific to ITER are maintained as part of PCSSP, using the same separation between generally-applicable and device-specific functions and models. The structure shown in the figures above represent the installation at DIII-D. Most installations will have only one of the device directories under the \"tokamaks\" branch of Toksys, i.e. corresponding to the device local to where the toolset is installed. TokSys follows the usual matlab convention for providing on-line documentation to users in the form of function header documentation and Contents.m files. Each subdirectory in TokSys contains a Contents.m file that provides a summary of functions available in that directory. This summary of functions is available at the matlab command line by typing \"help\" followed by the directory name. Each function or script contains a standard format header, which describes how to use the function. This description is available at the matlab command line by typing \"help\" followed by the function name. Note These tools can serve as the foundation for the construction of your own specialized set of functions for tokamak modeling. Source code for all functions is provided and therefore can be modified locally. Warning DO NOT modify the source files in the installed area. Instead, make a copy of the source file in a separate directory, modify it there, then add that directory name to the matlab path in front of the TokSys directories. Matlab executes the first version of a file that it finds in its search path. TokSys Generic Function Directories \u00b6 We provide here a list of the subdirectories of the matlab directory shown in Figure 1. These subdirectories are intended to contain matlab scripts and functions that are applicable to any of the tokamak models we support and, in many cases, generally applicable to any tokamak. While this objective has been essentially reached for most sub-directories, there are a few of the functional areas listed below that are still evolving. 3d Three-dimensional electromagnetic analysis calculations breakdown Generic plasma breakdown/rampup calculations circuit_models Conductor circuit modeling functions comm_tbx Public domain Communications Toolbox (not well-tested) design Control design tools dcontrol Public domain Digital Control toolbox (not well-tested) dina Functions related to DINA plasma simulation code (not maintained) dmp Matlab DMP tools efit Functions related to EFIT reconstruction code. GAcomm GA-developed communication functions (mostly Ultra-Wideband) GAcontrol GA-developed control design utility functions. GAgraphics GA-developed graphics functions GAsignal GA-developed signal processing functions geom Tokamak geometry manipulation tools jfit Functions related to JFIT Magnetics Fitting Code mag Magnetics Calculation Tools math Math calculations mdsplus MDSplus data extraction and manipulation functions ntm NTM control functions PCS Generic functions for interaction with PCS. Applicable to any installation of the DIII-D PCS. plasma_models Functions for generating plasma (or plasma+device) models. plresp (NOT Generic yet) pubgraphics Public domain graphics functions. RWM Functions for developing or analyzing RWM control (not currently available) regression Functions for regression simserver Functions for creating simserver simulations (to connect with PCS). teq Functions for interacting with Corsica and TEQ. (NOT Generic yet) tok_models Functions for generating plasma (or plasma+device) models toksim Toksim library and support functions utilities Utility functions validation Functions for model validation","title":"Overview"},{"location":"#overview","text":"This document describes how to use the collection of matlab functions and scripts, collectively called the Tokamak System toolbox or simply TokSys, which provides tools for tokamak system modeling and simulation, model validation, data analysis, and control design. Help If any description is incorrect or confusing, please contact Mike Walker at walker@fusion.gat.com . This document focuses on the description of those portions of TokSys that are applicable to plasma shape and position control design, testing, and data analysis because the methods for those applications have been largely standardized. However, TokSys also contains a number of tools relevant for other control development and analysis tasks, both general (e.g. data access and signal processing) and specific (e.g., for control of NTMs, RWMs, ONFR, etc.). All models produced using the tools described in this document use the convention that a positive toroidal current is a counter-clockwise current flow when viewed from above. Conductor voltages V are assumed connected such that V>0 causes coil currents Icoil to increase (in the absence of plasma). All data contained in the models described in this document use MKS units by default, i.e. Amps for current, Webers for flux, and Tesla for magnetic field. However, there is an option provided in some of the model calculation tools to produce data objects with currents in Mega-Amp-turns. Any talks or publications containing results derived from the use of the TokSys toolset should contain an attribution for GA TokSys.","title":"Overview"},{"location":"#linearized-plasma-models-for-boundary-control-development","text":"The model building environment consists of matlab functions and scripts to perform the following major functions: - Construct tokamak data objects such as conductor resistances, mutual inductances, and other Green functions, which are all defined by the device geometry in the absence of plasma. - Read in a plasma equilibrium around which a linearized model will be generated. - Combine the tokamak information in (a) with the specified plasma in (b) to generate the linearized model (See equation 1). - Compare the derived linearized model with experimentally measured data, as part of a model validation process. The TokSys toolbox has been used to derive models for the ITER, EAST, KSTAR, NSTX, MAST-U, DIII-D, SST-1, and Pegasus tokamaks, and the proposed Fusion Development Facility (FDF), among others. The developed models have been validated on DIII-D and NSTX and have been used to develop plasma controllers on DIII-D, ITER, EAST, KSTAR and Pegasus. Although even unvalidated or partially-validated models have proven very useful for developing and testing control software, use in a model-based control design requires that a real model-validation effort must be undertaken and completed before such controllers can be used with confidence in controlling plasmas. Model validation must include testing of individual component models, not just the final integrated model. Large integrated models are virtually never correct the first time used (or the 2nd, 3rd, ...) and typically cannot be made correct without identifying the source(s) of model discrepancy. Identifying sources of model discrepancy requires investigating individual components of the model. The development and use of a common toolset for multiple devices has significant advantages beyond the obvious issue of software re-use. In all cases, the models generated are first principles physics models, constructed without any \"tuning\" or \"fudge factors\", except for use of direct measurements of certain quantities such as coil resistance or inductance. Validation of this type of model versus experimental data on existing devices provides confidence in both the modeling approach and the model implementation when using the tools to extrapolate to model generation for devices that do not yet exist. Section 3 describes the modeling approach used by TokSys. Section 4 provides an overview of the organization and structure of the many modeling, analysis, and design functions. Section 5 provides instructions for how to make the Toksys tools available in your Matlab session. Section 6 provides a high-level summary list of device-independent modeling and analysis functions that are available when the Toksys tools are available in your session. Section 7 describes the process of constructing plasma response models, outlined in steps (a) through (c) above. Section 8 describes how the core set of generic modeling tools are used and expanded upon for modeling specific tokamaks and plasmas. Section 9 describes the process used for validation of TokSys models and the TokSys tools available to support this process. Section 10 describes a methodology employed to connect simulations constructed using TokSys models with a version of the real-time plasma control system (PCS), for those devices whose PCS is derived from the DIII-D PCS. Section 11 provides further details for some of the modeling tools. This section will be expanded in future versions of this document.","title":"Linearized plasma models for boundary control development"},{"location":"#plasma-control-modeling-approach","text":"The set of modeling tools in this toolbox automate the majority of the process of generating dynamic models for the tokamak and plasma poloidal field systems involved in plasma shape, position, and plasma current control. Key products of the model development process are linear models of the form \\[\\begin{equation} \\begin{aligned} \\dot{I} &= \\mathbf{A}I + \\mathbf{B}v + \\mathbf{F}w \\\\\\ y &= \\mathbf{C}I + \\mathbf{D}v + \\mathbf{H}w \\end{aligned} \\label{eq:dynamics} \\end{equation}\\] that represent the dynamics of evolution of currents in toroidal conductors (control coils, passive structure, and plasma) within the tokamak and include the effect of the nonstationary plasma on these dynamics. Here, \\(I\\) represents the toroidal currents in coils, passive conductors, and the bulk plasma, \\(v\\) represents coil power supply voltages, \\(y\\) represents magnetic measurements such as flux, field, or current, and \\(w\\) represents disturbance inputs which can be used to model the effect of changes in \\(\\beta_p\\) , \\(l_i\\) , or of noise. The matrices \\(\\mathbf{A} = -(\\mathbf{M}^*)^{-1}\\mathbf{R}\\) and \\(\\mathbf{B} = (\\mathbf{M}^*)^{-1}\\mathbf{V}\\) are computed from the conductor resistance matrix \\(\\mathbf{R}\\) , a plasma-modified mutual inductance matrix \\(\\mathbf{M}^*\\) (see [2]), and a matrix \\(\\mathbf{V}\\) that maps power supply source voltages into voltages applied to control coils. The matrix \\(\\mathbf{C}\\) is given primarily by the Green functions from currents to magnetic diagnostics, and \\(\\mathbf{D}\\) is usually 0. We refer to the first equation in \\(\\eqref{eq:dynamics}\\) as the \"dynamics equation\" because it describes how the dynamical system defined by the collection of toroidal conductor and plasma currents evolves. We refer to the second equation in \\(\\eqref{eq:dynamics}\\) as the \"output equation\" because it defines how the multiple magnetic diagnostics (B-probes, flux loops, coil and vessel Rogowskis, etc) depend on the toroidal currents and input voltages. The most basic and most mature plasma model construction method we use is based on the rigid plasma model approach described in [2]. Alternatives to this approach, including a nonrigid linear model [3] or nonlinear models [4] have also been integrated in this environment. Use of the nonrigid model requires only small variations from use of the rigid model, so we will confine the discussion in this document primarily to rigid plasma model development. Note Use of the nonlinear models will not be described here.","title":"Plasma Control Modeling Approach"},{"location":"#toksys-toolbox-file-structure","text":"The TokSys toolbox consists of a large collection of matlab functions organized into separate Linux directories according to similar functionality. There are three types of matlab files used for modeling: TokSys Matlab functions and models, generically applicable to any tokamak. Device-specific matlab functions and models, which invoke the TokSys modeling tools. General Matlab functions, which are invoked by both of the above. A TokSys installation consists of all three of these function sets plus additional tools for other related modeling and analysis purposes. The directory structure for such an installation is illustrated below. Figure 1: Illustration of TokSys installation directory structure The TokSys general modeling functions and generic matlab functions are located under the matlab path in the above figure. Device-specific functions are located under the tokamaks path. In addition to these two sets of directories, the TokSys toolset sits \"on top\" of the ITER PCSSP (Plasma Control System Simulation Platform) toolset, whose directories are structured similarly (see below). Figure 2: Illustration of PCSSP installation directory structure Codes and models specific to ITER are maintained as part of PCSSP, using the same separation between generally-applicable and device-specific functions and models. The structure shown in the figures above represent the installation at DIII-D. Most installations will have only one of the device directories under the \"tokamaks\" branch of Toksys, i.e. corresponding to the device local to where the toolset is installed. TokSys follows the usual matlab convention for providing on-line documentation to users in the form of function header documentation and Contents.m files. Each subdirectory in TokSys contains a Contents.m file that provides a summary of functions available in that directory. This summary of functions is available at the matlab command line by typing \"help\" followed by the directory name. Each function or script contains a standard format header, which describes how to use the function. This description is available at the matlab command line by typing \"help\" followed by the function name. Note These tools can serve as the foundation for the construction of your own specialized set of functions for tokamak modeling. Source code for all functions is provided and therefore can be modified locally. Warning DO NOT modify the source files in the installed area. Instead, make a copy of the source file in a separate directory, modify it there, then add that directory name to the matlab path in front of the TokSys directories. Matlab executes the first version of a file that it finds in its search path.","title":"TokSys Toolbox File Structure"},{"location":"#toksys-generic-function-directories","text":"We provide here a list of the subdirectories of the matlab directory shown in Figure 1. These subdirectories are intended to contain matlab scripts and functions that are applicable to any of the tokamak models we support and, in many cases, generally applicable to any tokamak. While this objective has been essentially reached for most sub-directories, there are a few of the functional areas listed below that are still evolving. 3d Three-dimensional electromagnetic analysis calculations breakdown Generic plasma breakdown/rampup calculations circuit_models Conductor circuit modeling functions comm_tbx Public domain Communications Toolbox (not well-tested) design Control design tools dcontrol Public domain Digital Control toolbox (not well-tested) dina Functions related to DINA plasma simulation code (not maintained) dmp Matlab DMP tools efit Functions related to EFIT reconstruction code. GAcomm GA-developed communication functions (mostly Ultra-Wideband) GAcontrol GA-developed control design utility functions. GAgraphics GA-developed graphics functions GAsignal GA-developed signal processing functions geom Tokamak geometry manipulation tools jfit Functions related to JFIT Magnetics Fitting Code mag Magnetics Calculation Tools math Math calculations mdsplus MDSplus data extraction and manipulation functions ntm NTM control functions PCS Generic functions for interaction with PCS. Applicable to any installation of the DIII-D PCS. plasma_models Functions for generating plasma (or plasma+device) models. plresp (NOT Generic yet) pubgraphics Public domain graphics functions. RWM Functions for developing or analyzing RWM control (not currently available) regression Functions for regression simserver Functions for creating simserver simulations (to connect with PCS). teq Functions for interacting with Corsica and TEQ. (NOT Generic yet) tok_models Functions for generating plasma (or plasma+device) models toksim Toksim library and support functions utilities Utility functions validation Functions for model validation","title":"TokSys Generic Function Directories"},{"location":"02_install/","text":"Installation \u00b6 This section describes how to set up the Toksys/PCSSP tools for use by your Matlab session. Many users will want to use only the installed versions of these toolboxes. Standard installation of Toksys/PCSSP at sites outside of GA is done by Brian Sammuli (sammuli@fusion.gat.com) in coordination with system administrators at each installation site. However, if you want to be able to make changes to existing Toksys functions or add new functions and submit the modified or new functions to the Toksys code base, you will need to use a version of Toksys cloned from the Git repository. Using previously installed Toksys and PCSSP \u00b6 Add the directory <toksys_root>/startups , where <toksys_root> is the installed TokSys root directory, to the linux environment variable MATLABPATH . For example, at D3D the command would be bash export MATLABPATH = /fusion/projects/codes/toksys/GAtools: $MATLABPATH tsch setenv MATLABPATH /fusion/projects/codes/toksys/GAtools: $MATLABPATH To start using TokSys start Matlab and run >> toksys_startup Note On iris and saturn at D3D, the command module load toksys steps up the environmental variables for you, but requires that you run module load matlab first. Using custom version of Toksys (and of PCSSP if desired) \u00b6 The easiest method is to clone it into the TokSys directory tree, e.g.: git clone git@odin.gat.com:TOKSYS/toksys.git cd toksys git clone ssh://git@git.iter.org/pcs/pcssp.git makeit The final makeit command performs the actions necessary to compile all S-functions in the Toksys and PCSSP directory trees. Alternatively, the PCSSP directory can be in a different location (either installed or cloned), in which case you can simply provide a link to it in the TokSys directory structure, e.g: git clone git@odin.gat.com:TOKSYS/toksys.git cd toksys ln -s <pcssp_root> pcssp makeit where <pcssp_root> is the root directory of the cloned (or installed) PCSSP directory tree The instructions above provide the necessary steps to make the Toksys/PCSSP tool sets usable and to add their locations to the search path in your Matlab session. If, in addition, you want to use these tools to perform modeling, control design, or analysis for a particular device, you will also need to type (in Matlab): >> < device_name > _startup where represents the name of the device, e.g. >> d3d_startup >> kstar_startup It is often convenient make provision for the default (generic) Matlab to always be in the search path when starting up Matlab. To enable this, create a file startup.m in your directory ~/matlab containing the line toksys_startup","title":"Installation"},{"location":"02_install/#installation","text":"This section describes how to set up the Toksys/PCSSP tools for use by your Matlab session. Many users will want to use only the installed versions of these toolboxes. Standard installation of Toksys/PCSSP at sites outside of GA is done by Brian Sammuli (sammuli@fusion.gat.com) in coordination with system administrators at each installation site. However, if you want to be able to make changes to existing Toksys functions or add new functions and submit the modified or new functions to the Toksys code base, you will need to use a version of Toksys cloned from the Git repository.","title":"Installation"},{"location":"02_install/#using-previously-installed-toksys-and-pcssp","text":"Add the directory <toksys_root>/startups , where <toksys_root> is the installed TokSys root directory, to the linux environment variable MATLABPATH . For example, at D3D the command would be bash export MATLABPATH = /fusion/projects/codes/toksys/GAtools: $MATLABPATH tsch setenv MATLABPATH /fusion/projects/codes/toksys/GAtools: $MATLABPATH To start using TokSys start Matlab and run >> toksys_startup Note On iris and saturn at D3D, the command module load toksys steps up the environmental variables for you, but requires that you run module load matlab first.","title":"Using previously installed Toksys and PCSSP"},{"location":"02_install/#using-custom-version-of-toksys-and-of-pcssp-if-desired","text":"The easiest method is to clone it into the TokSys directory tree, e.g.: git clone git@odin.gat.com:TOKSYS/toksys.git cd toksys git clone ssh://git@git.iter.org/pcs/pcssp.git makeit The final makeit command performs the actions necessary to compile all S-functions in the Toksys and PCSSP directory trees. Alternatively, the PCSSP directory can be in a different location (either installed or cloned), in which case you can simply provide a link to it in the TokSys directory structure, e.g: git clone git@odin.gat.com:TOKSYS/toksys.git cd toksys ln -s <pcssp_root> pcssp makeit where <pcssp_root> is the root directory of the cloned (or installed) PCSSP directory tree The instructions above provide the necessary steps to make the Toksys/PCSSP tool sets usable and to add their locations to the search path in your Matlab session. If, in addition, you want to use these tools to perform modeling, control design, or analysis for a particular device, you will also need to type (in Matlab): >> < device_name > _startup where represents the name of the device, e.g. >> d3d_startup >> kstar_startup It is often convenient make provision for the default (generic) Matlab to always be in the search path when starting up Matlab. To enable this, create a file startup.m in your directory ~/matlab containing the line toksys_startup","title":"Using custom version of Toksys (and of PCSSP if desired)"},{"location":"function-guide/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Available matlab tool directories: 3d - 3 dimensional magnetics modeling tools breakdown - breakdown analysis tools check_pcssp_conflicts - Check for name conflicts with PCSSP circuit_models - Tools for modeling of tokamak (non-plasma) systems. comm_tbx - tools for digital communications design/analysis. design - Controller design support functions dmp - Tools for exporting to DIII-D DMP hdf5 format. equil - General equilibrium: efit - EFIT tools GAcontrol - Tools for poloidal shape control design. GAgraphics - GA specific graphics routines GAsignal - Tools for signal processing. geom - geometry calculations gs - Grad-Shafranov equilibrium codes jfit - JFIT tools mag - Electromagnetic calculations math - General Math functions mdsplus - Tools to extract/manipulate mdsplus data. ntm - Miscellaneous tools for ntm analysis PCS - (D3D-type) PCS specific routines plasma_models - Tools for modeling of plasma systems (mostly obsolete) plresp - plasma response pubgraphics - Public domain graphics tools. (needs to be linked) regression - Regression testing tools RWM - RWM control analysis and design utility functions. simserver - Simserver utility functions. teq - TEQ tools tok_models - tokamak (+ plasma) models toksim - Toksim models. utilities - General utility functions. validation - Model validation routines","title":"Contents.m"},{"location":"function-guide/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/Contents_m/#basic-information","text":"Available matlab tool directories: 3d - 3 dimensional magnetics modeling tools breakdown - breakdown analysis tools check_pcssp_conflicts - Check for name conflicts with PCSSP circuit_models - Tools for modeling of tokamak (non-plasma) systems. comm_tbx - tools for digital communications design/analysis. design - Controller design support functions dmp - Tools for exporting to DIII-D DMP hdf5 format. equil - General equilibrium: efit - EFIT tools GAcontrol - Tools for poloidal shape control design. GAgraphics - GA specific graphics routines GAsignal - Tools for signal processing. geom - geometry calculations gs - Grad-Shafranov equilibrium codes jfit - JFIT tools mag - Electromagnetic calculations math - General Math functions mdsplus - Tools to extract/manipulate mdsplus data. ntm - Miscellaneous tools for ntm analysis PCS - (D3D-type) PCS specific routines plasma_models - Tools for modeling of plasma systems (mostly obsolete) plresp - plasma response pubgraphics - Public domain graphics tools. (needs to be linked) regression - Regression testing tools RWM - RWM control analysis and design utility functions. simserver - Simserver utility functions. teq - TEQ tools tok_models - tokamak (+ plasma) models toksim - Toksim models. utilities - General utility functions. validation - Model validation routines","title":"Basic Information"},{"location":"function-guide/check_pcssp_conflicts_m/","text":"check_pcssp_conflicts.m \u00b6 Basic Information \u00b6 SYNTAX: common_names = check_pcssp_conflicts() PURPOSE: Check for name conflicts with PCSSP. INPUT: none (reads GATOOLS_ROOT and PCSSP_root environment variables) OUTPUT: common_names = cell_array containing list of names in both","title":"check_pcssp_conflicts.m"},{"location":"function-guide/check_pcssp_conflicts_m/#check_pcssp_conflictsm","text":"","title":"check_pcssp_conflicts.m"},{"location":"function-guide/check_pcssp_conflicts_m/#basic-information","text":"SYNTAX: common_names = check_pcssp_conflicts() PURPOSE: Check for name conflicts with PCSSP. INPUT: none (reads GATOOLS_ROOT and PCSSP_root environment variables) OUTPUT: common_names = cell_array containing list of names in both","title":"Basic Information"},{"location":"function-guide/licenses_needed_m/","text":"licenses_needed.m \u00b6 Basic Information \u00b6 SYNTAX: plist = licenses_needed(root_dir) PURPOSE: Determine all matlab/simulink products that are needed to support the hierarchy of tools under root_dir. (This function takes a long time to run.) INPUT: root_dir = root directory of files to evaluate OUTPUT: plist = matlab/simulink product list","title":"licenses_needed.m"},{"location":"function-guide/licenses_needed_m/#licenses_neededm","text":"","title":"licenses_needed.m"},{"location":"function-guide/licenses_needed_m/#basic-information","text":"SYNTAX: plist = licenses_needed(root_dir) PURPOSE: Determine all matlab/simulink products that are needed to support the hierarchy of tools under root_dir. (This function takes a long time to run.) INPUT: root_dir = root directory of files to evaluate OUTPUT: plist = matlab/simulink product list","title":"Basic Information"},{"location":"function-guide/startup_m/","text":"startup.m \u00b6 Basic Information \u00b6 generic_startup.m: Generic pathnames that can be used in startup.m files to point to utility functions. Alternatively, can execute this file to add all paths. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE: When creating a new \"standard\" function, make sure to use this ENTIRE file as your startup.m file, and do an \"exist\" on the function name you want to create to check that the name is not already in use. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!","title":"startup.m"},{"location":"function-guide/startup_m/#startupm","text":"","title":"startup.m"},{"location":"function-guide/startup_m/#basic-information","text":"generic_startup.m: Generic pathnames that can be used in startup.m files to point to utility functions. Alternatively, can execute this file to add all paths. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE: When creating a new \"standard\" function, make sure to use this ENTIRE file as your startup.m file, and do an \"exist\" on the function name you want to create to check that the name is not already in use. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!","title":"Basic Information"},{"location":"function-guide/3d/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 matlab/3d: 3-D EM Analysis Tools calc_Gpx - calc Green function matrix between 3D conductors and pts calc_Mxx - Calc self inductance of 3D conductors calc_Mxy - Calc mutual inductance matrix between 3D conductors expand_fils - Expand filaments in minor radial position fil_length - Calculate length of filaments fils2paths - Convert fils to paths green_paths2pts - make_hel_fils - Construct helical filament sets make_rec_fils - Construct corner pts and filaments for picture frame coils make_tor_fils - Construct toroidal filament sets make_wallmesh - Generate filament array for mesh representation mut_fil_fil - Calculate the mutual inductance between two filament sets mut_paths2paths - mut_rec2rec - calc mutual between two rectangular picture frame coils plot_filament - plot_fils - Plot filaments self_barDH - Calculate the self inductance of a set of bars self_filDH - Calculate the self inductance of a set of filaments self_paths - test_mvv -","title":"Contents.m"},{"location":"function-guide/3d/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/3d/Contents_m/#basic-information","text":"matlab/3d: 3-D EM Analysis Tools calc_Gpx - calc Green function matrix between 3D conductors and pts calc_Mxx - Calc self inductance of 3D conductors calc_Mxy - Calc mutual inductance matrix between 3D conductors expand_fils - Expand filaments in minor radial position fil_length - Calculate length of filaments fils2paths - Convert fils to paths green_paths2pts - make_hel_fils - Construct helical filament sets make_rec_fils - Construct corner pts and filaments for picture frame coils make_tor_fils - Construct toroidal filament sets make_wallmesh - Generate filament array for mesh representation mut_fil_fil - Calculate the mutual inductance between two filament sets mut_paths2paths - mut_rec2rec - calc mutual between two rectangular picture frame coils plot_filament - plot_fils - Plot filaments self_barDH - Calculate the self inductance of a set of bars self_filDH - Calculate the self inductance of a set of filaments self_paths - test_mvv -","title":"Basic Information"},{"location":"function-guide/3d/calcGpx0529a_m/","text":"calcGpx0529a.m \u00b6 Basic Information \u00b6 SYNTAX: [Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m)","title":"calcGpx0529a.m"},{"location":"function-guide/3d/calcGpx0529a_m/#calcgpx0529am","text":"","title":"calcGpx0529a.m"},{"location":"function-guide/3d/calcGpx0529a_m/#basic-information","text":"SYNTAX: [Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m)","title":"Basic Information"},{"location":"function-guide/3d/calc_GpxX_m/","text":"calc_GpxX.m \u00b6 Basic Information \u00b6 SYNTAX: [Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m)","title":"calc_GpxX.m"},{"location":"function-guide/3d/calc_GpxX_m/#calc_gpxxm","text":"","title":"calc_GpxX.m"},{"location":"function-guide/3d/calc_GpxX_m/#basic-information","text":"SYNTAX: [Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m)","title":"Basic Information"},{"location":"function-guide/3d/calc_Gpx_m/","text":"calc_Gpx.m \u00b6 Basic Information \u00b6 SYNTAX: [Gpx,Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpx = Green function matrix for total poloidal Bp [T/MA] Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m)","title":"calc_Gpx.m"},{"location":"function-guide/3d/calc_Gpx_m/#calc_gpxm","text":"","title":"calc_Gpx.m"},{"location":"function-guide/3d/calc_Gpx_m/#basic-information","text":"SYNTAX: [Gpx,Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpx = Green function matrix for total poloidal Bp [T/MA] Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m)","title":"Basic Information"},{"location":"function-guide/3d/calc_Mxx_m/","text":"calc_Mxx.m \u00b6 Basic Information \u00b6 SYNTAX: Mxx = calc_Mxx(XXpaths,XXfracp,as) PURPOSE: Calc self inductance of conductor X whose paths are described by cell array XXpaths (see mut_paths2paths) INPUTS: as = scalar or vector of radii of paths in conductor X OUTPUTS: Mxx = self inductance of conductor X [uH] RESTRICTIONS: X Paths cell arrays must contain filament matrices in FILC convention... METHOD: Uses mut_paths2paths.m","title":"calc_Mxx.m"},{"location":"function-guide/3d/calc_Mxx_m/#calc_mxxm","text":"","title":"calc_Mxx.m"},{"location":"function-guide/3d/calc_Mxx_m/#basic-information","text":"SYNTAX: Mxx = calc_Mxx(XXpaths,XXfracp,as) PURPOSE: Calc self inductance of conductor X whose paths are described by cell array XXpaths (see mut_paths2paths) INPUTS: as = scalar or vector of radii of paths in conductor X OUTPUTS: Mxx = self inductance of conductor X [uH] RESTRICTIONS: X Paths cell arrays must contain filament matrices in FILC convention... METHOD: Uses mut_paths2paths.m","title":"Basic Information"},{"location":"function-guide/3d/calc_Mxy_m/","text":"calc_Mxy.m \u00b6 Basic Information \u00b6 SYNTAX: Mxy = calc_Mxy(XXpaths,XXfracp,YYpaths,YYfracp) PURPOSE: Calc mutual inductance matrix between conductors X and Y, whose paths are described by cell arrays XXpaths and YYpaths (see mut_paths2paths) INPUTS: OUTPUTS: Mxy = mutual inductance matrix [uH] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... METHOD: Uses mut_paths2paths.m","title":"calc_Mxy.m"},{"location":"function-guide/3d/calc_Mxy_m/#calc_mxym","text":"","title":"calc_Mxy.m"},{"location":"function-guide/3d/calc_Mxy_m/#basic-information","text":"SYNTAX: Mxy = calc_Mxy(XXpaths,XXfracp,YYpaths,YYfracp) PURPOSE: Calc mutual inductance matrix between conductors X and Y, whose paths are described by cell arrays XXpaths and YYpaths (see mut_paths2paths) INPUTS: OUTPUTS: Mxy = mutual inductance matrix [uH] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... METHOD: Uses mut_paths2paths.m","title":"Basic Information"},{"location":"function-guide/3d/expand_fils_m/","text":"expand_fils.m \u00b6 Basic Information \u00b6 SYNTAX: nufils = expand_fils(fils,rwnorm,Rref) PURPOSE: Expand filaments in minor radial position according to rwnorm (eg creates marginal wall position with rwnorm=rwmarginal/rwactual) in toroidal geometry. INPUTS: fils = filament array rwnorm = marginal wall minor radial position normalized to rw_actual (rwnorm=rwmarginal/rwactual; ref'd at midplane) Rref = major radius of reference pt (z=0 taken to be the vertical posit. of the reference point) from which expansion happens OUTPUTS: nufils = new (expanded) filaments RESTRICTIONS: rwnorm must not be large enough to cause the *inboard* wall to cross the machine center line (for the moment): no safeguard is provided in present version to prevent this... METHOD:","title":"expand_fils.m"},{"location":"function-guide/3d/expand_fils_m/#expand_filsm","text":"","title":"expand_fils.m"},{"location":"function-guide/3d/expand_fils_m/#basic-information","text":"SYNTAX: nufils = expand_fils(fils,rwnorm,Rref) PURPOSE: Expand filaments in minor radial position according to rwnorm (eg creates marginal wall position with rwnorm=rwmarginal/rwactual) in toroidal geometry. INPUTS: fils = filament array rwnorm = marginal wall minor radial position normalized to rw_actual (rwnorm=rwmarginal/rwactual; ref'd at midplane) Rref = major radius of reference pt (z=0 taken to be the vertical posit. of the reference point) from which expansion happens OUTPUTS: nufils = new (expanded) filaments RESTRICTIONS: rwnorm must not be large enough to cause the *inboard* wall to cross the machine center line (for the moment): no safeguard is provided in present version to prevent this... METHOD:","title":"Basic Information"},{"location":"function-guide/3d/fil_length_m/","text":"fil_length.m \u00b6 Basic Information \u00b6 SYNTAX: length = fil_length(fil) PURPOSE: Calculate length of filament (or lengths of all in array of filaments) Filament spec is JAL standard [x1,y1,z1,x2,y2,z2] (or columns of same) INPUTS: fil = filament vector or array OUTPUTS: length = length of filament (or vector with lengths of setof filaments) RESTRICTIONS: METHOD:","title":"fil_length.m"},{"location":"function-guide/3d/fil_length_m/#fil_lengthm","text":"","title":"fil_length.m"},{"location":"function-guide/3d/fil_length_m/#basic-information","text":"SYNTAX: length = fil_length(fil) PURPOSE: Calculate length of filament (or lengths of all in array of filaments) Filament spec is JAL standard [x1,y1,z1,x2,y2,z2] (or columns of same) INPUTS: fil = filament vector or array OUTPUTS: length = length of filament (or vector with lengths of setof filaments) RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/3d/fils2paths_m/","text":"fils2paths.m \u00b6 Basic Information \u00b6 SYNTAX: [VVpaths,VVfracp] = fils2paths(VVfils,VVfrac,nfilp); PURPOSE: Convert fils to paths (Note fils NOT FILSC notation!!!) INPUTS: OUTPUTS: RESTRICTIONS: METHOD:","title":"fils2paths.m"},{"location":"function-guide/3d/fils2paths_m/#fils2pathsm","text":"","title":"fils2paths.m"},{"location":"function-guide/3d/fils2paths_m/#basic-information","text":"SYNTAX: [VVpaths,VVfracp] = fils2paths(VVfils,VVfrac,nfilp); PURPOSE: Convert fils to paths (Note fils NOT FILSC notation!!!) INPUTS: OUTPUTS: RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/3d/green_paths2ptsORIG_m/","text":"green_paths2ptsORIG.m \u00b6 Basic Information \u00b6 SYNTAX: [Gr, Gz, Gt] = green_paths2pts(pts,Paths) PURPOSE: INPUTS: pts = pts geometry array (npts x 3) (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit. OR can be a *single* path, described by a filament *array* OUTPUTS: Gr,Gz,Gt = (npts,npaths) Green fun matrices from all paths in Paths to all pts in pts (all equally weighted). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD:","title":"green_paths2ptsORIG.m"},{"location":"function-guide/3d/green_paths2ptsORIG_m/#green_paths2ptsorigm","text":"","title":"green_paths2ptsORIG.m"},{"location":"function-guide/3d/green_paths2ptsORIG_m/#basic-information","text":"SYNTAX: [Gr, Gz, Gt] = green_paths2pts(pts,Paths) PURPOSE: INPUTS: pts = pts geometry array (npts x 3) (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit. OR can be a *single* path, described by a filament *array* OUTPUTS: Gr,Gz,Gt = (npts,npaths) Green fun matrices from all paths in Paths to all pts in pts (all equally weighted). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/green_paths2pts_m/","text":"green_paths2pts.m \u00b6 Basic Information \u00b6 SYNTAX: [Gr, Gz, Gt] = green_paths2pts(pts,Paths) PURPOSE: INPUTS: pts = pts geometry array (npts x 3) (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit. OR can be a *single* path, described by a filament *array* OUTPUTS: Gr,Gz,Gt = (npts,npaths) Green fun matrices from all paths in Paths to all pts in pts (all equally weighted). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD:","title":"green_paths2pts.m"},{"location":"function-guide/3d/green_paths2pts_m/#green_paths2ptsm","text":"","title":"green_paths2pts.m"},{"location":"function-guide/3d/green_paths2pts_m/#basic-information","text":"SYNTAX: [Gr, Gz, Gt] = green_paths2pts(pts,Paths) PURPOSE: INPUTS: pts = pts geometry array (npts x 3) (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit. OR can be a *single* path, described by a filament *array* OUTPUTS: Gr,Gz,Gt = (npts,npaths) Green fun matrices from all paths in Paths to all pts in pts (all equally weighted). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/make_hel_fils_m/","text":"make_hel_fils.m \u00b6 Basic Information \u00b6 SYNTAX: [fils,frac,Paths,fracp] = make_hel_fils(polpts,mmode,nmode, ... Rref,phase,iplot) PURPOSE: Construct helical filament sets for nonaxisymmetric mode on continuous surface such as plasma or vessel wall. INPUTS: polpts = set of poloidal points = (npts,2) matrix [x,z] [m] mmode = m poloidal mode number nmode = n toroidal mode number Rref = reference major radius [m] phase = (optional) phase relative to toroidal angle phi=0; phase=0 (default) gives cos mode, phase=-pi/2 gives sin mode. iplot = (optional) flag to select plotting: 0=no plot(default), 1= plot helicity = (optional) +1 for LH (default), -1 for RH OUTPUTS: fils = matrix describing set of filaments in [x1,y1,z1,x2,y2,z2] format frac = fraction of current in each filament (const on each hel winding) Paths = cell array of filament sets corr to each *path* in hel windings (note that the Paths cell array is a *column* cell array, dims {npaths,1} to allow row dimension to be used for modes...) NOTE WELL that the Paths matrices are in FILC format!!! fracp = vector of fracs corr to each *path* RESTRICTIONS: # of pts in polpts must be even multiple of mmode, and should be >> 1 (for example for 3,1 mode must have multiple of 3, like 24, 36, 60... Multiples of 12 are nice, since contain factors 2,3,4) METHOD:","title":"make_hel_fils.m"},{"location":"function-guide/3d/make_hel_fils_m/#make_hel_filsm","text":"","title":"make_hel_fils.m"},{"location":"function-guide/3d/make_hel_fils_m/#basic-information","text":"SYNTAX: [fils,frac,Paths,fracp] = make_hel_fils(polpts,mmode,nmode, ... Rref,phase,iplot) PURPOSE: Construct helical filament sets for nonaxisymmetric mode on continuous surface such as plasma or vessel wall. INPUTS: polpts = set of poloidal points = (npts,2) matrix [x,z] [m] mmode = m poloidal mode number nmode = n toroidal mode number Rref = reference major radius [m] phase = (optional) phase relative to toroidal angle phi=0; phase=0 (default) gives cos mode, phase=-pi/2 gives sin mode. iplot = (optional) flag to select plotting: 0=no plot(default), 1= plot helicity = (optional) +1 for LH (default), -1 for RH OUTPUTS: fils = matrix describing set of filaments in [x1,y1,z1,x2,y2,z2] format frac = fraction of current in each filament (const on each hel winding) Paths = cell array of filament sets corr to each *path* in hel windings (note that the Paths cell array is a *column* cell array, dims {npaths,1} to allow row dimension to be used for modes...) NOTE WELL that the Paths matrices are in FILC format!!! fracp = vector of fracs corr to each *path* RESTRICTIONS: # of pts in polpts must be even multiple of mmode, and should be >> 1 (for example for 3,1 mode must have multiple of 3, like 24, 36, 60... Multiples of 12 are nice, since contain factors 2,3,4) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/make_rec_filsORIG_m/","text":"make_rec_filsORIG.m \u00b6 Basic Information \u00b6 SYNTAX: [RECpts,RECfils] = make_rec_fils(zphis,thetas,rs,tilts,dzphis, ... hs,Rref,nfils) PURPOSE: Construct corner pts and filaments for picture frame coils in *toroidal* geometry (with horizontal legs curving around toroidal direction, but not necessarily at same minor or major radius...). INPUTS: (vectors are all 1x2) zphis = vector of phi=toroidal angle positions of frame *centers*. [rad] thetas = vector of theta (angular) positions of frame centers [rad] poloidal angle rel. to the major axis of the torus at R=Rref rs = vector of R (major radial) positions of frame centers [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to major radius R [rad] (when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames angular width dphi in [rad] hs = vector of full heights of frames [m] Rref = Reference major radius for toroidal case nfils = (opt) vec of # of sub-filaments to split legs into (def=10) OUTPUTS: RECpts = matrix of points making up rec coil rows of [x,y,z] RECfils = matrix of filaments [x1,y1,z1,x2,y2,z2] RESTRICTIONS: METHOD: For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"make_rec_filsORIG.m"},{"location":"function-guide/3d/make_rec_filsORIG_m/#make_rec_filsorigm","text":"","title":"make_rec_filsORIG.m"},{"location":"function-guide/3d/make_rec_filsORIG_m/#basic-information","text":"SYNTAX: [RECpts,RECfils] = make_rec_fils(zphis,thetas,rs,tilts,dzphis, ... hs,Rref,nfils) PURPOSE: Construct corner pts and filaments for picture frame coils in *toroidal* geometry (with horizontal legs curving around toroidal direction, but not necessarily at same minor or major radius...). INPUTS: (vectors are all 1x2) zphis = vector of phi=toroidal angle positions of frame *centers*. [rad] thetas = vector of theta (angular) positions of frame centers [rad] poloidal angle rel. to the major axis of the torus at R=Rref rs = vector of R (major radial) positions of frame centers [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to major radius R [rad] (when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames angular width dphi in [rad] hs = vector of full heights of frames [m] Rref = Reference major radius for toroidal case nfils = (opt) vec of # of sub-filaments to split legs into (def=10) OUTPUTS: RECpts = matrix of points making up rec coil rows of [x,y,z] RECfils = matrix of filaments [x1,y1,z1,x2,y2,z2] RESTRICTIONS: METHOD: For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"Basic Information"},{"location":"function-guide/3d/make_rec_fils_m/","text":"make_rec_fils.m \u00b6 Basic Information \u00b6 SYNTAX: [RECpts,RECfils] = make_rec_fils(zphis,thetas,rs,tilts,dzphis, ... hs,Rref,nfils) PURPOSE: Construct corner pts and filaments for picture frame coils in *toroidal* geometry (with horizontal legs curving around toroidal direction, but not necessarily at same minor or major radius...). INPUTS: (vectors are all 1x2) zphis = vector of phi=toroidal angle positions of frame *centers*. [rad] thetas = vector of theta (angular) positions of frame centers [rad] poloidal angle rel. to the major axis of the torus at R=Rref rs = vector of R (major radial) positions of frame centers [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to major radius R [rad] (when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames angular width dphi in [rad] hs = vector of full heights of frames [m] Rref = Reference major radius for toroidal case nfils = (opt) vec of # of sub-filaments to split legs into (def=10) OUTPUTS: RECpts = matrix of points making up rec coil rows of [x,y,z] RECfils = matrix of filaments [x1,y1,z1,x2,y2,z2] RESTRICTIONS: METHOD: For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"make_rec_fils.m"},{"location":"function-guide/3d/make_rec_fils_m/#make_rec_filsm","text":"","title":"make_rec_fils.m"},{"location":"function-guide/3d/make_rec_fils_m/#basic-information","text":"SYNTAX: [RECpts,RECfils] = make_rec_fils(zphis,thetas,rs,tilts,dzphis, ... hs,Rref,nfils) PURPOSE: Construct corner pts and filaments for picture frame coils in *toroidal* geometry (with horizontal legs curving around toroidal direction, but not necessarily at same minor or major radius...). INPUTS: (vectors are all 1x2) zphis = vector of phi=toroidal angle positions of frame *centers*. [rad] thetas = vector of theta (angular) positions of frame centers [rad] poloidal angle rel. to the major axis of the torus at R=Rref rs = vector of R (major radial) positions of frame centers [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to major radius R [rad] (when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames angular width dphi in [rad] hs = vector of full heights of frames [m] Rref = Reference major radius for toroidal case nfils = (opt) vec of # of sub-filaments to split legs into (def=10) OUTPUTS: RECpts = matrix of points making up rec coil rows of [x,y,z] RECfils = matrix of filaments [x1,y1,z1,x2,y2,z2] RESTRICTIONS: METHOD: For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"Basic Information"},{"location":"function-guide/3d/make_tor_fils_m/","text":"make_tor_fils.m \u00b6 Basic Information \u00b6 SYNTAX: [fils,frac,Paths,fracp] = make_tor_fils(polpts,Rref,mmode, ... nvvtor,iplot) PURPOSE: Construct toroidal filament sets for axisymmetric mode on continuous surface such as plasma or vessel wall. INPUTS: polpts = set of poloidal points = (npts,2) matrix [x,z] [m] mmode = m poloidal mode number Rref = reference major radius [m] nvvtor = # of toroidal pts iplot = (optional) flag to select plotting: 0=no plot(default), 1= plot OUTPUTS: fils = matrix describing set of filaments in [x1,y1,z1,x2,y2,z2] format frac = fraction of current in each filament (const on each hel winding) Paths = cell array of filament sets corr to each *path* in hel windings (note that the Paths cell array is a *column* cell array, dims {npaths,1} to allow row dimension to be used for modes...) NOTE WELL that the Paths matrices are in FILC format!!!! fracp = vector of fracs corr to each *path* RESTRICTIONS: # of pts in polpts must be even multiple of mmode, and should be >> 1 (for example for 3,1 mode must have multiple of 3, like 24, 36, 60... Multiples of 12 are nice, since contain factors 2,3,4) METHOD:","title":"make_tor_fils.m"},{"location":"function-guide/3d/make_tor_fils_m/#make_tor_filsm","text":"","title":"make_tor_fils.m"},{"location":"function-guide/3d/make_tor_fils_m/#basic-information","text":"SYNTAX: [fils,frac,Paths,fracp] = make_tor_fils(polpts,Rref,mmode, ... nvvtor,iplot) PURPOSE: Construct toroidal filament sets for axisymmetric mode on continuous surface such as plasma or vessel wall. INPUTS: polpts = set of poloidal points = (npts,2) matrix [x,z] [m] mmode = m poloidal mode number Rref = reference major radius [m] nvvtor = # of toroidal pts iplot = (optional) flag to select plotting: 0=no plot(default), 1= plot OUTPUTS: fils = matrix describing set of filaments in [x1,y1,z1,x2,y2,z2] format frac = fraction of current in each filament (const on each hel winding) Paths = cell array of filament sets corr to each *path* in hel windings (note that the Paths cell array is a *column* cell array, dims {npaths,1} to allow row dimension to be used for modes...) NOTE WELL that the Paths matrices are in FILC format!!!! fracp = vector of fracs corr to each *path* RESTRICTIONS: # of pts in polpts must be even multiple of mmode, and should be >> 1 (for example for 3,1 mode must have multiple of 3, like 24, 36, 60... Multiples of 12 are nice, since contain factors 2,3,4) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/make_wallmesh_m/","text":"make_wallmesh.m \u00b6 Basic Information \u00b6 SYNTAX: [vvPfils,vvTfils,Cvpol,Cvtor] = make_wallmesh(vvpolpts,torangs, ... iclosepol,iclosetor,iplot,Rref); PURPOSE: Generate filament array for mesh representation of toroidal wall or wall segment. INPUTS: vvpolpts = array of poloidal points for wall representation (npts,2) [R(:) Z(:)] [m] torangs = toroidal angles for wall discretization [deg] iclosepol = flag =1 to select closing of wall in pol direction (def=1) iclosetor = flag =1 to select closing of wall in tor direction (def=1) iplot = flag to select plotting if 3D geometry OUTPUTS: vvPfils = filament array for poloidal-pointing filaments in mesh representation vvTfils = filament array for toroidal-pointing filaments in mesh representation Cvpol = constraint matrix for poloidal filaments (total constraint matrix is Cvv=[Cvpol Cvtor], total filament matrix is vvfils = [vvPfils; vvTfils]) Cvtor = constraint matrix for toroidal filaments RESTRICTIONS: METHOD: Two filament arrays are produced, one for poloidally-pointing filaments and one for toroidally-pointing filaments. Poloidal and toroidal filaments with the same index emerge from the same point. Filaments associated with a given point are the right-pointing toroidal and the upward-pointing poloidal filament. Constraint matrix represents the node current equations: # of rows = total # of pts (=npolpts*ntorpts), while # of columns = # of pol fils + # of tor fils = 2x(tot # of pts). Constraint equation is thus C*I=0, so current vectors lie in null space of constraint matrix.","title":"make_wallmesh.m"},{"location":"function-guide/3d/make_wallmesh_m/#make_wallmeshm","text":"","title":"make_wallmesh.m"},{"location":"function-guide/3d/make_wallmesh_m/#basic-information","text":"SYNTAX: [vvPfils,vvTfils,Cvpol,Cvtor] = make_wallmesh(vvpolpts,torangs, ... iclosepol,iclosetor,iplot,Rref); PURPOSE: Generate filament array for mesh representation of toroidal wall or wall segment. INPUTS: vvpolpts = array of poloidal points for wall representation (npts,2) [R(:) Z(:)] [m] torangs = toroidal angles for wall discretization [deg] iclosepol = flag =1 to select closing of wall in pol direction (def=1) iclosetor = flag =1 to select closing of wall in tor direction (def=1) iplot = flag to select plotting if 3D geometry OUTPUTS: vvPfils = filament array for poloidal-pointing filaments in mesh representation vvTfils = filament array for toroidal-pointing filaments in mesh representation Cvpol = constraint matrix for poloidal filaments (total constraint matrix is Cvv=[Cvpol Cvtor], total filament matrix is vvfils = [vvPfils; vvTfils]) Cvtor = constraint matrix for toroidal filaments RESTRICTIONS: METHOD: Two filament arrays are produced, one for poloidally-pointing filaments and one for toroidally-pointing filaments. Poloidal and toroidal filaments with the same index emerge from the same point. Filaments associated with a given point are the right-pointing toroidal and the upward-pointing poloidal filament. Constraint matrix represents the node current equations: # of rows = total # of pts (=npolpts*ntorpts), while # of columns = # of pol fils + # of tor fils = 2x(tot # of pts). Constraint equation is thus C*I=0, so current vectors lie in null space of constraint matrix.","title":"Basic Information"},{"location":"function-guide/3d/mut_fil_fil_m/","text":"mut_fil_fil.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the mutual inductance between two sets of filaments A & B. Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. Sending filament set is \"A\", receiving filament set is \"B\" Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: mut_fil_fil(xa,xb,fa,fb) INPUT: (a= sending filament, b= receiving filament) xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] xb = same for receiving filaments [xb,yb,zb,dxb,dyb,dzb] fa,fb= Optional: fraction of current in filament for parallel filaments OUTPUT: m == mutual inductance between filament sets A to B [H] CAUTION: Will not work for filaments on top of each other (ie self inductance)","title":"mut_fil_fil.m"},{"location":"function-guide/3d/mut_fil_fil_m/#mut_fil_film","text":"","title":"mut_fil_fil.m"},{"location":"function-guide/3d/mut_fil_fil_m/#basic-information","text":"PURPOSE: Calculate the mutual inductance between two sets of filaments A & B. Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. Sending filament set is \"A\", receiving filament set is \"B\" Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: mut_fil_fil(xa,xb,fa,fb) INPUT: (a= sending filament, b= receiving filament) xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] xb = same for receiving filaments [xb,yb,zb,dxb,dyb,dzb] fa,fb= Optional: fraction of current in filament for parallel filaments OUTPUT: m == mutual inductance between filament sets A to B [H] CAUTION: Will not work for filaments on top of each other (ie self inductance)","title":"Basic Information"},{"location":"function-guide/3d/mut_filcs2filcs_m/","text":"mut_filcs2filcs.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate mutual inductances between sets of conductors described by cells of filc arrays SYNTAX: M = mut_filcs2filcs(filcs1,filcs2,aa1,aa2,f1,f2) INPUT: filcs1, filcs2 = CELLS of filament matrices defined by [xc,yc,zc,dx,dy,dz] aa1, aa2, radii of fils, = sqrt(cross sectional area / pi) aa1 is required if any conductor in set 1 is identical to any in 2 f1, f2 (optional) = fraction of current in a filament (for parallel fils) OUTPUT: M = matrix of mutuals from set filcs1 to set filcs2 of conductors [H] RESTRICTIONS: METHOD: Calls mut_fil_fil if the fils are different and self_filDH if same","title":"mut_filcs2filcs.m"},{"location":"function-guide/3d/mut_filcs2filcs_m/#mut_filcs2filcsm","text":"","title":"mut_filcs2filcs.m"},{"location":"function-guide/3d/mut_filcs2filcs_m/#basic-information","text":"PURPOSE: Calculate mutual inductances between sets of conductors described by cells of filc arrays SYNTAX: M = mut_filcs2filcs(filcs1,filcs2,aa1,aa2,f1,f2) INPUT: filcs1, filcs2 = CELLS of filament matrices defined by [xc,yc,zc,dx,dy,dz] aa1, aa2, radii of fils, = sqrt(cross sectional area / pi) aa1 is required if any conductor in set 1 is identical to any in 2 f1, f2 (optional) = fraction of current in a filament (for parallel fils) OUTPUT: M = matrix of mutuals from set filcs1 to set filcs2 of conductors [H] RESTRICTIONS: METHOD: Calls mut_fil_fil if the fils are different and self_filDH if same","title":"Basic Information"},{"location":"function-guide/3d/mut_fine_fil_m/","text":"mut_fine_fil.m \u00b6 Basic Information \u00b6 SYNTAX: mutuals = mut_fine_fil(acoil_data,bfils,nrecta) PURPOSE: Compute mutual inductance from a set of axisymmetric conductors to a set of straight line (filc) conductors. Filament conductors (identified by setting dR=dZ=0 in acoil_data) are allowed. INPUT: acoil_data = data describing geometry of coil set A Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. bfilcs is a cell array of conductors. Each cell has segments in rows and 6 columns [x y z dx dy dz] for center and vector of each segment. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (Henries) RESTRICTIONS: METHOD: Each conductor in set A is partitioned into a bunch of tiny rectangles. Flux through B is line integrated vector potential from A.","title":"mut_fine_fil.m"},{"location":"function-guide/3d/mut_fine_fil_m/#mut_fine_film","text":"","title":"mut_fine_fil.m"},{"location":"function-guide/3d/mut_fine_fil_m/#basic-information","text":"SYNTAX: mutuals = mut_fine_fil(acoil_data,bfils,nrecta) PURPOSE: Compute mutual inductance from a set of axisymmetric conductors to a set of straight line (filc) conductors. Filament conductors (identified by setting dR=dZ=0 in acoil_data) are allowed. INPUT: acoil_data = data describing geometry of coil set A Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. bfilcs is a cell array of conductors. Each cell has segments in rows and 6 columns [x y z dx dy dz] for center and vector of each segment. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (Henries) RESTRICTIONS: METHOD: Each conductor in set A is partitioned into a bunch of tiny rectangles. Flux through B is line integrated vector potential from A.","title":"Basic Information"},{"location":"function-guide/3d/mut_paths2paths_m/","text":"mut_paths2paths.m \u00b6 Basic Information \u00b6 SYNTAX: mut = mut_paths2paths(Paths1,Paths2) PURPOSE: INPUTS: Paths1,Paths2 = {npaths,1} cell arrays of (nfils,6) matrices specifying paths in two circuits. OR either or both can be a *single* path, described by a filament *array* OUTPUTS: mut = (npaths1,npaths2) mutual inductance matrix from all paths in Paths2 to all paths in Paths1 (all equally weighted). [H] RESTRICTIONS: Assumes none of the paths in Paths1 overlap any of the paths in Paths2 (to handle the case when, for example, Paths1=Paths2, use function self_paths.m) NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD: Calls mut_fil_fil.m","title":"mut_paths2paths.m"},{"location":"function-guide/3d/mut_paths2paths_m/#mut_paths2pathsm","text":"","title":"mut_paths2paths.m"},{"location":"function-guide/3d/mut_paths2paths_m/#basic-information","text":"SYNTAX: mut = mut_paths2paths(Paths1,Paths2) PURPOSE: INPUTS: Paths1,Paths2 = {npaths,1} cell arrays of (nfils,6) matrices specifying paths in two circuits. OR either or both can be a *single* path, described by a filament *array* OUTPUTS: mut = (npaths1,npaths2) mutual inductance matrix from all paths in Paths2 to all paths in Paths1 (all equally weighted). [H] RESTRICTIONS: Assumes none of the paths in Paths1 overlap any of the paths in Paths2 (to handle the case when, for example, Paths1=Paths2, use function self_paths.m) NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD: Calls mut_fil_fil.m","title":"Basic Information"},{"location":"function-guide/3d/mut_rec2recOLD_m/","text":"mut_rec2recOLD.m \u00b6 Basic Information \u00b6 SYNTAX: mut = mut_rec2rec(zs,thetas,rs,dzs,dthetas,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical geometry. INPUTS: zs = vector of z (axial) positions of frame *centers* [m] thetas = vector of theta (angular) positions of frame centers [rad] rs = vector of r (radial) positions of *axial legs* [m] dzs = vector of \"widths\" of frames [m] dthetas = vector of angular-extents of frames [rad] Note that this just defines the locations of the axial legs... The \"theta\" legs are still straight lines connecting the ends of the axial legs. nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator).","title":"mut_rec2recOLD.m"},{"location":"function-guide/3d/mut_rec2recOLD_m/#mut_rec2recoldm","text":"","title":"mut_rec2recOLD.m"},{"location":"function-guide/3d/mut_rec2recOLD_m/#basic-information","text":"SYNTAX: mut = mut_rec2rec(zs,thetas,rs,dzs,dthetas,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical geometry. INPUTS: zs = vector of z (axial) positions of frame *centers* [m] thetas = vector of theta (angular) positions of frame centers [rad] rs = vector of r (radial) positions of *axial legs* [m] dzs = vector of \"widths\" of frames [m] dthetas = vector of angular-extents of frames [rad] Note that this just defines the locations of the axial legs... The \"theta\" legs are still straight lines connecting the ends of the axial legs. nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator).","title":"Basic Information"},{"location":"function-guide/3d/mut_rec2recX_m/","text":"mut_rec2recX.m \u00b6 Basic Information \u00b6 SYNTAX: mut = mut_rec2rec(zphis,thetas,rs,tilts,dzphis,hs, ... Rref,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical or toroidal geometry (with straight legs parallel to axial or toroidal direction respectively but not necessarily at same minor or major radius). INPUTS: (vectors are all 1x2) zphis = vector of z (axial) (OR phi=toroidal angle) positions of frame *centers*. If Rref=0, zphis specifies z positions. If Rref=1, zphis specifies phi toroidal angles. [m if z, rad if phi] thetas = vector of theta (angular) positions of frame centers [rad] (absolute cylindrical angle if Rref=0, or poloidal angle relative to the major axis of the torus at R=Rref for Rref~=0) rs = vector of r (minor radial) positions of frame centers for Rref=0, or R (major radial) positions of frame centers for Rref~=0 [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to minor radius if Rref=0, or relative to major radius R if Rref~=0 [rad] (If Rref=0, when coil frame is tangent to cyl the tilt = 0) (If Rref~=0, when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames (linear width in [m] for Rref=0 and angular width dphi in [rad] for Rref~=0) hs = vector of full heights of frames [m] Rref = (opt) Reference major radius for toroidal case AND flag to specify whether cylindrical (=0, default) or toroidal (NOT =0) (units of [m] in toroidal case, and used only as flag in cylindrical) (def = 0) nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator). For cylindrical geometry, r,theta plane in this code correspond to x,y plane in mut_fil_fil, and z = z (axial direction of cylinder). For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"mut_rec2recX.m"},{"location":"function-guide/3d/mut_rec2recX_m/#mut_rec2recxm","text":"","title":"mut_rec2recX.m"},{"location":"function-guide/3d/mut_rec2recX_m/#basic-information","text":"SYNTAX: mut = mut_rec2rec(zphis,thetas,rs,tilts,dzphis,hs, ... Rref,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical or toroidal geometry (with straight legs parallel to axial or toroidal direction respectively but not necessarily at same minor or major radius). INPUTS: (vectors are all 1x2) zphis = vector of z (axial) (OR phi=toroidal angle) positions of frame *centers*. If Rref=0, zphis specifies z positions. If Rref=1, zphis specifies phi toroidal angles. [m if z, rad if phi] thetas = vector of theta (angular) positions of frame centers [rad] (absolute cylindrical angle if Rref=0, or poloidal angle relative to the major axis of the torus at R=Rref for Rref~=0) rs = vector of r (minor radial) positions of frame centers for Rref=0, or R (major radial) positions of frame centers for Rref~=0 [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to minor radius if Rref=0, or relative to major radius R if Rref~=0 [rad] (If Rref=0, when coil frame is tangent to cyl the tilt = 0) (If Rref~=0, when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames (linear width in [m] for Rref=0 and angular width dphi in [rad] for Rref~=0) hs = vector of full heights of frames [m] Rref = (opt) Reference major radius for toroidal case AND flag to specify whether cylindrical (=0, default) or toroidal (NOT =0) (units of [m] in toroidal case, and used only as flag in cylindrical) (def = 0) nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator). For cylindrical geometry, r,theta plane in this code correspond to x,y plane in mut_fil_fil, and z = z (axial direction of cylinder). For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"Basic Information"},{"location":"function-guide/3d/mut_rec2rec_m/","text":"mut_rec2rec.m \u00b6 Basic Information \u00b6 SYNTAX: mut = mut_rec2rec(zphis,thetas,rs,tilts,dzphis,hs, ... Rref,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical or toroidal geometry (with straight legs parallel to axial or toroidal direction respectively but not necessarily at same minor or major radius). INPUTS: (vectors are all 1x2) zphis = vector of z (axial) (OR phi=toroidal angle) positions of frame *centers*. If Rref=0, zphis specifies z positions. If Rref=1, zphis specifies phi toroidal angles. [m if z, rad if phi] thetas = vector of theta (angular) positions of frame centers [rad] (absolute cylindrical angle if Rref=0, or poloidal angle relative to the major axis of the torus at R=Rref for Rref~=0) rs = vector of r (minor radial) positions of frame centers for Rref=0, or R (major radial) positions of frame centers for Rref~=0 [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to minor radius if Rref=0, or relative to major radius R if Rref~=0 [rad] (If Rref=0, when coil frame is tangent to cyl the tilt = 0) (If Rref~=0, when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames (linear width in [m] for Rref=0 and angular width dphi in [rad] for Rref~=0) hs = vector of full heights of frames [m] Rref = (opt) Reference major radius for toroidal case AND flag to specify whether cylindrical (=0, default) or toroidal (NOT =0) (units of [m] in toroidal case, and used only as flag in cylindrical) (def = 0) nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator). For cylindrical geometry, r,theta plane in this code correspond to x,y plane in mut_fil_fil, and z = z (axial direction of cylinder). For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"mut_rec2rec.m"},{"location":"function-guide/3d/mut_rec2rec_m/#mut_rec2recm","text":"","title":"mut_rec2rec.m"},{"location":"function-guide/3d/mut_rec2rec_m/#basic-information","text":"SYNTAX: mut = mut_rec2rec(zphis,thetas,rs,tilts,dzphis,hs, ... Rref,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical or toroidal geometry (with straight legs parallel to axial or toroidal direction respectively but not necessarily at same minor or major radius). INPUTS: (vectors are all 1x2) zphis = vector of z (axial) (OR phi=toroidal angle) positions of frame *centers*. If Rref=0, zphis specifies z positions. If Rref=1, zphis specifies phi toroidal angles. [m if z, rad if phi] thetas = vector of theta (angular) positions of frame centers [rad] (absolute cylindrical angle if Rref=0, or poloidal angle relative to the major axis of the torus at R=Rref for Rref~=0) rs = vector of r (minor radial) positions of frame centers for Rref=0, or R (major radial) positions of frame centers for Rref~=0 [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to minor radius if Rref=0, or relative to major radius R if Rref~=0 [rad] (If Rref=0, when coil frame is tangent to cyl the tilt = 0) (If Rref~=0, when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames (linear width in [m] for Rref=0 and angular width dphi in [rad] for Rref~=0) hs = vector of full heights of frames [m] Rref = (opt) Reference major radius for toroidal case AND flag to specify whether cylindrical (=0, default) or toroidal (NOT =0) (units of [m] in toroidal case, and used only as flag in cylindrical) (def = 0) nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator). For cylindrical geometry, r,theta plane in this code correspond to x,y plane in mut_fil_fil, and z = z (axial direction of cylinder). For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"Basic Information"},{"location":"function-guide/3d/plot_filament_m/","text":"plot_filament.m \u00b6 Basic Information \u00b6 plot_filament.m reads fil_file and plots in figure.","title":"plot_filament.m"},{"location":"function-guide/3d/plot_filament_m/#plot_filamentm","text":"","title":"plot_filament.m"},{"location":"function-guide/3d/plot_filament_m/#basic-information","text":"plot_filament.m reads fil_file and plots in figure.","title":"Basic Information"},{"location":"function-guide/3d/plot_fils_m/","text":"plot_fils.m \u00b6 Basic Information \u00b6 SYNTAX: h = plot_fils(fils,clstr,lw,frac) PURPOSE: Plot filaments in standard filament specification matrix (npts,6): [x1,y1,z1,x2,y2,z2] INPUTS: fils = filament specification matrix (npts,6): [x1,y1,z1,x2,y2,z2] (or cell with several (npts,6) elements) clstr = (optional) color/linetype string (def= 'g' for green/solid) lw = (optional) linewidth (def=4) frac = (optional) scale factor, must have same number of rows as fils segments with frac>0 are plotted green and frac<0 are plotted red); OUTPUTS: h = figure handle","title":"plot_fils.m"},{"location":"function-guide/3d/plot_fils_m/#plot_filsm","text":"","title":"plot_fils.m"},{"location":"function-guide/3d/plot_fils_m/#basic-information","text":"SYNTAX: h = plot_fils(fils,clstr,lw,frac) PURPOSE: Plot filaments in standard filament specification matrix (npts,6): [x1,y1,z1,x2,y2,z2] INPUTS: fils = filament specification matrix (npts,6): [x1,y1,z1,x2,y2,z2] (or cell with several (npts,6) elements) clstr = (optional) color/linetype string (def= 'g' for green/solid) lw = (optional) linewidth (def=4) frac = (optional) scale factor, must have same number of rows as fils segments with frac>0 are plotted green and frac<0 are plotted red); OUTPUTS: h = figure handle","title":"Basic Information"},{"location":"function-guide/3d/self_barDH_m/","text":"self_barDH.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the self inductance of a set of bars A Bar is defined by center and deltas x= [xc,yc,zc,dx,dy,dz] and perimeters, pa, which is all that is needed to compute self inductance. self_bar is related to self_fil which computes self inductance of filament set. Cross-inductances are calculated as filaments using fil_a; only diagonals (and thus single bars) have self inductances calculated as bars. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_barDH(xa,pa,fa,full) INPUT: xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] pa = Perimeters of bars for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of bar A sets [H] RESTRICTIONS: CAUTION: Filament perimeter pa cannot be zero METHOD: Uses AIP handbook expression for self inductance of rectangular X-sect bar:","title":"self_barDH.m"},{"location":"function-guide/3d/self_barDH_m/#self_bardhm","text":"","title":"self_barDH.m"},{"location":"function-guide/3d/self_barDH_m/#basic-information","text":"PURPOSE: Calculate the self inductance of a set of bars A Bar is defined by center and deltas x= [xc,yc,zc,dx,dy,dz] and perimeters, pa, which is all that is needed to compute self inductance. self_bar is related to self_fil which computes self inductance of filament set. Cross-inductances are calculated as filaments using fil_a; only diagonals (and thus single bars) have self inductances calculated as bars. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_barDH(xa,pa,fa,full) INPUT: xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] pa = Perimeters of bars for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of bar A sets [H] RESTRICTIONS: CAUTION: Filament perimeter pa cannot be zero METHOD: Uses AIP handbook expression for self inductance of rectangular X-sect bar:","title":"Basic Information"},{"location":"function-guide/3d/self_filDH_m/","text":"self_filDH.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,aa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero","title":"self_filDH.m"},{"location":"function-guide/3d/self_filDH_m/#self_fildhm","text":"","title":"self_filDH.m"},{"location":"function-guide/3d/self_filDH_m/#basic-information","text":"PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,aa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero","title":"Basic Information"},{"location":"function-guide/3d/self_fil_m/","text":"self_fil.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero","title":"self_fil.m"},{"location":"function-guide/3d/self_fil_m/#self_film","text":"","title":"self_fil.m"},{"location":"function-guide/3d/self_fil_m/#basic-information","text":"PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero","title":"Basic Information"},{"location":"function-guide/3d/self_paths_m/","text":"self_paths.m \u00b6 Basic Information \u00b6 SYNTAX: selfind = self_paths(Paths,as) PURPOSE: INPUTS: Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit for which want self inductance. as = (npaths,1) vector of minor radii corr to each path [m] OUTPUTS: selfind = (npaths,npaths) mutual inductance *matrix* from all paths in Paths to all paths in Paths (all equally weighted). Actual self inductance calculated for diagonals (coincident paths). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD:","title":"self_paths.m"},{"location":"function-guide/3d/self_paths_m/#self_pathsm","text":"","title":"self_paths.m"},{"location":"function-guide/3d/self_paths_m/#basic-information","text":"SYNTAX: selfind = self_paths(Paths,as) PURPOSE: INPUTS: Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit for which want self inductance. as = (npaths,1) vector of minor radii corr to each path [m] OUTPUTS: selfind = (npaths,npaths) mutual inductance *matrix* from all paths in Paths to all paths in Paths (all equally weighted). Actual self inductance calculated for diagonals (coincident paths). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/test_mvv_m/","text":"test_mvv.m \u00b6 Basic Information \u00b6 Simple script to calc Mvv from straight mutind, selfind calcs for vvdata:","title":"test_mvv.m"},{"location":"function-guide/3d/test_mvv_m/#test_mvvm","text":"","title":"test_mvv.m"},{"location":"function-guide/3d/test_mvv_m/#basic-information","text":"Simple script to calc Mvv from straight mutind, selfind calcs for vvdata:","title":"Basic Information"},{"location":"function-guide/GAcomm/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 UWB functions. Data manipulation: get_DPO_data - Load data acquired from DPO scope. get_DSO_data - Load data acquired from DSO scope. General Purpose Functions FT_multicycle - analytical Fourier transform of multicycle sine pulse Q - compute Q function calcS - cont. Fourier transf. of discrete sequence of 1's,0's correlate - approximation of analog correlation function intQ.m - Integrate Q(d(t)) for signal d(t) on an interval [a,b] nbdistfn.m - Compute probability dist. fn. for narrowband noise noise_corr - Approximate noise corrltn. integral using random walk quad_gaussian - prob. dist. fn. for a quadratic fn of a gaussian shift_and_add - shift 1st signal by specified time and add to 2nd spectrum_analyzer - simulate HP spectrum analyzer TDMF specific Functions TDMF_PPM_symbols - Computes number of symbols for TDMF/PPM combinations TDMF_spectrum_analysis - TDMF_symbol_table - Count combinations for TDMF/PPM symbols symbol_cntM - compute number of combinations for TDMF symbol(Mode 7) symbol_cntM_1 - compute number of combinations for TDMF symbol(Mode 8) Functions for memo 8-0001-0004. Fnb_DPC - prob. dist. fn. for narrowband noise in DPC detector Qimp - Compute Qimp function defined in 8-0001-0004 c_imp - calc_I1 - Calculate integral I1 defined in DPC section calc_Mtilde - noise var. multiplier for sum of M alternating sign samples calc_cf - noise var. correlation factor for sum of M alternating sign samples crosscorr_multicycle - crosscorrelation of multicycle sine wave pulses fimp_c - Compute density for impulsive noise conditioned on t0","title":"Contents.m"},{"location":"function-guide/GAcomm/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/GAcomm/Contents_m/#basic-information","text":"UWB functions. Data manipulation: get_DPO_data - Load data acquired from DPO scope. get_DSO_data - Load data acquired from DSO scope. General Purpose Functions FT_multicycle - analytical Fourier transform of multicycle sine pulse Q - compute Q function calcS - cont. Fourier transf. of discrete sequence of 1's,0's correlate - approximation of analog correlation function intQ.m - Integrate Q(d(t)) for signal d(t) on an interval [a,b] nbdistfn.m - Compute probability dist. fn. for narrowband noise noise_corr - Approximate noise corrltn. integral using random walk quad_gaussian - prob. dist. fn. for a quadratic fn of a gaussian shift_and_add - shift 1st signal by specified time and add to 2nd spectrum_analyzer - simulate HP spectrum analyzer TDMF specific Functions TDMF_PPM_symbols - Computes number of symbols for TDMF/PPM combinations TDMF_spectrum_analysis - TDMF_symbol_table - Count combinations for TDMF/PPM symbols symbol_cntM - compute number of combinations for TDMF symbol(Mode 7) symbol_cntM_1 - compute number of combinations for TDMF symbol(Mode 8) Functions for memo 8-0001-0004. Fnb_DPC - prob. dist. fn. for narrowband noise in DPC detector Qimp - Compute Qimp function defined in 8-0001-0004 c_imp - calc_I1 - Calculate integral I1 defined in DPC section calc_Mtilde - noise var. multiplier for sum of M alternating sign samples calc_cf - noise var. correlation factor for sum of M alternating sign samples crosscorr_multicycle - crosscorrelation of multicycle sine wave pulses fimp_c - Compute density for impulsive noise conditioned on t0","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTinpstuff_m/","text":"CTinpstuff.m \u00b6 Basic Information \u00b6 SYNTAX: [numxinp,ndf,inppoint,names,namelen,maxlen,err] = CTinpstuff(inputvar); PURPOSE: May be able to use ordinary inpstuff.m (belongs to mutools) INPUT: inputvar = string with the name of the inputs to the global system OUTPUT: numxinp = number of total inputs (addition of the input channels of all the different inputs) ndf = number of different inputs inppoint = Each row corresponds to each different input [starting point of channels, number of channels] names = names of the input namelen = length of input names maxlen = maximum length of the input names err = error alert","title":"CTinpstuff.m"},{"location":"function-guide/GAcontrol/CTinpstuff_m/#ctinpstuffm","text":"","title":"CTinpstuff.m"},{"location":"function-guide/GAcontrol/CTinpstuff_m/#basic-information","text":"SYNTAX: [numxinp,ndf,inppoint,names,namelen,maxlen,err] = CTinpstuff(inputvar); PURPOSE: May be able to use ordinary inpstuff.m (belongs to mutools) INPUT: inputvar = string with the name of the inputs to the global system OUTPUT: numxinp = number of total inputs (addition of the input channels of all the different inputs) ndf = number of different inputs inppoint = Each row corresponds to each different input [starting point of channels, number of channels] names = names of the input namelen = length of input names maxlen = maximum length of the input names err = error alert","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTmtblanks_m/","text":"CTmtblanks.m \u00b6 Basic Information \u00b6 Copyright 1991-2001 by MUSYN Inc. and The MathWorks, Inc. $Revision: 1.6 $","title":"CTmtblanks.m"},{"location":"function-guide/GAcontrol/CTmtblanks_m/#ctmtblanksm","text":"","title":"CTmtblanks.m"},{"location":"function-guide/GAcontrol/CTmtblanks_m/#basic-information","text":"Copyright 1991-2001 by MUSYN Inc. and The MathWorks, Inc. $Revision: 1.6 $","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTnamstuff_m/","text":"CTnamstuff.m \u00b6 Basic Information \u00b6 SYNTAX: [numsys,names,namelen,maxlen] = CTnamstuff(systemnames); PURPOSE: May be able to use ordinary namstuff.m (belongs to mutools) INPUT: systemnames = string with the names of the different systems OUTPUT: numsys = number of systems names = names of systems namelen = length of system names maxlen = maximum length of the system names","title":"CTnamstuff.m"},{"location":"function-guide/GAcontrol/CTnamstuff_m/#ctnamstuffm","text":"","title":"CTnamstuff.m"},{"location":"function-guide/GAcontrol/CTnamstuff_m/#basic-information","text":"SYNTAX: [numsys,names,namelen,maxlen] = CTnamstuff(systemnames); PURPOSE: May be able to use ordinary namstuff.m (belongs to mutools) INPUT: systemnames = string with the names of the different systems OUTPUT: numsys = number of systems names = names of systems namelen = length of system names maxlen = maximum length of the system names","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTpass1_m/","text":"CTpass1.m \u00b6 Basic Information \u00b6 SYNTAX: [arraydata,arraylen,err] = pass1(var) PURPOSE: Parses a string of semicolon separated tokens into array of individual token strings. INPUT: var = string variable containing semicolon separated tokens OUTPUT: arraydata = array of tokens which were separated by semicolons in var arraylen = vector of lengths of token strings in arraydata err = error code, if 0 everything is OK","title":"CTpass1.m"},{"location":"function-guide/GAcontrol/CTpass1_m/#ctpass1m","text":"","title":"CTpass1.m"},{"location":"function-guide/GAcontrol/CTpass1_m/#basic-information","text":"SYNTAX: [arraydata,arraylen,err] = pass1(var) PURPOSE: Parses a string of semicolon separated tokens into array of individual token strings. INPUT: var = string variable containing semicolon separated tokens OUTPUT: arraydata = array of tokens which were separated by semicolons in var arraylen = vector of lengths of token strings in arraydata err = error code, if 0 everything is OK","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTpass2_m/","text":"CTpass2.m \u00b6 Basic Information \u00b6 SYNTAX: [od,odl,fromsys,gains,er] = ... CTpass2(tokidx,strtok,toklens,names,namelens,sysd) PURPOSE: This works on the data between colons on a INPUT_TO_SYS, determining which system the outputs come from (FROMSYS), which particular outputs (OD), and the scalar gain (GAINS). INPUT: tokidx = index into array strtok defining token to work on(?) strtok = array containing string tokens (parsed by CTpass1) toklens = length of strings in each entry of strtok names = array of system names namelens = length of string for each entry in names sysdata = matrix defining number of states, outputs, inputs for each system listed in names OUTPUT: od odl fromsys = system from which ... gains er = error code, if 0 then everything is OK","title":"CTpass2.m"},{"location":"function-guide/GAcontrol/CTpass2_m/#ctpass2m","text":"","title":"CTpass2.m"},{"location":"function-guide/GAcontrol/CTpass2_m/#basic-information","text":"SYNTAX: [od,odl,fromsys,gains,er] = ... CTpass2(tokidx,strtok,toklens,names,namelens,sysd) PURPOSE: This works on the data between colons on a INPUT_TO_SYS, determining which system the outputs come from (FROMSYS), which particular outputs (OD), and the scalar gain (GAINS). INPUT: tokidx = index into array strtok defining token to work on(?) strtok = array containing string tokens (parsed by CTpass1) toklens = length of strings in each entry of strtok names = array of system names namelens = length of string for each entry in names sysdata = matrix defining number of states, outputs, inputs for each system listed in names OUTPUT: od odl fromsys = system from which ... gains er = error code, if 0 then everything is OK","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTpass3_m/","text":"CTpass3.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: INPUT: j od odl OUTPUT: out err","title":"CTpass3.m"},{"location":"function-guide/GAcontrol/CTpass3_m/#ctpass3m","text":"","title":"CTpass3.m"},{"location":"function-guide/GAcontrol/CTpass3_m/#basic-information","text":"SYNTAX: PURPOSE: INPUT: j od odl OUTPUT: out err","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTsysbal_m/","text":"CTsysbal.m \u00b6 Basic Information \u00b6 SYNTAX: function [sysout,sig] = sysbal(sys,tol) PURPOSE: Finds a truncated balanced realization of the system state-space model. Eigenvalues of A must have negative real part. The result is truncated to retain all Hankel- singular values greater than TOL. If TOL is omitted then it is set to max(sig(1)*1.0E-12,1.0E-16). INPUT: sys = tol = OUTPUT: sysout = sig = RESTRICTIONS: The systems are expressed in Control Toolbox format. METHOD: WRITTEN BY: Eugenio Schuster ON 8/3/02","title":"CTsysbal.m"},{"location":"function-guide/GAcontrol/CTsysbal_m/#ctsysbalm","text":"","title":"CTsysbal.m"},{"location":"function-guide/GAcontrol/CTsysbal_m/#basic-information","text":"SYNTAX: function [sysout,sig] = sysbal(sys,tol) PURPOSE: Finds a truncated balanced realization of the system state-space model. Eigenvalues of A must have negative real part. The result is truncated to retain all Hankel- singular values greater than TOL. If TOL is omitted then it is set to max(sig(1)*1.0E-12,1.0E-16). INPUT: sys = tol = OUTPUT: sysout = sig = RESTRICTIONS: The systems are expressed in Control Toolbox format. METHOD: WRITTEN BY: Eugenio Schuster ON 8/3/02","title":"Basic Information"},{"location":"function-guide/GAcontrol/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Control design utility functions. analyze_Xpt approx_B bld_approx_vert_prop - Build reduced approx. to analog vertical control filters, proportional term version bld_approx_vert_noprop - Build reduced approx. to analog vertical control filters, no proportional term version bld_chopper_filter - build representation for chopper anti-alias filter bld_vertchoppers - build system model of choppers used in vertical control bodehz - same as bode but with Hz on x-axis, better plotting calc_ssop - Calc steady state values I0 and V0 compare_systems - compare frequency response of 2 system models controllability - calculate controllability matrix dbodehz - same as dbode but with Hz on x-axis, better plotting design_inner_loop_control - design inner loop controller diagnose_control - plot results of control (flux, Rx, Zx errors, etc.) final_states - compute final states for system with constant input u find_dynamic_equil - find (approx.) dynamic equilibrium near EFIT equilibrium gen_AW_m - generate anti-windup matrix for bumpless transfer get_std_plant - get standard plant objects A, B1, B2, C1, C2, D11, ... Hanus_cntlr - convert controller to Hanus conditioned controller. improve_cond - determine transformation which improves system cond'n linearize_vertcontrol - linearize the vertical_control_sim.mdl -> a,b,c,d make_command_sim make_z_cntl - make vertical control algorithm as implemented on DIII-D MRC - model reference control calculation phase - replaces matlab phase.m, doesn't require row vector input plot_d3d_sim_output- plot_sim_point - plot_simulink_shapes - EFIT type plots of SIMULINK simulation results polyadd - add two matlab polynomials of possibly different order ptnames_from_master read_design_file - read_gridsize_file - read file containing realtime efit grid sizes, locations read_response - reduce_model - reduce number of states in system model remove_algebraic - remove algebraic eqns from system (improve condition) rga - calculate relative gain array setup_simserver_run - create the initialization file needed for simserver run sysbal_trans - same as sysbal (muSYN), plus transformation matrices sysconnect - connect together systems sysinfo - get info on Control Toolbox system. sysmult - Multiply several systems together. vertpos_objects - matrices needed for vertical position model construction replicate_sys - get multiple copies of a system model rtefit_defns - rtefit data object size definitions transform_states - another version of ss2ss vert_cntl_model - Construct vertical control open-loop controller system. write_test_data write_MIMO_controller - write ascii file containing MIMO filter data write_MIMOcontroller4PCS - calls write_MIMO_controller","title":"Contents.m"},{"location":"function-guide/GAcontrol/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/GAcontrol/Contents_m/#basic-information","text":"Control design utility functions. analyze_Xpt approx_B bld_approx_vert_prop - Build reduced approx. to analog vertical control filters, proportional term version bld_approx_vert_noprop - Build reduced approx. to analog vertical control filters, no proportional term version bld_chopper_filter - build representation for chopper anti-alias filter bld_vertchoppers - build system model of choppers used in vertical control bodehz - same as bode but with Hz on x-axis, better plotting calc_ssop - Calc steady state values I0 and V0 compare_systems - compare frequency response of 2 system models controllability - calculate controllability matrix dbodehz - same as dbode but with Hz on x-axis, better plotting design_inner_loop_control - design inner loop controller diagnose_control - plot results of control (flux, Rx, Zx errors, etc.) final_states - compute final states for system with constant input u find_dynamic_equil - find (approx.) dynamic equilibrium near EFIT equilibrium gen_AW_m - generate anti-windup matrix for bumpless transfer get_std_plant - get standard plant objects A, B1, B2, C1, C2, D11, ... Hanus_cntlr - convert controller to Hanus conditioned controller. improve_cond - determine transformation which improves system cond'n linearize_vertcontrol - linearize the vertical_control_sim.mdl -> a,b,c,d make_command_sim make_z_cntl - make vertical control algorithm as implemented on DIII-D MRC - model reference control calculation phase - replaces matlab phase.m, doesn't require row vector input plot_d3d_sim_output- plot_sim_point - plot_simulink_shapes - EFIT type plots of SIMULINK simulation results polyadd - add two matlab polynomials of possibly different order ptnames_from_master read_design_file - read_gridsize_file - read file containing realtime efit grid sizes, locations read_response - reduce_model - reduce number of states in system model remove_algebraic - remove algebraic eqns from system (improve condition) rga - calculate relative gain array setup_simserver_run - create the initialization file needed for simserver run sysbal_trans - same as sysbal (muSYN), plus transformation matrices sysconnect - connect together systems sysinfo - get info on Control Toolbox system. sysmult - Multiply several systems together. vertpos_objects - matrices needed for vertical position model construction replicate_sys - get multiple copies of a system model rtefit_defns - rtefit data object size definitions transform_states - another version of ss2ss vert_cntl_model - Construct vertical control open-loop controller system. write_test_data write_MIMO_controller - write ascii file containing MIMO filter data write_MIMOcontroller4PCS - calls write_MIMO_controller","title":"Basic Information"},{"location":"function-guide/GAcontrol/Hanus_cntlr2_m/","text":"Hanus_cntlr2.m \u00b6 Basic Information \u00b6 SYNTAX: [AH,BH,CH,DH] = Hanus_cntlr2(Ac,Bc,Cc,Dc,refcols,meascols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. This version is different from the original in that inputs keep their same order. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous refcols = columns of input matrices (Bc,Dc) corresp. to references meascols = columns of input matrices (Bc,Dc) corresp. to measurements OUTPUT: AH,BH,CH,DH = Hanus controller RESTRICTIONS: This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987","title":"Hanus_cntlr2.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr2_m/#hanus_cntlr2m","text":"","title":"Hanus_cntlr2.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr2_m/#basic-information","text":"SYNTAX: [AH,BH,CH,DH] = Hanus_cntlr2(Ac,Bc,Cc,Dc,refcols,meascols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. This version is different from the original in that inputs keep their same order. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous refcols = columns of input matrices (Bc,Dc) corresp. to references meascols = columns of input matrices (Bc,Dc) corresp. to measurements OUTPUT: AH,BH,CH,DH = Hanus controller RESTRICTIONS: This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987","title":"Basic Information"},{"location":"function-guide/GAcontrol/Hanus_cntlr_m/","text":"Hanus_cntlr.m \u00b6 Basic Information \u00b6 SYNTAX: [AH,BH,CH,DH,Cr,Dr,Dinv] = Hanus_cntlr(Ac,Bc,Cc,Dc,refcols,meascols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous refcols = columns of input matrices (Bc,Dc) corresp. to references meascols = columns of input matrices (Bc,Dc) corresp. to measurements OUTPUT: AH,BH,CH,DH = Hanus controller system description Cr,Dr = output matrices which compute realizable reference (realizable ref.= Cr*[cntlr state] + Dr*[cntlr inputs] Note: no matter where reference signal comes into input controller, Hanus controller arranges inputs as [measurements, references, limited outputs] RESTRICTIONS: This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987","title":"Hanus_cntlr.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr_m/#hanus_cntlrm","text":"","title":"Hanus_cntlr.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr_m/#basic-information","text":"SYNTAX: [AH,BH,CH,DH,Cr,Dr,Dinv] = Hanus_cntlr(Ac,Bc,Cc,Dc,refcols,meascols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous refcols = columns of input matrices (Bc,Dc) corresp. to references meascols = columns of input matrices (Bc,Dc) corresp. to measurements OUTPUT: AH,BH,CH,DH = Hanus controller system description Cr,Dr = output matrices which compute realizable reference (realizable ref.= Cr*[cntlr state] + Dr*[cntlr inputs] Note: no matter where reference signal comes into input controller, Hanus controller arranges inputs as [measurements, references, limited outputs] RESTRICTIONS: This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987","title":"Basic Information"},{"location":"function-guide/GAcontrol/Hanus_cntlr_rev1_m/","text":"Hanus_cntlr_rev1.m \u00b6 Basic Information \u00b6 SYNTAX: [AH,BH,CH,DH,Cr,Dr,D1inv] = Hanus_cntlr(Ac,Bc,Cc,Dc,rcols,mcols,scols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous rcols = columns of input matrices (Bc,Dc) corresp. to references mcols = columns of input matrices (Bc,Dc) corresp. to measurements scols = columns of input matrices (Bc,Dc) corresp. to chosen subblock (scols must = first noutputs columns of Dc, where noutputs = number of outputs) OUTPUT: AH,BH,CH,DH = Hanus controller system description Cr,Dr = output matrices which compute realizable reference (realizable ref.= Cr*[cntlr state] + Dr*[cntlr inputs] Note: no matter where reference signal comes into input controller, Hanus controller arranges inputs as [measurements, references, limited outputs] RESTRICTIONS: This version is experimental. It inverts a square subblock of the full D matrix chosen by the user. Explain why somewhere.... Right now, only works for Dc which has more columns than rows, and scols must be first set of colums in Dc. This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987","title":"Hanus_cntlr_rev1.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr_rev1_m/#hanus_cntlr_rev1m","text":"","title":"Hanus_cntlr_rev1.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr_rev1_m/#basic-information","text":"SYNTAX: [AH,BH,CH,DH,Cr,Dr,D1inv] = Hanus_cntlr(Ac,Bc,Cc,Dc,rcols,mcols,scols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous rcols = columns of input matrices (Bc,Dc) corresp. to references mcols = columns of input matrices (Bc,Dc) corresp. to measurements scols = columns of input matrices (Bc,Dc) corresp. to chosen subblock (scols must = first noutputs columns of Dc, where noutputs = number of outputs) OUTPUT: AH,BH,CH,DH = Hanus controller system description Cr,Dr = output matrices which compute realizable reference (realizable ref.= Cr*[cntlr state] + Dr*[cntlr inputs] Note: no matter where reference signal comes into input controller, Hanus controller arranges inputs as [measurements, references, limited outputs] RESTRICTIONS: This version is experimental. It inverts a square subblock of the full D matrix chosen by the user. Explain why somewhere.... Right now, only works for Dc which has more columns than rows, and scols must be first set of colums in Dc. This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987","title":"Basic Information"},{"location":"function-guide/GAcontrol/MRC_m/","text":"MRC.m \u00b6 Basic Information \u00b6 SYNTAX: controller = MRC(plant,ref_model) PURPOSE: Model reference control calculation. Given a model of the plant and a model of the desired closed loop response, compute a feedback controller that gives that closed loop response. This code has been tested, but not extensively. INPUT: plant = SISO model of plant (Control Toolbox format) ref_model = SISO model of desired response (Control Toolbox format) OUTPUT: controller = derived controller in (CT format): inputs = [ref, measured], output = input to plant RESTRICTIONS: plant: Must be stable with no (closed) right half plane zeros. ref_model: Must be stable with no (closed) right half plane zeros and same relative degree as plant. METHOD: Based on algorithm for Model Reference Control in W.S.Levine, The Control Handbook, CRC press, 1996","title":"MRC.m"},{"location":"function-guide/GAcontrol/MRC_m/#mrcm","text":"","title":"MRC.m"},{"location":"function-guide/GAcontrol/MRC_m/#basic-information","text":"SYNTAX: controller = MRC(plant,ref_model) PURPOSE: Model reference control calculation. Given a model of the plant and a model of the desired closed loop response, compute a feedback controller that gives that closed loop response. This code has been tested, but not extensively. INPUT: plant = SISO model of plant (Control Toolbox format) ref_model = SISO model of desired response (Control Toolbox format) OUTPUT: controller = derived controller in (CT format): inputs = [ref, measured], output = input to plant RESTRICTIONS: plant: Must be stable with no (closed) right half plane zeros. ref_model: Must be stable with no (closed) right half plane zeros and same relative degree as plant. METHOD: Based on algorithm for Model Reference Control in W.S.Levine, The Control Handbook, CRC press, 1996","title":"Basic Information"},{"location":"function-guide/GAcontrol/analyze_Xpt_m/","text":"analyze_Xpt.m \u00b6 Basic Information \u00b6 SYNTAX: [rxpt,zxpt,figure_num] = ... analyze_Xpt(Psi0,BR0,BZ0,rgrid,zgrid,figure_num) PURPOSE: Locate X point using B-field on Xpoint grid. Optionally, make plots of flux and field with X point overlaid. INPUT: Psi0,BR0,BZ0 rgrid,zgrid figure_num = (optional, default = [] and no figures produced) OUTPUT: rxpt,zxpt = calculated x point (meters)","title":"analyze_Xpt.m"},{"location":"function-guide/GAcontrol/analyze_Xpt_m/#analyze_xptm","text":"","title":"analyze_Xpt.m"},{"location":"function-guide/GAcontrol/analyze_Xpt_m/#basic-information","text":"SYNTAX: [rxpt,zxpt,figure_num] = ... analyze_Xpt(Psi0,BR0,BZ0,rgrid,zgrid,figure_num) PURPOSE: Locate X point using B-field on Xpoint grid. Optionally, make plots of flux and field with X point overlaid. INPUT: Psi0,BR0,BZ0 rgrid,zgrid figure_num = (optional, default = [] and no figures produced) OUTPUT: rxpt,zxpt = calculated x point (meters)","title":"Basic Information"},{"location":"function-guide/GAcontrol/approx_B_m/","text":"approx_B.m \u00b6 Basic Information \u00b6 SYNTAX: [figure_num] = approx_B(Psi0,BR0,BZ0,rgrid,zgrid,figure_num) PURPOSE: Compare BR0 and BZ0 on X point grid with approximation derived from Psi0 on X point grid. INPUT: Psi0 = flux on X point grid BR0 = Br on X point grid BZ0 = Bz on X point grid rgrid = r coordinates of Xpoint grid zgrid = z coordinates of Xpoint grid figure_num = last figure plotted Psi0,BR0,BZ0 all stored in vector (length nrb*nzb) form OUTPUT: figure_num = last figure plotted (updated for figures produced here) RESTRICTIONS: ASSUMES grid intervals of 3 cm in both r and z.","title":"approx_B.m"},{"location":"function-guide/GAcontrol/approx_B_m/#approx_bm","text":"","title":"approx_B.m"},{"location":"function-guide/GAcontrol/approx_B_m/#basic-information","text":"SYNTAX: [figure_num] = approx_B(Psi0,BR0,BZ0,rgrid,zgrid,figure_num) PURPOSE: Compare BR0 and BZ0 on X point grid with approximation derived from Psi0 on X point grid. INPUT: Psi0 = flux on X point grid BR0 = Br on X point grid BZ0 = Bz on X point grid rgrid = r coordinates of Xpoint grid zgrid = z coordinates of Xpoint grid figure_num = last figure plotted Psi0,BR0,BZ0 all stored in vector (length nrb*nzb) form OUTPUT: figure_num = last figure plotted (updated for figures produced here) RESTRICTIONS: ASSUMES grid intervals of 3 cm in both r and z.","title":"Basic Information"},{"location":"function-guide/GAcontrol/bodehz_m/","text":"bodehz.m \u00b6 Basic Information \u00b6 SYNTAX: [mag,phi,wout] = bodehz(a,b,c,d,iu,w) PURPOSE: Bode frequency response for continuous-time linear systems. BODE(A,B,C,D,IU) produces a Bode plot from the single input IU to all the outputs of the continuous state-space system (A,B,C,D). IU is an index into the inputs of the system and specifies which input to use for the Bode response. The frequency range and number of points are chosen automatically. INPUT: a,b,c,d = system matrices iu = input number w = frequencies at which to calculate/plot freq. response (Hz) OUTPUT: bode plot of system, frequency in Hz (if no outputs specified) mag = magnitude of gain phi = phase lag (degrees) wout = frequencies (Hz) of mag, phi RESTRICTIONS: METHOD: Uses matlab bode function (which has CRAPPY defaults) See Also \u00b6 dbodehz References \u00b6 User Guide","title":"bodehz.m"},{"location":"function-guide/GAcontrol/bodehz_m/#bodehzm","text":"","title":"bodehz.m"},{"location":"function-guide/GAcontrol/bodehz_m/#basic-information","text":"SYNTAX: [mag,phi,wout] = bodehz(a,b,c,d,iu,w) PURPOSE: Bode frequency response for continuous-time linear systems. BODE(A,B,C,D,IU) produces a Bode plot from the single input IU to all the outputs of the continuous state-space system (A,B,C,D). IU is an index into the inputs of the system and specifies which input to use for the Bode response. The frequency range and number of points are chosen automatically. INPUT: a,b,c,d = system matrices iu = input number w = frequencies at which to calculate/plot freq. response (Hz) OUTPUT: bode plot of system, frequency in Hz (if no outputs specified) mag = magnitude of gain phi = phase lag (degrees) wout = frequencies (Hz) of mag, phi RESTRICTIONS: METHOD: Uses matlab bode function (which has CRAPPY defaults)","title":"Basic Information"},{"location":"function-guide/GAcontrol/bodehz_m/#see-also","text":"dbodehz","title":"See Also"},{"location":"function-guide/GAcontrol/bodehz_m/#references","text":"User Guide","title":"References"},{"location":"function-guide/GAcontrol/compare_sv_m/","text":"compare_sv.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: Make comparison plots of specified open-loop singular values vs. achieved open loop singular values in NCF design. INPUT: wtd_plant = weighted plant WR*G*WL controller = controller constructed by ncfsyn omega = frequencies (rad/sec) at which to evaluate singular values figure_num = current figure number OUTPUT: plots of singular values of specified vs achieved open-loop system new_figure = updated current figure number RESTRICTIONS: METHOD: WRITTEN BY: Mike Walker ON 11/22/96","title":"compare_sv.m"},{"location":"function-guide/GAcontrol/compare_sv_m/#compare_svm","text":"","title":"compare_sv.m"},{"location":"function-guide/GAcontrol/compare_sv_m/#basic-information","text":"SYNTAX: PURPOSE: Make comparison plots of specified open-loop singular values vs. achieved open loop singular values in NCF design. INPUT: wtd_plant = weighted plant WR*G*WL controller = controller constructed by ncfsyn omega = frequencies (rad/sec) at which to evaluate singular values figure_num = current figure number OUTPUT: plots of singular values of specified vs achieved open-loop system new_figure = updated current figure number RESTRICTIONS: METHOD: WRITTEN BY: Mike Walker ON 11/22/96","title":"Basic Information"},{"location":"function-guide/GAcontrol/compare_systems_m/","text":"compare_systems.m \u00b6 Basic Information \u00b6 SYNTAX: [figure_num,mag1,phi1,mag2,phi2,f]= ... compare_systems(system1, system2, figure_num, f) PURPOSE: Compare input-output response of MIMO systems. Overlays bode plots of 2 MIMO systems, 1-input and 1-output at a time to see if they represent approximately the same input-output system. INPUT: system1 = first system, in Control Toolbox system format system2 = second system, in Control Toolbox system format figure_num = (optional) next figure number in sequence f = frequency points(Hz) to plot bode plots at (optional, default is f=w/(2*pi), with w calculated by bode function) OUTPUT: figure_num = next figure number in sequence mag1,phi1 = frequency response for system 1, last input being viewed mag2,phi2 = frequency response for system 2, last input being viewed f = frequencies (Hz) corresponding to magi, phii RESTRICTIONS: system1 and system2 must have the same number of inputs and the same number of outputs.","title":"compare_systems.m"},{"location":"function-guide/GAcontrol/compare_systems_m/#compare_systemsm","text":"","title":"compare_systems.m"},{"location":"function-guide/GAcontrol/compare_systems_m/#basic-information","text":"SYNTAX: [figure_num,mag1,phi1,mag2,phi2,f]= ... compare_systems(system1, system2, figure_num, f) PURPOSE: Compare input-output response of MIMO systems. Overlays bode plots of 2 MIMO systems, 1-input and 1-output at a time to see if they represent approximately the same input-output system. INPUT: system1 = first system, in Control Toolbox system format system2 = second system, in Control Toolbox system format figure_num = (optional) next figure number in sequence f = frequency points(Hz) to plot bode plots at (optional, default is f=w/(2*pi), with w calculated by bode function) OUTPUT: figure_num = next figure number in sequence mag1,phi1 = frequency response for system 1, last input being viewed mag2,phi2 = frequency response for system 2, last input being viewed f = frequencies (Hz) corresponding to magi, phii RESTRICTIONS: system1 and system2 must have the same number of inputs and the same number of outputs.","title":"Basic Information"},{"location":"function-guide/GAcontrol/condition_ABCD_m/","text":"condition_ABCD.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate condition of the system block matrix A | B --------- C | D with state transformed by T=diag(Tdiag). For use with fminu in improve_cond.m INPUT: A,B,C,D = system model Tdiag = vector containing diagonal of state transformation matrix T OUTPUT: condition = condition number of transformed system RESTRICTIONS: METHOD: WRITTEN BY: Mike Walker ON ??/94 Copyright 1994 General Atomics. Unpublished - rights reserved under the Copyright Laws of the United States.","title":"condition_ABCD.m"},{"location":"function-guide/GAcontrol/condition_ABCD_m/#condition_abcdm","text":"","title":"condition_ABCD.m"},{"location":"function-guide/GAcontrol/condition_ABCD_m/#basic-information","text":"PURPOSE: Calculate condition of the system block matrix A | B --------- C | D with state transformed by T=diag(Tdiag). For use with fminu in improve_cond.m INPUT: A,B,C,D = system model Tdiag = vector containing diagonal of state transformation matrix T OUTPUT: condition = condition number of transformed system RESTRICTIONS: METHOD: WRITTEN BY: Mike Walker ON ??/94 Copyright 1994 General Atomics. Unpublished - rights reserved under the Copyright Laws of the United States.","title":"Basic Information"},{"location":"function-guide/GAcontrol/condition_A_m/","text":"condition_A.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate condition of system A matrix with state transformed by T=diag(Tdiag). For use with fminu in improve_cond.m. INPUT: A,B,C,D = system model Tdiag = vector containing diagonal of state transformation matrix T OUTPUT: condition = condition number of transformed A matrix RESTRICTIONS: METHOD: WRITTEN BY: Mike Walker ON ??/94 Copyright 1994 General Atomics. Unpublished - rights reserved under the Copyright Laws of the United States.","title":"condition_A.m"},{"location":"function-guide/GAcontrol/condition_A_m/#condition_am","text":"","title":"condition_A.m"},{"location":"function-guide/GAcontrol/condition_A_m/#basic-information","text":"PURPOSE: Calculate condition of system A matrix with state transformed by T=diag(Tdiag). For use with fminu in improve_cond.m. INPUT: A,B,C,D = system model Tdiag = vector containing diagonal of state transformation matrix T OUTPUT: condition = condition number of transformed A matrix RESTRICTIONS: METHOD: WRITTEN BY: Mike Walker ON ??/94 Copyright 1994 General Atomics. Unpublished - rights reserved under the Copyright Laws of the United States.","title":"Basic Information"},{"location":"function-guide/GAcontrol/controllability_m/","text":"controllability.m \u00b6 Basic Information \u00b6 SYNTAX: [CC,nn,perp] = controllability(a,b,c,d,figure_num) PURPOSE: Calculate controllability matrix of a system. INPUT: a,b,c,d = system matrices figure_num = figure number on which to plot singular values of CC (optional, plot is produced only if this number is given) OUTPUT: CC = controllability matrix nn = nullspace of CC' (Anything in nn cannot be reached by the system [a,b,c,d] - See Kailath, Example 2.5-1.) perp = perp of nullspace of CC = \"reachable subspace\"","title":"controllability.m"},{"location":"function-guide/GAcontrol/controllability_m/#controllabilitym","text":"","title":"controllability.m"},{"location":"function-guide/GAcontrol/controllability_m/#basic-information","text":"SYNTAX: [CC,nn,perp] = controllability(a,b,c,d,figure_num) PURPOSE: Calculate controllability matrix of a system. INPUT: a,b,c,d = system matrices figure_num = figure number on which to plot singular values of CC (optional, plot is produced only if this number is given) OUTPUT: CC = controllability matrix nn = nullspace of CC' (Anything in nn cannot be reached by the system [a,b,c,d] - See Kailath, Example 2.5-1.) perp = perp of nullspace of CC = \"reachable subspace\"","title":"Basic Information"},{"location":"function-guide/GAcontrol/dbodehz_m/","text":"dbodehz.m \u00b6 Basic Information \u00b6 SYNTAX: [mag,phi,wout] = dbodehz(a,b,c,d,dt,iu,w) PURPOSE: Bode frequency response for continuous-time linear systems. BODE(A,B,C,D,dt,IU) produces a Bode plot from the single input IU to all the outputs of the continuous state-space system (A,B,C,D). IU is an index into the inputs of the system and specifies which input to use for the Bode response. The frequency range and number of points are chosen automatically. INPUT: a,b,c,d = system matrices dt = sample time of discrete system iu = input number w = frequencies at which to calculate/plot freq. response (Hz) OUTPUT: bode plot of system, frequency in Hz mag = magnitude of gain phi = phase lag (degrees) wout = frequencies (Hz) of mag, phi RESTRICTIONS: METHOD: Uses matlab dbode function (which has CRAPPY defaults) See Also \u00b6 bodehz References \u00b6 User Guide","title":"dbodehz.m"},{"location":"function-guide/GAcontrol/dbodehz_m/#dbodehzm","text":"","title":"dbodehz.m"},{"location":"function-guide/GAcontrol/dbodehz_m/#basic-information","text":"SYNTAX: [mag,phi,wout] = dbodehz(a,b,c,d,dt,iu,w) PURPOSE: Bode frequency response for continuous-time linear systems. BODE(A,B,C,D,dt,IU) produces a Bode plot from the single input IU to all the outputs of the continuous state-space system (A,B,C,D). IU is an index into the inputs of the system and specifies which input to use for the Bode response. The frequency range and number of points are chosen automatically. INPUT: a,b,c,d = system matrices dt = sample time of discrete system iu = input number w = frequencies at which to calculate/plot freq. response (Hz) OUTPUT: bode plot of system, frequency in Hz mag = magnitude of gain phi = phase lag (degrees) wout = frequencies (Hz) of mag, phi RESTRICTIONS: METHOD: Uses matlab dbode function (which has CRAPPY defaults)","title":"Basic Information"},{"location":"function-guide/GAcontrol/dbodehz_m/#see-also","text":"bodehz","title":"See Also"},{"location":"function-guide/GAcontrol/dbodehz_m/#references","text":"User Guide","title":"References"},{"location":"function-guide/GAcontrol/final_states_m/","text":"final_states.m \u00b6 Basic Information \u00b6 SYNTAX: [x,y,resid] = final_states(A,B,C,D,u) PURPOSE: Compute final states for system with constant input u. INPUT: A,B,C,D = system matrices u = (constant) input vector OUTPUT: x = states of system y = steady state output with input u resid = residual error (LHS*x - RHS)","title":"final_states.m"},{"location":"function-guide/GAcontrol/final_states_m/#final_statesm","text":"","title":"final_states.m"},{"location":"function-guide/GAcontrol/final_states_m/#basic-information","text":"SYNTAX: [x,y,resid] = final_states(A,B,C,D,u) PURPOSE: Compute final states for system with constant input u. INPUT: A,B,C,D = system matrices u = (constant) input vector OUTPUT: x = states of system y = steady state output with input u resid = residual error (LHS*x - RHS)","title":"Basic Information"},{"location":"function-guide/GAcontrol/find_x_point_m/","text":"find_x_point.m \u00b6 Basic Information \u00b6 SYNTAX: [dr,dz,drm,dzm,px] = find_x_point(pe,bre,bze,brepr, ... bzepr,brepz,bzepz,rm,delta_r,delta_z,rsign,zsign) PURPOSE: Calculates X point location by linear expansion about a grid point in the X point grid. INPUT: pe = flux at expansion point bre = br at expansion point bze = bz at expansion point brepr = br at expansion point + one step in r bzepr = bz at expansion point + one step in r brepz = br at expansion point + one step in z bzepz = bz at expansion point + one step in z rm = r coordinate of expansion pt in meters delta_r = distance between X point grids in radial direction (m) delta_z = distance between X point grids in vertical direction (m) rsign = direction of one step in r zsign = direction of one step in z OUTPUT: dr,dz = displacement of X pt from expansion pt (units of grid spacings) drm,dzm = displacement of X point in meters px = estimated flux at the X point","title":"find_x_point.m"},{"location":"function-guide/GAcontrol/find_x_point_m/#find_x_pointm","text":"","title":"find_x_point.m"},{"location":"function-guide/GAcontrol/find_x_point_m/#basic-information","text":"SYNTAX: [dr,dz,drm,dzm,px] = find_x_point(pe,bre,bze,brepr, ... bzepr,brepz,bzepz,rm,delta_r,delta_z,rsign,zsign) PURPOSE: Calculates X point location by linear expansion about a grid point in the X point grid. INPUT: pe = flux at expansion point bre = br at expansion point bze = bz at expansion point brepr = br at expansion point + one step in r bzepr = bz at expansion point + one step in r brepz = br at expansion point + one step in z bzepz = bz at expansion point + one step in z rm = r coordinate of expansion pt in meters delta_r = distance between X point grids in radial direction (m) delta_z = distance between X point grids in vertical direction (m) rsign = direction of one step in r zsign = direction of one step in z OUTPUT: dr,dz = displacement of X pt from expansion pt (units of grid spacings) drm,dzm = displacement of X point in meters px = estimated flux at the X point","title":"Basic Information"},{"location":"function-guide/GAcontrol/gen_AW_m_m/","text":"gen_AW_m.m \u00b6 Basic Information \u00b6 SYNTAX: AW_m=gen_AW_m(Ad,Bd,c) PURPOSE: Generate antiwindup matrix, for bumpless transfer. INPUT: Ad, Bd = A,B matrices for A,B,C,D controller being switched to. c = number of powers of Ad to add for \"wind-on\". If c=-1, then c is computed using gamma=max(real(eig(Ad))) (must have |gamma|<1) (optional, default is c=size(Ad,1)) OUTPUT: AW_m = antiwindup matrix - apply to error at transition to \"wind-on\" the new controller","title":"gen_AW_m.m"},{"location":"function-guide/GAcontrol/gen_AW_m_m/#gen_aw_mm","text":"","title":"gen_AW_m.m"},{"location":"function-guide/GAcontrol/gen_AW_m_m/#basic-information","text":"SYNTAX: AW_m=gen_AW_m(Ad,Bd,c) PURPOSE: Generate antiwindup matrix, for bumpless transfer. INPUT: Ad, Bd = A,B matrices for A,B,C,D controller being switched to. c = number of powers of Ad to add for \"wind-on\". If c=-1, then c is computed using gamma=max(real(eig(Ad))) (must have |gamma|<1) (optional, default is c=size(Ad,1)) OUTPUT: AW_m = antiwindup matrix - apply to error at transition to \"wind-on\" the new controller","title":"Basic Information"},{"location":"function-guide/GAcontrol/improve_cond_m/","text":"improve_cond.m \u00b6 Basic Information \u00b6 SYNTAX: [T,condition] = improve_cond(A,B,C,D,condition_fn,old_T,n_iterations) PURPOSE: Improve the condition of the system through a state transformation T, where condition is defined by condition_fn. For example, condition of A or condition of the block A | B --------- C | D INPUT: A,B,C,D = system to improve condition for condition_fn = string = function to return a condition number (e.g. containing cond(A); see condition_A.m and condition_ABCD.m for examples.) old_T = square matrix (size A) = initial value for T (optional) n_iterations = max number of iterations in fmin u OUTPUT: T = state transformation which give minimum value of condition condition = value of condition achieved","title":"improve_cond.m"},{"location":"function-guide/GAcontrol/improve_cond_m/#improve_condm","text":"","title":"improve_cond.m"},{"location":"function-guide/GAcontrol/improve_cond_m/#basic-information","text":"SYNTAX: [T,condition] = improve_cond(A,B,C,D,condition_fn,old_T,n_iterations) PURPOSE: Improve the condition of the system through a state transformation T, where condition is defined by condition_fn. For example, condition of A or condition of the block A | B --------- C | D INPUT: A,B,C,D = system to improve condition for condition_fn = string = function to return a condition number (e.g. containing cond(A); see condition_A.m and condition_ABCD.m for examples.) old_T = square matrix (size A) = initial value for T (optional) n_iterations = max number of iterations in fmin u OUTPUT: T = state transformation which give minimum value of condition condition = value of condition achieved","title":"Basic Information"},{"location":"function-guide/GAcontrol/plot_simulink_shapes_m/","text":"plot_simulink_shapes.m \u00b6 Basic Information \u00b6 SYNTAX: plot_simulink_shapes PURPOSE: Plot results of SIMULINK simulations which use the S-file sim_Xpt2.c in an EFIT type contour plot. INPUT: algorithm = one of 'isosnull', 'isousnull', or 'isodnull' filename = g0 file containing equilibrium around which plant model was created tstart = first time to plot simulated boundary (seconds), default 0.0 stepsize = steps for boundary plots (seconds), default 0.01s plot_geometry = set to 1 to plot D3d geometry around equil. (default 0) axis_to_show = plot range to show = argument to axis function (optional, default = [1 2.3 -1.4 1.4] figure_num (generated by simulink simulation and its setup process): time_sim0 = output of simulink model nsegments Xpt_sim tgt_sim simXpt2_flux_sim OUTPUT: plot - Steps through multiple time slices: - shows yellow x on control segments where flux = Xpt flux - connects yellow line between these x's and to Xpt. - shows yellow * for location of magnetic axis (location is updated for z coordinate, r coordinate is assumed fixed) - shows target points with red + - original equilibrium shown in white (with mag axis = x) figure_num RESTRICTIONS: (1) requires g0* file exist METHOD: The flux on each control segment at time t is approximated by adding the flux on the segment at equilibrium to the change in flux of the chosen control point (on that segment) from equilibrium. Then the point on the segment whose flux is closest to the Xpt flux value at time t is used to define the boundary location at time t.","title":"plot_simulink_shapes.m"},{"location":"function-guide/GAcontrol/plot_simulink_shapes_m/#plot_simulink_shapesm","text":"","title":"plot_simulink_shapes.m"},{"location":"function-guide/GAcontrol/plot_simulink_shapes_m/#basic-information","text":"SYNTAX: plot_simulink_shapes PURPOSE: Plot results of SIMULINK simulations which use the S-file sim_Xpt2.c in an EFIT type contour plot. INPUT: algorithm = one of 'isosnull', 'isousnull', or 'isodnull' filename = g0 file containing equilibrium around which plant model was created tstart = first time to plot simulated boundary (seconds), default 0.0 stepsize = steps for boundary plots (seconds), default 0.01s plot_geometry = set to 1 to plot D3d geometry around equil. (default 0) axis_to_show = plot range to show = argument to axis function (optional, default = [1 2.3 -1.4 1.4] figure_num (generated by simulink simulation and its setup process): time_sim0 = output of simulink model nsegments Xpt_sim tgt_sim simXpt2_flux_sim OUTPUT: plot - Steps through multiple time slices: - shows yellow x on control segments where flux = Xpt flux - connects yellow line between these x's and to Xpt. - shows yellow * for location of magnetic axis (location is updated for z coordinate, r coordinate is assumed fixed) - shows target points with red + - original equilibrium shown in white (with mag axis = x) figure_num RESTRICTIONS: (1) requires g0* file exist METHOD: The flux on each control segment at time t is approximated by adding the flux on the segment at equilibrium to the change in flux of the chosen control point (on that segment) from equilibrium. Then the point on the segment whose flux is closest to the Xpt flux value at time t is used to define the boundary location at time t.","title":"Basic Information"},{"location":"function-guide/GAcontrol/qpmpclti2d_m/","text":"qpmpclti2d.m \u00b6 Basic Information \u00b6 function rep=qpmpclti2d(P,utyp,udim,solverstr,solveropts) Basic discrete-time MPC quadratic program solver for LTI systems. Time-varying reference trajectory and particular time-varying constraints are supported. Solves the same problem as does qpmpclti2c, also uses condensing, but optimizes/reduces block matrix operations further. utyp = 'pwc' (piecewise constant) utyp = 'pwl' (piecewise linear) utyp = 'impulse' (udim ignored, no reduction of input) (TODO: B-spline support) (TODO: allow the insertion of a terminal cost Qxn) (TODO: support soft constraints) udim = # nodes for control downgrading < P.n solverstr = 'quadprog' (Optimization Toolbox required). solverstr = 'pdipmqpneq' (Stand-alone plain matlab QP solver) solverstr = 'pdipmqpneq2' (uses a different stop condition) solverstr = 'pdipmqpneq3' (improved initial condition, possibly) solverstr = 'pdipmqpi.c' (MEX file compiled from C-code pdipmqpi.c) solverstr = 'admmqpneq1' (TO BE ALLOWED SOON) solveropts (optional) is a struct with fields ipm_maxiters and ipm_epsstop that can adjust the solution convergence requirements. The specific MPC problem solved is this: min sum_(i=0)^(n) (e(i)'*W*e(i)+u(i)'*R*u(i)+x(i)'*Qx*x(i)) s.t. x(i+1)=A*x(i)+B*u(i)+w(i), i = 0..n-1 y(i)=C*x(i)+D*u(i), e(i)=y(i)-r(i), i=0..n F1*x(i)+F2*u(i)<=f3(i), i=0..n x(0)=x where u(i) is constrained as either piecewise constant or piecewise linear with udim nodes, equidistributed over the horizon n. This is a quadratic program. W,Qx,R must form a pos. def. cost function. r(i) is a reference trajectory, f3(i) can be used for (simple) time-varying constraint formulations. The inequality constraint must not be omitted. (A,B,C,D) is a discrete time LTI system. If C is empty then neither of D,W,r are considered in the cost function. r can be given as an (n+1)-by-ny matrix, or an ny-by-(n+1)-matrix, or a column vector of length ny (not time-varying). f3 analogous to r, but with size nq instead, nq = #(col) of F1 (and F2). Also, w analogous but with dimension nx and n instead. W, R, and Qx can be given as column vectors (they will be expanded to diagonal matrices internally in that case). A scalar will also be expanded to a scaling of the identity matrix. The solution is a trajectory (x(i),u(i)) for i=0..n. Only the first control sample u(0) would typically be used (returned as rep.u0).","title":"qpmpclti2d.m"},{"location":"function-guide/GAcontrol/qpmpclti2d_m/#qpmpclti2dm","text":"","title":"qpmpclti2d.m"},{"location":"function-guide/GAcontrol/qpmpclti2d_m/#basic-information","text":"function rep=qpmpclti2d(P,utyp,udim,solverstr,solveropts) Basic discrete-time MPC quadratic program solver for LTI systems. Time-varying reference trajectory and particular time-varying constraints are supported. Solves the same problem as does qpmpclti2c, also uses condensing, but optimizes/reduces block matrix operations further. utyp = 'pwc' (piecewise constant) utyp = 'pwl' (piecewise linear) utyp = 'impulse' (udim ignored, no reduction of input) (TODO: B-spline support) (TODO: allow the insertion of a terminal cost Qxn) (TODO: support soft constraints) udim = # nodes for control downgrading < P.n solverstr = 'quadprog' (Optimization Toolbox required). solverstr = 'pdipmqpneq' (Stand-alone plain matlab QP solver) solverstr = 'pdipmqpneq2' (uses a different stop condition) solverstr = 'pdipmqpneq3' (improved initial condition, possibly) solverstr = 'pdipmqpi.c' (MEX file compiled from C-code pdipmqpi.c) solverstr = 'admmqpneq1' (TO BE ALLOWED SOON) solveropts (optional) is a struct with fields ipm_maxiters and ipm_epsstop that can adjust the solution convergence requirements. The specific MPC problem solved is this: min sum_(i=0)^(n) (e(i)'*W*e(i)+u(i)'*R*u(i)+x(i)'*Qx*x(i)) s.t. x(i+1)=A*x(i)+B*u(i)+w(i), i = 0..n-1 y(i)=C*x(i)+D*u(i), e(i)=y(i)-r(i), i=0..n F1*x(i)+F2*u(i)<=f3(i), i=0..n x(0)=x where u(i) is constrained as either piecewise constant or piecewise linear with udim nodes, equidistributed over the horizon n. This is a quadratic program. W,Qx,R must form a pos. def. cost function. r(i) is a reference trajectory, f3(i) can be used for (simple) time-varying constraint formulations. The inequality constraint must not be omitted. (A,B,C,D) is a discrete time LTI system. If C is empty then neither of D,W,r are considered in the cost function. r can be given as an (n+1)-by-ny matrix, or an ny-by-(n+1)-matrix, or a column vector of length ny (not time-varying). f3 analogous to r, but with size nq instead, nq = #(col) of F1 (and F2). Also, w analogous but with dimension nx and n instead. W, R, and Qx can be given as column vectors (they will be expanded to diagonal matrices internally in that case). A scalar will also be expanded to a scaling of the identity matrix. The solution is a trajectory (x(i),u(i)) for i=0..n. Only the first control sample u(0) would typically be used (returned as rep.u0).","title":"Basic Information"},{"location":"function-guide/GAcontrol/remove_algebraic_m/","text":"remove_algebraic.m \u00b6 Basic Information \u00b6 SYNTAX: [A1,B1,C1,D1,E1,T,K] = remove_algebraic(A,B,C,D,E,condn) PURPOSE: Remove algebraic relationships from a system in descriptor form: E dx/dt = Ax + Bu y = Cx + Du for 2 cases: (1) where a row of E is identically 0. (2) where E = identity INPUT: A,B,C,D,E = descriptor system with (possible) algebraic relation (E is optional, default = identity) condn = set = 1 to improve system condition as well as remove algebraic, set = 0 to only remove algebraic (optional, default=1) OUTPUT: A1,B1,C1,D1,E1 = descriptor system with algebraic relation removed T = state transformation matrix: x = T*x1, where x1 is new state vector K = If E~=identity, matrix describing algebraic relationship: states removed = K * (remaining states) If E==identity, K = indices of states deleted from x1 RESTRICTIONS: This routine is not truly general purpose yet. Needs to be extended to the case where a row of E can be brought to 0 using elementary operations.","title":"remove_algebraic.m"},{"location":"function-guide/GAcontrol/remove_algebraic_m/#remove_algebraicm","text":"","title":"remove_algebraic.m"},{"location":"function-guide/GAcontrol/remove_algebraic_m/#basic-information","text":"SYNTAX: [A1,B1,C1,D1,E1,T,K] = remove_algebraic(A,B,C,D,E,condn) PURPOSE: Remove algebraic relationships from a system in descriptor form: E dx/dt = Ax + Bu y = Cx + Du for 2 cases: (1) where a row of E is identically 0. (2) where E = identity INPUT: A,B,C,D,E = descriptor system with (possible) algebraic relation (E is optional, default = identity) condn = set = 1 to improve system condition as well as remove algebraic, set = 0 to only remove algebraic (optional, default=1) OUTPUT: A1,B1,C1,D1,E1 = descriptor system with algebraic relation removed T = state transformation matrix: x = T*x1, where x1 is new state vector K = If E~=identity, matrix describing algebraic relationship: states removed = K * (remaining states) If E==identity, K = indices of states deleted from x1 RESTRICTIONS: This routine is not truly general purpose yet. Needs to be extended to the case where a row of E can be brought to 0 using elementary operations.","title":"Basic Information"},{"location":"function-guide/GAcontrol/rga_m/","text":"rga.m \u00b6 Basic Information \u00b6 RGA Relative Gain Array R=rga(G) returns the Relative Gain Array, R based on the gain matrix, G. For square matrix, G, R is the normal RGA, defined as follows: R = inv(G') .* G If G is nonsquare, R is the so called General RGA: R = pinv(G') .* G The RGA is a very useful tool for control structure design. For a square system (the number of inputs equals to the number of output), the RGA can be used to find input-output pairs (one input to control one output). There are many publications on how to pair input and output using the RGA. The basic rule is: 1. Avoid input and output pairs which have negative relative gains. 2. Avoid input and output pairs which have large relative gains. 3. Select input and output pairs which have the relative gain close to 1. Interestingly, if the RGA is repeatedly calculated based on R, i.e. R = rga(R); Eventualy, the RGA will converge to a selection (0,1)-matrix. With the second output, [R,S] = rga(G) produces a selection matrix, S based on the repeated RGA. where S is (0,1) matrix with the same dimension as G. Each row and each column of S have only one element of 1, but all others are 0. The element of 1 indicates which input (column) should be used to pair which output (row). Note: The selection matrix, S, is only a recommendation. It may not satisfy the rules stated above and may not be appropriate for some systems. For nonsquare systems, the general RGA can also be used to select inputs if the number of inputs is larger than the number of outputs, or to choose outputs, if the system has more outputs than inputs. The second output in this case gives the input (output) effectiveness, E. [R,E] = rga(G) Where E is a column vector corresponding to the input (output). Inputs (outputs) with largest input (output) effectiveness are recommented to be selected for the control system.","title":"rga.m"},{"location":"function-guide/GAcontrol/rga_m/#rgam","text":"","title":"rga.m"},{"location":"function-guide/GAcontrol/rga_m/#basic-information","text":"RGA Relative Gain Array R=rga(G) returns the Relative Gain Array, R based on the gain matrix, G. For square matrix, G, R is the normal RGA, defined as follows: R = inv(G') .* G If G is nonsquare, R is the so called General RGA: R = pinv(G') .* G The RGA is a very useful tool for control structure design. For a square system (the number of inputs equals to the number of output), the RGA can be used to find input-output pairs (one input to control one output). There are many publications on how to pair input and output using the RGA. The basic rule is: 1. Avoid input and output pairs which have negative relative gains. 2. Avoid input and output pairs which have large relative gains. 3. Select input and output pairs which have the relative gain close to 1. Interestingly, if the RGA is repeatedly calculated based on R, i.e. R = rga(R); Eventualy, the RGA will converge to a selection (0,1)-matrix. With the second output, [R,S] = rga(G) produces a selection matrix, S based on the repeated RGA. where S is (0,1) matrix with the same dimension as G. Each row and each column of S have only one element of 1, but all others are 0. The element of 1 indicates which input (column) should be used to pair which output (row). Note: The selection matrix, S, is only a recommendation. It may not satisfy the rules stated above and may not be appropriate for some systems. For nonsquare systems, the general RGA can also be used to select inputs if the number of inputs is larger than the number of outputs, or to choose outputs, if the system has more outputs than inputs. The second output in this case gives the input (output) effectiveness, E. [R,E] = rga(G) Where E is a column vector corresponding to the input (output). Inputs (outputs) with largest input (output) effectiveness are recommented to be selected for the control system.","title":"Basic Information"},{"location":"function-guide/GAcontrol/seg_error_name_m/","text":"seg_error_name.m \u00b6 Basic Information \u00b6 SYNTAX: ptname = seg_error_name(algorithm,error) PURPOSE: Returns the ptname for the error'th segment when specified algorithm is used. INPUT: algorithm = one of 'isosnull', 'isodnull', 'isousnull', or 'equilibrium' error = one of 'br1', 'br2', 'bz1', 'bz2', or an (integer) segment number OUTPUT: ptname","title":"seg_error_name.m"},{"location":"function-guide/GAcontrol/seg_error_name_m/#seg_error_namem","text":"","title":"seg_error_name.m"},{"location":"function-guide/GAcontrol/seg_error_name_m/#basic-information","text":"SYNTAX: ptname = seg_error_name(algorithm,error) PURPOSE: Returns the ptname for the error'th segment when specified algorithm is used. INPUT: algorithm = one of 'isosnull', 'isodnull', 'isousnull', or 'equilibrium' error = one of 'br1', 'br2', 'bz1', 'bz2', or an (integer) segment number OUTPUT: ptname","title":"Basic Information"},{"location":"function-guide/GAcontrol/sysbal_trans_m/","text":"sysbal_trans.m \u00b6 Basic Information \u00b6 SYNTAX: [sysout,sig,Tleft,Tright] = sysbal_trans(sys,tol) PURPOSE: Does same work as sysbal, plus provides the transformation matrices for the resulting state space change of coordinates. Finds a truncated balanced realization of the system state-space model. Eigenvalues of A must have negative real part. The result is truncated to retain all Hankel- singular values greater than TOL. If TOL is omitted then it is set to max(sig(1)*1.0E-12,1.0E-16). INPUT: sys = system (muSYN packed) to balance/reduce OUTPUT: sysout = balanced/reduced system sig = Hankel singular values Tleft,Tright = matrices which multiply original A0,B0,C0 so that new system (sysout) is constructed by change of coordinates + truncation A1 = Tleft*A0*Tright, B1 = Tleft*B0, C1 = C0*Tright See also: HANKMR, REORDSYS, FRWTBAL, SFRWTBLD, SNCFBAL, SRELBAL, SRESID, SVD, and TRUNC.","title":"sysbal_trans.m"},{"location":"function-guide/GAcontrol/sysbal_trans_m/#sysbal_transm","text":"","title":"sysbal_trans.m"},{"location":"function-guide/GAcontrol/sysbal_trans_m/#basic-information","text":"SYNTAX: [sysout,sig,Tleft,Tright] = sysbal_trans(sys,tol) PURPOSE: Does same work as sysbal, plus provides the transformation matrices for the resulting state space change of coordinates. Finds a truncated balanced realization of the system state-space model. Eigenvalues of A must have negative real part. The result is truncated to retain all Hankel- singular values greater than TOL. If TOL is omitted then it is set to max(sig(1)*1.0E-12,1.0E-16). INPUT: sys = system (muSYN packed) to balance/reduce OUTPUT: sysout = balanced/reduced system sig = Hankel singular values Tleft,Tright = matrices which multiply original A0,B0,C0 so that new system (sysout) is constructed by change of coordinates + truncation A1 = Tleft*A0*Tright, B1 = Tleft*B0, C1 = C0*Tright See also: HANKMR, REORDSYS, FRWTBAL, SFRWTBLD, SNCFBAL, SRELBAL, SRESID, SVD, and TRUNC.","title":"Basic Information"},{"location":"function-guide/GAcontrol/sysconnect_m/","text":"sysconnect.m \u00b6 Basic Information \u00b6 SYNTAX: [systot,ierr] = sysconnect(system_defns, sys1, sys2, ...) PURPOSE: Connect together multiple systems in Control Toolbox format. Note that Control Toolbox functions tend to produce poorly conditioned system matrices. Use remove_algebraic.m to improve conditioning. INPUT: sys_defns= structure containing definitions of system to build. Structure must contain at least the fields: systemnames, inputvar, outputvar and \"input_to_\"... for each system listed in systemnames. Format is the same as for sysic in the muSYN toolbox. sys1, sys2, ... = systems defined in \"systemnames\" - must be in the same order as listed in systemnames Example: sys_defns = struct('systemnames','DIIID1 ip_feedback', ... 'inputvar','[choppers(18); dist(4)]', ... 'outputvar','[DIIID1]', ... 'input_to_DIIID1','[ip_feedback; choppers; dist]', ... 'input_to_ip_feedback','[DIIID1(46)]'); (then, for arguments, sys1 = DIIID1, sys2 = ip_feedback) OUTPUT: systot = connected together system ierr = error code, different from 0 if error prevented systot from being successfully built SEE ALSO: sysmult, sysinfo RESTRICTIONS: Cannot handle arithmetic operations inside the string (e.g. sys1+sys2, 2*sys3, etc.) like sysic can.","title":"sysconnect.m"},{"location":"function-guide/GAcontrol/sysconnect_m/#sysconnectm","text":"","title":"sysconnect.m"},{"location":"function-guide/GAcontrol/sysconnect_m/#basic-information","text":"SYNTAX: [systot,ierr] = sysconnect(system_defns, sys1, sys2, ...) PURPOSE: Connect together multiple systems in Control Toolbox format. Note that Control Toolbox functions tend to produce poorly conditioned system matrices. Use remove_algebraic.m to improve conditioning. INPUT: sys_defns= structure containing definitions of system to build. Structure must contain at least the fields: systemnames, inputvar, outputvar and \"input_to_\"... for each system listed in systemnames. Format is the same as for sysic in the muSYN toolbox. sys1, sys2, ... = systems defined in \"systemnames\" - must be in the same order as listed in systemnames Example: sys_defns = struct('systemnames','DIIID1 ip_feedback', ... 'inputvar','[choppers(18); dist(4)]', ... 'outputvar','[DIIID1]', ... 'input_to_DIIID1','[ip_feedback; choppers; dist]', ... 'input_to_ip_feedback','[DIIID1(46)]'); (then, for arguments, sys1 = DIIID1, sys2 = ip_feedback) OUTPUT: systot = connected together system ierr = error code, different from 0 if error prevented systot from being successfully built SEE ALSO: sysmult, sysinfo RESTRICTIONS: Cannot handle arithmetic operations inside the string (e.g. sys1+sys2, 2*sys3, etc.) like sysic can.","title":"Basic Information"},{"location":"function-guide/GAcontrol/sysinfo_m/","text":"sysinfo.m \u00b6 Basic Information \u00b6 SYNTAX: [type,noutput,ninput,nstates] = sysinfo(system,debug) PURPOSE: Provide information about the system contained in a Control Toolbox system object. Works for system and ordinary matrix objects. INPUT: system = system in Control Toolbox packed format, or matrix debug = if 1, you get printed info OUTPUT: type = either 'syst' or 'cons' noutput = number of outputs ninput = number of inputs nstates = number of states (0 for matrix)","title":"sysinfo.m"},{"location":"function-guide/GAcontrol/sysinfo_m/#sysinfom","text":"","title":"sysinfo.m"},{"location":"function-guide/GAcontrol/sysinfo_m/#basic-information","text":"SYNTAX: [type,noutput,ninput,nstates] = sysinfo(system,debug) PURPOSE: Provide information about the system contained in a Control Toolbox system object. Works for system and ordinary matrix objects. INPUT: system = system in Control Toolbox packed format, or matrix debug = if 1, you get printed info OUTPUT: type = either 'syst' or 'cons' noutput = number of outputs ninput = number of inputs nstates = number of states (0 for matrix)","title":"Basic Information"},{"location":"function-guide/GAcontrol/sysmult_m/","text":"sysmult.m \u00b6 Basic Information \u00b6 SYNTAX: sysout = sysmult(sys1,sys2,...) PURPOSE: Multiply several systems together. Systems are either in Control Toolbox packed format or simple matrices. INPUT: sys1, sys2, ... = systems to be multiplied OUTPUT: sysout = product of systems RESTRICTIONS: (1) Maximum of 10 arguments (2) Uses Control Toolbox","title":"sysmult.m"},{"location":"function-guide/GAcontrol/sysmult_m/#sysmultm","text":"","title":"sysmult.m"},{"location":"function-guide/GAcontrol/sysmult_m/#basic-information","text":"SYNTAX: sysout = sysmult(sys1,sys2,...) PURPOSE: Multiply several systems together. Systems are either in Control Toolbox packed format or simple matrices. INPUT: sys1, sys2, ... = systems to be multiplied OUTPUT: sysout = product of systems RESTRICTIONS: (1) Maximum of 10 arguments (2) Uses Control Toolbox","title":"Basic Information"},{"location":"function-guide/GAcontrol/transform_states_m/","text":"transform_states.m \u00b6 Basic Information \u00b6 SYNTAX: [an,bn,cn,dn]=transform_states(A,B,C,D,T) -1 PURPOSE: Performs the similarity transform z = T x. The resulting state space system is: . -1 -1 z = [T AT] z + [T B] u y = [CT ] z + Du NOTE: In most cases, the function ss2ss will perform the same function, but in some cases, the \"balance\" function returns T that is nearly singular. In that case, ss2ss requires T^-1 and doesn't perform well. INPUT: A,B,C,D = original system description T = state transformation OUTPUT: an,bn,cn,dn = transformed system description","title":"transform_states.m"},{"location":"function-guide/GAcontrol/transform_states_m/#transform_statesm","text":"","title":"transform_states.m"},{"location":"function-guide/GAcontrol/transform_states_m/#basic-information","text":"SYNTAX: [an,bn,cn,dn]=transform_states(A,B,C,D,T) -1 PURPOSE: Performs the similarity transform z = T x. The resulting state space system is: . -1 -1 z = [T AT] z + [T B] u y = [CT ] z + Du NOTE: In most cases, the function ss2ss will perform the same function, but in some cases, the \"balance\" function returns T that is nearly singular. In that case, ss2ss requires T^-1 and doesn't perform well. INPUT: A,B,C,D = original system description T = state transformation OUTPUT: an,bn,cn,dn = transformed system description","title":"Basic Information"},{"location":"function-guide/GAcontrol/updateQ_m/","text":"updateQ.m \u00b6 Basic Information \u00b6 SYNTAX: [Q,ierr] = updateQ(ksys,tokarr,Q,system_data,numsys,sysnames) PURPOSE: Add connections for the ksys'th system to the connection matrix Q. INPUT: ksys = number of system being worked on tokarr = array of tokens for input to ksys'th system Q = connection matrix for connect.m in Control Toolbox system_data= array containin #states, inputs, outputs for each system numsys = number of total systems sysnames = names of all systems OUTPUT: Q = connection matrix after update ierr = error code, different from 0 if error in construction","title":"updateQ.m"},{"location":"function-guide/GAcontrol/updateQ_m/#updateqm","text":"","title":"updateQ.m"},{"location":"function-guide/GAcontrol/updateQ_m/#basic-information","text":"SYNTAX: [Q,ierr] = updateQ(ksys,tokarr,Q,system_data,numsys,sysnames) PURPOSE: Add connections for the ksys'th system to the connection matrix Q. INPUT: ksys = number of system being worked on tokarr = array of tokens for input to ksys'th system Q = connection matrix for connect.m in Control Toolbox system_data= array containin #states, inputs, outputs for each system numsys = number of total systems sysnames = names of all systems OUTPUT: Q = connection matrix after update ierr = error code, different from 0 if error in construction","title":"Basic Information"},{"location":"function-guide/GAgraphics/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 GA graphics functions add_lines - add vertical lines to plot at specified x values arrow - Draws a 3-d line with arrow head arrow_head - Puts arrow heads on last segment of line in 2-D blowup - Blow up region of plot using mouse cursor unblowup - Switch back to axis scale prior to using blowup contour_smooth - Smooths and makes points on contour line equal length curve_colors - plot colors for curves to see order date_stamp - Puts date [& text] in right hand corner of plot eps_all_figs - Makes f#.eps file from each figure (ex: f1.eps, f2.eps ..) letter_figure - put a letter into a figure window for report make_many_points - reads point_list and makes point in matlab area (pt pt_t) next_figure - open next figure window in sequence of figures next_line_type - generates next line type for plotting subplot_ga - Review like subplot (no space between frames) rm_x_label - makes x number scale invisible rm_y_label - makes y number scale invisible paper_position - changes the print page origin, width and height plot_geo_tok - plots geometry of tokamak from typical tokamak model plot_box - plots parallelogram box given r,z,dr,dz,angl1,angl2 (d3d) plot_boxx - Same as plot_box except put X in box (corner to corner) plot_rect - plots rectangular box given r,z,dr,dz plot_many_points - reads point_list & plot many points in subplot areas plot_vertlines - put vertical lines into plot titlee - like title but exchanges \"_\" with \"\\_\" to eliminate subs set_def_fig_loc - sets the figure pixel location {& size} in main screen (0) slice_ga - puts vertical line (slice) on figure at x axis points yaxisloc_right - puts the y axis on the right side of frame","title":"Contents.m"},{"location":"function-guide/GAgraphics/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/GAgraphics/Contents_m/#basic-information","text":"GA graphics functions add_lines - add vertical lines to plot at specified x values arrow - Draws a 3-d line with arrow head arrow_head - Puts arrow heads on last segment of line in 2-D blowup - Blow up region of plot using mouse cursor unblowup - Switch back to axis scale prior to using blowup contour_smooth - Smooths and makes points on contour line equal length curve_colors - plot colors for curves to see order date_stamp - Puts date [& text] in right hand corner of plot eps_all_figs - Makes f#.eps file from each figure (ex: f1.eps, f2.eps ..) letter_figure - put a letter into a figure window for report make_many_points - reads point_list and makes point in matlab area (pt pt_t) next_figure - open next figure window in sequence of figures next_line_type - generates next line type for plotting subplot_ga - Review like subplot (no space between frames) rm_x_label - makes x number scale invisible rm_y_label - makes y number scale invisible paper_position - changes the print page origin, width and height plot_geo_tok - plots geometry of tokamak from typical tokamak model plot_box - plots parallelogram box given r,z,dr,dz,angl1,angl2 (d3d) plot_boxx - Same as plot_box except put X in box (corner to corner) plot_rect - plots rectangular box given r,z,dr,dz plot_many_points - reads point_list & plot many points in subplot areas plot_vertlines - put vertical lines into plot titlee - like title but exchanges \"_\" with \"\\_\" to eliminate subs set_def_fig_loc - sets the figure pixel location {& size} in main screen (0) slice_ga - puts vertical line (slice) on figure at x axis points yaxisloc_right - puts the y axis on the right side of frame","title":"Basic Information"},{"location":"function-guide/GAgraphics/add_lines_m/","text":"add_lines.m \u00b6 Basic Information \u00b6 SYNTAX: add_lines(xlocs,figure_num,subpl_num) PURPOSE: Draw vertical lines in plot window at specified x locations. INPUT: xlocs = vector of x axis locations at which to draw lines figure_num = figure number (optional, default=current figure) NOT WORKING YET: subpl_num = subplot number (optional, default=current subplot) OUTPUT: none RESTRICTIONS: This function should be called after any adjustment of axes in order to ensure lines go all the way from bottom to top of plot.","title":"add_lines.m"},{"location":"function-guide/GAgraphics/add_lines_m/#add_linesm","text":"","title":"add_lines.m"},{"location":"function-guide/GAgraphics/add_lines_m/#basic-information","text":"SYNTAX: add_lines(xlocs,figure_num,subpl_num) PURPOSE: Draw vertical lines in plot window at specified x locations. INPUT: xlocs = vector of x axis locations at which to draw lines figure_num = figure number (optional, default=current figure) NOT WORKING YET: subpl_num = subplot number (optional, default=current subplot) OUTPUT: none RESTRICTIONS: This function should be called after any adjustment of axes in order to ensure lines go all the way from bottom to top of plot.","title":"Basic Information"},{"location":"function-guide/GAgraphics/arrow_head_m/","text":"arrow_head.m \u00b6 Basic Information \u00b6 arrow_head produces an arrow head in x,y (2d) using 2 lines formed into a \"v\" Use: hndl= arrow_head(x,y,<scale,color,angle>) input: x,y= vectors of line elements the last element of which gets arrow_head scale= scale factor for arrow head to line length [0.3] color= color of arrows ['k'] angle= included angle of arrow head, degrees [50] output: hndl= handle to arrow_head['s]; 2 per line","title":"arrow_head.m"},{"location":"function-guide/GAgraphics/arrow_head_m/#arrow_headm","text":"","title":"arrow_head.m"},{"location":"function-guide/GAgraphics/arrow_head_m/#basic-information","text":"arrow_head produces an arrow head in x,y (2d) using 2 lines formed into a \"v\" Use: hndl= arrow_head(x,y,<scale,color,angle>) input: x,y= vectors of line elements the last element of which gets arrow_head scale= scale factor for arrow head to line length [0.3] color= color of arrows ['k'] angle= included angle of arrow head, degrees [50] output: hndl= handle to arrow_head['s]; 2 per line","title":"Basic Information"},{"location":"function-guide/GAgraphics/arrow_m/","text":"arrow.m \u00b6 Basic Information \u00b6 ARROW Draw a line with an arrowhead. ARROW(Start,Stop) draws a line with an arrow from Start to Stop (points should be vectors of length 2 or 3, or matrices with 2 or 3 columns), and returns the graphics handle of the arrow(s). ARROW uses the mouse (click-drag) to create an arrow. ARROW DEMO & ARROW DEMO2 show 3-D & 2-D demos of the capabilities of ARROW. ARROW may be called with a normal argument list or a property-based list. ARROW(Start,Stop,Length,BaseAngle,TipAngle,Width,Page,CrossDir) is the full normal argument list, where all but the Start and Stop points are optional. If you need to specify a later argument (e.g., Page) but want default values of earlier ones (e.g., TipAngle), pass an empty matrix for the earlier ones (e.g., TipAngle=[]). ARROW('Property1',PropVal1,'Property2',PropVal2,...) creates arrows with the given properties, using default values for any unspecified or given as 'default' or NaN. Some properties used for line and patch objects are used in a modified fashion, others are passed directly to LINE, PATCH, or SET. For a detailed properties explanation, call ARROW PROPERTIES. Start The starting points. B Stop The end points. /|\\ ^ Length Length of the arrowhead in pixels. /|||\\ | BaseAngle Base angle in degrees (ADE). //|||\\\\ L| TipAngle Tip angle in degrees (ABC). ///|||\\\\\\ e| Width Width of the base in pixels. ////|||\\\\\\\\ n| Page Use hardcopy proportions. /////|D|\\\\\\\\\\ g| CrossDir Vector || to arrowhead plane. //// ||| \\\\\\\\ t| NormalDir Vector out of arrowhead plane. /// ||| \\\\\\ h| Ends Which end has an arrowhead. //<----->|| \\\\ | ObjectHandles Vector of handles to update. / base ||| \\ V E angle||<-------->C ARROW(H,'Prop1',PropVal1,...), where H is a |||tipangle vector of handles to previously-created arrows ||| and/or line objects, will update the previously- ||| created arrows according to the current view -->|A|<-- width and any specified properties, and will convert two-point line objects to corresponding arrows. ARROW(H) will update the arrows if the current view has changed. Root, figure, or axes handles included in H are replaced by all descendant Arrow objects. A property list can follow any specified normal argument list, e.g., ARROW([1 2 3],[0 0 0],36,'BaseAngle',60) creates an arrow from (1,2,3) to the origin, with an arrowhead of length 36 pixels and 60-degree base angle. The basic arguments or properties can generally be vectorized to create multiple arrows with the same call. This is done by passing a property with one row per arrow, or, if all arrows are to have the same property value, just one row may be specified. You may want to execute AXIS(AXIS) before calling ARROW so it doesn't change the axes on you; ARROW determines the sizes of arrow components BEFORE the arrow is plotted, so if ARROW changes axis limits, arrows may be malformed. This version of ARROW uses features of MATLAB 5 and is incompatible with earlier MATLAB versions (ARROW for MATLAB 4.2c is available separately); some problems with perspective plots still exist.","title":"arrow.m"},{"location":"function-guide/GAgraphics/arrow_m/#arrowm","text":"","title":"arrow.m"},{"location":"function-guide/GAgraphics/arrow_m/#basic-information","text":"ARROW Draw a line with an arrowhead. ARROW(Start,Stop) draws a line with an arrow from Start to Stop (points should be vectors of length 2 or 3, or matrices with 2 or 3 columns), and returns the graphics handle of the arrow(s). ARROW uses the mouse (click-drag) to create an arrow. ARROW DEMO & ARROW DEMO2 show 3-D & 2-D demos of the capabilities of ARROW. ARROW may be called with a normal argument list or a property-based list. ARROW(Start,Stop,Length,BaseAngle,TipAngle,Width,Page,CrossDir) is the full normal argument list, where all but the Start and Stop points are optional. If you need to specify a later argument (e.g., Page) but want default values of earlier ones (e.g., TipAngle), pass an empty matrix for the earlier ones (e.g., TipAngle=[]). ARROW('Property1',PropVal1,'Property2',PropVal2,...) creates arrows with the given properties, using default values for any unspecified or given as 'default' or NaN. Some properties used for line and patch objects are used in a modified fashion, others are passed directly to LINE, PATCH, or SET. For a detailed properties explanation, call ARROW PROPERTIES. Start The starting points. B Stop The end points. /|\\ ^ Length Length of the arrowhead in pixels. /|||\\ | BaseAngle Base angle in degrees (ADE). //|||\\\\ L| TipAngle Tip angle in degrees (ABC). ///|||\\\\\\ e| Width Width of the base in pixels. ////|||\\\\\\\\ n| Page Use hardcopy proportions. /////|D|\\\\\\\\\\ g| CrossDir Vector || to arrowhead plane. //// ||| \\\\\\\\ t| NormalDir Vector out of arrowhead plane. /// ||| \\\\\\ h| Ends Which end has an arrowhead. //<----->|| \\\\ | ObjectHandles Vector of handles to update. / base ||| \\ V E angle||<-------->C ARROW(H,'Prop1',PropVal1,...), where H is a |||tipangle vector of handles to previously-created arrows ||| and/or line objects, will update the previously- ||| created arrows according to the current view -->|A|<-- width and any specified properties, and will convert two-point line objects to corresponding arrows. ARROW(H) will update the arrows if the current view has changed. Root, figure, or axes handles included in H are replaced by all descendant Arrow objects. A property list can follow any specified normal argument list, e.g., ARROW([1 2 3],[0 0 0],36,'BaseAngle',60) creates an arrow from (1,2,3) to the origin, with an arrowhead of length 36 pixels and 60-degree base angle. The basic arguments or properties can generally be vectorized to create multiple arrows with the same call. This is done by passing a property with one row per arrow, or, if all arrows are to have the same property value, just one row may be specified. You may want to execute AXIS(AXIS) before calling ARROW so it doesn't change the axes on you; ARROW determines the sizes of arrow components BEFORE the arrow is plotted, so if ARROW changes axis limits, arrows may be malformed. This version of ARROW uses features of MATLAB 5 and is incompatible with earlier MATLAB versions (ARROW for MATLAB 4.2c is available separately); some problems with perspective plots still exist.","title":"Basic Information"},{"location":"function-guide/GAgraphics/blowup_m/","text":"blowup.m \u00b6 Basic Information \u00b6 blowup: Script to blowup a region of a plot. Usage: >> blowup","title":"blowup.m"},{"location":"function-guide/GAgraphics/blowup_m/#blowupm","text":"","title":"blowup.m"},{"location":"function-guide/GAgraphics/blowup_m/#basic-information","text":"blowup: Script to blowup a region of a plot. Usage: >> blowup","title":"Basic Information"},{"location":"function-guide/GAgraphics/contour_smooth_m/","text":"contour_smooth.m \u00b6 Basic Information \u00b6 PURPOSE: smooth contour and make uniform spacing in length SYNTAX: con_out= contour_smooth(con,iplt,isym); INPUT: con= contour vector from con=contour(...) or con=contourc(...) iplt= 0=> no plot; 1=> plot each contour [0] isym= plot symbol i.e. 'r--' ['y-'] OUTPUT: con_out= smoothed contour with equal grid spacing FILE: contour_smooth.m","title":"contour_smooth.m"},{"location":"function-guide/GAgraphics/contour_smooth_m/#contour_smoothm","text":"","title":"contour_smooth.m"},{"location":"function-guide/GAgraphics/contour_smooth_m/#basic-information","text":"PURPOSE: smooth contour and make uniform spacing in length SYNTAX: con_out= contour_smooth(con,iplt,isym); INPUT: con= contour vector from con=contour(...) or con=contourc(...) iplt= 0=> no plot; 1=> plot each contour [0] isym= plot symbol i.e. 'r--' ['y-'] OUTPUT: con_out= smoothed contour with equal grid spacing FILE: contour_smooth.m","title":"Basic Information"},{"location":"function-guide/GAgraphics/curve_colors_m/","text":"curve_colors.m \u00b6 Basic Information \u00b6 show order of color for curves","title":"curve_colors.m"},{"location":"function-guide/GAgraphics/curve_colors_m/#curve_colorsm","text":"","title":"curve_colors.m"},{"location":"function-guide/GAgraphics/curve_colors_m/#basic-information","text":"show order of color for curves","title":"Basic Information"},{"location":"function-guide/GAgraphics/date_stamp_m/","text":"date_stamp.m \u00b6 Basic Information \u00b6 date_stamp(name) puts the \"name\" and date stamp outside the right bottom margin of a figure input: name= text preappended to date text when printing rot= =0 xdir across bottom, =[1] rotate 90 & along right side output: hndl= handle to text","title":"date_stamp.m"},{"location":"function-guide/GAgraphics/date_stamp_m/#date_stampm","text":"","title":"date_stamp.m"},{"location":"function-guide/GAgraphics/date_stamp_m/#basic-information","text":"date_stamp(name) puts the \"name\" and date stamp outside the right bottom margin of a figure input: name= text preappended to date text when printing rot= =0 xdir across bottom, =[1] rotate 90 & along right side output: hndl= handle to text","title":"Basic Information"},{"location":"function-guide/GAgraphics/draw_axis_m/","text":"draw_axis.m \u00b6 Basic Information \u00b6 draw_axis draws axis along X, Y, Z axis and puts X,Y,Z at end of axis SYNTAX: hdl= draw_axis(cl) INPUT: cl= color of line and symbols [k]","title":"draw_axis.m"},{"location":"function-guide/GAgraphics/draw_axis_m/#draw_axism","text":"","title":"draw_axis.m"},{"location":"function-guide/GAgraphics/draw_axis_m/#basic-information","text":"draw_axis draws axis along X, Y, Z axis and puts X,Y,Z at end of axis SYNTAX: hdl= draw_axis(cl) INPUT: cl= color of line and symbols [k]","title":"Basic Information"},{"location":"function-guide/GAgraphics/eps_all_figs_m/","text":"eps_all_figs.m \u00b6 Basic Information \u00b6 SYNTAX: figs= eps_all_figs; makes f1.eps f2.eps ... all figs figs= eps_all_figs(fig_nums); makes f2.eps f?.eps ... from fig_nums figs= eps_all_figs([],1); prints all figures to file: figs.eps figs= eps_all_figs([],'ps'); prints to f2.ps instead of .eps PURPOSE: makes f#.eps for each figure in fig_nums (or all figures) # is number of each figure in fig_num (or all open figures) INPUT: [default] fig_nums = list of figure numbers (ex: fig_num= [1 3 5]; {default all figs} append = 1; append figures to single big .eps file [0] = 'ps' prints to ps instead of eps (does not append) OUTPUT: Files: f1.eps, f2.eps, .... f#.eps {NOTE: Will overwrite in local dir} if append=1 makes file: figs.ps figs = list of figure numbers printed","title":"eps_all_figs.m"},{"location":"function-guide/GAgraphics/eps_all_figs_m/#eps_all_figsm","text":"","title":"eps_all_figs.m"},{"location":"function-guide/GAgraphics/eps_all_figs_m/#basic-information","text":"SYNTAX: figs= eps_all_figs; makes f1.eps f2.eps ... all figs figs= eps_all_figs(fig_nums); makes f2.eps f?.eps ... from fig_nums figs= eps_all_figs([],1); prints all figures to file: figs.eps figs= eps_all_figs([],'ps'); prints to f2.ps instead of .eps PURPOSE: makes f#.eps for each figure in fig_nums (or all figures) # is number of each figure in fig_num (or all open figures) INPUT: [default] fig_nums = list of figure numbers (ex: fig_num= [1 3 5]; {default all figs} append = 1; append figures to single big .eps file [0] = 'ps' prints to ps instead of eps (does not append) OUTPUT: Files: f1.eps, f2.eps, .... f#.eps {NOTE: Will overwrite in local dir} if append=1 makes file: figs.ps figs = list of figure numbers printed","title":"Basic Information"},{"location":"function-guide/GAgraphics/letter_figure_m/","text":"letter_figure.m \u00b6 Basic Information \u00b6 SYNTAX: letter_figure(corner,letter,figure_num,subpl_num) PURPOSE: Put a letter into a figure suitable for use as part of a figure in a report. INPUT: corner = one of 'ur','ul','lr','ll' letter = letter or label such as (a),(b),(c), ..., (1), (2), ... figure_num = figure number (optional, default=current figure) NOT WORKING YET: subpl_num = subplot number (optional, default=current subplot) OUTPUT: none RESTRICTIONS: This function should be called after any adjustment of axes to ensure that letter ends up in the corner of the final plot frame rather than in the corner of the unadjusted plot.","title":"letter_figure.m"},{"location":"function-guide/GAgraphics/letter_figure_m/#letter_figurem","text":"","title":"letter_figure.m"},{"location":"function-guide/GAgraphics/letter_figure_m/#basic-information","text":"SYNTAX: letter_figure(corner,letter,figure_num,subpl_num) PURPOSE: Put a letter into a figure suitable for use as part of a figure in a report. INPUT: corner = one of 'ur','ul','lr','ll' letter = letter or label such as (a),(b),(c), ..., (1), (2), ... figure_num = figure number (optional, default=current figure) NOT WORKING YET: subpl_num = subplot number (optional, default=current subplot) OUTPUT: none RESTRICTIONS: This function should be called after any adjustment of axes to ensure that letter ends up in the corner of the final plot frame rather than in the corner of the unadjusted plot.","title":"Basic Information"},{"location":"function-guide/GAgraphics/make_many_points_m/","text":"make_many_points.m \u00b6 Basic Information \u00b6 make_many_points.m: script which reads ptdata and makes point from point_list Input: point_list= list of point names (typically input using read_point) shot= shot number tmin= minimum time (s) tmax= maximum time (s) ical= type of data to read from ptdata 1=physical units idebug= debug switch: 0=no debug, 1=shot info icase= make upper or lower case (-1=lower, 0=nochange, 1=upper) point_details= 0= make PT & PT_t 1= make PT, PT_t, PT_e, PT_s Output: Point and time vectors: example: IP, IP_t (time), IP_e (error), IP_s (shot)","title":"make_many_points.m"},{"location":"function-guide/GAgraphics/make_many_points_m/#make_many_pointsm","text":"","title":"make_many_points.m"},{"location":"function-guide/GAgraphics/make_many_points_m/#basic-information","text":"make_many_points.m: script which reads ptdata and makes point from point_list Input: point_list= list of point names (typically input using read_point) shot= shot number tmin= minimum time (s) tmax= maximum time (s) ical= type of data to read from ptdata 1=physical units idebug= debug switch: 0=no debug, 1=shot info icase= make upper or lower case (-1=lower, 0=nochange, 1=upper) point_details= 0= make PT & PT_t 1= make PT, PT_t, PT_e, PT_s Output: Point and time vectors: example: IP, IP_t (time), IP_e (error), IP_s (shot)","title":"Basic Information"},{"location":"function-guide/GAgraphics/next_line_type_m/","text":"next_line_type.m \u00b6 Basic Information \u00b6 SYNTAX: next_line_type(col_strs,sym_strs) PURPOSE: bring up a new line type INPUT: line_flag = set = 1 to connect symbols with line col_strs = array of color strings (optional) sym_strs = array of symbol strings (optional) OUTPUT:","title":"next_line_type.m"},{"location":"function-guide/GAgraphics/next_line_type_m/#next_line_typem","text":"","title":"next_line_type.m"},{"location":"function-guide/GAgraphics/next_line_type_m/#basic-information","text":"SYNTAX: next_line_type(col_strs,sym_strs) PURPOSE: bring up a new line type INPUT: line_flag = set = 1 to connect symbols with line col_strs = array of color strings (optional) sym_strs = array of symbol strings (optional) OUTPUT:","title":"Basic Information"},{"location":"function-guide/GAgraphics/paper_position_m/","text":"paper_position.m \u00b6 Basic Information \u00b6 function paper_position(x0,y0,dx,dy) paper_position.m Usage: paper_position(x0,y0,dx,dy); this sets the output paper size to x0,y0,dx,dy for ploting puting into reports Input: typical defaults=[0.25,2.5,8,6]; good print values= {1,1,7,10.5} x0= X Location of bottom left-hand side of plot area [0.25] y0= Y Location of bottom left-hand side of plot area [2.5] dx= Width of plot area [8.0] dy= Height of plot area [6.0] x0= 'paper' makes file fill full 8x11 with 0.5\" margins x0= 'word' makes file size to plug into typical word document","title":"paper_position.m"},{"location":"function-guide/GAgraphics/paper_position_m/#paper_positionm","text":"","title":"paper_position.m"},{"location":"function-guide/GAgraphics/paper_position_m/#basic-information","text":"function paper_position(x0,y0,dx,dy) paper_position.m Usage: paper_position(x0,y0,dx,dy); this sets the output paper size to x0,y0,dx,dy for ploting puting into reports Input: typical defaults=[0.25,2.5,8,6]; good print values= {1,1,7,10.5} x0= X Location of bottom left-hand side of plot area [0.25] y0= Y Location of bottom left-hand side of plot area [2.5] dx= Width of plot area [8.0] dy= Height of plot area [6.0] x0= 'paper' makes file fill full 8x11 with 0.5\" margins x0= 'word' makes file size to plug into typical word document","title":"Basic Information"},{"location":"function-guide/GAgraphics/plot_box_m/","text":"plot_box.m \u00b6 Basic Information \u00b6 function h= plot_box(rs,zs,delrs,delzs,clstr,ang1,ang2): To plot rectangular boxes at vector of locations corr. to rs, zs, with widths and heights given by delrs, delzs in plot units. So intended for geometry plots. clstr is the color/linetype string used for call to plot. Note that must only use color or linetype, *not* symbol markers for clstr, or else won't close the boxes. DAH 3/1/95 plot_box now does parallelogram plotting if ang vectors are supplied (optionally) DAH 4/25/95 Inputs: rs = vector of major radial locations zs = vector of vertical positions delrs = vector of box widths delzs = vector of box heights clstr = color/linetype string used for call to plot (*not* symbol markers) ang1 = 0 for rectangle, otherwise rise angle for flatsided parallelogram ang2 = 0 for rectangle, otherwise rise angle for flatbottom parallelogram Outputs: h= handle of ploted objects Plots parallelogram coils on active figure. Restrictions: None. --------------------------------------------------------------------","title":"plot_box.m"},{"location":"function-guide/GAgraphics/plot_box_m/#plot_boxm","text":"","title":"plot_box.m"},{"location":"function-guide/GAgraphics/plot_box_m/#basic-information","text":"function h= plot_box(rs,zs,delrs,delzs,clstr,ang1,ang2): To plot rectangular boxes at vector of locations corr. to rs, zs, with widths and heights given by delrs, delzs in plot units. So intended for geometry plots. clstr is the color/linetype string used for call to plot. Note that must only use color or linetype, *not* symbol markers for clstr, or else won't close the boxes. DAH 3/1/95 plot_box now does parallelogram plotting if ang vectors are supplied (optionally) DAH 4/25/95 Inputs: rs = vector of major radial locations zs = vector of vertical positions delrs = vector of box widths delzs = vector of box heights clstr = color/linetype string used for call to plot (*not* symbol markers) ang1 = 0 for rectangle, otherwise rise angle for flatsided parallelogram ang2 = 0 for rectangle, otherwise rise angle for flatbottom parallelogram Outputs: h= handle of ploted objects Plots parallelogram coils on active figure. Restrictions: None. --------------------------------------------------------------------","title":"Basic Information"},{"location":"function-guide/GAgraphics/plot_boxx_m/","text":"plot_boxx.m \u00b6 Basic Information \u00b6 function h=plot_boxx(rs,zs,delrs,delzs,clstr,ang1,ang2): To plot rectangular boxes WITH Xs IN THEM at vector of locations corr. to rs, zs, with widths and heights given by delrs, delzs in plot units. So intended for geometry plots. clstr is the color/linetype string used for call to plot. Note that must only use color or linetype, *not* symbol markers for clstr, or else won't close the boxes. Inputs: rs = vector of major radial locations zs = vector of vertical positions delrs = vector of box widths delzs = vector of box heights clstr = color/linetype string used for call to plot (*not* symbol markers) ang1 = 0 for rectangle, otherwise rise angle for flatsided parallelogram ang2 = 0 for rectangle, otherwise rise angle for flatbottom parallelogram Output: h = handle to plot","title":"plot_boxx.m"},{"location":"function-guide/GAgraphics/plot_boxx_m/#plot_boxxm","text":"","title":"plot_boxx.m"},{"location":"function-guide/GAgraphics/plot_boxx_m/#basic-information","text":"function h=plot_boxx(rs,zs,delrs,delzs,clstr,ang1,ang2): To plot rectangular boxes WITH Xs IN THEM at vector of locations corr. to rs, zs, with widths and heights given by delrs, delzs in plot units. So intended for geometry plots. clstr is the color/linetype string used for call to plot. Note that must only use color or linetype, *not* symbol markers for clstr, or else won't close the boxes. Inputs: rs = vector of major radial locations zs = vector of vertical positions delrs = vector of box widths delzs = vector of box heights clstr = color/linetype string used for call to plot (*not* symbol markers) ang1 = 0 for rectangle, otherwise rise angle for flatsided parallelogram ang2 = 0 for rectangle, otherwise rise angle for flatbottom parallelogram Output: h = handle to plot","title":"Basic Information"},{"location":"function-guide/GAgraphics/plot_line_ang_m/","text":"plot_line_ang.m \u00b6 Basic Information \u00b6 plot_line_ang.m: plots line defined by center (r,z) angle (ang) and length(leng) using line style & color (color) optionally adds arrow to end line Syntax: [ri,ro,zl,zu]= plot_rect(r,z,ang,leng,color) Input: r= Radius of center of box z= Vertical location of center of box ang= Angle of line with Radial Line (deg) leng= Length of line (leng) color= Color/line_type & arrowhead to use in box plot ['ak-'] If color contains \"a\" then an arrow head is added at end Output: r1= Starting point Radius z1= Starting Point Z r2= Ending Point Radius z2= Ending Point Z","title":"plot_line_ang.m"},{"location":"function-guide/GAgraphics/plot_line_ang_m/#plot_line_angm","text":"","title":"plot_line_ang.m"},{"location":"function-guide/GAgraphics/plot_line_ang_m/#basic-information","text":"plot_line_ang.m: plots line defined by center (r,z) angle (ang) and length(leng) using line style & color (color) optionally adds arrow to end line Syntax: [ri,ro,zl,zu]= plot_rect(r,z,ang,leng,color) Input: r= Radius of center of box z= Vertical location of center of box ang= Angle of line with Radial Line (deg) leng= Length of line (leng) color= Color/line_type & arrowhead to use in box plot ['ak-'] If color contains \"a\" then an arrow head is added at end Output: r1= Starting point Radius z1= Starting Point Z r2= Ending Point Radius z2= Ending Point Z","title":"Basic Information"},{"location":"function-guide/GAgraphics/plot_many_points_m/","text":"plot_many_points.m \u00b6 Basic Information \u00b6 plot_many_points.m: script which plots points in point_list Input: point_list= list of point names (typically input using read_point) idebug= debug switch: 0=no debug, 1=debug info icase= case of symbols made by make_many_points Note: if the following variables are single elements then they apply to all variables if row variables then they must be same size as number of point names (rows of point_list): shot= shot number tpmin= minimum time (s) (-99 = use default) tpmax= maximum time (s) (-99 = use default) ypmax= maximum value (-99 = use default) ypmin= maximum value (-99 = use default) sub_plt= identity of subplot to put plot in hold_plt= turn hold 1=on, 0=no change, -1= off for plot example point names: IP, IP_t (time) Output: Plot all points to current figure","title":"plot_many_points.m"},{"location":"function-guide/GAgraphics/plot_many_points_m/#plot_many_pointsm","text":"","title":"plot_many_points.m"},{"location":"function-guide/GAgraphics/plot_many_points_m/#basic-information","text":"plot_many_points.m: script which plots points in point_list Input: point_list= list of point names (typically input using read_point) idebug= debug switch: 0=no debug, 1=debug info icase= case of symbols made by make_many_points Note: if the following variables are single elements then they apply to all variables if row variables then they must be same size as number of point names (rows of point_list): shot= shot number tpmin= minimum time (s) (-99 = use default) tpmax= maximum time (s) (-99 = use default) ypmax= maximum value (-99 = use default) ypmin= maximum value (-99 = use default) sub_plt= identity of subplot to put plot in hold_plt= turn hold 1=on, 0=no change, -1= off for plot example point names: IP, IP_t (time) Output: Plot all points to current figure","title":"Basic Information"},{"location":"function-guide/GAgraphics/plot_rect_m/","text":"plot_rect.m \u00b6 Basic Information \u00b6 plot_rect.m: plots rectangular boxes given r,z,dr,dz and generates outer geometry: ri,ro,zl,zu Syntax: [ri,ro,zl,zu]= plot_rect(r,z,dr,dz,color) Input: r= Radius of center of box z= Vertical location of center of box dr= Radial width of box dz= Axial height of box color= Color/line_type to use in box plot ['k-'] Output: ri= Inner Radius of box ro= Outer Radius of box zl= Lower Z of box zu= Upper Z of box","title":"plot_rect.m"},{"location":"function-guide/GAgraphics/plot_rect_m/#plot_rectm","text":"","title":"plot_rect.m"},{"location":"function-guide/GAgraphics/plot_rect_m/#basic-information","text":"plot_rect.m: plots rectangular boxes given r,z,dr,dz and generates outer geometry: ri,ro,zl,zu Syntax: [ri,ro,zl,zu]= plot_rect(r,z,dr,dz,color) Input: r= Radius of center of box z= Vertical location of center of box dr= Radial width of box dz= Axial height of box color= Color/line_type to use in box plot ['k-'] Output: ri= Inner Radius of box ro= Outer Radius of box zl= Lower Z of box zu= Upper Z of box","title":"Basic Information"},{"location":"function-guide/GAgraphics/plot_vertlines_m/","text":"plot_vertlines.m \u00b6 Basic Information \u00b6 SYNTAX: plot_vertlines(line_locs) PURPOSE: Plot vertical lines from bottom to top of current figure and subplot. INPUT: line_locs = list of line locations on x-axis OUTPUT: none RESTRICTIONS: Plot must have hold on.","title":"plot_vertlines.m"},{"location":"function-guide/GAgraphics/plot_vertlines_m/#plot_vertlinesm","text":"","title":"plot_vertlines.m"},{"location":"function-guide/GAgraphics/plot_vertlines_m/#basic-information","text":"SYNTAX: plot_vertlines(line_locs) PURPOSE: Plot vertical lines from bottom to top of current figure and subplot. INPUT: line_locs = list of line locations on x-axis OUTPUT: none RESTRICTIONS: Plot must have hold on.","title":"Basic Information"},{"location":"function-guide/GAgraphics/rm_x_label_m/","text":"rm_x_label.m \u00b6 Basic Information \u00b6 rm_x_label by default removes the x label With an argument it removes selected tick marks. It is ment to be used with my_subplot to eliminate overwirting. Routine returns handle to axis SYNTAX: handle= rm_x_label(spot) Input: spot = No argument provided => Make X Label Invisable = Number => remove label defined by index spot ASCI: = 'first' => eliminate 1st label = 'last' => eliminate last label = 'all' => eliminate all labels = (unknown variable) => eliminate 1st label Output: handle = handle to axis Note: (use get(handle)] to see axis attributes","title":"rm_x_label.m"},{"location":"function-guide/GAgraphics/rm_x_label_m/#rm_x_labelm","text":"","title":"rm_x_label.m"},{"location":"function-guide/GAgraphics/rm_x_label_m/#basic-information","text":"rm_x_label by default removes the x label With an argument it removes selected tick marks. It is ment to be used with my_subplot to eliminate overwirting. Routine returns handle to axis SYNTAX: handle= rm_x_label(spot) Input: spot = No argument provided => Make X Label Invisable = Number => remove label defined by index spot ASCI: = 'first' => eliminate 1st label = 'last' => eliminate last label = 'all' => eliminate all labels = (unknown variable) => eliminate 1st label Output: handle = handle to axis Note: (use get(handle)] to see axis attributes","title":"Basic Information"},{"location":"function-guide/GAgraphics/rm_y_label_m/","text":"rm_y_label.m \u00b6 Basic Information \u00b6 rm_y_label by default removes the Y label With an argument it removes selected tick marks. It is ment to be used with my_subplot to eliminate overwirting. Routine returns handle to axis SYNTAX: handle= rm_y_label(spot) Input: spot = No argument provided => Make Y Label Invisable = Number => remove label defined by index spot ASCI: = 'first' => eliminate 1st label = 'last' => eliminate last label = 'all' => eliminate all labels = (unknown variable) => eliminate 1st label Output: handle = handle to axis Note: (use get(handle)] to see axis attributes","title":"rm_y_label.m"},{"location":"function-guide/GAgraphics/rm_y_label_m/#rm_y_labelm","text":"","title":"rm_y_label.m"},{"location":"function-guide/GAgraphics/rm_y_label_m/#basic-information","text":"rm_y_label by default removes the Y label With an argument it removes selected tick marks. It is ment to be used with my_subplot to eliminate overwirting. Routine returns handle to axis SYNTAX: handle= rm_y_label(spot) Input: spot = No argument provided => Make Y Label Invisable = Number => remove label defined by index spot ASCI: = 'first' => eliminate 1st label = 'last' => eliminate last label = 'all' => eliminate all labels = (unknown variable) => eliminate 1st label Output: handle = handle to axis Note: (use get(handle)] to see axis attributes","title":"Basic Information"},{"location":"function-guide/GAgraphics/rm_z_label_m/","text":"rm_z_label.m \u00b6 Basic Information \u00b6 rm_z_label by default removes the z label With an argument it removes selected tick marks. It is ment to be used with my_subplot to eliminate overwirting. Routine returns handle to axis SYNTAX: handle= rm_z_label(spot) Input: spot = No argument provided => Make z Label Invisable = Number => remove label defined by index spot ASCI: = 'first' => eliminate 1st label = 'last' => eliminate last label = 'all' => eliminate all labels = (unknown variable) => eliminate 1st label Output: handle = handle to axis Note: (use get(handle)] to see axis attributes","title":"rm_z_label.m"},{"location":"function-guide/GAgraphics/rm_z_label_m/#rm_z_labelm","text":"","title":"rm_z_label.m"},{"location":"function-guide/GAgraphics/rm_z_label_m/#basic-information","text":"rm_z_label by default removes the z label With an argument it removes selected tick marks. It is ment to be used with my_subplot to eliminate overwirting. Routine returns handle to axis SYNTAX: handle= rm_z_label(spot) Input: spot = No argument provided => Make z Label Invisable = Number => remove label defined by index spot ASCI: = 'first' => eliminate 1st label = 'last' => eliminate last label = 'all' => eliminate all labels = (unknown variable) => eliminate 1st label Output: handle = handle to axis Note: (use get(handle)] to see axis attributes","title":"Basic Information"},{"location":"function-guide/GAgraphics/set_def_fig_loc_m/","text":"set_def_fig_loc.m \u00b6 Basic Information \u00b6 SYNTAX: ijdidj= set_def_fig_loc(ijdidj); vector ijdidj= i, j, di, dj screen pixels set_def_fig_loc; window bottom corner 1/2 screen set_def_fig_loc(frc); window bottom corner frc screen set_def_fig_loc(i,j); window bottom corner i,j pixel's set_def_fig_loc(i,j,di,dj) window corner i,j and size di dj pixels PURPOSE: Sets default figure pixel location relative to screen sets: set(0,'defaultFigurePosition',ijdidj). INPUT: ijdidj= scalar => fac of screen for bottom left window loc = ScreenSize(3,4)/ijdidj ijdidj= vector [2] or [4] [i, j, di, dj] pixel coordinates of figure in main screen (0) defaults i, j to ScreenSize(3,4)/2 defaults di,dj to DefaultFigurePosition(3,4) if 2 or 4 arguments present then assums arguments are i, j, di, dj OUTPUT: executes set(0,'defaultFigurePosition', ijdidj); RESTRICTIONS:","title":"set_def_fig_loc.m"},{"location":"function-guide/GAgraphics/set_def_fig_loc_m/#set_def_fig_locm","text":"","title":"set_def_fig_loc.m"},{"location":"function-guide/GAgraphics/set_def_fig_loc_m/#basic-information","text":"SYNTAX: ijdidj= set_def_fig_loc(ijdidj); vector ijdidj= i, j, di, dj screen pixels set_def_fig_loc; window bottom corner 1/2 screen set_def_fig_loc(frc); window bottom corner frc screen set_def_fig_loc(i,j); window bottom corner i,j pixel's set_def_fig_loc(i,j,di,dj) window corner i,j and size di dj pixels PURPOSE: Sets default figure pixel location relative to screen sets: set(0,'defaultFigurePosition',ijdidj). INPUT: ijdidj= scalar => fac of screen for bottom left window loc = ScreenSize(3,4)/ijdidj ijdidj= vector [2] or [4] [i, j, di, dj] pixel coordinates of figure in main screen (0) defaults i, j to ScreenSize(3,4)/2 defaults di,dj to DefaultFigurePosition(3,4) if 2 or 4 arguments present then assums arguments are i, j, di, dj OUTPUT: executes set(0,'defaultFigurePosition', ijdidj); RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/GAgraphics/slice_ga_m/","text":"slice_ga.m \u00b6 Basic Information \u00b6 slice_ga puts a vertical line (slice) on present axis at x defined by xpoint Routine returns handle(s) to line(s) SYNTAX: handle= slice_ga(xpoint) Input: {default} xpoint= x location of slice(s) [vector] line_spec= line specification for slice (ex. 'r..') {'b'} Output: handle = handle to line(s) Note: (use get(handle(1))] to see line(1) attributes","title":"slice_ga.m"},{"location":"function-guide/GAgraphics/slice_ga_m/#slice_gam","text":"","title":"slice_ga.m"},{"location":"function-guide/GAgraphics/slice_ga_m/#basic-information","text":"slice_ga puts a vertical line (slice) on present axis at x defined by xpoint Routine returns handle(s) to line(s) SYNTAX: handle= slice_ga(xpoint) Input: {default} xpoint= x location of slice(s) [vector] line_spec= line specification for slice (ex. 'r..') {'b'} Output: handle = handle to line(s) Note: (use get(handle(1))] to see line(1) attributes","title":"Basic Information"},{"location":"function-guide/GAgraphics/subplot_ga_m/","text":"subplot_ga.m \u00b6 Basic Information \u00b6 SUBPLOT Create axes in tiled positions. SUBPLOT(m,n,p), or SUBPLOT(mnp), breaks the Figure window into an m-by-n matrix of small axes, selects the p-th axes for for the current plot, and returns the axis handle. The axes are counted along the top row of the Figure window, then the second row, etc. For example, SUBPLOT(2,1,1), PLOT(income) SUBPLOT(2,1,2), PLOT(outgo) plots income on the top half of the window and outgo on the bottom half. SUBPLOT(m,n,p), if the axis already exists, makes it current. SUBPLOT(H), where H is an axis handle, is another way of making an axis current for subsequent plotting commands. SUBPLOT('position',[left bottom width height]) creates an axis at the specified position in normalized coordinates (in in the range from 0.0 to 1.0). If a SUBPLOT specification causes a new axis to overlap an existing axis, the existing axis is deleted. For example, the statement SUBPLOT(1,1,1) deletes all existing smaller axes in the Figure window and creates a new full-figure axis.","title":"subplot_ga.m"},{"location":"function-guide/GAgraphics/subplot_ga_m/#subplot_gam","text":"","title":"subplot_ga.m"},{"location":"function-guide/GAgraphics/subplot_ga_m/#basic-information","text":"SUBPLOT Create axes in tiled positions. SUBPLOT(m,n,p), or SUBPLOT(mnp), breaks the Figure window into an m-by-n matrix of small axes, selects the p-th axes for for the current plot, and returns the axis handle. The axes are counted along the top row of the Figure window, then the second row, etc. For example, SUBPLOT(2,1,1), PLOT(income) SUBPLOT(2,1,2), PLOT(outgo) plots income on the top half of the window and outgo on the bottom half. SUBPLOT(m,n,p), if the axis already exists, makes it current. SUBPLOT(H), where H is an axis handle, is another way of making an axis current for subsequent plotting commands. SUBPLOT('position',[left bottom width height]) creates an axis at the specified position in normalized coordinates (in in the range from 0.0 to 1.0). If a SUBPLOT specification causes a new axis to overlap an existing axis, the existing axis is deleted. For example, the statement SUBPLOT(1,1,1) deletes all existing smaller axes in the Figure window and creates a new full-figure axis.","title":"Basic Information"},{"location":"function-guide/GAgraphics/unblowup_m/","text":"unblowup.m \u00b6 Basic Information \u00b6 unblowup: Script to restore a blownup region of a plot. Usage: >> unblowup","title":"unblowup.m"},{"location":"function-guide/GAgraphics/unblowup_m/#unblowupm","text":"","title":"unblowup.m"},{"location":"function-guide/GAgraphics/unblowup_m/#basic-information","text":"unblowup: Script to restore a blownup region of a plot. Usage: >> unblowup","title":"Basic Information"},{"location":"function-guide/GAgraphics/yaxisloc_right_m/","text":"yaxisloc_right.m \u00b6 Basic Information \u00b6 yaxisloc_right puts the axis on the right hand side rather than left","title":"yaxisloc_right.m"},{"location":"function-guide/GAgraphics/yaxisloc_right_m/#yaxisloc_rightm","text":"","title":"yaxisloc_right.m"},{"location":"function-guide/GAgraphics/yaxisloc_right_m/#basic-information","text":"yaxisloc_right puts the axis on the right hand side rather than left","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/depsFromEqn_m/","text":"depsFromEqn.m \u00b6 Basic Information \u00b6 A pre-defined ignored input","title":"depsFromEqn.m"},{"location":"function-guide/GAplotting/data_access/depsFromEqn_m/#depsfromeqnm","text":"","title":"depsFromEqn.m"},{"location":"function-guide/GAplotting/data_access/depsFromEqn_m/#basic-information","text":"A pre-defined ignored input","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/getDisruptTimes_m/","text":"getDisruptTimes.m \u00b6 Basic Information \u00b6 desired_sigs = {'in','aminor','bt0','vpsdfz','dfz','bmspinj','echpwrc','lhpinj'};","title":"getDisruptTimes.m"},{"location":"function-guide/GAplotting/data_access/getDisruptTimes_m/#getdisrupttimesm","text":"","title":"getDisruptTimes.m"},{"location":"function-guide/GAplotting/data_access/getDisruptTimes_m/#basic-information","text":"desired_sigs = {'in','aminor','bt0','vpsdfz','dfz','bmspinj','echpwrc','lhpinj'};","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/getTBase_m/","text":"getTBase.m \u00b6 Basic Information \u00b6 Default slicing options:","title":"getTBase.m"},{"location":"function-guide/GAplotting/data_access/getTBase_m/#gettbasem","text":"","title":"getTBase.m"},{"location":"function-guide/GAplotting/data_access/getTBase_m/#basic-information","text":"Default slicing options:","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/get_defaults_for_tok_m/","text":"get_defaults_for_tok.m \u00b6 Basic Information \u00b6 First, figure out what tokamak to get good defaults for signal definitions:","title":"get_defaults_for_tok.m"},{"location":"function-guide/GAplotting/data_access/get_defaults_for_tok_m/#get_defaults_for_tokm","text":"","title":"get_defaults_for_tok.m"},{"location":"function-guide/GAplotting/data_access/get_defaults_for_tok_m/#basic-information","text":"First, figure out what tokamak to get good defaults for signal definitions:","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/get_prefix_metric_m/","text":"get_prefix_metric.m \u00b6 Basic Information \u00b6 Special case: half-way between two possible exponents:","title":"get_prefix_metric.m"},{"location":"function-guide/GAplotting/data_access/get_prefix_metric_m/#get_prefix_metricm","text":"","title":"get_prefix_metric.m"},{"location":"function-guide/GAplotting/data_access/get_prefix_metric_m/#basic-information","text":"Special case: half-way between two possible exponents:","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/isSigDef_m/","text":"isSigDef.m \u00b6 Basic Information \u00b6 plt_cell = {'ptname', 'tree', [timwin], calib#, 'units', {procs}, {deps}, {pltargs}, 'label', 'math', 'desc'};}","title":"isSigDef.m"},{"location":"function-guide/GAplotting/data_access/isSigDef_m/#issigdefm","text":"","title":"isSigDef.m"},{"location":"function-guide/GAplotting/data_access/isSigDef_m/#basic-information","text":"plt_cell = {'ptname', 'tree', [timwin], calib#, 'units', {procs}, {deps}, {pltargs}, 'label', 'math', 'desc'};}","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/parse_units_m/","text":"parse_units.m \u00b6 Basic Information \u00b6 We match:","title":"parse_units.m"},{"location":"function-guide/GAplotting/data_access/parse_units_m/#parse_unitsm","text":"","title":"parse_units.m"},{"location":"function-guide/GAplotting/data_access/parse_units_m/#basic-information","text":"We match:","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/ptname_find_mdstree_m/","text":"ptname_find_mdstree.m \u00b6 Basic Information \u00b6 Make a new MDSplus connection if none was provided:","title":"ptname_find_mdstree.m"},{"location":"function-guide/GAplotting/data_access/ptname_find_mdstree_m/#ptname_find_mdstreem","text":"","title":"ptname_find_mdstree.m"},{"location":"function-guide/GAplotting/data_access/ptname_find_mdstree_m/#basic-information","text":"Make a new MDSplus connection if none was provided:","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/pullShotData_m/","text":"pullShotData.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: INPUTS: OUTPUT: EXAMPLES: RESTRICTIONS: METHOD: WRITTEN BY: Jayson Barr","title":"pullShotData.m"},{"location":"function-guide/GAplotting/data_access/pullShotData_m/#pullshotdatam","text":"","title":"pullShotData.m"},{"location":"function-guide/GAplotting/data_access/pullShotData_m/#basic-information","text":"SYNTAX: PURPOSE: INPUTS: OUTPUT: EXAMPLES: RESTRICTIONS: METHOD: WRITTEN BY: Jayson Barr","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/sigStruct_m/","text":"sigStruct.m \u00b6 Basic Information \u00b6 plt_cell = {'ptname', 'tree', [timwin], calib#, 'units', {postprocs}, {deps}, {pltargs}, 'label', 'desc'};","title":"sigStruct.m"},{"location":"function-guide/GAplotting/data_access/sigStruct_m/#sigstructm","text":"","title":"sigStruct.m"},{"location":"function-guide/GAplotting/data_access/sigStruct_m/#basic-information","text":"plt_cell = {'ptname', 'tree', [timwin], calib#, 'units', {postprocs}, {deps}, {pltargs}, 'label', 'desc'};","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/syncToTbase_m/","text":"syncToTbase.m \u00b6 Basic Information \u00b6 Determine if windowing or interpolating","title":"syncToTbase.m"},{"location":"function-guide/GAplotting/data_access/syncToTbase_m/#synctotbasem","text":"","title":"syncToTbase.m"},{"location":"function-guide/GAplotting/data_access/syncToTbase_m/#basic-information","text":"Determine if windowing or interpolating","title":"Basic Information"},{"location":"function-guide/GAplotting/data_conditioning/hpf_signal_m/","text":"hpf_signal.m \u00b6 Basic Information \u00b6 freqz(coefs)","title":"hpf_signal.m"},{"location":"function-guide/GAplotting/data_conditioning/hpf_signal_m/#hpf_signalm","text":"","title":"hpf_signal.m"},{"location":"function-guide/GAplotting/data_conditioning/hpf_signal_m/#basic-information","text":"freqz(coefs)","title":"Basic Information"},{"location":"function-guide/GAplotting/data_conditioning/lpf_signal_m/","text":"lpf_signal.m \u00b6 Basic Information \u00b6 freqz(coefs)","title":"lpf_signal.m"},{"location":"function-guide/GAplotting/data_conditioning/lpf_signal_m/#lpf_signalm","text":"","title":"lpf_signal.m"},{"location":"function-guide/GAplotting/data_conditioning/lpf_signal_m/#basic-information","text":"freqz(coefs)","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/breakup_trippedsig_m/","text":"breakup_trippedsig.m \u00b6 Basic Information \u00b6 BREAKUP_TRIPPEDSIG Break up bit-flag data from a signal. [trips, trips_t, out_labels, ier_post] = breakup_trippedsig(signal, signal_t, sig_name, do_plot) INPUTS: sig_name: A string for looking up the values of the bits. Recognized bit flags are for: 'onstripped', 'dudtrip', or 'onsstates' shot_data: data structure holding all the shot's data. do_plot: Optional plot of the broken up outputs. OUTPUTS: trips: Matrix: rows = time dimension, columns = each bit in the source signal. For example, trips(:,1) an array with values for each time point for the 2^0 bit. 0 means flag off, and 1 means the flag was on. trips_t: Array of time values - the same signal_t. out_labels: If sig_name was supplied and corresponds to one of the supported signals (onstripped, dustripped, or onsstates), then out_labels contains the labels fo each bit = each column in trips. ier_post: 0 if no error, positive integer if an error occurs. or 1 in to array the values versus time for","title":"breakup_trippedsig.m"},{"location":"function-guide/GAplotting/derived_data_funcs/breakup_trippedsig_m/#breakup_trippedsigm","text":"","title":"breakup_trippedsig.m"},{"location":"function-guide/GAplotting/derived_data_funcs/breakup_trippedsig_m/#basic-information","text":"BREAKUP_TRIPPEDSIG Break up bit-flag data from a signal. [trips, trips_t, out_labels, ier_post] = breakup_trippedsig(signal, signal_t, sig_name, do_plot) INPUTS: sig_name: A string for looking up the values of the bits. Recognized bit flags are for: 'onstripped', 'dudtrip', or 'onsstates' shot_data: data structure holding all the shot's data. do_plot: Optional plot of the broken up outputs. OUTPUTS: trips: Matrix: rows = time dimension, columns = each bit in the source signal. For example, trips(:,1) an array with values for each time point for the 2^0 bit. 0 means flag off, and 1 means the flag was on. trips_t: Array of time values - the same signal_t. out_labels: If sig_name was supplied and corresponds to one of the supported signals (onstripped, dustripped, or onsstates), then out_labels contains the labels fo each bit = each column in trips. ier_post: 0 if no error, positive integer if an error occurs. or 1 in to array the values versus time for","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_fft_m/","text":"d_fft.m \u00b6 Basic Information \u00b6 Sort just in case:","title":"d_fft.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_fft_m/#d_fftm","text":"","title":"d_fft.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_fft_m/#basic-information","text":"Sort just in case:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_geom2_m/","text":"d_geom2.m \u00b6 Basic Information \u00b6 diff_psi_frac_thresh_is_perfect_dnd = diff_psi_frac_thresh_is_bdy;","title":"d_geom2.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_geom2_m/#d_geom2m","text":"","title":"d_geom2.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_geom2_m/#basic-information","text":"diff_psi_frac_thresh_is_perfect_dnd = diff_psi_frac_thresh_is_bdy;","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_geomTest_m/","text":"d_geomTest.m \u00b6 Basic Information \u00b6 Large positive values mean an error:","title":"d_geomTest.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_geomTest_m/#d_geomtestm","text":"","title":"d_geomTest.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_geomTest_m/#basic-information","text":"Large positive values mean an error:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_geom_m/","text":"d_geom.m \u00b6 Basic Information \u00b6 this signal not available - assume source not used and try the next source provided:","title":"d_geom.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_geom_m/#d_geomm","text":"","title":"d_geom.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_geom_m/#basic-information","text":"this signal not available - assume source not used and try the next source provided:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_hmode_m/","text":"d_hmode.m \u00b6 Basic Information \u00b6 Possible output values:","title":"d_hmode.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_hmode_m/#d_hmodem","text":"","title":"d_hmode.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_hmode_m/#basic-information","text":"Possible output values:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_hpf_m/","text":"d_hpf.m \u00b6 Basic Information \u00b6 Special case: the [] input normally used for the time-window is over-loaded with filter params:","title":"d_hpf.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_hpf_m/#d_hpfm","text":"","title":"d_hpf.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_hpf_m/#basic-information","text":"Special case: the [] input normally used for the time-window is over-loaded with filter params:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_lpf_m/","text":"d_lpf.m \u00b6 Basic Information \u00b6 if n_args == 3+n_taps+1 coefs = [filt_params{4:end}]; else","title":"d_lpf.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_lpf_m/#d_lpfm","text":"","title":"d_lpf.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_lpf_m/#basic-information","text":"if n_args == 3+n_taps+1 coefs = [filt_params{4:end}]; else","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_lpf_old_m/","text":"d_lpf_old.m \u00b6 Basic Information \u00b6 Special case: the [] input normally used for the time-window is over-loaded with filter params:","title":"d_lpf_old.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_lpf_old_m/#d_lpf_oldm","text":"","title":"d_lpf_old.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_lpf_old_m/#basic-information","text":"Special case: the [] input normally used for the time-window is over-loaded with filter params:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_lpfsmth_m/","text":"d_lpfsmth.m \u00b6 Basic Information \u00b6 Special case: the [] input normally used for the time-window is over-loaded with filter params:","title":"d_lpfsmth.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_lpfsmth_m/#d_lpfsmthm","text":"","title":"d_lpfsmth.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_lpfsmth_m/#basic-information","text":"Special case: the [] input normally used for the time-window is over-loaded with filter params:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_math_m/","text":"d_math.m \u00b6 Basic Information \u00b6 Default is to sum:","title":"d_math.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_math_m/#d_mathm","text":"","title":"d_math.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_math_m/#basic-information","text":"Default is to sum:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_poh_m/","text":"d_poh.m \u00b6 Basic Information \u00b6 Do we have required inputs?","title":"d_poh.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_poh_m/#d_pohm","text":"","title":"d_poh.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_poh_m/#basic-information","text":"Do we have required inputs?","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_psol_m/","text":"d_psol.m \u00b6 Basic Information \u00b6 Default is to sum:","title":"d_psol.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_psol_m/#d_psolm","text":"","title":"d_psol.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_psol_m/#basic-information","text":"Default is to sum:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_sub_m/","text":"d_sub.m \u00b6 Basic Information \u00b6 this signal not available - assume source not used and try the next source provided:","title":"d_sub.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_sub_m/#d_subm","text":"","title":"d_sub.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_sub_m/#basic-information","text":"this signal not available - assume source not used and try the next source provided:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_sum_m/","text":"d_sum.m \u00b6 Basic Information \u00b6 this signal not available - assume source not used and try the next source provided:","title":"d_sum.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_sum_m/#d_summ","text":"","title":"d_sum.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_sum_m/#basic-information","text":"this signal not available - assume source not used and try the next source provided:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_tripdetect_m/","text":"d_tripdetect.m \u00b6 Basic Information \u00b6 Get the input signal data:","title":"d_tripdetect.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_tripdetect_m/#d_tripdetectm","text":"","title":"d_tripdetect.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_tripdetect_m/#basic-information","text":"Get the input signal data:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/d_vsurf_m/","text":"d_vsurf.m \u00b6 Basic Information \u00b6 First, derivative:","title":"d_vsurf.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_vsurf_m/#d_vsurfm","text":"","title":"d_vsurf.m"},{"location":"function-guide/GAplotting/derived_data_funcs/d_vsurf_m/#basic-information","text":"First, derivative:","title":"Basic Information"},{"location":"function-guide/GAplotting/derived_data_funcs/split_trip_flags_m/","text":"split_trip_flags.m \u00b6 Basic Information \u00b6 BREAKUP_TRIPPEDSIG Break up bit-flag data from a signal. [trips, trips_t, out_labels, ier_post] = breakup_trippedsig(signal, signal_t, sig_name, do_plot) INPUTS: sig_name: A string for looking up the values of the bits. Recognized bit flags are for: 'onstripped', 'dudtrip', or 'onsstates' shot_data: data structure holding all the shot's data. do_plot: Optional plot of the broken up outputs. OUTPUTS: trips: Matrix: rows = time dimension, columns = each bit in the source signal. For example, trips(:,1) an array with values for each time point for the 2^0 bit. 0 means flag off, and 1 means the flag was on. trips_t: Array of time values - the same signal_t. out_labels: If sig_name was supplied and corresponds to one of the supported signals (onstripped, dustripped, or onsstates), then out_labels contains the labels fo each bit = each column in trips. ier_post: 0 if no error, positive integer if an error occurs. or 1 in to array the values versus time for","title":"split_trip_flags.m"},{"location":"function-guide/GAplotting/derived_data_funcs/split_trip_flags_m/#split_trip_flagsm","text":"","title":"split_trip_flags.m"},{"location":"function-guide/GAplotting/derived_data_funcs/split_trip_flags_m/#basic-information","text":"BREAKUP_TRIPPEDSIG Break up bit-flag data from a signal. [trips, trips_t, out_labels, ier_post] = breakup_trippedsig(signal, signal_t, sig_name, do_plot) INPUTS: sig_name: A string for looking up the values of the bits. Recognized bit flags are for: 'onstripped', 'dudtrip', or 'onsstates' shot_data: data structure holding all the shot's data. do_plot: Optional plot of the broken up outputs. OUTPUTS: trips: Matrix: rows = time dimension, columns = each bit in the source signal. For example, trips(:,1) an array with values for each time point for the 2^0 bit. 0 means flag off, and 1 means the flag was on. trips_t: Array of time values - the same signal_t. out_labels: If sig_name was supplied and corresponds to one of the supported signals (onstripped, dustripped, or onsstates), then out_labels contains the labels fo each bit = each column in trips. ier_post: 0 if no error, positive integer if an error occurs. or 1 in to array the values versus time for","title":"Basic Information"},{"location":"function-guide/GAplotting/old/backup_tokPlotGUI_m/","text":"backup_tokPlotGUI.m \u00b6 Basic Information \u00b6 Need to make gui options for this:","title":"backup_tokPlotGUI.m"},{"location":"function-guide/GAplotting/old/backup_tokPlotGUI_m/#backup_tokplotguim","text":"","title":"backup_tokPlotGUI.m"},{"location":"function-guide/GAplotting/old/backup_tokPlotGUI_m/#basic-information","text":"Need to make gui options for this:","title":"Basic Information"},{"location":"function-guide/GAplotting/old/expandFigSetup_m/","text":"expandFigSetup.m \u00b6 Basic Information \u00b6 Can specify plot setup multiple ways: A cell array: { {'ptname', <'tree'>, Order *after ptname* <[xmin,xmax,<ymin,ymax>]>, does *not* matter. <'Label'>,<{'plot','args'}>, *except* if label is }, provided before the tree - in this case you *must* add either \"tree:\", or \":\" to the beginning of the tree def, -or- \"label:\", or \"$\" to the beginning of the label def. ***also***, you may use a simple string for the plot args, but you *must* { Combo plot = multi signals, same plot: 'combo', 'c', 'm', or 'multi' also works. 'ptname1', first signal 'ptname2', second signal {'ptname3','tree3'}, third signal }, 'ptname', Simple string def - see below 'ptname:tree', Simple string def - see below } A simple, single string can define a plot: 'ptname1' Default tree, default stylings, etc. A detailed string can add many options: 'ptname1<:tree1><(-inf,inf,0,10<)>><@postproc1,postproc2><&req,other,sigs,for,procs><#..k,LineWidth,2><$LabelHere>' where <...> indicates that an argument is optional, and the order of these added options does not matter - except that the pointname *must* be first each part defines more plot details: :tree_name = Designates a particular tree, defaulting to default tree set by get_defaults_for_tok $Label = Give a styled label for the legend. Default = pointname (tree)s #plot,args,specs = Split by ',' and plain numbers are converted to floats, otherwise passed as strings Single level array of strings - each is a sep. plot { 'ptname2:tree1#--b', Specified tree, basic stylings 'ptname3#..k,LineWidth,2' Default tree, detailed stylings } If a cell is another array - indicates plots with >1 signal in the same plot { 'ptname1#..k', First plot has one signale { 'ptname1', Second plot has 2 signals 'ptname2:tree2', }, 'ptname3:tree3', A third plot now ... can define another plot here..., 'style:LineWidth,2', (Optional: set default styling for *all* the plots) } ### Can define a reference to a pre-made shot setup definition: 'plot:plot_setup1' ### Any compo of above will work! { 'ptname1', 1st plot: 1 sig 'plot:plot_setup1', 2nd plot: pre-designed {'ptname1:tree1,'ptname2#..k'}, 3rd plot: 2 signals 'style:-,LineWidth,2', Some default styling }","title":"expandFigSetup.m"},{"location":"function-guide/GAplotting/old/expandFigSetup_m/#expandfigsetupm","text":"","title":"expandFigSetup.m"},{"location":"function-guide/GAplotting/old/expandFigSetup_m/#basic-information","text":"Can specify plot setup multiple ways: A cell array: { {'ptname', <'tree'>, Order *after ptname* <[xmin,xmax,<ymin,ymax>]>, does *not* matter. <'Label'>,<{'plot','args'}>, *except* if label is }, provided before the tree - in this case you *must* add either \"tree:\", or \":\" to the beginning of the tree def, -or- \"label:\", or \"$\" to the beginning of the label def. ***also***, you may use a simple string for the plot args, but you *must* { Combo plot = multi signals, same plot: 'combo', 'c', 'm', or 'multi' also works. 'ptname1', first signal 'ptname2', second signal {'ptname3','tree3'}, third signal }, 'ptname', Simple string def - see below 'ptname:tree', Simple string def - see below } A simple, single string can define a plot: 'ptname1' Default tree, default stylings, etc. A detailed string can add many options: 'ptname1<:tree1><(-inf,inf,0,10<)>><@postproc1,postproc2><&req,other,sigs,for,procs><#..k,LineWidth,2><$LabelHere>' where <...> indicates that an argument is optional, and the order of these added options does not matter - except that the pointname *must* be first each part defines more plot details: :tree_name = Designates a particular tree, defaulting to default tree set by get_defaults_for_tok $Label = Give a styled label for the legend. Default = pointname (tree)s #plot,args,specs = Split by ',' and plain numbers are converted to floats, otherwise passed as strings Single level array of strings - each is a sep. plot { 'ptname2:tree1#--b', Specified tree, basic stylings 'ptname3#..k,LineWidth,2' Default tree, detailed stylings } If a cell is another array - indicates plots with >1 signal in the same plot { 'ptname1#..k', First plot has one signale { 'ptname1', Second plot has 2 signals 'ptname2:tree2', }, 'ptname3:tree3', A third plot now ... can define another plot here..., 'style:LineWidth,2', (Optional: set default styling for *all* the plots) } ### Can define a reference to a pre-made shot setup definition: 'plot:plot_setup1' ### Any compo of above will work! { 'ptname1', 1st plot: 1 sig 'plot:plot_setup1', 2nd plot: pre-designed {'ptname1:tree1,'ptname2#..k'}, 3rd plot: 2 signals 'style:-,LineWidth,2', Some default styling }","title":"Basic Information"},{"location":"function-guide/GAplotting/old/signals_from_plot_setup_m/","text":"signals_from_plot_setup.m \u00b6 Basic Information \u00b6 Tokamaks: Default Servers: Default Trees:","title":"signals_from_plot_setup.m"},{"location":"function-guide/GAplotting/old/signals_from_plot_setup_m/#signals_from_plot_setupm","text":"","title":"signals_from_plot_setup.m"},{"location":"function-guide/GAplotting/old/signals_from_plot_setup_m/#basic-information","text":"Tokamaks: Default Servers: Default Trees:","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/bookmarks_m/","text":"bookmarks.m \u00b6 Basic Information \u00b6 bMarks should be a string which indicates a pre-setup plot/figure setup already defined in bookmarks.m Right now, choices are: 'basic' and 'trips'","title":"bookmarks.m"},{"location":"function-guide/GAplotting/plotting/bookmarks_m/#bookmarksm","text":"","title":"bookmarks.m"},{"location":"function-guide/GAplotting/plotting/bookmarks_m/#basic-information","text":"bMarks should be a string which indicates a pre-setup plot/figure setup already defined in bookmarks.m Right now, choices are: 'basic' and 'trips'","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/combineStyles_m/","text":"combineStyles.m \u00b6 Basic Information \u00b6 If odd number args, must have the ML-style LineSPec first string:","title":"combineStyles.m"},{"location":"function-guide/GAplotting/plotting/combineStyles_m/#combinestylesm","text":"","title":"combineStyles.m"},{"location":"function-guide/GAplotting/plotting/combineStyles_m/#basic-information","text":"If odd number args, must have the ML-style LineSPec first string:","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/combine_plots_m/","text":"combine_plots.m \u00b6 Basic Information \u00b6 sorted:","title":"combine_plots.m"},{"location":"function-guide/GAplotting/plotting/combine_plots_m/#combine_plotsm","text":"","title":"combine_plots.m"},{"location":"function-guide/GAplotting/plotting/combine_plots_m/#basic-information","text":"sorted:","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/expandFigSigDef_m/","text":"expandFigSigDef.m \u00b6 Basic Information \u00b6 Can specify plot setup multiple ways: plt_cell = {'ptname', 'tree', [timwin], calib#, 'units', {procs}, {deps}, {pltargs}, 'label', 'desc'};}","title":"expandFigSigDef.m"},{"location":"function-guide/GAplotting/plotting/expandFigSigDef_m/#expandfigsigdefm","text":"","title":"expandFigSigDef.m"},{"location":"function-guide/GAplotting/plotting/expandFigSigDef_m/#basic-information","text":"Can specify plot setup multiple ways: plt_cell = {'ptname', 'tree', [timwin], calib#, 'units', {procs}, {deps}, {pltargs}, 'label', 'desc'};}","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/facy_export_dmp_h5_m/","text":"facy_export_dmp_h5.m \u00b6 Basic Information \u00b6 Reverse ordering:","title":"facy_export_dmp_h5.m"},{"location":"function-guide/GAplotting/plotting/facy_export_dmp_h5_m/#facy_export_dmp_h5m","text":"","title":"facy_export_dmp_h5.m"},{"location":"function-guide/GAplotting/plotting/facy_export_dmp_h5_m/#basic-information","text":"Reverse ordering:","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/fancy_area_m/","text":"fancy_area.m \u00b6 Basic Information \u00b6 User just wants the axes!","title":"fancy_area.m"},{"location":"function-guide/GAplotting/plotting/fancy_area_m/#fancy_aream","text":"","title":"fancy_area.m"},{"location":"function-guide/GAplotting/plotting/fancy_area_m/#basic-information","text":"User just wants the axes!","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/fancy_bar_m/","text":"fancy_bar.m \u00b6 Basic Information \u00b6 User just wants the axes!","title":"fancy_bar.m"},{"location":"function-guide/GAplotting/plotting/fancy_bar_m/#fancy_barm","text":"","title":"fancy_bar.m"},{"location":"function-guide/GAplotting/plotting/fancy_bar_m/#basic-information","text":"User just wants the axes!","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/fancy_hist_m/","text":"fancy_hist.m \u00b6 Basic Information \u00b6 User just wants the axes!","title":"fancy_hist.m"},{"location":"function-guide/GAplotting/plotting/fancy_hist_m/#fancy_histm","text":"","title":"fancy_hist.m"},{"location":"function-guide/GAplotting/plotting/fancy_hist_m/#basic-information","text":"User just wants the axes!","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/fancy_plot_m/","text":"fancy_plot.m \u00b6 Basic Information \u00b6 User just wants the axes!","title":"fancy_plot.m"},{"location":"function-guide/GAplotting/plotting/fancy_plot_m/#fancy_plotm","text":"","title":"fancy_plot.m"},{"location":"function-guide/GAplotting/plotting/fancy_plot_m/#basic-information","text":"User just wants the axes!","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/fancy_save_m/","text":"fancy_save.m \u00b6 Basic Information \u00b6 Update the figure before saving:","title":"fancy_save.m"},{"location":"function-guide/GAplotting/plotting/fancy_save_m/#fancy_savem","text":"","title":"fancy_save.m"},{"location":"function-guide/GAplotting/plotting/fancy_save_m/#basic-information","text":"Update the figure before saving:","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/fancy_scatter_m/","text":"fancy_scatter.m \u00b6 Basic Information \u00b6 User just wants the axes!","title":"fancy_scatter.m"},{"location":"function-guide/GAplotting/plotting/fancy_scatter_m/#fancy_scatterm","text":"","title":"fancy_scatter.m"},{"location":"function-guide/GAplotting/plotting/fancy_scatter_m/#basic-information","text":"User just wants the axes!","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/get_hist_edges_m/","text":"get_hist_edges.m \u00b6 Basic Information \u00b6 if nargin < 2 || isempty(n_bins) || isnan(n_bins) || isinf(n_bins) Dealt with below!!! end","title":"get_hist_edges.m"},{"location":"function-guide/GAplotting/plotting/get_hist_edges_m/#get_hist_edgesm","text":"","title":"get_hist_edges.m"},{"location":"function-guide/GAplotting/plotting/get_hist_edges_m/#basic-information","text":"if nargin < 2 || isempty(n_bins) || isnan(n_bins) || isinf(n_bins) Dealt with below!!! end","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/parsePltDefStr_m/","text":"parsePltDefStr.m \u00b6 Basic Information \u00b6 A simple, single string can define a plot: 'ptname1' Default tree, default stylings, etc. A detailed string can add many options: 'ptname1<:tree1><(-inf,inf,0,10<)>><#..k,LineWidth,2><$LabelHere>' where <...> indicates that an argument is optional, and the order of these added options does not matter - except that the pointname *must* be first each part defines more plot details: :tree_name = Designates a particular tree, defaulting to default tree set by get_defaults_for_tok (xmin,xmax,<ymin,ymax><)>= Give plot axes, default is [-inf,inf,inf,inf] $Label = Give a styled label for the legend. Default = pointname (tree)s #plot,args,specs = Split by ',' and plain numbers are converted to floats, otherwise passed as strings","title":"parsePltDefStr.m"},{"location":"function-guide/GAplotting/plotting/parsePltDefStr_m/#parsepltdefstrm","text":"","title":"parsePltDefStr.m"},{"location":"function-guide/GAplotting/plotting/parsePltDefStr_m/#basic-information","text":"A simple, single string can define a plot: 'ptname1' Default tree, default stylings, etc. A detailed string can add many options: 'ptname1<:tree1><(-inf,inf,0,10<)>><#..k,LineWidth,2><$LabelHere>' where <...> indicates that an argument is optional, and the order of these added options does not matter - except that the pointname *must* be first each part defines more plot details: :tree_name = Designates a particular tree, defaulting to default tree set by get_defaults_for_tok (xmin,xmax,<ymin,ymax><)>= Give plot axes, default is [-inf,inf,inf,inf] $Label = Give a styled label for the legend. Default = pointname (tree)s #plot,args,specs = Split by ',' and plain numbers are converted to floats, otherwise passed as strings","title":"Basic Information"},{"location":"function-guide/GAplotting/plotting/plotShot_m/","text":"plotShot.m \u00b6 Basic Information \u00b6 SYNTAX: [ shot_data, fig_handles, conn]=... plotShot(snlist, fig_setup, tokOrServer, figs_layout_spec, tightx, shot_data, conn, slice_options) PURPOSE: For quick plotting of experimental data, with options for more post-processing as needed. INPUTS: snlist = array of shot numbers to plot data from, or a single number if only one shot is desired. (Required input) fig_setup = a cellarray defining a figure or set of figures. For many examples, or quick layouts to start with, see bookmarks.m. (Required input) Basic spec for a signal definition (string!) is a string pointname followed by a series of deliminators before added options. Deliminators are nedded before adding these argurments, but if leaving default do not supply any deliminators not being used. Minimum: 'ptname' Common: 'ptname:tree' Full spec: 'ptname[chord]:tree#pltargs$label*calib@postprocfunc(t0,t1)&dependency1,dep2units?Description' * Note that everything but the ptname is optional! Details on each part of the spec (): ptname = pointname of desired signal [chord] = optional designation of chord location :tree = ptdata or a mdsplus tree where the data resides. If not set, first looks for ptdata, then searches for a tree where it finds the pointname. If in EFIT trees, the order of preference for EFIT to use is set per-tokamak in get_defaults_for_tok.m. For D3D, it is EFIT01,EFITRT1... *Note: if the user is defining a new signal that is constructed from multiple other signals via a post-processing function, then tree MUST be set to 'D' (which is to stand for derived). #pltargs = comma deliminated set of plotting arguments to be passed to the plot function. Do not use quotation marks. For example, to set the line-width to 2, you would put this in your signal spec: 'ptname#LineWidth,2' $label = a label to use for plotting y-axis and legend. using standard matlab stying. Example: 'ipsip$I_p' *calib = a multiplicative calibration factor to apply *instead* of the one stored in mdsplus @postprocfunc = a post-processing function to apply to the signal. This function must expect the appropriate inputs and give the right outputs. See all of provided functions in GAplotting/derivedd_data_funcs for examples. Many useful functions already exist. Of particular note is d_math. (t0,t1) = subwindow of time to include data from, if not desired to use the full time series &dependency1,dep2,dep3... = a list of other ptnames that must be loaded as well before applying the post-processing function to this signal. units = units for labelling in the plots. If not supplied, then first mdsplus will be checked to see if units are associated with the pointname. Then, get_defaults_for_tok.m will be used to check for noted units for pointnames listed there. ?Description = optional description of the signal, stored in the output data structure Separate subplots into sub-cell arrays: {{subplot1}, {subplot2}, {subplot3}} tokOrServer = the name of a tokamak or server address collect data from. For recognized tokamak names, the server address is known and applied (see get_defaults_for_tok.m). (Default: d3d) Tokamaks recognized: d3d, kstar, east, eastga, mastu, nstxu, jet *eastga = GA local server of subset of EAST data. figs_layout_spec = [# rows, # columns] for the layout of subplots in the output figures. If only one number is specified, it is assumed to be the number of rows, and # columns assumed to be 1. Set just an empty array like [] to auto-scale the # rows and # columns to fit all of the subplots defined in a single plot. (Default: []) *If the number of subplots define din fig_setup is larger than the #rows * # plots, then multiple figures will be generated, following the defined order of subplots defined in fit_setup, and each with [# rows, # columns]. tightx = Set to a true value if it is desired to have plots in the same column be closer together vertically, hiding the x-axis labels for all but the bottom plot. The x-axes will be linked so that all of the x-axes have the same scales, and change together. Especially useful for figures of several time-series signals. shot_data = a structure of the type produced by pullShotData.m. If provided, then before pulling data from servers this structure will be first checked to see if the data already exists locally. This is the same type as output by this function. This is to save time from repeatedly downloading data when unnecessary. If set to NaN, then just load all of the data first. (Default: nan = no starting data, just reload all needed) conn = an mds connection object as can be obtained from getmdsconn.m, which can be used to connect to a remote mds server. Reusing a connection save serious time in downloading data, using the getmdata.m function instead of getmds.m. Note that a connection of this type is also an output - allowing for easy reuse of connections to save time. Set to nan to ignore and just open a new connection. (Default: nan = open a new connection) slice_options = If it is desired to sync all loaded data to a common timebase, then define a structure here of the type expected by getTBase.m. See getTBase.m for how to define this structure if synchronizing timebase is desired. Set to nan to just keep the original timebase of each loaded signal. (Default: nan = keep indivicual, original signal timebases). OUTPUT: shot_data = a structure of the type produced by pullShotData.m, containing all data loaded for plotting. If the user supplied a shot_data structure as an input, the user-supplied data was used where possible, and any additional data was loaded as needed. See pullShotData.m for more detailed specification of the structure layout. fig_handles = an array of figure handles for each of the figures produced by this function while plotting. conn = a reusable mds connection object as can be obtained from getmdsconn.m, and the original user-given objust if this optional input was provided. See more details in input definition above or in getmdsconn.m EXAMPLES: plotShot(181035,{'ip','kappa:EFIT01','bmspinj'}) [shot_data,~,conn]=plotShot([181035,181041],{'ipsip','li','sysfpstrip'}) plotShot([181035,181041],{'ipsip','li','sysfpstrip'},'d3d',[],1,shot_data,conn) plotShot(95145,{'ip'},'east') plotShot(181035,bookmarks('basic','d3d'),'d3d') plotShot(181035,{'ipsip$I_p*1e6A'}) plotShot(181035,{'ip','gasTot:D@d_math&+gasa,+gasb,+gasc,+gasd,+gase'}) RESTRICTIONS: METHOD: WRITTEN BY: Jayson Barr","title":"plotShot.m"},{"location":"function-guide/GAplotting/plotting/plotShot_m/#plotshotm","text":"","title":"plotShot.m"},{"location":"function-guide/GAplotting/plotting/plotShot_m/#basic-information","text":"SYNTAX: [ shot_data, fig_handles, conn]=... plotShot(snlist, fig_setup, tokOrServer, figs_layout_spec, tightx, shot_data, conn, slice_options) PURPOSE: For quick plotting of experimental data, with options for more post-processing as needed. INPUTS: snlist = array of shot numbers to plot data from, or a single number if only one shot is desired. (Required input) fig_setup = a cellarray defining a figure or set of figures. For many examples, or quick layouts to start with, see bookmarks.m. (Required input) Basic spec for a signal definition (string!) is a string pointname followed by a series of deliminators before added options. Deliminators are nedded before adding these argurments, but if leaving default do not supply any deliminators not being used. Minimum: 'ptname' Common: 'ptname:tree' Full spec: 'ptname[chord]:tree#pltargs$label*calib@postprocfunc(t0,t1)&dependency1,dep2units?Description' * Note that everything but the ptname is optional! Details on each part of the spec (): ptname = pointname of desired signal [chord] = optional designation of chord location :tree = ptdata or a mdsplus tree where the data resides. If not set, first looks for ptdata, then searches for a tree where it finds the pointname. If in EFIT trees, the order of preference for EFIT to use is set per-tokamak in get_defaults_for_tok.m. For D3D, it is EFIT01,EFITRT1... *Note: if the user is defining a new signal that is constructed from multiple other signals via a post-processing function, then tree MUST be set to 'D' (which is to stand for derived). #pltargs = comma deliminated set of plotting arguments to be passed to the plot function. Do not use quotation marks. For example, to set the line-width to 2, you would put this in your signal spec: 'ptname#LineWidth,2' $label = a label to use for plotting y-axis and legend. using standard matlab stying. Example: 'ipsip$I_p' *calib = a multiplicative calibration factor to apply *instead* of the one stored in mdsplus @postprocfunc = a post-processing function to apply to the signal. This function must expect the appropriate inputs and give the right outputs. See all of provided functions in GAplotting/derivedd_data_funcs for examples. Many useful functions already exist. Of particular note is d_math. (t0,t1) = subwindow of time to include data from, if not desired to use the full time series &dependency1,dep2,dep3... = a list of other ptnames that must be loaded as well before applying the post-processing function to this signal. units = units for labelling in the plots. If not supplied, then first mdsplus will be checked to see if units are associated with the pointname. Then, get_defaults_for_tok.m will be used to check for noted units for pointnames listed there. ?Description = optional description of the signal, stored in the output data structure Separate subplots into sub-cell arrays: {{subplot1}, {subplot2}, {subplot3}} tokOrServer = the name of a tokamak or server address collect data from. For recognized tokamak names, the server address is known and applied (see get_defaults_for_tok.m). (Default: d3d) Tokamaks recognized: d3d, kstar, east, eastga, mastu, nstxu, jet *eastga = GA local server of subset of EAST data. figs_layout_spec = [# rows, # columns] for the layout of subplots in the output figures. If only one number is specified, it is assumed to be the number of rows, and # columns assumed to be 1. Set just an empty array like [] to auto-scale the # rows and # columns to fit all of the subplots defined in a single plot. (Default: []) *If the number of subplots define din fig_setup is larger than the #rows * # plots, then multiple figures will be generated, following the defined order of subplots defined in fit_setup, and each with [# rows, # columns]. tightx = Set to a true value if it is desired to have plots in the same column be closer together vertically, hiding the x-axis labels for all but the bottom plot. The x-axes will be linked so that all of the x-axes have the same scales, and change together. Especially useful for figures of several time-series signals. shot_data = a structure of the type produced by pullShotData.m. If provided, then before pulling data from servers this structure will be first checked to see if the data already exists locally. This is the same type as output by this function. This is to save time from repeatedly downloading data when unnecessary. If set to NaN, then just load all of the data first. (Default: nan = no starting data, just reload all needed) conn = an mds connection object as can be obtained from getmdsconn.m, which can be used to connect to a remote mds server. Reusing a connection save serious time in downloading data, using the getmdata.m function instead of getmds.m. Note that a connection of this type is also an output - allowing for easy reuse of connections to save time. Set to nan to ignore and just open a new connection. (Default: nan = open a new connection) slice_options = If it is desired to sync all loaded data to a common timebase, then define a structure here of the type expected by getTBase.m. See getTBase.m for how to define this structure if synchronizing timebase is desired. Set to nan to just keep the original timebase of each loaded signal. (Default: nan = keep indivicual, original signal timebases). OUTPUT: shot_data = a structure of the type produced by pullShotData.m, containing all data loaded for plotting. If the user supplied a shot_data structure as an input, the user-supplied data was used where possible, and any additional data was loaded as needed. See pullShotData.m for more detailed specification of the structure layout. fig_handles = an array of figure handles for each of the figures produced by this function while plotting. conn = a reusable mds connection object as can be obtained from getmdsconn.m, and the original user-given objust if this optional input was provided. See more details in input definition above or in getmdsconn.m EXAMPLES: plotShot(181035,{'ip','kappa:EFIT01','bmspinj'}) [shot_data,~,conn]=plotShot([181035,181041],{'ipsip','li','sysfpstrip'}) plotShot([181035,181041],{'ipsip','li','sysfpstrip'},'d3d',[],1,shot_data,conn) plotShot(95145,{'ip'},'east') plotShot(181035,bookmarks('basic','d3d'),'d3d') plotShot(181035,{'ipsip$I_p*1e6A'}) plotShot(181035,{'ip','gasTot:D@d_math&+gasa,+gasb,+gasc,+gasd,+gase'}) RESTRICTIONS: METHOD: WRITTEN BY: Jayson Barr","title":"Basic Information"},{"location":"function-guide/GAsignal/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Signal processing functions. clip - clip a signal and return the clipped version detect_peaks - peak detector eqconstr_lsqs - equality constrained least squares solver find_vertices - find vertices in piecewise linear data fft_filter - filter data using fft (ideal cutoff characteristics) inout_fresp - calculate frequency response from input/output data integrate - Calculate definite integral of data from t1 to t2(approx.) integrate_t - Calculate indefinite integral of data from t1 to t integrate2D - Compute approx. integral of data defined over x-y grid. linearfit - linear fit to data of the form (sample, data(sample)) linearfit2 - linear fit to (x,y) data make_stepfn - make a step function from data with specified sampling median_filter - see percentile filter percentile_filter - generalization of median filter - choose percent'th sample plot_response - plot sampled frequency response remove_offset - remove DC offset from data vector resamplev - resample data at specified times sample_time - get t0, dt data from a sampled time vector saturatev - vector saturation S-file (see C source code documentation) shift_signal - shift a signal by specified number of samples smoothdt - Boxcar average over specified time interval spectrum - calculate spectrum of data with proper scaling stepfn - make (nonuniform sampled) step function from data (fast) subsample - resample data vector at fixed increments taufilter - one pole filter with time constant tau window_data - extract x-window from (x,y) data zero_crossings - find zero crossings in signal","title":"Contents.m"},{"location":"function-guide/GAsignal/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/GAsignal/Contents_m/#basic-information","text":"Signal processing functions. clip - clip a signal and return the clipped version detect_peaks - peak detector eqconstr_lsqs - equality constrained least squares solver find_vertices - find vertices in piecewise linear data fft_filter - filter data using fft (ideal cutoff characteristics) inout_fresp - calculate frequency response from input/output data integrate - Calculate definite integral of data from t1 to t2(approx.) integrate_t - Calculate indefinite integral of data from t1 to t integrate2D - Compute approx. integral of data defined over x-y grid. linearfit - linear fit to data of the form (sample, data(sample)) linearfit2 - linear fit to (x,y) data make_stepfn - make a step function from data with specified sampling median_filter - see percentile filter percentile_filter - generalization of median filter - choose percent'th sample plot_response - plot sampled frequency response remove_offset - remove DC offset from data vector resamplev - resample data at specified times sample_time - get t0, dt data from a sampled time vector saturatev - vector saturation S-file (see C source code documentation) shift_signal - shift a signal by specified number of samples smoothdt - Boxcar average over specified time interval spectrum - calculate spectrum of data with proper scaling stepfn - make (nonuniform sampled) step function from data (fast) subsample - resample data vector at fixed increments taufilter - one pole filter with time constant tau window_data - extract x-window from (x,y) data zero_crossings - find zero crossings in signal","title":"Basic Information"},{"location":"function-guide/GAsignal/apply_inverse_filter_m/","text":"apply_inverse_filter.m \u00b6 Basic Information \u00b6 SYNTAX: [data_out,figure_num]= apply_inverse_filter(data_in,time_in,B,A,cutoff,figure_num) PURPOSE: Inverse filter data which has been filtered by a filter=B/A. The filter spectrum is inverted and multiplied by the data spectrum up to the cutoff frequency. Spectra above the corner frequency are set to 0. INPUTS: data_in = filtered data (must be uniformly sampled) time_in = time vector corresponding to data_in B,A = numerator and denominator of Laplace function description of filter cutoff = cutoff of inversion figure_num = turns on plotting of intermediate results if specified, plots beginning at figure(figure_num+1). (optional) OUTPUTS: data_out = data after inverse filtering","title":"apply_inverse_filter.m"},{"location":"function-guide/GAsignal/apply_inverse_filter_m/#apply_inverse_filterm","text":"","title":"apply_inverse_filter.m"},{"location":"function-guide/GAsignal/apply_inverse_filter_m/#basic-information","text":"SYNTAX: [data_out,figure_num]= apply_inverse_filter(data_in,time_in,B,A,cutoff,figure_num) PURPOSE: Inverse filter data which has been filtered by a filter=B/A. The filter spectrum is inverted and multiplied by the data spectrum up to the cutoff frequency. Spectra above the corner frequency are set to 0. INPUTS: data_in = filtered data (must be uniformly sampled) time_in = time vector corresponding to data_in B,A = numerator and denominator of Laplace function description of filter cutoff = cutoff of inversion figure_num = turns on plotting of intermediate results if specified, plots beginning at figure(figure_num+1). (optional) OUTPUTS: data_out = data after inverse filtering","title":"Basic Information"},{"location":"function-guide/GAsignal/bld_RC_filter_m/","text":"bld_RC_filter.m \u00b6 Basic Information \u00b6 SYNTAX: [num,den,RC] = bld_RC_filter(corner) PURPOSE: Build an RC filter transfer function with a given corner frequency. INPUT: corner = corner frequency (Hz) OUTPUT: num,den = transfer function of RC filter RC = RC value of filter (tau = 1/RC)","title":"bld_RC_filter.m"},{"location":"function-guide/GAsignal/bld_RC_filter_m/#bld_rc_filterm","text":"","title":"bld_RC_filter.m"},{"location":"function-guide/GAsignal/bld_RC_filter_m/#basic-information","text":"SYNTAX: [num,den,RC] = bld_RC_filter(corner) PURPOSE: Build an RC filter transfer function with a given corner frequency. INPUT: corner = corner frequency (Hz) OUTPUT: num,den = transfer function of RC filter RC = RC value of filter (tau = 1/RC)","title":"Basic Information"},{"location":"function-guide/GAsignal/change_profile_coords_m/","text":"change_profile_coords.m \u00b6 Basic Information \u00b6 SYNTAX: profile_data = change_profile_coords(prof_data_in,coord,options) PURPOSE: Perform transformation of profile data to user-selected coordinate. INPUT: prof_data_in = data structure, which must contain the fields: time: column vector of profile times coord_vals: row vector of profile independent coordinate (normalized psi) values data: profile data, with each row a profile and time increasing down columns psimag: column vector containing psi value at magnetic axis for each time psibry: column vector containing psi value at boundary for each time coord = radial coordinates to convert to. One of: 'psi' (total poloidal flux) 'Phi' (total toroidal flux) 'rho' (GA defn of toroidal flux: sqrt(Phi^2/(pi*BT0) ) 'theta' (Lehigh coordinate: BT0*rho_bdry*rho/q ) options = structure containing optional or additional data: normalize = if 1, divide coord vals by boundary value, default 0 q_profiles = q-profile structure, needed if Phi, rho, or theta requested BT0 = Toroidal field in T at magnetic axis needed for Phi, rho, and theta, at times contained in prof_data_in. OUTPUT: profile_data = data structure, with same structure as prof_data_in RESTRICTIONS: (1) Most conversions require q profile (code complains if required). (2) Function now assumes that prof_data_in has coordinates of psinorm. This can be generalized later.","title":"change_profile_coords.m"},{"location":"function-guide/GAsignal/change_profile_coords_m/#change_profile_coordsm","text":"","title":"change_profile_coords.m"},{"location":"function-guide/GAsignal/change_profile_coords_m/#basic-information","text":"SYNTAX: profile_data = change_profile_coords(prof_data_in,coord,options) PURPOSE: Perform transformation of profile data to user-selected coordinate. INPUT: prof_data_in = data structure, which must contain the fields: time: column vector of profile times coord_vals: row vector of profile independent coordinate (normalized psi) values data: profile data, with each row a profile and time increasing down columns psimag: column vector containing psi value at magnetic axis for each time psibry: column vector containing psi value at boundary for each time coord = radial coordinates to convert to. One of: 'psi' (total poloidal flux) 'Phi' (total toroidal flux) 'rho' (GA defn of toroidal flux: sqrt(Phi^2/(pi*BT0) ) 'theta' (Lehigh coordinate: BT0*rho_bdry*rho/q ) options = structure containing optional or additional data: normalize = if 1, divide coord vals by boundary value, default 0 q_profiles = q-profile structure, needed if Phi, rho, or theta requested BT0 = Toroidal field in T at magnetic axis needed for Phi, rho, and theta, at times contained in prof_data_in. OUTPUT: profile_data = data structure, with same structure as prof_data_in RESTRICTIONS: (1) Most conversions require q profile (code complains if required). (2) Function now assumes that prof_data_in has coordinates of psinorm. This can be generalized later.","title":"Basic Information"},{"location":"function-guide/GAsignal/chirpmulti_fresp_m/","text":"chirpmulti_fresp.m \u00b6 Basic Information \u00b6 SYNTAX: [gain,phi,freq] = chirpmulti_fresp(input_d,input_t, output_d,output_t,min_freq, max_freq, in_yaxis, out_yaxis, inpowerof2, out_powerof2, npeaks, showplots) PURPOSE: multidimensional version of inout_fresp.m for chirp wave signal input. Modified from same type of algorithm for sine wave inputs. Not very successful in getting good data from chirp wave inputs because of S/N problems, so results should be viewed with suspicion. INPUT: input_d = input data vector input_t = input time vector output_d = output data vector output_t = output time vector min_freq = minimum frequency - don't look at spectrum below this max_freq = maximum frequency - don't look at spectrum above this in_yaxis = vector of ymin and ymax values for input data plots(optional) out_yaxis=vector of ymin and ymax values for output data plots(optional) powerof2 = integer = some power of 2 greater than the number of samples in either input_d or output_d, to use in fft (optional) signal is zero filled to this number. (this speeds up fft calculation as well as giving finer frequency sampling for more accurate gain/phase calculation) npeaks = number of points (peaks) in spectrum at which to compute resp. showplots= set=1 if you want to see plots, otherwise no plots (optional) OUTPUT: gain = calculated gain from input to output signal phi = calculated phase from input to output signal (degrees) freq = calculated frequency of input signal (output is checked also) RESTRICTIONS: (1) Both input and output data MUST have uniform sampling rate. (2) Both input and output data MUST represent same time window.","title":"chirpmulti_fresp.m"},{"location":"function-guide/GAsignal/chirpmulti_fresp_m/#chirpmulti_frespm","text":"","title":"chirpmulti_fresp.m"},{"location":"function-guide/GAsignal/chirpmulti_fresp_m/#basic-information","text":"SYNTAX: [gain,phi,freq] = chirpmulti_fresp(input_d,input_t, output_d,output_t,min_freq, max_freq, in_yaxis, out_yaxis, inpowerof2, out_powerof2, npeaks, showplots) PURPOSE: multidimensional version of inout_fresp.m for chirp wave signal input. Modified from same type of algorithm for sine wave inputs. Not very successful in getting good data from chirp wave inputs because of S/N problems, so results should be viewed with suspicion. INPUT: input_d = input data vector input_t = input time vector output_d = output data vector output_t = output time vector min_freq = minimum frequency - don't look at spectrum below this max_freq = maximum frequency - don't look at spectrum above this in_yaxis = vector of ymin and ymax values for input data plots(optional) out_yaxis=vector of ymin and ymax values for output data plots(optional) powerof2 = integer = some power of 2 greater than the number of samples in either input_d or output_d, to use in fft (optional) signal is zero filled to this number. (this speeds up fft calculation as well as giving finer frequency sampling for more accurate gain/phase calculation) npeaks = number of points (peaks) in spectrum at which to compute resp. showplots= set=1 if you want to see plots, otherwise no plots (optional) OUTPUT: gain = calculated gain from input to output signal phi = calculated phase from input to output signal (degrees) freq = calculated frequency of input signal (output is checked also) RESTRICTIONS: (1) Both input and output data MUST have uniform sampling rate. (2) Both input and output data MUST represent same time window.","title":"Basic Information"},{"location":"function-guide/GAsignal/clip_m/","text":"clip.m \u00b6 Basic Information \u00b6 SYNTAX: data_out = clip(data_in,minval,maxval) PURPOSE: Clip a signal and return the clipped version. INPUT: data_in = signal to be clipped minval = clip signal if below this value (either scalar or vector of same size as data_in) maxval = clip signal if above this value (either scalar or vector of same size as data_in) OUTPUT: data_out = clipped signal RESTRICTIONS: maxval >= minval","title":"clip.m"},{"location":"function-guide/GAsignal/clip_m/#clipm","text":"","title":"clip.m"},{"location":"function-guide/GAsignal/clip_m/#basic-information","text":"SYNTAX: data_out = clip(data_in,minval,maxval) PURPOSE: Clip a signal and return the clipped version. INPUT: data_in = signal to be clipped minval = clip signal if below this value (either scalar or vector of same size as data_in) maxval = clip signal if above this value (either scalar or vector of same size as data_in) OUTPUT: data_out = clipped signal RESTRICTIONS: maxval >= minval","title":"Basic Information"},{"location":"function-guide/GAsignal/correct_drift_intvals_m/","text":"correct_drift_intvals.m \u00b6 Basic Information \u00b6 SYNTAX: corrected_d = correct_drift_intvals(old_data,old_tvec,intval1,intval2) PURPOSE: Correct measured shot data for integrator drift. INPUT: old_data = data vector to correct for drift old_tvec = time vector corresponding to old_data intval1 = vector [tmin,tmax] to define offset near beginning of data intval2 = vector [tmin,tmax] to define offset near end of data (optional, default = remove offset from intval1 only) OUTPUT: corrected_d = data corrected for drift RESTRICTIONS: (1) Assumes approximately linear drift over duration of shot. METHOD: Samples are averaged in data defined by intervals to define beginning and end offsets. Beginning offset is subtracted out. A linear drift defined by the 2 offsets is assumed and corrected for in remainder of data.","title":"correct_drift_intvals.m"},{"location":"function-guide/GAsignal/correct_drift_intvals_m/#correct_drift_intvalsm","text":"","title":"correct_drift_intvals.m"},{"location":"function-guide/GAsignal/correct_drift_intvals_m/#basic-information","text":"SYNTAX: corrected_d = correct_drift_intvals(old_data,old_tvec,intval1,intval2) PURPOSE: Correct measured shot data for integrator drift. INPUT: old_data = data vector to correct for drift old_tvec = time vector corresponding to old_data intval1 = vector [tmin,tmax] to define offset near beginning of data intval2 = vector [tmin,tmax] to define offset near end of data (optional, default = remove offset from intval1 only) OUTPUT: corrected_d = data corrected for drift RESTRICTIONS: (1) Assumes approximately linear drift over duration of shot. METHOD: Samples are averaged in data defined by intervals to define beginning and end offsets. Beginning offset is subtracted out. A linear drift defined by the 2 offsets is assumed and corrected for in remainder of data.","title":"Basic Information"},{"location":"function-guide/GAsignal/correct_drift_m/","text":"correct_drift.m \u00b6 Basic Information \u00b6 SYNTAX: corrected_d = correct_drift(old_data, old_tvec, nsamples, sampleloc) PURPOSE: Correct measured shot data for integrator drift. INPUT: old_data = data vector to correct for drift old_tvec = time vector corresponding to old_data nsamples = optional number of samples to use to calculate average offset at beginning and end (default 25) sampleloc= optional location of \"end\" (1st, last) set of samples for defining the average offset at \"end\" (default is last sample of vector) if not specified, or specified as a number <0, default=data length OUTPUT: corrected_d = data corrected for drift RESTRICTIONS: (1) Assumes approximately linear drift over duration of shot. (2) MUST HAVE >=28 samples both at beginning and end of shot from which to calculate beginning and end offsets (UNLESS nsamples < 25). METHOD: Samples are averaged at beginning and end of data to define beginning and end offsets. Beginning offset is subtracted out. A linear drift defined by the 2 offsets is assumed and corrected for in remainder of data. SEE ALSO: correct_drift_intvals","title":"correct_drift.m"},{"location":"function-guide/GAsignal/correct_drift_m/#correct_driftm","text":"","title":"correct_drift.m"},{"location":"function-guide/GAsignal/correct_drift_m/#basic-information","text":"SYNTAX: corrected_d = correct_drift(old_data, old_tvec, nsamples, sampleloc) PURPOSE: Correct measured shot data for integrator drift. INPUT: old_data = data vector to correct for drift old_tvec = time vector corresponding to old_data nsamples = optional number of samples to use to calculate average offset at beginning and end (default 25) sampleloc= optional location of \"end\" (1st, last) set of samples for defining the average offset at \"end\" (default is last sample of vector) if not specified, or specified as a number <0, default=data length OUTPUT: corrected_d = data corrected for drift RESTRICTIONS: (1) Assumes approximately linear drift over duration of shot. (2) MUST HAVE >=28 samples both at beginning and end of shot from which to calculate beginning and end offsets (UNLESS nsamples < 25). METHOD: Samples are averaged at beginning and end of data to define beginning and end offsets. Beginning offset is subtracted out. A linear drift defined by the 2 offsets is assumed and corrected for in remainder of data. SEE ALSO: correct_drift_intvals","title":"Basic Information"},{"location":"function-guide/GAsignal/correlate_m/","text":"correlate.m \u00b6 Basic Information \u00b6 SYNTAX: [corrfn,time] = correlate(data1,time1,data2,time2,dt,zl) PURPOSE: Compute approximation of analog correlation function: corrfn(t) = integral_{-infinity}^{+infinity} data1(s) data2(s+t) ds Numerical integration is done so that amplitude is approx. correct to represent the cross-correlation of the two continuous signals which these sampled data signals represent. Corresponding time data is produced rather than just sample indices. INPUT: data1, time1 = first signal data2, time2 = second signal (optional, if no 2nd signal then autocorrelation of 1st signal is computed) dt = time between samples (optional, default = min dt of time1, time2) zl = zero level = multiplier of average absolute value of computed correlation function, used to eliminate \"zero\" values at beginning and end of correlation function (optional, default = 1e-8). Set=0 to prevent zero eliminations. OUTPUT: corrfn, time = correlation function (either cross- or auto-)","title":"correlate.m"},{"location":"function-guide/GAsignal/correlate_m/#correlatem","text":"","title":"correlate.m"},{"location":"function-guide/GAsignal/correlate_m/#basic-information","text":"SYNTAX: [corrfn,time] = correlate(data1,time1,data2,time2,dt,zl) PURPOSE: Compute approximation of analog correlation function: corrfn(t) = integral_{-infinity}^{+infinity} data1(s) data2(s+t) ds Numerical integration is done so that amplitude is approx. correct to represent the cross-correlation of the two continuous signals which these sampled data signals represent. Corresponding time data is produced rather than just sample indices. INPUT: data1, time1 = first signal data2, time2 = second signal (optional, if no 2nd signal then autocorrelation of 1st signal is computed) dt = time between samples (optional, default = min dt of time1, time2) zl = zero level = multiplier of average absolute value of computed correlation function, used to eliminate \"zero\" values at beginning and end of correlation function (optional, default = 1e-8). Set=0 to prevent zero eliminations. OUTPUT: corrfn, time = correlation function (either cross- or auto-)","title":"Basic Information"},{"location":"function-guide/GAsignal/detect_peaks_m/","text":"detect_peaks.m \u00b6 Basic Information \u00b6 SYNTAX: peak_locs = detect_peaks(data) PURPOSE: Find locations of local maxima of input data signal. INPUT: data = data to detect peaks in OUTPUT: peak_locs = sample numbers where peaks are located RESTRICTIONS: Use input -data to find local minima.","title":"detect_peaks.m"},{"location":"function-guide/GAsignal/detect_peaks_m/#detect_peaksm","text":"","title":"detect_peaks.m"},{"location":"function-guide/GAsignal/detect_peaks_m/#basic-information","text":"SYNTAX: peak_locs = detect_peaks(data) PURPOSE: Find locations of local maxima of input data signal. INPUT: data = data to detect peaks in OUTPUT: peak_locs = sample numbers where peaks are located RESTRICTIONS: Use input -data to find local minima.","title":"Basic Information"},{"location":"function-guide/GAsignal/est_gamma_m/","text":"est_gamma.m \u00b6 Basic Information \u00b6 SYNTAX: [gam_est, zfit] = est_gamma(z_data,t_data,dtsm,iplot,fig_num1) PURPOSE: Estimate growth rate for exponential function of form z(t) = z00 + dz0*exp(gamma*t) INPUTS: z_data = z(t) data t_data = t vector dtsm = time interval for smoothdt (same units as t_data) iplot = flag to enable plotting: 1=plots,0=no plots(def) (optional) fig_num1 = first fig number to use, increments from there (optional, default = 1) OUTPUTS: gam_est = estimated growth rate (rad/units of t_data) zfit = fitted z(t) to test RESTRICTIONS: Units of dtsm must be same units as t_data METHOD: Take derivative of smoothed signal to eliminate z00, smooth, take deriv of log of that signal, average middle of signal to get gam_est. Then should use fit_gamma with the result...","title":"est_gamma.m"},{"location":"function-guide/GAsignal/est_gamma_m/#est_gammam","text":"","title":"est_gamma.m"},{"location":"function-guide/GAsignal/est_gamma_m/#basic-information","text":"SYNTAX: [gam_est, zfit] = est_gamma(z_data,t_data,dtsm,iplot,fig_num1) PURPOSE: Estimate growth rate for exponential function of form z(t) = z00 + dz0*exp(gamma*t) INPUTS: z_data = z(t) data t_data = t vector dtsm = time interval for smoothdt (same units as t_data) iplot = flag to enable plotting: 1=plots,0=no plots(def) (optional) fig_num1 = first fig number to use, increments from there (optional, default = 1) OUTPUTS: gam_est = estimated growth rate (rad/units of t_data) zfit = fitted z(t) to test RESTRICTIONS: Units of dtsm must be same units as t_data METHOD: Take derivative of smoothed signal to eliminate z00, smooth, take deriv of log of that signal, average middle of signal to get gam_est. Then should use fit_gamma with the result...","title":"Basic Information"},{"location":"function-guide/GAsignal/fft_filter_m/","text":"fft_filter.m \u00b6 Basic Information \u00b6 [filtered_d,filtered_t]= fft_filter(data_vec,time_vec,cutoff,zero_fill,sample_check) PURPOSE: Filter data according to cutoff frequency (using forward and backward FFT's). INPUTS:[default] data_vec = data vector to filter time_vec = corresponding time vector (s) cutoff = cutoff frequency for filtering of data (Hz) zero_fill = total sample size; end of vector is filled with zeros [0] sample_check = 0 turns off uniform sampling check [1] OUTPUT: filtered_d = filtered version of data_vec filtered_t = corresponding time vector RESTRICTIONS: (1) Assumes real data input (2) Requires data be uniformly sampled","title":"fft_filter.m"},{"location":"function-guide/GAsignal/fft_filter_m/#fft_filterm","text":"","title":"fft_filter.m"},{"location":"function-guide/GAsignal/fft_filter_m/#basic-information","text":"[filtered_d,filtered_t]= fft_filter(data_vec,time_vec,cutoff,zero_fill,sample_check) PURPOSE: Filter data according to cutoff frequency (using forward and backward FFT's). INPUTS:[default] data_vec = data vector to filter time_vec = corresponding time vector (s) cutoff = cutoff frequency for filtering of data (Hz) zero_fill = total sample size; end of vector is filled with zeros [0] sample_check = 0 turns off uniform sampling check [1] OUTPUT: filtered_d = filtered version of data_vec filtered_t = corresponding time vector RESTRICTIONS: (1) Assumes real data input (2) Requires data be uniformly sampled","title":"Basic Information"},{"location":"function-guide/GAsignal/find_delay_m/","text":"find_delay.m \u00b6 Basic Information \u00b6 SYNTAX: delay = find_delay(shotnum,ptname1,ptname2) PURPOSE: Find delay time between ptname1 and ptname2. Assumes they are both seperately digitized versions of the same signal. INPUT: shotnum = shot number ptname1 = first ptname ptname2 = second ptname OUTPUT: delay = time difference between the 2 (should be identical) signals","title":"find_delay.m"},{"location":"function-guide/GAsignal/find_delay_m/#find_delaym","text":"","title":"find_delay.m"},{"location":"function-guide/GAsignal/find_delay_m/#basic-information","text":"SYNTAX: delay = find_delay(shotnum,ptname1,ptname2) PURPOSE: Find delay time between ptname1 and ptname2. Assumes they are both seperately digitized versions of the same signal. INPUT: shotnum = shot number ptname1 = first ptname ptname2 = second ptname OUTPUT: delay = time difference between the 2 (should be identical) signals","title":"Basic Information"},{"location":"function-guide/GAsignal/find_local_max_m/","text":"find_local_max.m \u00b6 Basic Information \u00b6 SYNTAX: maxloc = find_local_max(x,y,max_locs,binsize) PURPOSE: find local maxima INPUT: x = x data for array y y = data to find local maxima in max_locs - number of maxima locations binsize = bin size - find only the max value in each bin of this size OUTPUT: maxloc = indices in arrays (x,y) of maxima","title":"find_local_max.m"},{"location":"function-guide/GAsignal/find_local_max_m/#find_local_maxm","text":"","title":"find_local_max.m"},{"location":"function-guide/GAsignal/find_local_max_m/#basic-information","text":"SYNTAX: maxloc = find_local_max(x,y,max_locs,binsize) PURPOSE: find local maxima INPUT: x = x data for array y y = data to find local maxima in max_locs - number of maxima locations binsize = bin size - find only the max value in each bin of this size OUTPUT: maxloc = indices in arrays (x,y) of maxima","title":"Basic Information"},{"location":"function-guide/GAsignal/find_vertices_m/","text":"find_vertices.m \u00b6 Basic Information \u00b6 SYNTAX: [x,y] = find_vertices(t,d,tol) PURPOSE: Find the vertices in a piecewise linear data. INPUT: d,t = data and time of piecewise linear data. tol = tolerance to determine when slope changes (optional,default=1e-3) OUTPUT: x,y = vertices where data \"breaks\"","title":"find_vertices.m"},{"location":"function-guide/GAsignal/find_vertices_m/#find_verticesm","text":"","title":"find_vertices.m"},{"location":"function-guide/GAsignal/find_vertices_m/#basic-information","text":"SYNTAX: [x,y] = find_vertices(t,d,tol) PURPOSE: Find the vertices in a piecewise linear data. INPUT: d,t = data and time of piecewise linear data. tol = tolerance to determine when slope changes (optional,default=1e-3) OUTPUT: x,y = vertices where data \"breaks\"","title":"Basic Information"},{"location":"function-guide/GAsignal/fit_gamma_m/","text":"fit_gamma.m \u00b6 Basic Information \u00b6 SYNTAX: [gamma,z_fit,residual,p,resnorm,exitflag,output] = ... fit_gamma(z_data,t_data,p_guess) PURPOSE: Fits offset exponential growth to z_data. Assumed form is therefore z(t-t_data(1))=z00 + dz0*exp(gamma*(t-t_data(1))) INPUTS: z_data = Data vector to be fitted t_data = Time vector for fitting p_guess = Initial guess for [z00,dz0,gamma] OUTPUTS: z_fit = Fitted data vector gamma = Fitted growth rate p = Fitted parameters [z00,dz0,gamma] residual = Residual vector resnorm = Squared 2-norm of residual exitflag = Describes why fit terminated (see lsqcurvefit help) output = Structure of fitting statistics RESTRICTIONS: METHOD: Least square fitting","title":"fit_gamma.m"},{"location":"function-guide/GAsignal/fit_gamma_m/#fit_gammam","text":"","title":"fit_gamma.m"},{"location":"function-guide/GAsignal/fit_gamma_m/#basic-information","text":"SYNTAX: [gamma,z_fit,residual,p,resnorm,exitflag,output] = ... fit_gamma(z_data,t_data,p_guess) PURPOSE: Fits offset exponential growth to z_data. Assumed form is therefore z(t-t_data(1))=z00 + dz0*exp(gamma*(t-t_data(1))) INPUTS: z_data = Data vector to be fitted t_data = Time vector for fitting p_guess = Initial guess for [z00,dz0,gamma] OUTPUTS: z_fit = Fitted data vector gamma = Fitted growth rate p = Fitted parameters [z00,dz0,gamma] residual = Residual vector resnorm = Squared 2-norm of residual exitflag = Describes why fit terminated (see lsqcurvefit help) output = Structure of fitting statistics RESTRICTIONS: METHOD: Least square fitting","title":"Basic Information"},{"location":"function-guide/GAsignal/fit_n012_m/","text":"fit_n012.m \u00b6 Basic Information \u00b6 SYNTAX: [amplitudes,phases,err,dtst] = fit_n012(t,data,angs,iplot); PURPOSE: Decompose data into n=0, n=1, n=2 components for each time point in t. INPUTS: t = time vector (nt,1) data = data array (nt,nangs) angs = vector of nangs angles corr. to columns of data array [degrees] iplot = (optional) flag to select plotting of error: iplot>0 plots (iplot=fig.num.), iplot=0 doesn't. Default=0 OUTPUTS: amplitudes = array of amplitudes over time (nt,3) = [a0(nt,1) a1(nt,1) a2(nt,1) phases = array of phase data over time (nt,3) (radians) = [zeros(nt,1) phi1(nt,1) phi2(nt,1)] (note that initial column of zeros is dummy) err = vector of RMS av error sum over angs as fraction of a0 (nt,1) dtst = signal composed of sum of n=0,1,2 components RESTRICTIONS: All elements of angs must lie in range 0<= angs <360. Angles must monotonically increase (and no repetitions in particular). Data must be real. METHOD: Simple linear fit of sin,cos basis functions. For each time point fits to corresponding row of data. Function for fitting is: a0 + a1*sin(1*ang + phi1) + a2*sin(2*ang + phi2) ...where rows of amplitudes contain [a0 a1 a2] and rows of phases contain [0 phi1 phi2]. The actual representation used in the fit is a0 + c1*sin(1*ang) + d1*cos(1*ang) + c2*sin(2*ang) + d2*cos(2*ang) ...which is converted to the amplitude,phase data for output.","title":"fit_n012.m"},{"location":"function-guide/GAsignal/fit_n012_m/#fit_n012m","text":"","title":"fit_n012.m"},{"location":"function-guide/GAsignal/fit_n012_m/#basic-information","text":"SYNTAX: [amplitudes,phases,err,dtst] = fit_n012(t,data,angs,iplot); PURPOSE: Decompose data into n=0, n=1, n=2 components for each time point in t. INPUTS: t = time vector (nt,1) data = data array (nt,nangs) angs = vector of nangs angles corr. to columns of data array [degrees] iplot = (optional) flag to select plotting of error: iplot>0 plots (iplot=fig.num.), iplot=0 doesn't. Default=0 OUTPUTS: amplitudes = array of amplitudes over time (nt,3) = [a0(nt,1) a1(nt,1) a2(nt,1) phases = array of phase data over time (nt,3) (radians) = [zeros(nt,1) phi1(nt,1) phi2(nt,1)] (note that initial column of zeros is dummy) err = vector of RMS av error sum over angs as fraction of a0 (nt,1) dtst = signal composed of sum of n=0,1,2 components RESTRICTIONS: All elements of angs must lie in range 0<= angs <360. Angles must monotonically increase (and no repetitions in particular). Data must be real. METHOD: Simple linear fit of sin,cos basis functions. For each time point fits to corresponding row of data. Function for fitting is: a0 + a1*sin(1*ang + phi1) + a2*sin(2*ang + phi2) ...where rows of amplitudes contain [a0 a1 a2] and rows of phases contain [0 phi1 phi2]. The actual representation used in the fit is a0 + c1*sin(1*ang) + d1*cos(1*ang) + c2*sin(2*ang) + d2*cos(2*ang) ...which is converted to the amplitude,phase data for output.","title":"Basic Information"},{"location":"function-guide/GAsignal/inout_fresp_m/","text":"inout_fresp.m \u00b6 Basic Information \u00b6 SYNTAX: fresp = inout_fresp(fresp_inputs) PURPOSE: Calculate frequency response for a generic input/output pair of sinusoidal signals. DC components of both signals are removed before calculating response. INPUT: fresp_inputs = structure containing: out_num = output number for output_d (use 1 if only one output) input_d = input data vector input_t = input time vector output_d = output data vector or matrix (i.e., one output per column) output_t = output time vector max_search_f = maximum frequency - don't look for spectral peaks past this max_plot_f = maximum frequency in plot of spectra of input/output signals And optionally: powerof2 = integer = some power of 2 greater than the number of samples in either input_d or output_d, to use in fft (optional) signal is zero filled to this number. (this speeds up fft calculation as well as giving finer frequency sampling for more accurate gain/phase calculation) showplots= set>=1 to see plots used in freq response calculation, otherwise 0 (default), use a value > 1 to cause program to wait after each plot reject_thresh = thresholds for declaring response = NaN when problems with data, e.g. input/output frequencies don't match, or SNR of output too small = [freq_thresh (), snr_thresh (dB)] (default = 10, 0 dB) verbose = set > 0 to get printed diagnostic information (larger numbers => more info) OUTPUT: fresp = structure containing: gain = calculated gain from input to output signal phi = calculated phase from input to output signal (degrees) freq = calculated frequency of input signal (output is checked also) max_in = maximum amplitude of input signal max_out= maximum amplitude of output signal RESTRICTIONS: (1) Both input and output data MUST have uniform sampling rate. (2) Both input and output data MUST represent same time window.","title":"inout_fresp.m"},{"location":"function-guide/GAsignal/inout_fresp_m/#inout_frespm","text":"","title":"inout_fresp.m"},{"location":"function-guide/GAsignal/inout_fresp_m/#basic-information","text":"SYNTAX: fresp = inout_fresp(fresp_inputs) PURPOSE: Calculate frequency response for a generic input/output pair of sinusoidal signals. DC components of both signals are removed before calculating response. INPUT: fresp_inputs = structure containing: out_num = output number for output_d (use 1 if only one output) input_d = input data vector input_t = input time vector output_d = output data vector or matrix (i.e., one output per column) output_t = output time vector max_search_f = maximum frequency - don't look for spectral peaks past this max_plot_f = maximum frequency in plot of spectra of input/output signals And optionally: powerof2 = integer = some power of 2 greater than the number of samples in either input_d or output_d, to use in fft (optional) signal is zero filled to this number. (this speeds up fft calculation as well as giving finer frequency sampling for more accurate gain/phase calculation) showplots= set>=1 to see plots used in freq response calculation, otherwise 0 (default), use a value > 1 to cause program to wait after each plot reject_thresh = thresholds for declaring response = NaN when problems with data, e.g. input/output frequencies don't match, or SNR of output too small = [freq_thresh (), snr_thresh (dB)] (default = 10, 0 dB) verbose = set > 0 to get printed diagnostic information (larger numbers => more info) OUTPUT: fresp = structure containing: gain = calculated gain from input to output signal phi = calculated phase from input to output signal (degrees) freq = calculated frequency of input signal (output is checked also) max_in = maximum amplitude of input signal max_out= maximum amplitude of output signal RESTRICTIONS: (1) Both input and output data MUST have uniform sampling rate. (2) Both input and output data MUST represent same time window.","title":"Basic Information"},{"location":"function-guide/GAsignal/integrate2D_m/","text":"integrate2D.m \u00b6 Basic Information \u00b6 SYNTAX: integral = integrate2D(x,y,z,xmin,xmax,ymin,ymax) PURPOSE: Compute approximate integral of data defined over an x-y grid. INPUT: z = data over grid x,y = x and y coordinates where data z is given xmin,xmax = x limits of integration (must be inside defined x values) (optional, default = min and max from x vector ymin,ymax = y limits of integration (must be inside defined y values) (optional, default = min and max from y vector OUTPUT: integral = value of integral","title":"integrate2D.m"},{"location":"function-guide/GAsignal/integrate2D_m/#integrate2dm","text":"","title":"integrate2D.m"},{"location":"function-guide/GAsignal/integrate2D_m/#basic-information","text":"SYNTAX: integral = integrate2D(x,y,z,xmin,xmax,ymin,ymax) PURPOSE: Compute approximate integral of data defined over an x-y grid. INPUT: z = data over grid x,y = x and y coordinates where data z is given xmin,xmax = x limits of integration (must be inside defined x values) (optional, default = min and max from x vector ymin,ymax = y limits of integration (must be inside defined y values) (optional, default = min and max from y vector OUTPUT: integral = value of integral","title":"Basic Information"},{"location":"function-guide/GAsignal/integrate_m/","text":"integrate.m \u00b6 Basic Information \u00b6 SYNTAX: integral = integrate(y,x,x1,x2,dx) PURPOSE: Calculate definite integral of y from x1 to x2 (approx.). INPUT: y = data y(x) to integrate x = independent variable corresponding to data y x1 = lower limit of integration x2 = upper limit of integration dx = fixed sampling rate (optional, default = compute from vector x) OUTPUT: integral = value of (approximate) integral RESTRICTIONS: (1) Right now, requires FIXED sampling rate. Can be upgraded to handle multiple sampling domains with some work. (2) To integrate from -infinity use x(1), to +infinity use x(end). This assumes that support of function y is captured by vector x. See also: integrate_t","title":"integrate.m"},{"location":"function-guide/GAsignal/integrate_m/#integratem","text":"","title":"integrate.m"},{"location":"function-guide/GAsignal/integrate_m/#basic-information","text":"SYNTAX: integral = integrate(y,x,x1,x2,dx) PURPOSE: Calculate definite integral of y from x1 to x2 (approx.). INPUT: y = data y(x) to integrate x = independent variable corresponding to data y x1 = lower limit of integration x2 = upper limit of integration dx = fixed sampling rate (optional, default = compute from vector x) OUTPUT: integral = value of (approximate) integral RESTRICTIONS: (1) Right now, requires FIXED sampling rate. Can be upgraded to handle multiple sampling domains with some work. (2) To integrate from -infinity use x(1), to +infinity use x(end). This assumes that support of function y is captured by vector x. See also: integrate_t","title":"Basic Information"},{"location":"function-guide/GAsignal/integrate_t_m/","text":"integrate_t.m \u00b6 Basic Information \u00b6 SYNTAX: integral_t = integrate_t(data,time,t1,t2,IC,deltat,method) PURPOSE: Calculate indefinite integral of data from t1 to t (approx.) on interval [t1,t2]. INPUT: data = data to integrate (if more than one data vector, time vector must correspond to increasing row number) time = time corresponding to data t1 = lower limit of integration t2 = upper limit of integration IC = initial condition vector, size=1 x (# columns of data) (optional, default=0) deltat = fixed sampling rate (optional) method = set to 0 for rectangular (faster), 1 for trapezoidal (default) OUTPUT: integral_t = vector defined on time vector representing (approximately) integral of function data(t) from t1 to t. RESTRICTIONS: Right now, requires FIXED sampling rate. Can be upgraded to handle multiple time domains with some work. METHOD: Uses trapezoidal integration. (Assumes linear interpolation between samples.)","title":"integrate_t.m"},{"location":"function-guide/GAsignal/integrate_t_m/#integrate_tm","text":"","title":"integrate_t.m"},{"location":"function-guide/GAsignal/integrate_t_m/#basic-information","text":"SYNTAX: integral_t = integrate_t(data,time,t1,t2,IC,deltat,method) PURPOSE: Calculate indefinite integral of data from t1 to t (approx.) on interval [t1,t2]. INPUT: data = data to integrate (if more than one data vector, time vector must correspond to increasing row number) time = time corresponding to data t1 = lower limit of integration t2 = upper limit of integration IC = initial condition vector, size=1 x (# columns of data) (optional, default=0) deltat = fixed sampling rate (optional) method = set to 0 for rectangular (faster), 1 for trapezoidal (default) OUTPUT: integral_t = vector defined on time vector representing (approximately) integral of function data(t) from t1 to t. RESTRICTIONS: Right now, requires FIXED sampling rate. Can be upgraded to handle multiple time domains with some work. METHOD: Uses trapezoidal integration. (Assumes linear interpolation between samples.)","title":"Basic Information"},{"location":"function-guide/GAsignal/lin_error_m/","text":"lin_error.m \u00b6 Basic Information \u00b6 calculate error between x1 + x2*k and data","title":"lin_error.m"},{"location":"function-guide/GAsignal/lin_error_m/#lin_errorm","text":"","title":"lin_error.m"},{"location":"function-guide/GAsignal/lin_error_m/#basic-information","text":"calculate error between x1 + x2*k and data","title":"Basic Information"},{"location":"function-guide/GAsignal/linearfit2_m/","text":"linearfit2.m \u00b6 Basic Information \u00b6 SYNTAX: [p,norm_error] = linearfit2(data) PURPOSE: Do a linear fit to data of y = p(1) + p(2)*x. This version assumes that the data is both x and y data. INPUT: data = 2 column matrix, 1st col. = independent variable, 2nd = dependent OUTPUT: p = vector of length 2: p(1) = constant offset p(2) = linear multiplier SEE ALSO: linearfit","title":"linearfit2.m"},{"location":"function-guide/GAsignal/linearfit2_m/#linearfit2m","text":"","title":"linearfit2.m"},{"location":"function-guide/GAsignal/linearfit2_m/#basic-information","text":"SYNTAX: [p,norm_error] = linearfit2(data) PURPOSE: Do a linear fit to data of y = p(1) + p(2)*x. This version assumes that the data is both x and y data. INPUT: data = 2 column matrix, 1st col. = independent variable, 2nd = dependent OUTPUT: p = vector of length 2: p(1) = constant offset p(2) = linear multiplier SEE ALSO: linearfit","title":"Basic Information"},{"location":"function-guide/GAsignal/linearfit_m/","text":"linearfit.m \u00b6 Basic Information \u00b6 SYNTAX: [x,norm_error] = linearfit(data) PURPOSE: Do a linear fit to data and return intercept=x(1), slope=x(2). Also produce a plot overlaying line on the data for inspection. INPUT: data = vector of data to fit OUTPUT: x = intercept x(1) and slope x(2) of a line fit to data norm_error = normalized error between data and fitted line SEE ALSO: linearfit2","title":"linearfit.m"},{"location":"function-guide/GAsignal/linearfit_m/#linearfitm","text":"","title":"linearfit.m"},{"location":"function-guide/GAsignal/linearfit_m/#basic-information","text":"SYNTAX: [x,norm_error] = linearfit(data) PURPOSE: Do a linear fit to data and return intercept=x(1), slope=x(2). Also produce a plot overlaying line on the data for inspection. INPUT: data = vector of data to fit OUTPUT: x = intercept x(1) and slope x(2) of a line fit to data norm_error = normalized error between data and fitted line SEE ALSO: linearfit2","title":"Basic Information"},{"location":"function-guide/GAsignal/make_stepfn_m/","text":"make_stepfn.m \u00b6 Basic Information \u00b6 SYNTAX: [d,t] = make_stepfn(data,time,timevec) PURPOSE: Make a step function from given (time,data) pairs and sampled on a given time base. INPUT: data = data to create step function from time = time vector corresponding to data timevec = times at which to create steps OUTPUT: d = step function data t = time vector for d (= timevec) RESTRICTIONS: This function assumes that timevec is much finer sampled than time vector. I don't know what happens if this is not true. SEE ALSO: stepfn","title":"make_stepfn.m"},{"location":"function-guide/GAsignal/make_stepfn_m/#make_stepfnm","text":"","title":"make_stepfn.m"},{"location":"function-guide/GAsignal/make_stepfn_m/#basic-information","text":"SYNTAX: [d,t] = make_stepfn(data,time,timevec) PURPOSE: Make a step function from given (time,data) pairs and sampled on a given time base. INPUT: data = data to create step function from time = time vector corresponding to data timevec = times at which to create steps OUTPUT: d = step function data t = time vector for d (= timevec) RESTRICTIONS: This function assumes that timevec is much finer sampled than time vector. I don't know what happens if this is not true. SEE ALSO: stepfn","title":"Basic Information"},{"location":"function-guide/GAsignal/median_filter_m/","text":"median_filter.m \u00b6 Basic Information \u00b6 SYNTAX: result = median_filter(signal,filterlen) PURPOSE: median filter applied to a vector INPUT: signal = vector to filter filterlen = number of samples to use in median calculation (odd) OUTPUT: result = vector after median filtering SEE ALSO: percentile_filter","title":"median_filter.m"},{"location":"function-guide/GAsignal/median_filter_m/#median_filterm","text":"","title":"median_filter.m"},{"location":"function-guide/GAsignal/median_filter_m/#basic-information","text":"SYNTAX: result = median_filter(signal,filterlen) PURPOSE: median filter applied to a vector INPUT: signal = vector to filter filterlen = number of samples to use in median calculation (odd) OUTPUT: result = vector after median filtering SEE ALSO: percentile_filter","title":"Basic Information"},{"location":"function-guide/GAsignal/percentile_filter_m/","text":"percentile_filter.m \u00b6 Basic Information \u00b6 SYNTAX: result = percentile_filter(signal,filterlen,percent) PURPOSE: Percentile filter applied to a vector. Percentile filter is a generalization of a median filter (median = 50). INPUT: signal = vector to filter filterlen = number of samples to use in filter window percent = specifies which sample to select out of filter window OUTPUT: result = vector after percentile filtering SEE ALSO: median_filter","title":"percentile_filter.m"},{"location":"function-guide/GAsignal/percentile_filter_m/#percentile_filterm","text":"","title":"percentile_filter.m"},{"location":"function-guide/GAsignal/percentile_filter_m/#basic-information","text":"SYNTAX: result = percentile_filter(signal,filterlen,percent) PURPOSE: Percentile filter applied to a vector. Percentile filter is a generalization of a median filter (median = 50). INPUT: signal = vector to filter filterlen = number of samples to use in filter window percent = specifies which sample to select out of filter window OUTPUT: result = vector after percentile filtering SEE ALSO: median_filter","title":"Basic Information"},{"location":"function-guide/GAsignal/resamplev_m/","text":"resamplev.m \u00b6 Basic Information \u00b6 [new_data,new_tvec] = resamplev(old_data, old_tvec, new_tvec) PURPOSE: Resample data vector to produce new data vector at times specified by new_tvec. This performs linear interpolation same as the matlab supported function interp1 but is much faster. (Also faster than old version, resamplevec.m) INPUT: old_data = data to resample (if a matrix, columns must be data over time) old_tvec = time vector of data to resample new_tvec = times to resample at OUTPUT: new_data = resampled data vector or matrix new_tvec = given as input RESTRICTIONS: Times in new_tvec must be between min and max times in old_tvec.","title":"resamplev.m"},{"location":"function-guide/GAsignal/resamplev_m/#resamplevm","text":"","title":"resamplev.m"},{"location":"function-guide/GAsignal/resamplev_m/#basic-information","text":"[new_data,new_tvec] = resamplev(old_data, old_tvec, new_tvec) PURPOSE: Resample data vector to produce new data vector at times specified by new_tvec. This performs linear interpolation same as the matlab supported function interp1 but is much faster. (Also faster than old version, resamplevec.m) INPUT: old_data = data to resample (if a matrix, columns must be data over time) old_tvec = time vector of data to resample new_tvec = times to resample at OUTPUT: new_data = resampled data vector or matrix new_tvec = given as input RESTRICTIONS: Times in new_tvec must be between min and max times in old_tvec.","title":"Basic Information"},{"location":"function-guide/GAsignal/sample_time_m/","text":"sample_time.m \u00b6 Basic Information \u00b6 SYNTAX: [t0, dt, n] = sample_time(time_vec, sensitivity) PURPOSE: Gets the initial sampling time(s) and sampling interval(s) defined by the time vector. If the time between samples is not uniform the outputs will be vectors. INPUT: time_vec = time vector (usually returned by getptd) sensitivity = fraction of min time step to be used to detect change in time step (optional, default = 1e-2) OUTPUT: t0 = initial sample time beginning each time segment having different sample times dt = time between samples in each segment n = sample numbers corresponding to each t0 RESTRICTIONS: Certain time vectors, notably those corresponding to chopper data, have numerically nonuniform sampling over ANY interval and this procedure fails to return meaningful results.","title":"sample_time.m"},{"location":"function-guide/GAsignal/sample_time_m/#sample_timem","text":"","title":"sample_time.m"},{"location":"function-guide/GAsignal/sample_time_m/#basic-information","text":"SYNTAX: [t0, dt, n] = sample_time(time_vec, sensitivity) PURPOSE: Gets the initial sampling time(s) and sampling interval(s) defined by the time vector. If the time between samples is not uniform the outputs will be vectors. INPUT: time_vec = time vector (usually returned by getptd) sensitivity = fraction of min time step to be used to detect change in time step (optional, default = 1e-2) OUTPUT: t0 = initial sample time beginning each time segment having different sample times dt = time between samples in each segment n = sample numbers corresponding to each t0 RESTRICTIONS: Certain time vectors, notably those corresponding to chopper data, have numerically nonuniform sampling over ANY interval and this procedure fails to return meaningful results.","title":"Basic Information"},{"location":"function-guide/GAsignal/shift_signal_m/","text":"shift_signal.m \u00b6 Basic Information \u00b6 SYNTAX: shift = shift_signal(signal,ishift, circular) PURPOSE: Shift signal by ishift samples INPUT: signal = signal to shift ishift = number of samples to shift (ishift>0 is shift to right) circular = set to 1 if signal is assumed circular, else 0 fill at ends (optional, default = 0) OUTPUT: shift = shifted signal","title":"shift_signal.m"},{"location":"function-guide/GAsignal/shift_signal_m/#shift_signalm","text":"","title":"shift_signal.m"},{"location":"function-guide/GAsignal/shift_signal_m/#basic-information","text":"SYNTAX: shift = shift_signal(signal,ishift, circular) PURPOSE: Shift signal by ishift samples INPUT: signal = signal to shift ishift = number of samples to shift (ishift>0 is shift to right) circular = set to 1 if signal is assumed circular, else 0 fill at ends (optional, default = 0) OUTPUT: shift = shifted signal","title":"Basic Information"},{"location":"function-guide/GAsignal/smoothdt_m/","text":"smoothdt.m \u00b6 Basic Information \u00b6 SYNTAX: dsmo = smoothdt(data,time,dtbox) dsmo = smoothdt(ts,dtbox) PURPOSE: Boxcar-average data within time intervals dtbox If data is a matrix, size(data,1) should equal length(time) INPUT: data = vector or matrix with data to smooth time = time vector, or just the time between samples dtbox = width of time window for smoothing ts = timeseries object OUTPUT: dsmo = data after boxcar smoothing","title":"smoothdt.m"},{"location":"function-guide/GAsignal/smoothdt_m/#smoothdtm","text":"","title":"smoothdt.m"},{"location":"function-guide/GAsignal/smoothdt_m/#basic-information","text":"SYNTAX: dsmo = smoothdt(data,time,dtbox) dsmo = smoothdt(ts,dtbox) PURPOSE: Boxcar-average data within time intervals dtbox If data is a matrix, size(data,1) should equal length(time) INPUT: data = vector or matrix with data to smooth time = time vector, or just the time between samples dtbox = width of time window for smoothing ts = timeseries object OUTPUT: dsmo = data after boxcar smoothing","title":"Basic Information"},{"location":"function-guide/GAsignal/spectrum_m/","text":"spectrum.m \u00b6 Basic Information \u00b6 SYNTAX: [spectrum_d,spectrum_f]=spectrum(data_vec,time_vec,... zero_fill,sample_check) PURPOSE: calculate spectrum of (uniformly sampled) data INPUT: data_vec = data vector to calculate spectrum for time_vec = corresponding time vector zero_fill = number of samples to fill out to with zeros (optional) sample_check= set=0 to turn off checking for uniform sampling (optional) OUTPUT: spectrum_d = spectrum data - fft divided by number of input samples spectrum_f = spectrum frequencies in Hz (frequency corresp. to each data sample) RESTRICTIONS: METHOD: The computed spectrum is normalized so that when a cosine wave signal is processed, a spectrum s(f) is produced with s(f0)+conj(s(-f0)) = amplitude of cosine wave, and phase approximately=0, where f0 is the frequency of the cosine wave","title":"spectrum.m"},{"location":"function-guide/GAsignal/spectrum_m/#spectrumm","text":"","title":"spectrum.m"},{"location":"function-guide/GAsignal/spectrum_m/#basic-information","text":"SYNTAX: [spectrum_d,spectrum_f]=spectrum(data_vec,time_vec,... zero_fill,sample_check) PURPOSE: calculate spectrum of (uniformly sampled) data INPUT: data_vec = data vector to calculate spectrum for time_vec = corresponding time vector zero_fill = number of samples to fill out to with zeros (optional) sample_check= set=0 to turn off checking for uniform sampling (optional) OUTPUT: spectrum_d = spectrum data - fft divided by number of input samples spectrum_f = spectrum frequencies in Hz (frequency corresp. to each data sample) RESTRICTIONS: METHOD: The computed spectrum is normalized so that when a cosine wave signal is processed, a spectrum s(f) is produced with s(f0)+conj(s(-f0)) = amplitude of cosine wave, and phase approximately=0, where f0 is the frequency of the cosine wave","title":"Basic Information"},{"location":"function-guide/GAsignal/stepfn_m/","text":"stepfn.m \u00b6 Basic Information \u00b6 SYNTAX: [dnew,tnew] = stepfn(d,t) PURPOSE: Make step function from sampled data. Use make_stepfn if you need uniformly sampled output data. INPUT: d = input data t = input time OUTPUT: dnew = output data tnew = output time (this WILL NOT be uniformly sampled) SEE ALSO: make_stepfn","title":"stepfn.m"},{"location":"function-guide/GAsignal/stepfn_m/#stepfnm","text":"","title":"stepfn.m"},{"location":"function-guide/GAsignal/stepfn_m/#basic-information","text":"SYNTAX: [dnew,tnew] = stepfn(d,t) PURPOSE: Make step function from sampled data. Use make_stepfn if you need uniformly sampled output data. INPUT: d = input data t = input time OUTPUT: dnew = output data tnew = output time (this WILL NOT be uniformly sampled) SEE ALSO: make_stepfn","title":"Basic Information"},{"location":"function-guide/GAsignal/subsample_m/","text":"subsample.m \u00b6 Basic Information \u00b6 SYNTAX: [new_data,new_tvec] = subsample(old_data, old_tvec, increment, k0) PURPOSE: Subsample data vector at increments of \"increment\", starting at sample k0. INPUT: old_data = data to subsample (if data is matrix, time corresp. to column) old_tvec = time vector corresponding to old_data increment = increment to subsample (can be a vector) k0 = sample numbers at which to start subsampling (optional, default=1) (data is returned only for samples >= k0(1) ) EXAMPLE: If increment = [10 100], then k0 must exist and be the same size say, k0=[1 1000]. Then time and data vectors would be subsampled every 10 samples between 1 and 1000 (i.e. 1, 11, 21, 31, ..., 991) and every 100 samples thereafter until the end of the data. OUTPUT: new_data = subsampled data new_tvec = time vector corresponding to new_data","title":"subsample.m"},{"location":"function-guide/GAsignal/subsample_m/#subsamplem","text":"","title":"subsample.m"},{"location":"function-guide/GAsignal/subsample_m/#basic-information","text":"SYNTAX: [new_data,new_tvec] = subsample(old_data, old_tvec, increment, k0) PURPOSE: Subsample data vector at increments of \"increment\", starting at sample k0. INPUT: old_data = data to subsample (if data is matrix, time corresp. to column) old_tvec = time vector corresponding to old_data increment = increment to subsample (can be a vector) k0 = sample numbers at which to start subsampling (optional, default=1) (data is returned only for samples >= k0(1) ) EXAMPLE: If increment = [10 100], then k0 must exist and be the same size say, k0=[1 1000]. Then time and data vectors would be subsampled every 10 samples between 1 and 1000 (i.e. 1, 11, 21, 31, ..., 991) and every 100 samples thereafter until the end of the data. OUTPUT: new_data = subsampled data new_tvec = time vector corresponding to new_data","title":"Basic Information"},{"location":"function-guide/GAsignal/taufilter_m/","text":"taufilter.m \u00b6 Basic Information \u00b6 USAGE: dataf = taufilter(data,time,tau,dataf0) PURPOSE: Filter a signal with a one pole filter having a given time constant tau. INPUT: data = data to filter time = time values associated with each data point (in seconds) (can be uniformly or non-uniformly sampled) tau = time constant of filter (in seconds) dataf0 = initial value of filtered data (set to 0 for default) OUTPUT: dataf = filtered data","title":"taufilter.m"},{"location":"function-guide/GAsignal/taufilter_m/#taufilterm","text":"","title":"taufilter.m"},{"location":"function-guide/GAsignal/taufilter_m/#basic-information","text":"USAGE: dataf = taufilter(data,time,tau,dataf0) PURPOSE: Filter a signal with a one pole filter having a given time constant tau. INPUT: data = data to filter time = time values associated with each data point (in seconds) (can be uniformly or non-uniformly sampled) tau = time constant of filter (in seconds) dataf0 = initial value of filtered data (set to 0 for default) OUTPUT: dataf = filtered data","title":"Basic Information"},{"location":"function-guide/GAsignal/time_slice_m/","text":"time_slice.m \u00b6 Basic Information \u00b6 function [out_data,out_time,ier]=time_slice(in_data,in_time,tmin,tmax) PURPOSE: Cut out a time segment from the data and time vectors corresponding to samples between tmin and tmax. INPUT: in_data = data vector to take time slice out of (if matrix, then rows must correspond to time) in_time = time vector corresponding to in_data tmin = start time of time slice tmax = end time of time slice OUTPUT: out_data = data vector from specified time slice out_time = time vector corresponding to out_data ier = error code (value of 0 if OK) RESTRICTIONS: in_time must be a vector (i.e. n x 1 or 1 x n, for some n>0)","title":"time_slice.m"},{"location":"function-guide/GAsignal/time_slice_m/#time_slicem","text":"","title":"time_slice.m"},{"location":"function-guide/GAsignal/time_slice_m/#basic-information","text":"function [out_data,out_time,ier]=time_slice(in_data,in_time,tmin,tmax) PURPOSE: Cut out a time segment from the data and time vectors corresponding to samples between tmin and tmax. INPUT: in_data = data vector to take time slice out of (if matrix, then rows must correspond to time) in_time = time vector corresponding to in_data tmin = start time of time slice tmax = end time of time slice OUTPUT: out_data = data vector from specified time slice out_time = time vector corresponding to out_data ier = error code (value of 0 if OK) RESTRICTIONS: in_time must be a vector (i.e. n x 1 or 1 x n, for some n>0)","title":"Basic Information"},{"location":"function-guide/GAsignal/window_data_m/","text":"window_data.m \u00b6 Basic Information \u00b6 function [y_out,x_out,ier]=window_data(y_in,x_in,xmin,xmax) PURPOSE: Cut out a segment from the x and y vectors corresponding to samples between xmin and xmax. INPUT: y_in = data to take window out of (if matrix, then rows must correspond to x) x_in = x vector corresponding to y_in xmin = starting x value of window xmax = ending x value of window OUTPUT: y_out = y data from specified x-window x_out = x vector corresponding to y_out ier = error code (value of 0 if OK) RESTRICTIONS: x_in must be a vector (i.e. n x 1 or 1 x n, for some n>0)","title":"window_data.m"},{"location":"function-guide/GAsignal/window_data_m/#window_datam","text":"","title":"window_data.m"},{"location":"function-guide/GAsignal/window_data_m/#basic-information","text":"function [y_out,x_out,ier]=window_data(y_in,x_in,xmin,xmax) PURPOSE: Cut out a segment from the x and y vectors corresponding to samples between xmin and xmax. INPUT: y_in = data to take window out of (if matrix, then rows must correspond to x) x_in = x vector corresponding to y_in xmin = starting x value of window xmax = ending x value of window OUTPUT: y_out = y data from specified x-window x_out = x vector corresponding to y_out ier = error code (value of 0 if OK) RESTRICTIONS: x_in must be a vector (i.e. n x 1 or 1 x n, for some n>0)","title":"Basic Information"},{"location":"function-guide/GAsignal/zero_crossings_m/","text":"zero_crossings.m \u00b6 Basic Information \u00b6 SYNTAX: [ldg_edge_smple,trl_edge_smple,ldg_edge,trl_edge] = zero_crossings(data,time) PURPOSE: Estimate locations (sample indices) where data crosses zero. Optionally computes estimated times of zero crossings. INPUT: data = data vector to find zero crossings in time = time vector corresponding to data (optional, when input the ldg_edge and trl_edge outputs are computed) OUTPUT: ldg_edge_smple = sample numbers in \"data\" where data will cross zero with a positive slope going to next sample trl_edge_smple = sample numbers in \"data\" where data will cross zero with a negative slope going to next sample ldg_edge = time values corresponding to estimated zero crossing value trl_edge = time values corresponding to estimated zero crossing value","title":"zero_crossings.m"},{"location":"function-guide/GAsignal/zero_crossings_m/#zero_crossingsm","text":"","title":"zero_crossings.m"},{"location":"function-guide/GAsignal/zero_crossings_m/#basic-information","text":"SYNTAX: [ldg_edge_smple,trl_edge_smple,ldg_edge,trl_edge] = zero_crossings(data,time) PURPOSE: Estimate locations (sample indices) where data crosses zero. Optionally computes estimated times of zero crossings. INPUT: data = data vector to find zero crossings in time = time vector corresponding to data (optional, when input the ldg_edge and trl_edge outputs are computed) OUTPUT: ldg_edge_smple = sample numbers in \"data\" where data will cross zero with a positive slope going to next sample trl_edge_smple = sample numbers in \"data\" where data will cross zero with a negative slope going to next sample ldg_edge = time values corresponding to estimated zero crossing value trl_edge = time values corresponding to estimated zero crossing value","title":"Basic Information"},{"location":"function-guide/PCS/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 matlab/PCS directory: bld_flux_err - Build flux_err matrix to convert control pt fluxes to relative fluxes bld_isoflux_response - build isoflux output to incorporate in a,b,c,d model calc_isoflux_response - Compute response to isoflux points and grids calc_PCS_PID_response - calculate response of PCS PID algorithm calc_PID_coeff - Calculate PID coefficients as computed by PCS classify_param_names - Get parameter data from the PCS setup file get_cat_names - get list of category names from pcs setup data get_command_da_gain - returns the digital-to-analog convertor (DAC) gains for given commands get_command_indices - returns channel indices given list of command names get_cpu_indices - returns cpu indices given list of command names get_param_names - get a list of parameter block names from pcs setup data get_pcs_server - Determine name of mds server to use in fetching PCS data get_pcssetup - get parameter data from PCS setup data get_pcssetup_calib - get calibration data from PCS setup data get_pcssetup_struct - load all parameter data from PCS setup into matlab structure get_pcssetup_waveform - get waveform from PCS setup data get_phase_names - get list of phases from PCS setup data read_pcs_ss_filter - Read a standard PCS state-space filter file. segment_response - Calculate flux and field response to isoflux segment write_pcs_filter - Write PCS filter file for filter in state-space form write_PCS_matrix_file - Write matrix data to a file readable by PCS","title":"Contents.m"},{"location":"function-guide/PCS/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/PCS/Contents_m/#basic-information","text":"matlab/PCS directory: bld_flux_err - Build flux_err matrix to convert control pt fluxes to relative fluxes bld_isoflux_response - build isoflux output to incorporate in a,b,c,d model calc_isoflux_response - Compute response to isoflux points and grids calc_PCS_PID_response - calculate response of PCS PID algorithm calc_PID_coeff - Calculate PID coefficients as computed by PCS classify_param_names - Get parameter data from the PCS setup file get_cat_names - get list of category names from pcs setup data get_command_da_gain - returns the digital-to-analog convertor (DAC) gains for given commands get_command_indices - returns channel indices given list of command names get_cpu_indices - returns cpu indices given list of command names get_param_names - get a list of parameter block names from pcs setup data get_pcs_server - Determine name of mds server to use in fetching PCS data get_pcssetup - get parameter data from PCS setup data get_pcssetup_calib - get calibration data from PCS setup data get_pcssetup_struct - load all parameter data from PCS setup into matlab structure get_pcssetup_waveform - get waveform from PCS setup data get_phase_names - get list of phases from PCS setup data read_pcs_ss_filter - Read a standard PCS state-space filter file. segment_response - Calculate flux and field response to isoflux segment write_pcs_filter - Write PCS filter file for filter in state-space form write_PCS_matrix_file - Write matrix data to a file readable by PCS","title":"Basic Information"},{"location":"function-guide/PCS/bld_flux_err_m/","text":"bld_flux_err.m \u00b6 Basic Information \u00b6 SYNTAX: [flux_err,nerrors] = ... bld_flux_err(algorithm,isonms,iso_refs,ref_num,Xpt_cntl,units,bias) PURPOSE: Build the flux_err matrix needed to convert from absolute flux at the segment control points to relative flux (abs. flux - flux at the X point) INPUT: algorithm = one of 'isodnull', 'isosnull', or 'isousnull' isonms = names of isoflux segments iso_refs = isoflux reference signals ref_num = index of reference signal used by each segment in isonms Xpt_cntl = define type of control to use on Xpt(s), in pairs of [R,Z], e.g. ['S','X'] indicates R should be controlled by strike point, while Z should be controlled at the X point. For LSN or USN, use one pair while for DND, use two consecutive pairs, i.e. [R1,Z1,R2,Z2]. (optional, default = ['X','X'] for LSN, USN, ['X','X','X','X'] for DND) units = either 'Wb' or 'Wb/rad' (as in PCS), defining units for flux errors (optional, default = 'Wb') bias = used only if algorithm = 'isodnull'; one of: 1 = upper-bias shape (DRSEP>0) 0 = balanced shape (DRSEP=0) -1 = lower-bias shape (DRSEP<0) OUTPUT: flux_err = matrix to compute errors from flux values on isoflux segments. Columns are: isodnull: seg.flux,psi_grid1,BrBz_grid1,psi_grid2,BrBz_grid2,Fcoils others: seg.flux, psi_grid1, BrBz_grid1, Fcoils Rows are: isodnull: seg.flux_errs,BrBz_grid1,BrBz_grid2,symmetry_err,Fcoils others: seg.flux_errs, BrBz_grid1, Fcoils nerrors = number of rows corresponding to isoflux errors RESTRICTIONS: NOTE that this code assumes errors are in units of Wb, while in the PCS, they actually come in as Wb/rad. (Units conversion must be done.)","title":"bld_flux_err.m"},{"location":"function-guide/PCS/bld_flux_err_m/#bld_flux_errm","text":"","title":"bld_flux_err.m"},{"location":"function-guide/PCS/bld_flux_err_m/#basic-information","text":"SYNTAX: [flux_err,nerrors] = ... bld_flux_err(algorithm,isonms,iso_refs,ref_num,Xpt_cntl,units,bias) PURPOSE: Build the flux_err matrix needed to convert from absolute flux at the segment control points to relative flux (abs. flux - flux at the X point) INPUT: algorithm = one of 'isodnull', 'isosnull', or 'isousnull' isonms = names of isoflux segments iso_refs = isoflux reference signals ref_num = index of reference signal used by each segment in isonms Xpt_cntl = define type of control to use on Xpt(s), in pairs of [R,Z], e.g. ['S','X'] indicates R should be controlled by strike point, while Z should be controlled at the X point. For LSN or USN, use one pair while for DND, use two consecutive pairs, i.e. [R1,Z1,R2,Z2]. (optional, default = ['X','X'] for LSN, USN, ['X','X','X','X'] for DND) units = either 'Wb' or 'Wb/rad' (as in PCS), defining units for flux errors (optional, default = 'Wb') bias = used only if algorithm = 'isodnull'; one of: 1 = upper-bias shape (DRSEP>0) 0 = balanced shape (DRSEP=0) -1 = lower-bias shape (DRSEP<0) OUTPUT: flux_err = matrix to compute errors from flux values on isoflux segments. Columns are: isodnull: seg.flux,psi_grid1,BrBz_grid1,psi_grid2,BrBz_grid2,Fcoils others: seg.flux, psi_grid1, BrBz_grid1, Fcoils Rows are: isodnull: seg.flux_errs,BrBz_grid1,BrBz_grid2,symmetry_err,Fcoils others: seg.flux_errs, BrBz_grid1, Fcoils nerrors = number of rows corresponding to isoflux errors RESTRICTIONS: NOTE that this code assumes errors are in units of Wb, while in the PCS, they actually come in as Wb/rad. (Units conversion must be done.)","title":"Basic Information"},{"location":"function-guide/PCS/bld_isoflux_response_m/","text":"bld_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: [Gcntl,Gcntlbetap,Gcntlli] = bld_isoflux_response(isoflux_defns, ... tok_system,RX,ZX,good_X_pt,do_model_validation,output_objs) PURPOSE: Build the Greens functions to isoflux segments and grid to incorporate into output equation of state space model. INPUT: isoflux_defns = structure containing: nsegments = number of segments in isoflux control ngrids = number of segments in isoflux control segment_resp_flag = scalar or vector value. If vector, this is the set of indices in each control segment to use to define response. If scalar, 1=average over segment, otherwise use center point. bgrid_resp_loc = scalar or vector. If vector, these are the (R,Z) target location(s) ([R,Z] or [R1,Z1,R2,Z2]). If scalar, 1= average over grid, 2=use pt nearest equil Xpt, else use grid center. tok_system = data structure created by build_tokamak_system.m RX,ZX = if only 1 Xpt grid, these define Xpt location for calculation of shape response; for DND, these are length 2 vectors, first entry for bottom Xpt,2nd for top (used only if bgrid_resp_loc=2) good_X_pt = set to 1 if values of RX, ZX are known good, else 0 do_model_validation = output_objs = data structure created by plasma_output.m OUTPUT: Gcntl = response of flux at isoflux control points and field at Xpts to changes in conductor currents. Outputs = [nsegments fluxes(Wb), flux,Br,Bz at Xpt1(Wb,T), flux,Br,Bz at Xpt2(Wb,T)] Inputs = currents conductors (E,F,vv,Ip). Units = A. Gcntlbetap = response of betap to same conductors Gcntlli = response of li to same conductors","title":"bld_isoflux_response.m"},{"location":"function-guide/PCS/bld_isoflux_response_m/#bld_isoflux_responsem","text":"","title":"bld_isoflux_response.m"},{"location":"function-guide/PCS/bld_isoflux_response_m/#basic-information","text":"SYNTAX: [Gcntl,Gcntlbetap,Gcntlli] = bld_isoflux_response(isoflux_defns, ... tok_system,RX,ZX,good_X_pt,do_model_validation,output_objs) PURPOSE: Build the Greens functions to isoflux segments and grid to incorporate into output equation of state space model. INPUT: isoflux_defns = structure containing: nsegments = number of segments in isoflux control ngrids = number of segments in isoflux control segment_resp_flag = scalar or vector value. If vector, this is the set of indices in each control segment to use to define response. If scalar, 1=average over segment, otherwise use center point. bgrid_resp_loc = scalar or vector. If vector, these are the (R,Z) target location(s) ([R,Z] or [R1,Z1,R2,Z2]). If scalar, 1= average over grid, 2=use pt nearest equil Xpt, else use grid center. tok_system = data structure created by build_tokamak_system.m RX,ZX = if only 1 Xpt grid, these define Xpt location for calculation of shape response; for DND, these are length 2 vectors, first entry for bottom Xpt,2nd for top (used only if bgrid_resp_loc=2) good_X_pt = set to 1 if values of RX, ZX are known good, else 0 do_model_validation = output_objs = data structure created by plasma_output.m OUTPUT: Gcntl = response of flux at isoflux control points and field at Xpts to changes in conductor currents. Outputs = [nsegments fluxes(Wb), flux,Br,Bz at Xpt1(Wb,T), flux,Br,Bz at Xpt2(Wb,T)] Inputs = currents conductors (E,F,vv,Ip). Units = A. Gcntlbetap = response of betap to same conductors Gcntlli = response of li to same conductors","title":"Basic Information"},{"location":"function-guide/PCS/calc_PCS_PID_response_m/","text":"calc_PCS_PID_response.m \u00b6 Basic Information \u00b6 SYNTAX: PIDsys = calc_PCS_PID_response(dt,Gp,Gd,Gi,taup,taud,taui) PURPOSE: Compute (digital) frequency response of PCS PID implementation. (Response is nearly, but not quite, independent of dt - for dt small enough. Put in a reasonable approximate value.) INPUT: dt = sample time Gp = proportional gain Gd = derivative gain Gi = integral gain taup = proportional time constant (sec) taud = derivative time constant (sec) taui = integral time constant (sec) OUTPUT: PIDsys = digital transfer function model of PID algorithm (control toolbox packed format)","title":"calc_PCS_PID_response.m"},{"location":"function-guide/PCS/calc_PCS_PID_response_m/#calc_pcs_pid_responsem","text":"","title":"calc_PCS_PID_response.m"},{"location":"function-guide/PCS/calc_PCS_PID_response_m/#basic-information","text":"SYNTAX: PIDsys = calc_PCS_PID_response(dt,Gp,Gd,Gi,taup,taud,taui) PURPOSE: Compute (digital) frequency response of PCS PID implementation. (Response is nearly, but not quite, independent of dt - for dt small enough. Put in a reasonable approximate value.) INPUT: dt = sample time Gp = proportional gain Gd = derivative gain Gi = integral gain taup = proportional time constant (sec) taud = derivative time constant (sec) taui = integral time constant (sec) OUTPUT: PIDsys = digital transfer function model of PID algorithm (control toolbox packed format)","title":"Basic Information"},{"location":"function-guide/PCS/calc_PID_coeff_m/","text":"calc_PID_coeff.m \u00b6 Basic Information \u00b6 SYNTAX: [P1,P2,D1,D2,I1,I2] = calc_PID_coeff(dt,taup,taud,taui) PURPOSE: Calculate PID coefficients as computed by PCS. Discrete filters constructed from these coefficients are: proportional: P1(z+1)/(z+P2) derivative: D1(z-1)/(z+D2) integral: I1(z+1)/(z+I2) INPUT: dt = sample time taup = proportional time constant (sec) taud = derivative time constant (sec) taui = integral time constant (sec) OUTPUT: P1,P2 = proportional calculation coefficients D1,D2 = derivative calculation coefficients I1,I2 = integral calculation coefficients","title":"calc_PID_coeff.m"},{"location":"function-guide/PCS/calc_PID_coeff_m/#calc_pid_coeffm","text":"","title":"calc_PID_coeff.m"},{"location":"function-guide/PCS/calc_PID_coeff_m/#basic-information","text":"SYNTAX: [P1,P2,D1,D2,I1,I2] = calc_PID_coeff(dt,taup,taud,taui) PURPOSE: Calculate PID coefficients as computed by PCS. Discrete filters constructed from these coefficients are: proportional: P1(z+1)/(z+P2) derivative: D1(z-1)/(z+D2) integral: I1(z+1)/(z+I2) INPUT: dt = sample time taup = proportional time constant (sec) taud = derivative time constant (sec) taui = integral time constant (sec) OUTPUT: P1,P2 = proportional calculation coefficients D1,D2 = derivative calculation coefficients I1,I2 = integral calculation coefficients","title":"Basic Information"},{"location":"function-guide/PCS/calc_isoflux_response_m/","text":"calc_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: [sizedata,control_pts,mutuals,brgreens,bzgreens] = ... calc_isoflux_response(seg_grid_name,dir,tok_data_struct) PURPOSE: Compute response to isoflux points and grids. INPUT: seg_grid_name = segment or grid name (e.g. '0degree', 'bot_3cm') dir = directory where data files defining isoflux objects stored tok_data_struct= vacuum model data objects structure OUTPUT: sizedata = structure defining contents of response data (see help for segment_response.m) control_pts = control points at which responses computed mutuals = mutuals, current sources (coils,vessel,grid) to control pts brgreens = green fns, current sources (coils,vessel,grid) to control pts bzgreens = green fns, current sources (coils,vessel,grid) to control pts (Units of current = Amp-turns. Flux is in Wb/rad. Field is in Tesla.) RESTRICTIONS: METHOD: Checks that seg_grid_name matches one of names in response_input_<device>.txt (i.e. exists as an rtefit response object), then computes response the same way as computed for rtefit.","title":"calc_isoflux_response.m"},{"location":"function-guide/PCS/calc_isoflux_response_m/#calc_isoflux_responsem","text":"","title":"calc_isoflux_response.m"},{"location":"function-guide/PCS/calc_isoflux_response_m/#basic-information","text":"SYNTAX: [sizedata,control_pts,mutuals,brgreens,bzgreens] = ... calc_isoflux_response(seg_grid_name,dir,tok_data_struct) PURPOSE: Compute response to isoflux points and grids. INPUT: seg_grid_name = segment or grid name (e.g. '0degree', 'bot_3cm') dir = directory where data files defining isoflux objects stored tok_data_struct= vacuum model data objects structure OUTPUT: sizedata = structure defining contents of response data (see help for segment_response.m) control_pts = control points at which responses computed mutuals = mutuals, current sources (coils,vessel,grid) to control pts brgreens = green fns, current sources (coils,vessel,grid) to control pts bzgreens = green fns, current sources (coils,vessel,grid) to control pts (Units of current = Amp-turns. Flux is in Wb/rad. Field is in Tesla.) RESTRICTIONS: METHOD: Checks that seg_grid_name matches one of names in response_input_<device>.txt (i.e. exists as an rtefit response object), then computes response the same way as computed for rtefit.","title":"Basic Information"},{"location":"function-guide/PCS/classify_param_names_m/","text":"classify_param_names.m \u00b6 Basic Information \u00b6 SYNTAX: [matrices, labeled_data, misc] = classify_param_names(list) PURPOSE: Get parameter data from the PCS setup file. INPUT: list = character matrix whose rows are parameter data block names, typically generated from a call to get_param_names OUTPUT: matrices = cell array of strings listing matrix block labeled_data = cell array of strings listing standard, labeled, data blocks with fields :data and :labels misc = cell array of strings listing blocks not classified as either matrices or labeled_data.","title":"classify_param_names.m"},{"location":"function-guide/PCS/classify_param_names_m/#classify_param_namesm","text":"","title":"classify_param_names.m"},{"location":"function-guide/PCS/classify_param_names_m/#basic-information","text":"SYNTAX: [matrices, labeled_data, misc] = classify_param_names(list) PURPOSE: Get parameter data from the PCS setup file. INPUT: list = character matrix whose rows are parameter data block names, typically generated from a call to get_param_names OUTPUT: matrices = cell array of strings listing matrix block labeled_data = cell array of strings listing standard, labeled, data blocks with fields :data and :labels misc = cell array of strings listing blocks not classified as either matrices or labeled_data.","title":"Basic Information"},{"location":"function-guide/PCS/get_cat_names_m/","text":"get_cat_names.m \u00b6 Basic Information \u00b6 SYNTAX: names = get_cat_names(shot,[server]) PURPOSE: Retrieves the names of the PCS categories for a given shot INPUT: shot = shot number to get category names data from [server] = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a category name. If none found, is empty matrix [].","title":"get_cat_names.m"},{"location":"function-guide/PCS/get_cat_names_m/#get_cat_namesm","text":"","title":"get_cat_names.m"},{"location":"function-guide/PCS/get_cat_names_m/#basic-information","text":"SYNTAX: names = get_cat_names(shot,[server]) PURPOSE: Retrieves the names of the PCS categories for a given shot INPUT: shot = shot number to get category names data from [server] = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a category name. If none found, is empty matrix [].","title":"Basic Information"},{"location":"function-guide/PCS/get_command_channels_m/","text":"get_command_channels.m \u00b6 Basic Information \u00b6 SYNTAX: [channels,cpus,gains,names] = get_command_channels(pcs_dir,tokamak,category,signal_names) PURPOSE: Get the command channel indices, cpu numbers that produces each command, and gain of the digital-to-analog convertor that sends out the command, for all commands to be used by simserver. Supports use of command signals from any category. INPUT: pcs_dir = directory where PCS has already been built tokamak = tokamak corresponding to PCS (one of 'd3d','east','kstar','nstx-u') category = string defining category whose commands are to be used OR 'default' (the standard PCS commands); the category is the short name in macros like CMD_<name>*, CMDA_<name>* in simulation_includes.m. Usually these are the same as those listed in categories.h, but not always. signal_names = cell array with names of command signals to be used by simserver or 'all' (optional; if not specified, the only valid returned argument is \"names\") OUTPUT: channels = vector of indices of the command channels comprising the PCS interface output, indexed from 1 cpus = vector of cpu numbers where intcom values are coming from, indexed from 1 gains = vector of DAC gains, indexed from 1 names = struct with fields = channel_names,gain_names, cpu_names, each providing a list of preprocessor variables defined for the specified tokamak and category (currently not returned if category='default') See also get_command_indices, get_cpu_indices, and get_command_da_gain for fetching DEFAULT commands","title":"get_command_channels.m"},{"location":"function-guide/PCS/get_command_channels_m/#get_command_channelsm","text":"","title":"get_command_channels.m"},{"location":"function-guide/PCS/get_command_channels_m/#basic-information","text":"SYNTAX: [channels,cpus,gains,names] = get_command_channels(pcs_dir,tokamak,category,signal_names) PURPOSE: Get the command channel indices, cpu numbers that produces each command, and gain of the digital-to-analog convertor that sends out the command, for all commands to be used by simserver. Supports use of command signals from any category. INPUT: pcs_dir = directory where PCS has already been built tokamak = tokamak corresponding to PCS (one of 'd3d','east','kstar','nstx-u') category = string defining category whose commands are to be used OR 'default' (the standard PCS commands); the category is the short name in macros like CMD_<name>*, CMDA_<name>* in simulation_includes.m. Usually these are the same as those listed in categories.h, but not always. signal_names = cell array with names of command signals to be used by simserver or 'all' (optional; if not specified, the only valid returned argument is \"names\") OUTPUT: channels = vector of indices of the command channels comprising the PCS interface output, indexed from 1 cpus = vector of cpu numbers where intcom values are coming from, indexed from 1 gains = vector of DAC gains, indexed from 1 names = struct with fields = channel_names,gain_names, cpu_names, each providing a list of preprocessor variables defined for the specified tokamak and category (currently not returned if category='default') See also get_command_indices, get_cpu_indices, and get_command_da_gain for fetching DEFAULT commands","title":"Basic Information"},{"location":"function-guide/PCS/get_command_da_gain_m/","text":"get_command_da_gain.m \u00b6 Basic Information \u00b6 USAGE: get_command_da_gain(ind_struct,commands,single,tokamak) PURPOSE: returns the digital-to-analog convertor (DAC) gains for given commands INPUTS: ind_struct structure data from simulation_includes.m commands cell array commands used as input into simulink simulation single if 1, return only a single value for gain tokamak name of tokamak OUTPUTS: gain: multiplier that converts DAC output volts to input counts (DA_GAIN in io_PCS.c)","title":"get_command_da_gain.m"},{"location":"function-guide/PCS/get_command_da_gain_m/#get_command_da_gainm","text":"","title":"get_command_da_gain.m"},{"location":"function-guide/PCS/get_command_da_gain_m/#basic-information","text":"USAGE: get_command_da_gain(ind_struct,commands,single,tokamak) PURPOSE: returns the digital-to-analog convertor (DAC) gains for given commands INPUTS: ind_struct structure data from simulation_includes.m commands cell array commands used as input into simulink simulation single if 1, return only a single value for gain tokamak name of tokamak OUTPUTS: gain: multiplier that converts DAC output volts to input counts (DA_GAIN in io_PCS.c)","title":"Basic Information"},{"location":"function-guide/PCS/get_command_indices_m/","text":"get_command_indices.m \u00b6 Basic Information \u00b6 USAGE: indices = get_command_indices(ind_struct,commands,tokamak) PURPOSE: returns the channel indices given contents of simulation_input.m and a list of command names used in a simulink simulation INPUTS: ind_struct structure data from simulation_includes.m commands cell array commands used as input into simulink simulation OUTPUTS: indices integer array array of indexes linking commands with their associated values as specified by simulation_includes.m (in the INTEL_DIR directory) RESTRICTIONS: METHOD: Get this from CMD variables in simulation_includes.m Every PCS uses some different naming convention.","title":"get_command_indices.m"},{"location":"function-guide/PCS/get_command_indices_m/#get_command_indicesm","text":"","title":"get_command_indices.m"},{"location":"function-guide/PCS/get_command_indices_m/#basic-information","text":"USAGE: indices = get_command_indices(ind_struct,commands,tokamak) PURPOSE: returns the channel indices given contents of simulation_input.m and a list of command names used in a simulink simulation INPUTS: ind_struct structure data from simulation_includes.m commands cell array commands used as input into simulink simulation OUTPUTS: indices integer array array of indexes linking commands with their associated values as specified by simulation_includes.m (in the INTEL_DIR directory) RESTRICTIONS: METHOD: Get this from CMD variables in simulation_includes.m Every PCS uses some different naming convention.","title":"Basic Information"},{"location":"function-guide/PCS/get_cpu_indices_m/","text":"get_cpu_indices.m \u00b6 Basic Information \u00b6 USAGE: get_cpu_indices PURPOSE: returns the cpu indices given contents of simulation_input.m and a list of command names used in a simulink simulation INPUTS: ind_struct structure data from simulation_input.m commands cell array commands used as input into simulink simulation OUTPUTS: cpus integer array array of indices linking commands with their associated cpus as specified by simulation_input.m RESTRICTIONS: METHOD: Get this from CPU variables in simulation_includes.m Every PCS uses some different naming convention.","title":"get_cpu_indices.m"},{"location":"function-guide/PCS/get_cpu_indices_m/#get_cpu_indicesm","text":"","title":"get_cpu_indices.m"},{"location":"function-guide/PCS/get_cpu_indices_m/#basic-information","text":"USAGE: get_cpu_indices PURPOSE: returns the cpu indices given contents of simulation_input.m and a list of command names used in a simulink simulation INPUTS: ind_struct structure data from simulation_input.m commands cell array commands used as input into simulink simulation OUTPUTS: cpus integer array array of indices linking commands with their associated cpus as specified by simulation_input.m RESTRICTIONS: METHOD: Get this from CPU variables in simulation_includes.m Every PCS uses some different naming convention.","title":"Basic Information"},{"location":"function-guide/PCS/get_input_channels_m/","text":"get_input_channels.m \u00b6 Basic Information \u00b6 SYNTAX: [channels,names] = get_input_channels(pcs_dir,input_signals) PURPOSE: Fetch indices for PCS input signal channels, or provide names of input channels to choose from. INPUT: pcs_dir = directory where PCS has already been built input_signals = cell array of selected input signal names or 'all' to list all possible names in 2nd output argument OUTPUT: channels = indices of selected signals names = names of selected signals ind = the indices in input_signals for which channels were found","title":"get_input_channels.m"},{"location":"function-guide/PCS/get_input_channels_m/#get_input_channelsm","text":"","title":"get_input_channels.m"},{"location":"function-guide/PCS/get_input_channels_m/#basic-information","text":"SYNTAX: [channels,names] = get_input_channels(pcs_dir,input_signals) PURPOSE: Fetch indices for PCS input signal channels, or provide names of input channels to choose from. INPUT: pcs_dir = directory where PCS has already been built input_signals = cell array of selected input signal names or 'all' to list all possible names in 2nd output argument OUTPUT: channels = indices of selected signals names = names of selected signals ind = the indices in input_signals for which channels were found","title":"Basic Information"},{"location":"function-guide/PCS/get_param_names_m/","text":"get_param_names.m \u00b6 Basic Information \u00b6 SYNTAX: names = get_param_names(shot, category, phase, server) PURPOSE: Retrieves the names of the PCS parameter data blocks for a given shot,category, and phase. INPUT: shot = shot number to get category names data from category = pcs category phase = pcs phase server = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a parameter name. If none found, is empty matrix [].","title":"get_param_names.m"},{"location":"function-guide/PCS/get_param_names_m/#get_param_namesm","text":"","title":"get_param_names.m"},{"location":"function-guide/PCS/get_param_names_m/#basic-information","text":"SYNTAX: names = get_param_names(shot, category, phase, server) PURPOSE: Retrieves the names of the PCS parameter data blocks for a given shot,category, and phase. INPUT: shot = shot number to get category names data from category = pcs category phase = pcs phase server = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a parameter name. If none found, is empty matrix [].","title":"Basic Information"},{"location":"function-guide/PCS/get_pcs_server_m/","text":"get_pcs_server.m \u00b6 Basic Information \u00b6 SYNTAX: name = get_pcs_server(server) PURPOSE: Determine name of mds server to use in fetching PCS data. INPUT: server = name of mds server to get data from. Specify as one of: - actual server name - device name (e.g. 'd3d', 'nstx') to get remote mds server - device name followed by ':local' to get local mds server - empty or missing argument - use default processing - 'local' - use default processing to get local server (Default is to use remote server for the device currently at the top of matlab search path, or local version if \"local\" specified.) OUTPUT: name = name of server","title":"get_pcs_server.m"},{"location":"function-guide/PCS/get_pcs_server_m/#get_pcs_serverm","text":"","title":"get_pcs_server.m"},{"location":"function-guide/PCS/get_pcs_server_m/#basic-information","text":"SYNTAX: name = get_pcs_server(server) PURPOSE: Determine name of mds server to use in fetching PCS data. INPUT: server = name of mds server to get data from. Specify as one of: - actual server name - device name (e.g. 'd3d', 'nstx') to get remote mds server - device name followed by ':local' to get local mds server - empty or missing argument - use default processing - 'local' - use default processing to get local server (Default is to use remote server for the device currently at the top of matlab search path, or local version if \"local\" specified.) OUTPUT: name = name of server","title":"Basic Information"},{"location":"function-guide/PCS/get_pcssetup_calib_m/","text":"get_pcssetup_calib.m \u00b6 Basic Information \u00b6 SYNTAX: [calib,ptnames,ier]=get_pcssetup_calib(shotnum,idebug); PURPOSE: Get PCS shot diagniostic calibration data from shot startup file INPUT: shotnum = shot number to extract calibration data idebug = 1 for debug output [0] OUTPUT: calib = Calibration matrix [rc gain inherent_number vtophys] ptnames= Name of each dignostic, one for each row of calib ier = 0 if everything OK, else nonzero RESTRICTIONS: METHOD: Uses get_pcssetup_calib.c to read pcs setup data stored in ptdata","title":"get_pcssetup_calib.m"},{"location":"function-guide/PCS/get_pcssetup_calib_m/#get_pcssetup_calibm","text":"","title":"get_pcssetup_calib.m"},{"location":"function-guide/PCS/get_pcssetup_calib_m/#basic-information","text":"SYNTAX: [calib,ptnames,ier]=get_pcssetup_calib(shotnum,idebug); PURPOSE: Get PCS shot diagniostic calibration data from shot startup file INPUT: shotnum = shot number to extract calibration data idebug = 1 for debug output [0] OUTPUT: calib = Calibration matrix [rc gain inherent_number vtophys] ptnames= Name of each dignostic, one for each row of calib ier = 0 if everything OK, else nonzero RESTRICTIONS: METHOD: Uses get_pcssetup_calib.c to read pcs setup data stored in ptdata","title":"Basic Information"},{"location":"function-guide/PCS/get_pcssetup_m/","text":"get_pcssetup.m \u00b6 Basic Information \u00b6 SYNTAX: [data,ier] = get_pcssetup(shot,category,phase,data_name,server,debug) PURPOSE: Get parameter data from the PCS setup file. INPUT: shot = shot number to get data from category = one of the categories from PCS (e.g. \"Discharge Shape\", \"Error Field\", \"Neutral Beams\", etc.). CASE SENSITIVE phase = name of phase from PCS (e.g. \"ShotStart\") CASE SENSITIVE data_name = CASE INSENSITIVE server = server name (see get_pcs_server for processing of this input) debug (optional) = flag, set = 1 to get debug prints, else 0 OUTPUT: data = data structure containing parameter data with any relevant labels ier = error code, 0 = everything OK","title":"get_pcssetup.m"},{"location":"function-guide/PCS/get_pcssetup_m/#get_pcssetupm","text":"","title":"get_pcssetup.m"},{"location":"function-guide/PCS/get_pcssetup_m/#basic-information","text":"SYNTAX: [data,ier] = get_pcssetup(shot,category,phase,data_name,server,debug) PURPOSE: Get parameter data from the PCS setup file. INPUT: shot = shot number to get data from category = one of the categories from PCS (e.g. \"Discharge Shape\", \"Error Field\", \"Neutral Beams\", etc.). CASE SENSITIVE phase = name of phase from PCS (e.g. \"ShotStart\") CASE SENSITIVE data_name = CASE INSENSITIVE server = server name (see get_pcs_server for processing of this input) debug (optional) = flag, set = 1 to get debug prints, else 0 OUTPUT: data = data structure containing parameter data with any relevant labels ier = error code, 0 = everything OK","title":"Basic Information"},{"location":"function-guide/PCS/get_pcssetup_struct_m/","text":"get_pcssetup_struct.m \u00b6 Basic Information \u00b6 SYNTAX: setup = get_pcssetup_struct(shot, server, debug) PURPOSE: Get all parameter data from the PCS setup file and load it into a single matlab data structure. INPUT: shot = shot number to get data from server = server name (see get_pcs_server for processing of this input) debug = flag, set = 1 to get debug prints, else 0 OUTPUT: setup Each category/phase combination has three types of data, each of which is represented in the setup strucuture as a sub-structure. The matrices field contains data from matrix parameter data blocks. The labeled_data field contains structured data with labels. The misc field contains data that does not fit into the matrix or labeled data classifications. Setup has the following structure: setup. (category). --Struct. Name of pcs category. Spaces are replaced with '_'. If the leading character is a number, 'x' is prepended. (phase). --Struct. Name of pcs phase. Spaces are replaced with '_' If the leading character is a number, 'x' is prepended. matrices. --array of structs-- param_name --char array-- dims. --struct-- nmatrices nrows ncols matrix_names --char matrix-- col_names --char matrix-- row_names --char matrix-- data --3d matrix-- labeled_data --array of structs-- param_name --char array-- data_fields. --array of structs-- label --char array-- data misc param_name --char array-- data -- See note below-- Note on misc.data: When non-labeled or non-matrix data is retrieved, it is formatted one of two ways. If the data has a single field, then misc.data simply holds that fields data (e.g. misc.data = [3 3]). If the data has multiple fields, then misc.data has sub-fields with names field_0 ... field_N where N is the number of fields.","title":"get_pcssetup_struct.m"},{"location":"function-guide/PCS/get_pcssetup_struct_m/#get_pcssetup_structm","text":"","title":"get_pcssetup_struct.m"},{"location":"function-guide/PCS/get_pcssetup_struct_m/#basic-information","text":"SYNTAX: setup = get_pcssetup_struct(shot, server, debug) PURPOSE: Get all parameter data from the PCS setup file and load it into a single matlab data structure. INPUT: shot = shot number to get data from server = server name (see get_pcs_server for processing of this input) debug = flag, set = 1 to get debug prints, else 0 OUTPUT: setup Each category/phase combination has three types of data, each of which is represented in the setup strucuture as a sub-structure. The matrices field contains data from matrix parameter data blocks. The labeled_data field contains structured data with labels. The misc field contains data that does not fit into the matrix or labeled data classifications. Setup has the following structure: setup. (category). --Struct. Name of pcs category. Spaces are replaced with '_'. If the leading character is a number, 'x' is prepended. (phase). --Struct. Name of pcs phase. Spaces are replaced with '_' If the leading character is a number, 'x' is prepended. matrices. --array of structs-- param_name --char array-- dims. --struct-- nmatrices nrows ncols matrix_names --char matrix-- col_names --char matrix-- row_names --char matrix-- data --3d matrix-- labeled_data --array of structs-- param_name --char array-- data_fields. --array of structs-- label --char array-- data misc param_name --char array-- data -- See note below-- Note on misc.data: When non-labeled or non-matrix data is retrieved, it is formatted one of two ways. If the data has a single field, then misc.data simply holds that fields data (e.g. misc.data = [3 3]). If the data has multiple fields, then misc.data has sub-fields with names field_0 ... field_N where N is the number of fields.","title":"Basic Information"},{"location":"function-guide/PCS/get_pcssetup_waveform_m/","text":"get_pcssetup_waveform.m \u00b6 Basic Information \u00b6 SYNTAX: [data,time,ierror] = ... get_pcssetup_waveform(shot,category,phase,waveform,[server]); PURPOSE: Get waveform data from PCS setup file. INPUT: shot = shot number to get data from category = one of \"shape\", phase = string denoting which shot phase waveform = string denoting name of the waveform [server] = name of server to get data from (see get_pcs_server) OUTPUT: data = vector of doubles containing the y part of the waveform vertices time = vector of doubles containing the x part of the waveform vertices ierror = 0 if successful, non-zero otherwise. Error values: 1: Error, was not able to gather any infomation with the specified argument. 2: Warning. Arguments were ok, but there were no vertices to get.","title":"get_pcssetup_waveform.m"},{"location":"function-guide/PCS/get_pcssetup_waveform_m/#get_pcssetup_waveformm","text":"","title":"get_pcssetup_waveform.m"},{"location":"function-guide/PCS/get_pcssetup_waveform_m/#basic-information","text":"SYNTAX: [data,time,ierror] = ... get_pcssetup_waveform(shot,category,phase,waveform,[server]); PURPOSE: Get waveform data from PCS setup file. INPUT: shot = shot number to get data from category = one of \"shape\", phase = string denoting which shot phase waveform = string denoting name of the waveform [server] = name of server to get data from (see get_pcs_server) OUTPUT: data = vector of doubles containing the y part of the waveform vertices time = vector of doubles containing the x part of the waveform vertices ierror = 0 if successful, non-zero otherwise. Error values: 1: Error, was not able to gather any infomation with the specified argument. 2: Warning. Arguments were ok, but there were no vertices to get.","title":"Basic Information"},{"location":"function-guide/PCS/get_phase_names_m/","text":"get_phase_names.m \u00b6 Basic Information \u00b6 SYNTAX: names = get_phase_names(shot, category, [server]) PURPOSE: Retrieves the names of the PCS phases for a given shot and category INPUT: shot = shot number to get category names data from category = pcs category [server] = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a phase name. If none found, is empty matrix []. RESTRICTIONS: METHOD: WRITTEN BY: Brian Sammuli ON Dec. 3, 2009","title":"get_phase_names.m"},{"location":"function-guide/PCS/get_phase_names_m/#get_phase_namesm","text":"","title":"get_phase_names.m"},{"location":"function-guide/PCS/get_phase_names_m/#basic-information","text":"SYNTAX: names = get_phase_names(shot, category, [server]) PURPOSE: Retrieves the names of the PCS phases for a given shot and category INPUT: shot = shot number to get category names data from category = pcs category [server] = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a phase name. If none found, is empty matrix []. RESTRICTIONS: METHOD: WRITTEN BY: Brian Sammuli ON Dec. 3, 2009","title":"Basic Information"},{"location":"function-guide/PCS/getwaveform_c/","text":"getwaveform.c \u00b6 Basic Information \u00b6 if(vertices[ii].y > 0.0)","title":"getwaveform.c"},{"location":"function-guide/PCS/getwaveform_c/#getwaveformc","text":"","title":"getwaveform.c"},{"location":"function-guide/PCS/getwaveform_c/#basic-information","text":"if(vertices[ii].y > 0.0)","title":"Basic Information"},{"location":"function-guide/PCS/read_PCS_matrix_file_m/","text":"read_PCS_matrix_file.m \u00b6 Basic Information \u00b6 SYNTAX: read_PCS_matrix_file(matrix_file,matrix_data,rows,cols) PURPOSE: Write matrix data to a file readable by PCS. INPUT: matrix_file = name of file to read OUTPUT: matrix_data = data read from file rows = string array containing names corresponding to each row cols = string array containing names corresponding to each column","title":"read_PCS_matrix_file.m"},{"location":"function-guide/PCS/read_PCS_matrix_file_m/#read_pcs_matrix_filem","text":"","title":"read_PCS_matrix_file.m"},{"location":"function-guide/PCS/read_PCS_matrix_file_m/#basic-information","text":"SYNTAX: read_PCS_matrix_file(matrix_file,matrix_data,rows,cols) PURPOSE: Write matrix data to a file readable by PCS. INPUT: matrix_file = name of file to read OUTPUT: matrix_data = data read from file rows = string array containing names corresponding to each row cols = string array containing names corresponding to each column","title":"Basic Information"},{"location":"function-guide/PCS/read_define_m/","text":"read_define.m \u00b6 Basic Information \u00b6 SYNTAX: d = read_define(filename,v) PURPOSE: read all instances of #define in a file INPUT: filename, file name including path and extension v, structure with variables required to evaluate define statements, e.g. v.CMD_BITS2VOLTS = 10/2047 OUTPUT: d, structure with fields set to values defined in the file RESTRICTIONS: assumes one space between #define and name in the file define statements must be terminated with line-feed or /* define statements that can't be evaluated are ignored fields in v named: i,j,k,m,n,p,s, are clobbered","title":"read_define.m"},{"location":"function-guide/PCS/read_define_m/#read_definem","text":"","title":"read_define.m"},{"location":"function-guide/PCS/read_define_m/#basic-information","text":"SYNTAX: d = read_define(filename,v) PURPOSE: read all instances of #define in a file INPUT: filename, file name including path and extension v, structure with variables required to evaluate define statements, e.g. v.CMD_BITS2VOLTS = 10/2047 OUTPUT: d, structure with fields set to values defined in the file RESTRICTIONS: assumes one space between #define and name in the file define statements must be terminated with line-feed or /* define statements that can't be evaluated are ignored fields in v named: i,j,k,m,n,p,s, are clobbered","title":"Basic Information"},{"location":"function-guide/PCS/read_pcs_ss_filter_m/","text":"read_pcs_ss_filter.m \u00b6 Basic Information \u00b6 USAGE: [A,B,C,D] = read_pcs_ss_filter(filtfile) PURPOSE: Read a standard PCS state-space filter file. INPUT: filtfile = string defining name of file OUTPUT: A,B,C,D = state space description of filter","title":"read_pcs_ss_filter.m"},{"location":"function-guide/PCS/read_pcs_ss_filter_m/#read_pcs_ss_filterm","text":"","title":"read_pcs_ss_filter.m"},{"location":"function-guide/PCS/read_pcs_ss_filter_m/#basic-information","text":"USAGE: [A,B,C,D] = read_pcs_ss_filter(filtfile) PURPOSE: Read a standard PCS state-space filter file. INPUT: filtfile = string defining name of file OUTPUT: A,B,C,D = state space description of filter","title":"Basic Information"},{"location":"function-guide/PCS/segment_response_m/","text":"segment_response.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the response of the flux and magnetic field components to the current in the poloidal field coils, vessel segments, ohmic heating coils and plasma current on the calculation grid at a list of control point locations. INPUT: rcntrlpt = r coordinates of control points zcntrlpt = z coordinates of control points zg = vector of Z grid values (meters) rg = vector of R grid values (meters) zgg = array of Z values over entire grid rgg = array of R values over entire grid nz = grid vertical (Z=row) dimension nr = grid horizontal (R=col) dimension dz = vertical (Z=row) grid spacing (meters) dr = horizontal (R=col) grid spacing (meters) installation = one of 'D3D', 'NSTX', 'KSTAR', 'EAST' dir = directory where files defining rtefit objects reside OUTPUT: contents = text string describing contents of output mutuals = mutual inductances between each modeled current carrying element and each control point. 1st index: 1...nfcoil = F-coils, next nesum = E-coils, next nvessel = vessel elts, last nz x nr = grid elements 2nd index: 1..number of control points on the line segment rsource = r coordinates of current source points zsource = z coordinates of current source points sizedata = structure defining dimensions of data being returned bzgreens = green's function multipliers of current sources to get Bz brgreens = green's function multipliers of current sources to get Br (Units of current = Amp-turns. Flux is in Wb/rad. Field is in Tesla?)","title":"segment_response.m"},{"location":"function-guide/PCS/segment_response_m/#segment_responsem","text":"","title":"segment_response.m"},{"location":"function-guide/PCS/segment_response_m/#basic-information","text":"PURPOSE: Calculate the response of the flux and magnetic field components to the current in the poloidal field coils, vessel segments, ohmic heating coils and plasma current on the calculation grid at a list of control point locations. INPUT: rcntrlpt = r coordinates of control points zcntrlpt = z coordinates of control points zg = vector of Z grid values (meters) rg = vector of R grid values (meters) zgg = array of Z values over entire grid rgg = array of R values over entire grid nz = grid vertical (Z=row) dimension nr = grid horizontal (R=col) dimension dz = vertical (Z=row) grid spacing (meters) dr = horizontal (R=col) grid spacing (meters) installation = one of 'D3D', 'NSTX', 'KSTAR', 'EAST' dir = directory where files defining rtefit objects reside OUTPUT: contents = text string describing contents of output mutuals = mutual inductances between each modeled current carrying element and each control point. 1st index: 1...nfcoil = F-coils, next nesum = E-coils, next nvessel = vessel elts, last nz x nr = grid elements 2nd index: 1..number of control points on the line segment rsource = r coordinates of current source points zsource = z coordinates of current source points sizedata = structure defining dimensions of data being returned bzgreens = green's function multipliers of current sources to get Bz brgreens = green's function multipliers of current sources to get Br (Units of current = Amp-turns. Flux is in Wb/rad. Field is in Tesla?)","title":"Basic Information"},{"location":"function-guide/PCS/write_PCS_matrix_file_m/","text":"write_PCS_matrix_file.m \u00b6 Basic Information \u00b6 SYNTAX: write_PCS_matrix_file(matrix_file,matrix_data,rows,cols) PURPOSE: Write matrix data to a file readable by PCS. INPUT: matrix_file = name of file to write matrix_data = data to write to file rows = string array containing names corresponding to each row cols = string array containing names corresponding to each column OUTPUT: file written to disk","title":"write_PCS_matrix_file.m"},{"location":"function-guide/PCS/write_PCS_matrix_file_m/#write_pcs_matrix_filem","text":"","title":"write_PCS_matrix_file.m"},{"location":"function-guide/PCS/write_PCS_matrix_file_m/#basic-information","text":"SYNTAX: write_PCS_matrix_file(matrix_file,matrix_data,rows,cols) PURPOSE: Write matrix data to a file readable by PCS. INPUT: matrix_file = name of file to write matrix_data = data to write to file rows = string array containing names corresponding to each row cols = string array containing names corresponding to each column OUTPUT: file written to disk","title":"Basic Information"},{"location":"function-guide/PCS/write_pcs_filter_m/","text":"write_pcs_filter.m \u00b6 Basic Information \u00b6 WRITE_PCS_FILTER Writes filter file for PCS data filtering. SYNTAX: write_pcs_filter(filtsys,filename) PURPOSE: Writes out PCS filter file (for use by Data Acquisition category) given a filter in state-space form. INPUTS: filtss = Filter state-space object filename = Name of saved file OUTPUTS: Text file RESTRICTIONS: METHOD:","title":"write_pcs_filter.m"},{"location":"function-guide/PCS/write_pcs_filter_m/#write_pcs_filterm","text":"","title":"write_pcs_filter.m"},{"location":"function-guide/PCS/write_pcs_filter_m/#basic-information","text":"WRITE_PCS_FILTER Writes filter file for PCS data filtering. SYNTAX: write_pcs_filter(filtsys,filename) PURPOSE: Writes out PCS filter file (for use by Data Acquisition category) given a filter in state-space form. INPUTS: filtss = Filter state-space object filename = Name of saved file OUTPUTS: Text file RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/RWM/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 RWM control analysis and design utility functions. bld_Ccomp_filter - build C-coil filters used for ESLD compensation bld_PCS_RWM_mdl - build model of RWM algorithm in PCS get_cmatrix - get RWM algorithm C matrix for a shot from PCS setup data get_fmatrix - get RWM algorithm F matrix for a shot from PCS setup data get_RWM_PID_gains - get gains used by RWM control algorithm for a shot/time get_RWM_PID_taus - get taus used by RWM control algorithm for a shot/time SPA*_model.mat - data file containing model for SPA* supplies","title":"Contents.m"},{"location":"function-guide/RWM/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/RWM/Contents_m/#basic-information","text":"RWM control analysis and design utility functions. bld_Ccomp_filter - build C-coil filters used for ESLD compensation bld_PCS_RWM_mdl - build model of RWM algorithm in PCS get_cmatrix - get RWM algorithm C matrix for a shot from PCS setup data get_fmatrix - get RWM algorithm F matrix for a shot from PCS setup data get_RWM_PID_gains - get gains used by RWM control algorithm for a shot/time get_RWM_PID_taus - get taus used by RWM control algorithm for a shot/time SPA*_model.mat - data file containing model for SPA* supplies","title":"Basic Information"},{"location":"function-guide/breakdown/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Generic Breakdown Area: do_breakdown_tok Main program for calculating constrained breakdown traj. calc_bd_traj_tok Function to optimize voltage trajectory based on constraints ohmic_tok Calculate the Initial Magnetization State","title":"Contents.m"},{"location":"function-guide/breakdown/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/breakdown/Contents_m/#basic-information","text":"Generic Breakdown Area: do_breakdown_tok Main program for calculating constrained breakdown traj. calc_bd_traj_tok Function to optimize voltage trajectory based on constraints ohmic_tok Calculate the Initial Magnetization State","title":"Basic Information"},{"location":"function-guide/breakdown/calc_bd_traj_tok_m/","text":"calc_bd_traj_tok.m \u00b6 Basic Information \u00b6 SYNTAX: calc_bd_traj_tok PURPOSE: Compute breakdown current and voltage trajectories based on vacuum model M*dI/dt + R*I = V*v. INPUT: [default] r_plasma = Major R of plasma center (m) z_plasma = Z of plasma center (m) a_plasma= minor radius of plasma (m) npts_opt = number of points on boundary of plasma to optimize at Psidot_tgt= d/dt(Psi) at plasma center (scalar OR 1 x ntimes vector) optionally if exist('Emax') => Psidot_tgt computed from Emax Br_tgt = target radial field at pts on circle (npts_opt x 1 vector OR npts_opt x ntimes matrix for time-dependent) Bz_tgt = target vertical field at pts on circle (npts_opt x 1 vector OR npts_opt x ntimes matrix for time-dependent) Bzdot_tgt = dBz/dt at plasma center (scalar OR 1 x ntimes vector) wbr = vector of length npts_opt defining weights on Br at opt pts OR npts_opt x ntimes matrix for time-dependent) wbz = vector of length npts_opt defining weights on Bz at opt pts OR npts_opt x ntimes matrix for time-dependent) wbzdot = weight on Bzdot at plasma center (scalar OR 1 x ntimes vector) wpsidot = weight on Psidot at plasma (scalar OR 1 x ntimes vector) Vmin = minimum allowed voltage vector Vmax = maximum allowed voltage vector Idotmax = limits on absolute value of derivative of current in coils times = times at which flux, field, voltage target values specified nps = number of power supplies to drive (this needs to be generalized to specification of how to reduce degrees of freedom for optimization problem) I_init = initial currents vector (size = ncx x 1 for PF currents only OR (ncx+nvx) x 1 including vessel; optional, default = all zeros) pause_it= 1; => pause between figures [0]; rckts= array of Rckts values [ncx,max(iswtimes)] sets: Rckts= rckts(:,iswtimes(kk)) Rckts= additional circuit resistance - set to rckts (if rckts exists) cccirc= coil connective vector => defines final coil current states vccirc= voltage connection vector (like cccirc but for voltage inputs) default: [1:size(Bmat,2)]; => all input coils (kstar default) EAST: [1:6 1:6] iswtimes= times at which switch system matrix [1,zeros(size(times)-1,1)]; icoilc= print out of coilc_1.dat, _2.dat ... [0] ptimes= print times of coilc_?.dat files and incurment contour plots [times(1), 0 times(end)]; OUTPUT: Itraj = Current trajectories (ntimes x ncx) Vtraj = voltage trajectories (ntimes x nvoltx) psi_plasma = Flux at plasma center (ntimes x 1) (Vs) bz_opt0 = Bz at plasma center (ntimes x 1) (T) where: ncx= max(cccirc), nvoltx= max(vccirc) RESTRICTIONS: (1) Assumes that nps power supplies are the first nps out of ncx. (2) The PCS input mechanism (waveforms) restricts what can be used for voltage trajectories. This code assumes piecewise linear voltages continuously connected at discretely specified points. An alternative could be to use piecewise constant voltages that are discontinuous at these points. Minimum spacing of these points is 1ms. I'm not sure which alternative is better in this case. (3) At present it expects imks=1 iterminal=1 which brings in all objects in A, H, Ohm It is not clear if routine will work with other combination METHOD: Written to be consistent with: J.A.Leuer and J.C.Wesley, ITER Plasma Startup Modeling, 15th IEEE/NPSS Symp. on Fusion Eng., Oct.11-15, 1993, Hyannis, MA, p629 NOTE that current derivative constraint is only imposed at times in the input vector \"times\" - this is an approximation only.","title":"calc_bd_traj_tok.m"},{"location":"function-guide/breakdown/calc_bd_traj_tok_m/#calc_bd_traj_tokm","text":"","title":"calc_bd_traj_tok.m"},{"location":"function-guide/breakdown/calc_bd_traj_tok_m/#basic-information","text":"SYNTAX: calc_bd_traj_tok PURPOSE: Compute breakdown current and voltage trajectories based on vacuum model M*dI/dt + R*I = V*v. INPUT: [default] r_plasma = Major R of plasma center (m) z_plasma = Z of plasma center (m) a_plasma= minor radius of plasma (m) npts_opt = number of points on boundary of plasma to optimize at Psidot_tgt= d/dt(Psi) at plasma center (scalar OR 1 x ntimes vector) optionally if exist('Emax') => Psidot_tgt computed from Emax Br_tgt = target radial field at pts on circle (npts_opt x 1 vector OR npts_opt x ntimes matrix for time-dependent) Bz_tgt = target vertical field at pts on circle (npts_opt x 1 vector OR npts_opt x ntimes matrix for time-dependent) Bzdot_tgt = dBz/dt at plasma center (scalar OR 1 x ntimes vector) wbr = vector of length npts_opt defining weights on Br at opt pts OR npts_opt x ntimes matrix for time-dependent) wbz = vector of length npts_opt defining weights on Bz at opt pts OR npts_opt x ntimes matrix for time-dependent) wbzdot = weight on Bzdot at plasma center (scalar OR 1 x ntimes vector) wpsidot = weight on Psidot at plasma (scalar OR 1 x ntimes vector) Vmin = minimum allowed voltage vector Vmax = maximum allowed voltage vector Idotmax = limits on absolute value of derivative of current in coils times = times at which flux, field, voltage target values specified nps = number of power supplies to drive (this needs to be generalized to specification of how to reduce degrees of freedom for optimization problem) I_init = initial currents vector (size = ncx x 1 for PF currents only OR (ncx+nvx) x 1 including vessel; optional, default = all zeros) pause_it= 1; => pause between figures [0]; rckts= array of Rckts values [ncx,max(iswtimes)] sets: Rckts= rckts(:,iswtimes(kk)) Rckts= additional circuit resistance - set to rckts (if rckts exists) cccirc= coil connective vector => defines final coil current states vccirc= voltage connection vector (like cccirc but for voltage inputs) default: [1:size(Bmat,2)]; => all input coils (kstar default) EAST: [1:6 1:6] iswtimes= times at which switch system matrix [1,zeros(size(times)-1,1)]; icoilc= print out of coilc_1.dat, _2.dat ... [0] ptimes= print times of coilc_?.dat files and incurment contour plots [times(1), 0 times(end)]; OUTPUT: Itraj = Current trajectories (ntimes x ncx) Vtraj = voltage trajectories (ntimes x nvoltx) psi_plasma = Flux at plasma center (ntimes x 1) (Vs) bz_opt0 = Bz at plasma center (ntimes x 1) (T) where: ncx= max(cccirc), nvoltx= max(vccirc) RESTRICTIONS: (1) Assumes that nps power supplies are the first nps out of ncx. (2) The PCS input mechanism (waveforms) restricts what can be used for voltage trajectories. This code assumes piecewise linear voltages continuously connected at discretely specified points. An alternative could be to use piecewise constant voltages that are discontinuous at these points. Minimum spacing of these points is 1ms. I'm not sure which alternative is better in this case. (3) At present it expects imks=1 iterminal=1 which brings in all objects in A, H, Ohm It is not clear if routine will work with other combination METHOD: Written to be consistent with: J.A.Leuer and J.C.Wesley, ITER Plasma Startup Modeling, 15th IEEE/NPSS Symp. on Fusion Eng., Oct.11-15, 1993, Hyannis, MA, p629 NOTE that current derivative constraint is only imposed at times in the input vector \"times\" - this is an approximation only.","title":"Basic Information"},{"location":"function-guide/breakdown/connect_len_bkd_m/","text":"connect_len_bkd.m \u00b6 Basic Information \u00b6 SYNTAX: [conlen,crospos,turns] = ... connect_len_bkd(rlb,zlb,rgg,zgg,brg,bzg,rsb,zsb,Bt,R0,[maxturns]) PURPOSE: Calculate the approximate field line connection length from given starting points on a subgrid of the standard efit grid to a specified boundary. Also return the crossing point coords and the number of turns around the torus required to get there. INPUTS: [rsb,zsb]: (r,z) coordinates defining a boundary, the interior of which specifies the subset of rgg, zgg grid points that are used as the starting locations of the field lines to follow (meters). [rlb,zlb]: (r,z) coordinates defining 'limiter' boundary upon which the field lines impact that terminates the field line length calculation for each line (meters). rgg: Vector or matrix of poloidal radii of standard nz x nr tokamak grid (m) zgg: Vector or matrix of poloidal z-coords of standard tokamak grid (m) brg: Radial field value on standard tokamak grid (T) bzg: Verical field value on standard tokamak grid (T) Bt: Toroidal field (T) at radius R0 R0: Radius (m) where toroidal field is quoted. Bt(r) = Bt*R0/r maxturns: Maximum number of toroidal circuits to follow field lines. Default = 5000 if omitted. OUTPUTS: conlen: Vector of approximate length of field lines (meters) starting on grid points within [rsb,zsb] and ending on [rlb,zlb] defined 'limiter'. crospos: Matrix of final field line coords as they cross [rlb,zlb]. Rf=crospos(2,:); Zf=crospos(1,:) turns: Vector of number of toroidal circuits required for field line to cross [rlb,zlb] boundary. RESTRICTIONS: 1. Only valid if input fields brg, bzg are the entire poloidal field, so be sure to add PF coil and vacuum vessel contributions together to form brg, bzg. 2. The grid brg & bzg must be regular in the sense that the poloidal positions of brg, etc, can be defined by two vectors, rg (columns) and zg (rows). This is true for the standard tokamak poloidal grids. Substitute grids could be used if they follow this restriction. METHOD: This subroutine approximates the dR and dZ a field line traces out over one full circuit around the tokamak by calculating the slope the line has at a starting point in (R,phi) and (Z,phi) space, and intgrating that slope over 2*pi in phi. The connection length is then approximated as 2*pi*R and new slopes are calculated at the new R=R_old+dR, Z=Z_old+dZ and the process is iterated until R,Z cross the limiter boundary. The length of the last partial turn as the line crosses the boundary is NOT added to the total connection length for that line.","title":"connect_len_bkd.m"},{"location":"function-guide/breakdown/connect_len_bkd_m/#connect_len_bkdm","text":"","title":"connect_len_bkd.m"},{"location":"function-guide/breakdown/connect_len_bkd_m/#basic-information","text":"SYNTAX: [conlen,crospos,turns] = ... connect_len_bkd(rlb,zlb,rgg,zgg,brg,bzg,rsb,zsb,Bt,R0,[maxturns]) PURPOSE: Calculate the approximate field line connection length from given starting points on a subgrid of the standard efit grid to a specified boundary. Also return the crossing point coords and the number of turns around the torus required to get there. INPUTS: [rsb,zsb]: (r,z) coordinates defining a boundary, the interior of which specifies the subset of rgg, zgg grid points that are used as the starting locations of the field lines to follow (meters). [rlb,zlb]: (r,z) coordinates defining 'limiter' boundary upon which the field lines impact that terminates the field line length calculation for each line (meters). rgg: Vector or matrix of poloidal radii of standard nz x nr tokamak grid (m) zgg: Vector or matrix of poloidal z-coords of standard tokamak grid (m) brg: Radial field value on standard tokamak grid (T) bzg: Verical field value on standard tokamak grid (T) Bt: Toroidal field (T) at radius R0 R0: Radius (m) where toroidal field is quoted. Bt(r) = Bt*R0/r maxturns: Maximum number of toroidal circuits to follow field lines. Default = 5000 if omitted. OUTPUTS: conlen: Vector of approximate length of field lines (meters) starting on grid points within [rsb,zsb] and ending on [rlb,zlb] defined 'limiter'. crospos: Matrix of final field line coords as they cross [rlb,zlb]. Rf=crospos(2,:); Zf=crospos(1,:) turns: Vector of number of toroidal circuits required for field line to cross [rlb,zlb] boundary. RESTRICTIONS: 1. Only valid if input fields brg, bzg are the entire poloidal field, so be sure to add PF coil and vacuum vessel contributions together to form brg, bzg. 2. The grid brg & bzg must be regular in the sense that the poloidal positions of brg, etc, can be defined by two vectors, rg (columns) and zg (rows). This is true for the standard tokamak poloidal grids. Substitute grids could be used if they follow this restriction. METHOD: This subroutine approximates the dR and dZ a field line traces out over one full circuit around the tokamak by calculating the slope the line has at a starting point in (R,phi) and (Z,phi) space, and intgrating that slope over 2*pi in phi. The connection length is then approximated as 2*pi*R and new slopes are calculated at the new R=R_old+dR, Z=Z_old+dZ and the process is iterated until R,Z cross the limiter boundary. The length of the last partial turn as the line crosses the boundary is NOT added to the total connection length for that line.","title":"Basic Information"},{"location":"function-guide/breakdown/do_breakdown_tok_m/","text":"do_breakdown_tok.m \u00b6 Basic Information \u00b6 USAGE: [IM,figure_num]= do_breakdown_tok(IM_inputs,ramp_inputs, ... model_inputs,figure_num,pcs_files,pause_it) PURPOSE: Calculates Best Initial Magnetization and Breakdown Trajectories INPUTS (defaults=[..]): structure IM_inputs (Initial Magnetization (& Breakdown Ramp) Input): flux0= target flux at center (Vs) [3] bz_targ= target vertical field scaler or (npt,1) (T) [-0.00015] ic_min if exists => minimum coil current (A) [] ic_max if exists => maximum coil current (A) [] npt= Number of points on boundary for IM optimization [101] r_plasma= Major radius of breakdown circle [1.8]; z_plasma= Z Location of center of breakdown circle [0]; a_plasma= Minor radius of breakdown circle [0.4]; k_plasma= Elongation of breakdown circle [1.8]; d_plasma= Triangularity of breakdown circle [.5]; structure ramp_inputs (Breakdown Ramp Input): times time (s) interval for ramp, [0.001*[-12:1:12]']; times(1)= start ramp from IM, (negative start time) [-0.012] time=0 => breakdown time, (vector should have 0 in it) time(end)= end of simulation [+0.010] iswtimes [zeros(size(times))] Emx Central Electric Field times(1)=> times=0 (V/m) [0.3] Emn Central Electric Field at end of simulation [0.2] volt_fac= Voltage fractional increase for Ip calculation from VV EMF (1) li= Plasma internal inductance [0.5] beta= Plasma Beta [0]; cejima= Ejima coeficient for calculation of resistive flux [0.5]; ip_factor= Ip multiplier => reduce current requirement (and Bz) [1]; decay_index= n=-Rp/Zpt*Br_pt/Bz => 0 < n_stable < 1.5; [0.8] Vlimits = voltage limits on power supplies [make limits proportional to Nturns: 1-turn_Volt*N_turn= Vterminal_voltage] slew_limit= Idot limit on coils [19.5e+3 = ~ 20kA/s] wbr [200*[0, 1/sqrt(2) 1 1/sqrt(2) 0 1/sqrt(2) 1 1/sqrt(2)]'] wbz [200*[1, 1/sqrt(2) 0 1/sqrt(2) 1 1/sqrt(2) 0 1/sqrt(2)]'] wbzdot = [1] wpsidot = [0.2] structure model_inputs: Vmat = (must be in PCS order) tok_data_struct cccirc= PF circuit grouping vccirc = [1:max(cccirc)] vvgroup= VV grouping [vvid vvfraction] => 2 column matrix [] nps = number of power supplies scale_R_scpf [1] PSsys = power supply models (not used?) Rckt = resistances to add/replace coil resistance (essentialy 0) with switched in circuit resistors. Order must correspond to internal states. General Control Input pcs_files= 0; 1= Ouput PCS files on completion, 0=no files [0] pause_it= 0; => no pause, 1= pause, # = pause(pause-it) [0]; OUTPUTS: (primary output is \"*.dat\" files for PCS input [pcs_files=1]) structure IM: icc_ohmic= Optimum Ohmic Terminal Current vector (A) ic_ohmic = Optimum Ohmic Terminal Current vector (A-Turns) ict_ohmic= Optimum Ohmic Amp-Turn Current vector (A) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: uses standard tokamak vacuum objects for all magnetics Produces Amp-Turns. Should work on any tokamak but needs gneralization of cccirc code. METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m","title":"do_breakdown_tok.m"},{"location":"function-guide/breakdown/do_breakdown_tok_m/#do_breakdown_tokm","text":"","title":"do_breakdown_tok.m"},{"location":"function-guide/breakdown/do_breakdown_tok_m/#basic-information","text":"USAGE: [IM,figure_num]= do_breakdown_tok(IM_inputs,ramp_inputs, ... model_inputs,figure_num,pcs_files,pause_it) PURPOSE: Calculates Best Initial Magnetization and Breakdown Trajectories INPUTS (defaults=[..]): structure IM_inputs (Initial Magnetization (& Breakdown Ramp) Input): flux0= target flux at center (Vs) [3] bz_targ= target vertical field scaler or (npt,1) (T) [-0.00015] ic_min if exists => minimum coil current (A) [] ic_max if exists => maximum coil current (A) [] npt= Number of points on boundary for IM optimization [101] r_plasma= Major radius of breakdown circle [1.8]; z_plasma= Z Location of center of breakdown circle [0]; a_plasma= Minor radius of breakdown circle [0.4]; k_plasma= Elongation of breakdown circle [1.8]; d_plasma= Triangularity of breakdown circle [.5]; structure ramp_inputs (Breakdown Ramp Input): times time (s) interval for ramp, [0.001*[-12:1:12]']; times(1)= start ramp from IM, (negative start time) [-0.012] time=0 => breakdown time, (vector should have 0 in it) time(end)= end of simulation [+0.010] iswtimes [zeros(size(times))] Emx Central Electric Field times(1)=> times=0 (V/m) [0.3] Emn Central Electric Field at end of simulation [0.2] volt_fac= Voltage fractional increase for Ip calculation from VV EMF (1) li= Plasma internal inductance [0.5] beta= Plasma Beta [0]; cejima= Ejima coeficient for calculation of resistive flux [0.5]; ip_factor= Ip multiplier => reduce current requirement (and Bz) [1]; decay_index= n=-Rp/Zpt*Br_pt/Bz => 0 < n_stable < 1.5; [0.8] Vlimits = voltage limits on power supplies [make limits proportional to Nturns: 1-turn_Volt*N_turn= Vterminal_voltage] slew_limit= Idot limit on coils [19.5e+3 = ~ 20kA/s] wbr [200*[0, 1/sqrt(2) 1 1/sqrt(2) 0 1/sqrt(2) 1 1/sqrt(2)]'] wbz [200*[1, 1/sqrt(2) 0 1/sqrt(2) 1 1/sqrt(2) 0 1/sqrt(2)]'] wbzdot = [1] wpsidot = [0.2] structure model_inputs: Vmat = (must be in PCS order) tok_data_struct cccirc= PF circuit grouping vccirc = [1:max(cccirc)] vvgroup= VV grouping [vvid vvfraction] => 2 column matrix [] nps = number of power supplies scale_R_scpf [1] PSsys = power supply models (not used?) Rckt = resistances to add/replace coil resistance (essentialy 0) with switched in circuit resistors. Order must correspond to internal states. General Control Input pcs_files= 0; 1= Ouput PCS files on completion, 0=no files [0] pause_it= 0; => no pause, 1= pause, # = pause(pause-it) [0]; OUTPUTS: (primary output is \"*.dat\" files for PCS input [pcs_files=1]) structure IM: icc_ohmic= Optimum Ohmic Terminal Current vector (A) ic_ohmic = Optimum Ohmic Terminal Current vector (A-Turns) ict_ohmic= Optimum Ohmic Amp-Turn Current vector (A) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: uses standard tokamak vacuum objects for all magnetics Produces Amp-Turns. Should work on any tokamak but needs gneralization of cccirc code. METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m","title":"Basic Information"},{"location":"function-guide/breakdown/ohmic_tok_m/","text":"ohmic_tok.m \u00b6 Basic Information \u00b6 USAGE: ohmic_dist_data = ohmic_tok(ohmic_calc_inputs) PURPOSE: Calculates the Best Ohmic current distribution for F coils INPUTS: [default] ohmic_calc_inputs = structure, containing one or more of following: flux0= target flux at center, scaler (Vs) [1] bz_targ= target vertical field scaler or (npt,1) (T) [0] ic_min if exists => minimum coil current (A) => ic_min= -14500 ic_max if exists => maximum coil current (A) => ic_max= +14500 length(ic_min) = 1 or max(cccirc) npt= Number of points on boundary for optimization [101] r_plasma= Major radius of breakdown circle [1.8]; z_plasma= Z Location of center of breakdown circle [0]; a_plasma= Minor radius of breakdown circle [0.4]; k_plasma= Elongation of breakdown circle [1]; d_plasma= Triangularity of breakdown circle [0]; minimize_i = 0.1; Includes currents in opts. to reduce +-I [0] minimize_i weights how much I smooting to perform Value of 0 to 0.1 are reasonable tok_data_struct if this exists then uses existing tok_data_struct if it doesnt exist then loads KSTAR vacuum objects cccirc= circuit connection matrix [from tok_data_struct] pause_it= 1; => pause between figures [0]; tokamak= tokamak name prepended to each plot title []; OUTPUTS: ohmic_dist_data = structure, containing: icc_ohmic= Optimum Ohmic Terminal Current on circuit (cccirc) [12,1] (A) ic_ohmic = Optimum Ohmic Terminal (All Coil) Current vector [16,1] (A) ict_ohmic= Optimum Ohmic Amp-Turn Current vector [16,1] (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: reads in MA-turns standard tokamak vacuum objects calculates NOTE: Should work on any tokamak with gneralization of cccirc stuff below METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m now very similar to CUROPT by including Bz and constraints on currents now calculates based on terminal currents rather than (amp-turns)","title":"ohmic_tok.m"},{"location":"function-guide/breakdown/ohmic_tok_m/#ohmic_tokm","text":"","title":"ohmic_tok.m"},{"location":"function-guide/breakdown/ohmic_tok_m/#basic-information","text":"USAGE: ohmic_dist_data = ohmic_tok(ohmic_calc_inputs) PURPOSE: Calculates the Best Ohmic current distribution for F coils INPUTS: [default] ohmic_calc_inputs = structure, containing one or more of following: flux0= target flux at center, scaler (Vs) [1] bz_targ= target vertical field scaler or (npt,1) (T) [0] ic_min if exists => minimum coil current (A) => ic_min= -14500 ic_max if exists => maximum coil current (A) => ic_max= +14500 length(ic_min) = 1 or max(cccirc) npt= Number of points on boundary for optimization [101] r_plasma= Major radius of breakdown circle [1.8]; z_plasma= Z Location of center of breakdown circle [0]; a_plasma= Minor radius of breakdown circle [0.4]; k_plasma= Elongation of breakdown circle [1]; d_plasma= Triangularity of breakdown circle [0]; minimize_i = 0.1; Includes currents in opts. to reduce +-I [0] minimize_i weights how much I smooting to perform Value of 0 to 0.1 are reasonable tok_data_struct if this exists then uses existing tok_data_struct if it doesnt exist then loads KSTAR vacuum objects cccirc= circuit connection matrix [from tok_data_struct] pause_it= 1; => pause between figures [0]; tokamak= tokamak name prepended to each plot title []; OUTPUTS: ohmic_dist_data = structure, containing: icc_ohmic= Optimum Ohmic Terminal Current on circuit (cccirc) [12,1] (A) ic_ohmic = Optimum Ohmic Terminal (All Coil) Current vector [16,1] (A) ict_ohmic= Optimum Ohmic Amp-Turn Current vector [16,1] (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: reads in MA-turns standard tokamak vacuum objects calculates NOTE: Should work on any tokamak with gneralization of cccirc stuff below METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m now very similar to CUROPT by including Bz and constraints on currents now calculates based on terminal currents rather than (amp-turns)","title":"Basic Information"},{"location":"function-guide/circuit_models/BJacobians_m/","text":"BJacobians.m \u00b6 Basic Information \u00b6 SYNTAX: J=BJacobians(ra,za,rb,zb) PURPOSE: Compute Jacobian d(Br,Bz)/d(rb,zb) , where Br and Bz are the radial field components evaluated at (rb,zb) due to current source of 1 Amp at (ra,za). !!! NOTE: THIS DOES NOT COMPUTE d(Br,Bz)/d(ra,za) !!! INPUT: ra,za = (r,z) coordinates of current source (vectors) rb,zb = (r,z) coordinates of point where (Br,Bz) are measured (scalar) (units = meters) OUTPUT: J = Jacobian = [dbr/drb dbr/dzb dbz/drb dbz/dzb], (units = Tesla/Amp/m)","title":"BJacobians.m"},{"location":"function-guide/circuit_models/BJacobians_m/#bjacobiansm","text":"","title":"BJacobians.m"},{"location":"function-guide/circuit_models/BJacobians_m/#basic-information","text":"SYNTAX: J=BJacobians(ra,za,rb,zb) PURPOSE: Compute Jacobian d(Br,Bz)/d(rb,zb) , where Br and Bz are the radial field components evaluated at (rb,zb) due to current source of 1 Amp at (ra,za). !!! NOTE: THIS DOES NOT COMPUTE d(Br,Bz)/d(ra,za) !!! INPUT: ra,za = (r,z) coordinates of current source (vectors) rb,zb = (r,z) coordinates of point where (Br,Bz) are measured (scalar) (units = meters) OUTPUT: J = Jacobian = [dbr/drb dbr/dzb dbz/drb dbz/dzb], (units = Tesla/Amp/m)","title":"Basic Information"},{"location":"function-guide/circuit_models/BJacobians_source_m/","text":"BJacobians_source.m \u00b6 Basic Information \u00b6 NOT TESTED SYNTAX: J=BJacobians_source(ra,za,rb,zb) PURPOSE: Compute Jacobian d(Br,Bz)/d(ra,za) , where Br and Bz are the radial field components evaluated at (rb,zb) due to current source at (ra,za). !!! NOTE: THIS DOES NOT COMPUTE d(Br,Bz)/d(rb,zb) !!! INPUT: ra,za = (r,z) coordinates of current source (vectors) rb,zb = (r,z) coordinates of point where (Br,Bz) are measured (scalar) (units = meters) OUTPUT: J = Jacobian = [dbrdr dbrdz dbzdr dbzdz], (units = Tesla/Amp/m)","title":"BJacobians_source.m"},{"location":"function-guide/circuit_models/BJacobians_source_m/#bjacobians_sourcem","text":"","title":"BJacobians_source.m"},{"location":"function-guide/circuit_models/BJacobians_source_m/#basic-information","text":"NOT TESTED SYNTAX: J=BJacobians_source(ra,za,rb,zb) PURPOSE: Compute Jacobian d(Br,Bz)/d(ra,za) , where Br and Bz are the radial field components evaluated at (rb,zb) due to current source at (ra,za). !!! NOTE: THIS DOES NOT COMPUTE d(Br,Bz)/d(rb,zb) !!! INPUT: ra,za = (r,z) coordinates of current source (vectors) rb,zb = (r,z) coordinates of point where (Br,Bz) are measured (scalar) (units = meters) OUTPUT: J = Jacobian = [dbrdr dbrdz dbzdr dbzdz], (units = Tesla/Amp/m)","title":"Basic Information"},{"location":"function-guide/circuit_models/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Conductor circuit modeling User functions: BJacobians BJacobians_source bld_filter - Build a 4-pole Bessel or Chebyshev filter model cccirc_to_netlist - convert cccirc coil circuit description to netlist description coil_mutuals - Calculate mut inductance between pairs of coils/elements. coilR - Calculate resistance of toroidal current carrying element compare_fresp compare_multimodel compare_new compare_sim dynamic_equil.m ecoil_turns.dat elt_to_corners - Convert \"element form\" ([Z;R;dZ;dR;AC;AC2]) to set of element corners get_plasma_greens inverse_filter - Inverse filter data filtered by one of PCS antialiasing filters. Jacsind load_netlist - load a netlist from a netlist file make_units_struct M_B_vs_ecoils M_B_vs_fcoils M_B_vs_vessel MJacobians model_from_netlist - generate ABCD model from netlist input msecalc - Calculate mutuals from SL (saddle loops) to E coils. msfcalc - Calculate mutuals from SL (saddle loops) to F coils. mutind_sl - Calculate mut inductance between a coil and saddle loop. plot_mpp read_SL val_full_model Helper functions: echelon - Define branches in tree and co-tree in netlist modeling makcturnzr - Discretization of coils/vessel for calc of Green fn or mut induct make_griddata - Construct the plasma filaments grid make_incidence partn_cond - partition conductors into \"turns\" mut induct and Green fns calcs test_mpp_x_vec update_constraint_eqns","title":"Contents.m"},{"location":"function-guide/circuit_models/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/circuit_models/Contents_m/#basic-information","text":"Conductor circuit modeling User functions: BJacobians BJacobians_source bld_filter - Build a 4-pole Bessel or Chebyshev filter model cccirc_to_netlist - convert cccirc coil circuit description to netlist description coil_mutuals - Calculate mut inductance between pairs of coils/elements. coilR - Calculate resistance of toroidal current carrying element compare_fresp compare_multimodel compare_new compare_sim dynamic_equil.m ecoil_turns.dat elt_to_corners - Convert \"element form\" ([Z;R;dZ;dR;AC;AC2]) to set of element corners get_plasma_greens inverse_filter - Inverse filter data filtered by one of PCS antialiasing filters. Jacsind load_netlist - load a netlist from a netlist file make_units_struct M_B_vs_ecoils M_B_vs_fcoils M_B_vs_vessel MJacobians model_from_netlist - generate ABCD model from netlist input msecalc - Calculate mutuals from SL (saddle loops) to E coils. msfcalc - Calculate mutuals from SL (saddle loops) to F coils. mutind_sl - Calculate mut inductance between a coil and saddle loop. plot_mpp read_SL val_full_model Helper functions: echelon - Define branches in tree and co-tree in netlist modeling makcturnzr - Discretization of coils/vessel for calc of Green fn or mut induct make_griddata - Construct the plasma filaments grid make_incidence partn_cond - partition conductors into \"turns\" mut induct and Green fns calcs test_mpp_x_vec update_constraint_eqns","title":"Basic Information"},{"location":"function-guide/circuit_models/Jacsind_m/","text":"Jacsind.m \u00b6 Basic Information \u00b6 SYNTAX: dmdr = Jacsind(r,delr,delz) PURPOSE: Calculate Jacobian dmdr for source and msmnt point in same location. Assumes rectangular coil. INPUT: r = major radial location (meters) delr = width of rectangular coil delz = height of rectangular coil OUTPUT: J = Jacobian (units = Tesla/Amp) matrix, kth row of which holds [dm/d(ra) dm/d(za) dm/d(rb) dm/d(zb)] for the kth element in vectors r. (uH/m) RESTRICTIONS: Not accurate for delz/r > 2. (Huh?) METHOD: Self inductance does not depend on z position, so derivatives with respect to z are simply set to 0. does dr depend on whether source or measurement? WRITTEN BY: Mike Walker ON 11/11/96 (derived from Jim Leuer's RECTL function)","title":"Jacsind.m"},{"location":"function-guide/circuit_models/Jacsind_m/#jacsindm","text":"","title":"Jacsind.m"},{"location":"function-guide/circuit_models/Jacsind_m/#basic-information","text":"SYNTAX: dmdr = Jacsind(r,delr,delz) PURPOSE: Calculate Jacobian dmdr for source and msmnt point in same location. Assumes rectangular coil. INPUT: r = major radial location (meters) delr = width of rectangular coil delz = height of rectangular coil OUTPUT: J = Jacobian (units = Tesla/Amp) matrix, kth row of which holds [dm/d(ra) dm/d(za) dm/d(rb) dm/d(zb)] for the kth element in vectors r. (uH/m) RESTRICTIONS: Not accurate for delz/r > 2. (Huh?) METHOD: Self inductance does not depend on z position, so derivatives with respect to z are simply set to 0. does dr depend on whether source or measurement? WRITTEN BY: Mike Walker ON 11/11/96 (derived from Jim Leuer's RECTL function)","title":"Basic Information"},{"location":"function-guide/circuit_models/MJacobians_m/","text":"MJacobians.m \u00b6 Basic Information \u00b6 SYNTAX: J=MJacobians(ra,za,rb,zb) PURPOSE: Compute Jacobians dm(ra,za;rb,zb)/d(ra,za) and dm(ra,za;rb,zb)/d(rb,zb), where m(ra,za;rb,zb) is the mutual from (ra,za) to (rb,zb). INPUT: ra,za =(r,z) coordinates of current source (meters) rb,zb =(r,z) coordinates of point where psi is measured (meters) delr = delz = Legal input combinations are: - ra,za scalar, rb,zb column vectors of same length - rb,zb scalar, ra,za column vectors of same length - ra,za,rb,zb all column vectors of same length OUTPUT: J = Jacobian (units = Tesla/Amp) matrix, kth row of which holds [dm/d(ra) dm/d(za) dm/d(rb) dm/d(zb)] for the kth elements in vectors ra,za and/or rb,zb. RESTRICTIONS: Note that this function does not handle carefully the case where source and measurement location are very close. It DOES handle the case where source and measurement location are identical. METHOD: WRITTEN BY: Mike Walker ON 11/8/96","title":"MJacobians.m"},{"location":"function-guide/circuit_models/MJacobians_m/#mjacobiansm","text":"","title":"MJacobians.m"},{"location":"function-guide/circuit_models/MJacobians_m/#basic-information","text":"SYNTAX: J=MJacobians(ra,za,rb,zb) PURPOSE: Compute Jacobians dm(ra,za;rb,zb)/d(ra,za) and dm(ra,za;rb,zb)/d(rb,zb), where m(ra,za;rb,zb) is the mutual from (ra,za) to (rb,zb). INPUT: ra,za =(r,z) coordinates of current source (meters) rb,zb =(r,z) coordinates of point where psi is measured (meters) delr = delz = Legal input combinations are: - ra,za scalar, rb,zb column vectors of same length - rb,zb scalar, ra,za column vectors of same length - ra,za,rb,zb all column vectors of same length OUTPUT: J = Jacobian (units = Tesla/Amp) matrix, kth row of which holds [dm/d(ra) dm/d(za) dm/d(rb) dm/d(zb)] for the kth elements in vectors ra,za and/or rb,zb. RESTRICTIONS: Note that this function does not handle carefully the case where source and measurement location are very close. It DOES handle the case where source and measurement location are identical. METHOD: WRITTEN BY: Mike Walker ON 11/8/96","title":"Basic Information"},{"location":"function-guide/circuit_models/bld_filter_m/","text":"bld_filter.m \u00b6 Basic Information \u00b6 SYNTAX: [num,den]=bld_filter(type,corner) PURPOSE: Build a 4-pole Bessel or Chebyshev filter. (From FAX from Frequency Devices 1/21/94.) INPUTS: type = one of: 'Bessel' = bessel filter 'Chebyshev2' = .2dB Chebychev filter 'Chebyshev5' = .5dB Chebychev filter corner = corner frequency for filter (Hz) OUTPUTS: num, den = numerator and denominator polys in transfer function describing filter","title":"bld_filter.m"},{"location":"function-guide/circuit_models/bld_filter_m/#bld_filterm","text":"","title":"bld_filter.m"},{"location":"function-guide/circuit_models/bld_filter_m/#basic-information","text":"SYNTAX: [num,den]=bld_filter(type,corner) PURPOSE: Build a 4-pole Bessel or Chebyshev filter. (From FAX from Frequency Devices 1/21/94.) INPUTS: type = one of: 'Bessel' = bessel filter 'Chebyshev2' = .2dB Chebychev filter 'Chebyshev5' = .5dB Chebychev filter corner = corner frequency for filter (Hz) OUTPUTS: num, den = numerator and denominator polys in transfer function describing filter","title":"Basic Information"},{"location":"function-guide/circuit_models/cccirc_to_netlist_m/","text":"cccirc_to_netlist.m \u00b6 Basic Information \u00b6 SYNTAX: [netlist,inode1,inode2] = ... cccirc_to_netlist(cccirc,tok_data_struct,netlist_file) PURPOSE: Convert circuit connection defined by cccirc, vvgroup, and vvcirc into netlist. INPUT: cccirc = either cccirc vector or structure containing any combination of cccirc, vvgroup, and vvcirc tok_data_struct = vacuum data objects structure netlist_file = name of netlist file to create (optional, not created if no name specified) OUTPUT: netlist = similar to netlist input to Spice code, except that the \"value\" of M entries is the row corresponding to M and R matrices for that coil. Fictitious connections to ground are added to simplify the nodal analysis that occurs in building the system model. RESTRICTIONS: Code has been added to handle non-default vvgroup,vvcirc and the more complex code has been verified to work for default vvgroup, vvcirc but not extensively tested for non-default settings yet.","title":"cccirc_to_netlist.m"},{"location":"function-guide/circuit_models/cccirc_to_netlist_m/#cccirc_to_netlistm","text":"","title":"cccirc_to_netlist.m"},{"location":"function-guide/circuit_models/cccirc_to_netlist_m/#basic-information","text":"SYNTAX: [netlist,inode1,inode2] = ... cccirc_to_netlist(cccirc,tok_data_struct,netlist_file) PURPOSE: Convert circuit connection defined by cccirc, vvgroup, and vvcirc into netlist. INPUT: cccirc = either cccirc vector or structure containing any combination of cccirc, vvgroup, and vvcirc tok_data_struct = vacuum data objects structure netlist_file = name of netlist file to create (optional, not created if no name specified) OUTPUT: netlist = similar to netlist input to Spice code, except that the \"value\" of M entries is the row corresponding to M and R matrices for that coil. Fictitious connections to ground are added to simplify the nodal analysis that occurs in building the system model. RESTRICTIONS: Code has been added to handle non-default vvgroup,vvcirc and the more complex code has been verified to work for default vvgroup, vvcirc but not extensively tested for non-default settings yet.","title":"Basic Information"},{"location":"function-guide/circuit_models/dynamic_equil_m/","text":"dynamic_equil.m \u00b6 Basic Information \u00b6 SYNTAX: moving_equil = dynamic_equil(inputs) PURPOSE: Calculate \"moving equilibrium\" so that delta coordinates can be defined. Get objects to fit model where we take d/dt i_PF as input disturbance or forcing function. INPUT: (in structure \"inputs\") shotnum = shot number ip0 = approximate plasma current (Amps) vmat = mapping of input voltages to rows in state equation, after reduction vdata = approximate equil. power supply voltages (V) corresponding to cols in vmat good_vdata = vector of flags indicating which vdata values are \"good\" (0 or 1) tok_system = system model data structure for device being modeled Rp = plasma resistance ohstates_idx = indices of PF current states that participate in Ip control Optional (first 3 must be included or omitted together): LHSconstraint = defines extra LHS * (current states) = RHS constraints RHSconstraint = defines extra LHS * (current states) = RHS constraints constraint_str = string description of these constraints weight_coils = scalar or length ncx vector wtg factor for fitting coil currents (default=100) weight_volts = scalar or vector wtg factor (length(vdata)) for fitting power supply voltages (default=10) OUTPUT: (in structure moving_equil) equil_pt = nominal equilibrium to be used for linearization: RESTRICTIONS: If a particular voltage measurement is of poor or unknown quality, set the good_vdata flag = 0 and define a low fitting weight. METHOD: Performs a weighted least squares fit of free variables (see text variable \"var\" in output structure moving_equil) to shot data and constraint equations containing those variables defined by model circuit equations and physical constraints. \"Bad\" voltages are replaced by 0 during the fitting, but plots show comparison of input and fitted values.","title":"dynamic_equil.m"},{"location":"function-guide/circuit_models/dynamic_equil_m/#dynamic_equilm","text":"","title":"dynamic_equil.m"},{"location":"function-guide/circuit_models/dynamic_equil_m/#basic-information","text":"SYNTAX: moving_equil = dynamic_equil(inputs) PURPOSE: Calculate \"moving equilibrium\" so that delta coordinates can be defined. Get objects to fit model where we take d/dt i_PF as input disturbance or forcing function. INPUT: (in structure \"inputs\") shotnum = shot number ip0 = approximate plasma current (Amps) vmat = mapping of input voltages to rows in state equation, after reduction vdata = approximate equil. power supply voltages (V) corresponding to cols in vmat good_vdata = vector of flags indicating which vdata values are \"good\" (0 or 1) tok_system = system model data structure for device being modeled Rp = plasma resistance ohstates_idx = indices of PF current states that participate in Ip control Optional (first 3 must be included or omitted together): LHSconstraint = defines extra LHS * (current states) = RHS constraints RHSconstraint = defines extra LHS * (current states) = RHS constraints constraint_str = string description of these constraints weight_coils = scalar or length ncx vector wtg factor for fitting coil currents (default=100) weight_volts = scalar or vector wtg factor (length(vdata)) for fitting power supply voltages (default=10) OUTPUT: (in structure moving_equil) equil_pt = nominal equilibrium to be used for linearization: RESTRICTIONS: If a particular voltage measurement is of poor or unknown quality, set the good_vdata flag = 0 and define a low fitting weight. METHOD: Performs a weighted least squares fit of free variables (see text variable \"var\" in output structure moving_equil) to shot data and constraint equations containing those variables defined by model circuit equations and physical constraints. \"Bad\" voltages are replaced by 0 during the fitting, but plots show comparison of input and fitted values.","title":"Basic Information"},{"location":"function-guide/circuit_models/echelon_m/","text":"echelon.m \u00b6 Basic Information \u00b6 SYNTAX: [Amod,nodelist,branchlist] = echelon(A,nodelist,branchlist) PURPOSE: Echelon algorithm. Calculation to define branches in tree and co-tree and the matrix mapping currents in co-tree branches to currents in branches of tree. INPUT: A = node incidence matrix nodelist = node numbers corresponding to each row of A branchlist = branch indices into the netlist corresponding to columns of A OUTPUT: Amod = modified incidence matrix, of the form [I Dc] nodelist = node numbers corresponding to each row of Amod branchlist = netlist branch indices corresponding to columns of Amod RESTRICTIONS: METHOD: Reduction to row-echelong form based on Gaussian elimination.","title":"echelon.m"},{"location":"function-guide/circuit_models/echelon_m/#echelonm","text":"","title":"echelon.m"},{"location":"function-guide/circuit_models/echelon_m/#basic-information","text":"SYNTAX: [Amod,nodelist,branchlist] = echelon(A,nodelist,branchlist) PURPOSE: Echelon algorithm. Calculation to define branches in tree and co-tree and the matrix mapping currents in co-tree branches to currents in branches of tree. INPUT: A = node incidence matrix nodelist = node numbers corresponding to each row of A branchlist = branch indices into the netlist corresponding to columns of A OUTPUT: Amod = modified incidence matrix, of the form [I Dc] nodelist = node numbers corresponding to each row of Amod branchlist = netlist branch indices corresponding to columns of Amod RESTRICTIONS: METHOD: Reduction to row-echelong form based on Gaussian elimination.","title":"Basic Information"},{"location":"function-guide/circuit_models/elt_to_corners_m/","text":"elt_to_corners.m \u00b6 Basic Information \u00b6 SYNTAX: corners = elt_to_corners(element) PURPOSE: Convert standard \"element form\" ([Z;R;dZ;dR;AC;AC2]) to set of corners of the element. (For a description of this standard form, see Toksys users guide.) INPUT: element = [Z;R;dZ;dR;AC;AC2] OUTPUT: corners = [x y], where x = [x1 x2 x3 x4]^T, y = [y1 y2 y3 y4]^T are coordinates of the four corners of the parallelogram.","title":"elt_to_corners.m"},{"location":"function-guide/circuit_models/elt_to_corners_m/#elt_to_cornersm","text":"","title":"elt_to_corners.m"},{"location":"function-guide/circuit_models/elt_to_corners_m/#basic-information","text":"SYNTAX: corners = elt_to_corners(element) PURPOSE: Convert standard \"element form\" ([Z;R;dZ;dR;AC;AC2]) to set of corners of the element. (For a description of this standard form, see Toksys users guide.) INPUT: element = [Z;R;dZ;dR;AC;AC2] OUTPUT: corners = [x y], where x = [x1 x2 x3 x4]^T, y = [y1 y2 y3 y4]^T are coordinates of the four corners of the parallelogram.","title":"Basic Information"},{"location":"function-guide/circuit_models/load_netlist_m/","text":"load_netlist.m \u00b6 Basic Information \u00b6 SYNTAX: [netlist,numNode,numV] = load_netlist(fname) PURPOSE: Takes a netlist (similar to SPICE), parses it to derive the circuit equations, then solves them symbolically. INPUT: fname = name of netlist file to load OUTPUT: netlist = netlist information in a data structure numNode = total number of nodes in model numV = number of voltage sources","title":"load_netlist.m"},{"location":"function-guide/circuit_models/load_netlist_m/#load_netlistm","text":"","title":"load_netlist.m"},{"location":"function-guide/circuit_models/load_netlist_m/#basic-information","text":"SYNTAX: [netlist,numNode,numV] = load_netlist(fname) PURPOSE: Takes a netlist (similar to SPICE), parses it to derive the circuit equations, then solves them symbolically. INPUT: fname = name of netlist file to load OUTPUT: netlist = netlist information in a data structure numNode = total number of nodes in model numV = number of voltage sources","title":"Basic Information"},{"location":"function-guide/circuit_models/make_incidence_m/","text":"make_incidence.m \u00b6 Basic Information \u00b6 SYNTAX: [A,nodelist,sorted_netlist,Midx] = make_incidence(netlist) PURPOSE: Construct incidence matrix. Sort so that branches representing voltage sources come first, then capacitors, then resistors. INPUT: OUTPUT: A = incidence matrix nodelist = set of all nodes specified in the netlist sorted_netlist = netlist with elements sorted according to the order in [1] Midx = indices of inductive ('M') conductors in sorted_netlist (in same order as original netlist) RESTRICTIONS: METHOD: Described in [1] M.L. Walker, \"A General Purpose Circuit Modeling Code for Tokamak Plasma Magnetic Control, General Atomics Engineering Physics Memo EPMmlw070120a, Jan. 20, 2007","title":"make_incidence.m"},{"location":"function-guide/circuit_models/make_incidence_m/#make_incidencem","text":"","title":"make_incidence.m"},{"location":"function-guide/circuit_models/make_incidence_m/#basic-information","text":"SYNTAX: [A,nodelist,sorted_netlist,Midx] = make_incidence(netlist) PURPOSE: Construct incidence matrix. Sort so that branches representing voltage sources come first, then capacitors, then resistors. INPUT: OUTPUT: A = incidence matrix nodelist = set of all nodes specified in the netlist sorted_netlist = netlist with elements sorted according to the order in [1] Midx = indices of inductive ('M') conductors in sorted_netlist (in same order as original netlist) RESTRICTIONS: METHOD: Described in [1] M.L. Walker, \"A General Purpose Circuit Modeling Code for Tokamak Plasma Magnetic Control, General Atomics Engineering Physics Memo EPMmlw070120a, Jan. 20, 2007","title":"Basic Information"},{"location":"function-guide/circuit_models/make_units_struct_m/","text":"make_units_struct.m \u00b6 Basic Information \u00b6 SYNTAX: units = make_units_struct(imks,iterminal) PURPOSE: Make units data structure for standard format tokamak data struct. INPUT: imks = if 1, input objects in datafiles are mks, else 0 (default=mA,uH) iterminal = if 1, input objects are terminal units, else 0 (default) OUTPUT: units = units of data objects","title":"make_units_struct.m"},{"location":"function-guide/circuit_models/make_units_struct_m/#make_units_structm","text":"","title":"make_units_struct.m"},{"location":"function-guide/circuit_models/make_units_struct_m/#basic-information","text":"SYNTAX: units = make_units_struct(imks,iterminal) PURPOSE: Make units data structure for standard format tokamak data struct. INPUT: imks = if 1, input objects in datafiles are mks, else 0 (default=mA,uH) iterminal = if 1, input objects are terminal units, else 0 (default) OUTPUT: units = units of data objects","title":"Basic Information"},{"location":"function-guide/circuit_models/model_from_cccirc_m/","text":"model_from_cccirc.m \u00b6 Basic Information \u00b6 SYNTAX: model = model_from_cccirc(vacuum_objs,cccirc,vvcirc,vvgroup,Mmat,Rvec,iplcirc,verbose) PURPOSE: Create circuit model using cccirc input. INPUT: vacuum_objs = vacuum model objects (often called tok_data_struct) cccirc = coil conductor currents circuit description vvcirc = vacuum vessel conductors circuit description vvgroup = vacuum vessel element groupings Mmat = mutual inductances (matrix) for all conductors Rvec = resistances (vector) for all conductors iplcirc = if 1, include plasma circuit (in which case Mmat, Rvec must contain plasma elements), else 0 verbose = (optional) OUTPUT: data struct model containing: Pxx = Pcc = Mhat = Vhat = Rhat = RESTRICTIONS: Modeling with cccirc no longer supports use of Lckt_extra or Rckt_extra.","title":"model_from_cccirc.m"},{"location":"function-guide/circuit_models/model_from_cccirc_m/#model_from_cccircm","text":"","title":"model_from_cccirc.m"},{"location":"function-guide/circuit_models/model_from_cccirc_m/#basic-information","text":"SYNTAX: model = model_from_cccirc(vacuum_objs,cccirc,vvcirc,vvgroup,Mmat,Rvec,iplcirc,verbose) PURPOSE: Create circuit model using cccirc input. INPUT: vacuum_objs = vacuum model objects (often called tok_data_struct) cccirc = coil conductor currents circuit description vvcirc = vacuum vessel conductors circuit description vvgroup = vacuum vessel element groupings Mmat = mutual inductances (matrix) for all conductors Rvec = resistances (vector) for all conductors iplcirc = if 1, include plasma circuit (in which case Mmat, Rvec must contain plasma elements), else 0 verbose = (optional) OUTPUT: data struct model containing: Pxx = Pcc = Mhat = Vhat = Rhat = RESTRICTIONS: Modeling with cccirc no longer supports use of Lckt_extra or Rckt_extra.","title":"Basic Information"},{"location":"function-guide/circuit_models/model_from_netlist_m/","text":"model_from_netlist.m \u00b6 Basic Information \u00b6 SYNTAX: model = model_from_netlist(netlist,Mmat,Rvec,Iout,Vout,verbose) PURPOSE: Produces model that is generalization of that produced by the simpler tokamak/plasma modeling schemes, of the form: Mhat*dx/dt + Rhat*x = Vhat*u + What*du/dt y = Chat*x + Dhat*u + DWhat*du/dt where the generalized state and input vectors are: x = [i_inductors; v_capacitors], u = [Vsource; Isource] y = [current_outputs; voltage_outputs] INPUT: netlist = netlist specification of circuit connections Mmat = mutual inductance matrix for all \"M\" type elements in netlist Rvec = resistance vector for all \"M\" type elements in netlist (Values of netlist for \"M\" objects are indices into these objects.) Iout = array of strings defining branches for which to output currents (optional, default = no current outputs) Vout = n x 2 matrix, each row containing node numbers [N1 N2], with voltage output defined as V(N1)-V(N2) (optional, default = no voltage outputs) verbose = set to >0 to print model-building diagnostics to terminal (optional, default = 0) OUTPUT: (in structure \"model\") model = structure containing model objects; see descriptions field for description of contents of each field RESTRICTIONS: (1) Does not yet handle circuits containing capacitors or current sources. (2) Right now it can't handle outputs Vout if circuit is not specified as a connected graph (i.e. no floating potentials). METHOD: Described in: M.L.Walker, A General Purpose Circuit Modeling Code for Tokamak Plasma Magnetic Control, Engineering Physics Memo EPM070120a, January 20, 2007","title":"model_from_netlist.m"},{"location":"function-guide/circuit_models/model_from_netlist_m/#model_from_netlistm","text":"","title":"model_from_netlist.m"},{"location":"function-guide/circuit_models/model_from_netlist_m/#basic-information","text":"SYNTAX: model = model_from_netlist(netlist,Mmat,Rvec,Iout,Vout,verbose) PURPOSE: Produces model that is generalization of that produced by the simpler tokamak/plasma modeling schemes, of the form: Mhat*dx/dt + Rhat*x = Vhat*u + What*du/dt y = Chat*x + Dhat*u + DWhat*du/dt where the generalized state and input vectors are: x = [i_inductors; v_capacitors], u = [Vsource; Isource] y = [current_outputs; voltage_outputs] INPUT: netlist = netlist specification of circuit connections Mmat = mutual inductance matrix for all \"M\" type elements in netlist Rvec = resistance vector for all \"M\" type elements in netlist (Values of netlist for \"M\" objects are indices into these objects.) Iout = array of strings defining branches for which to output currents (optional, default = no current outputs) Vout = n x 2 matrix, each row containing node numbers [N1 N2], with voltage output defined as V(N1)-V(N2) (optional, default = no voltage outputs) verbose = set to >0 to print model-building diagnostics to terminal (optional, default = 0) OUTPUT: (in structure \"model\") model = structure containing model objects; see descriptions field for description of contents of each field RESTRICTIONS: (1) Does not yet handle circuits containing capacitors or current sources. (2) Right now it can't handle outputs Vout if circuit is not specified as a connected graph (i.e. no floating potentials). METHOD: Described in: M.L.Walker, A General Purpose Circuit Modeling Code for Tokamak Plasma Magnetic Control, Engineering Physics Memo EPM070120a, January 20, 2007","title":"Basic Information"},{"location":"function-guide/circuit_models/update_constraint_eqns_m/","text":"update_constraint_eqns.m \u00b6 Basic Information \u00b6 SYNTAX: update_constraint_eqns PURPOSE: Update the constraint equations in dynamic_equil.m. INPUT: LHS, RHS = matrices defining previous constraint equation (LHS*x=RHS) nvar = number of variables in optimization (size of x) addLHS, addRHS = additional rows to add to constraint equation (# columns in addLHS must be < = # columns in LHS) OUTPUT: LHS, RHS = matrices for updated constraint equations","title":"update_constraint_eqns.m"},{"location":"function-guide/circuit_models/update_constraint_eqns_m/#update_constraint_eqnsm","text":"","title":"update_constraint_eqns.m"},{"location":"function-guide/circuit_models/update_constraint_eqns_m/#basic-information","text":"SYNTAX: update_constraint_eqns PURPOSE: Update the constraint equations in dynamic_equil.m. INPUT: LHS, RHS = matrices defining previous constraint equation (LHS*x=RHS) nvar = number of variables in optimization (size of x) addLHS, addRHS = additional rows to add to constraint equation (# columns in addLHS must be < = # columns in LHS) OUTPUT: LHS, RHS = matrices for updated constraint equations","title":"Basic Information"},{"location":"function-guide/circuit_models/write_netlist_file_m/","text":"write_netlist_file.m \u00b6 Basic Information \u00b6 SYNTAX: write_netlist_file(netlist,netlist_file) PURPOSE: Write out a formatted ascii netlist file from a netlist data structure in matlab. INPUT: netlist = netlist data structure variable netlist_file = name of netlist file to write OUTPUT: ascii file containing netlist","title":"write_netlist_file.m"},{"location":"function-guide/circuit_models/write_netlist_file_m/#write_netlist_filem","text":"","title":"write_netlist_file.m"},{"location":"function-guide/circuit_models/write_netlist_file_m/#basic-information","text":"SYNTAX: write_netlist_file(netlist,netlist_file) PURPOSE: Write out a formatted ascii netlist file from a netlist data structure in matlab. INPUT: netlist = netlist data structure variable netlist_file = name of netlist file to write OUTPUT: ascii file containing netlist","title":"Basic Information"},{"location":"function-guide/comm_tbx/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Communications Toolbox. Version 2.0 17-Aug-93 Copyright (c) 1991-93 by Ryerson Polytechnic University RANDOM NUMBER GENERATION binary ............ random binary digits corr_seq .......... first order auto-regressive process exponent .......... exponential random variate gauss ............. Gaussian random variate laplace ........... Laplace random variate uniform ........... uniform random variate realize ........... sinusoidal random process with random phase speech ............ random voiced speech signal PROBABILISTIC ANALYSIS cdf ............... sample cdf of a random sequence. exp_cdf ........... cdf of an exponential random variable exp_pdf ........... pdf of an exponential random variable gamma_pdf ......... pdf of a gamma random variable gaus_cdf .......... cdf of a Gaussian random variable gaus_pdf .......... pdf of a Gaussian random variable lapl_cdf .......... cdf of a Laplacian random variable lapl_pdf .......... pdf of a Laplacian random variable meansq ............ mean-square power pdf ............... sample pdf of a random sequence q_function ........ Q function rayl_cdf .......... cdf of a Rayleigh random variable rayl_pdf .......... pdf of a Rayleigh random variable unif_cdf .......... cdf of a uniform random variable unif_pdf .......... pdf of a uniform random variable var ............... variance PROBABILITY & RANDOM PROCESS GAMES dice .............. random experiment with a die dart .............. visual depiction of a dart game guess ............. guess personal information data integral .......... integration of a function by Monte-Carlo simulation new_born .......... sample function representing new born babies person_data ....... generation of personal records temperature ....... sample function representing day time temperature GENERAL PURPOSE ANALYSIS TOOLS acf ............... autocorrelation function acf_plot .......... autocorrelation function display ecorr ............. ensemble autocorrelation function psd ............... power spectral density function psd_plot .......... power spectral density function display QUANTIZATION a2d ............... analog-to-digital conversion d2a ............... digital-to-analog conversion mu_inv ............ mu-law expansion mu_law ............ mu-law companding quant_ch .......... quantizer characteristics quant_ef .......... quantizer efficiency quantize .......... uniform quantization BINARY DATA PROCESSING bcd ............... binary-coded-decimal coding bin_enc ........... natural binary source coding bin_dec ........... natural binary source decoding bin2gray .......... natural binary to gray-code conversion gray2bin .......... gray-code to natural binary conversion bin2pol ........... binary to polar transformation bin2bipo .......... binary to bipolar transformation diff_dec .......... differential decoding diff_enc .......... differential encoding invert ............ 1's complement of a binary sequence par2ser ........... parallel-to-serial conversion pol2bin ........... polar to binary transformation ser2par ........... serial-to-parallel conversion xor ............... exclusive OR BINARY SIGNALLING FORMATS manchest .......... Manchester pulse rect_nrz .......... rectangular NRZ pulse rect_rz ........... rectangular RZ pulse triangle .......... triangular pulse nyquist ........... Nyquist pulse nyq_gen ........... generate Nyquist waveform duob_gen .......... generate duobinary waveform duobinar .......... modified duobinary pulse modulate .......... digital modulated wave (ASK,BPSK,FSK) osc ............... sinusoidal oscillator vco ............... voltage controlled oscillator wave_gen .......... binary signal waveform generation waveplot .......... display binary signal waveform DATA TRANSMISSION bpf ............... band-pass filter channel ........... data communication channel eye_diag .......... eye diagram generation and display lpf ............... low-pass filter rc ................ 1-st order RC-filter detect ............ binary data detection envelope .......... envelope detector int_dump .......... integrate-and-dump filter mixer ............. two input mixer match ............. matched filter rx ................ receiver function tx ................ transmitter function UTILITY FUNCTIONS blackbox .......... filter with unknown order and bandwidth check ............. check initialization of global variables exp5_c6 ........... compute signal power and SQNR fftsize ........... determine FFT size fx_menu ........... sample functions to be integrated limiter ........... limit input sequence to a user specified range mc_int ............ basic integration function used by integral normalize ......... scale input sequence play .............. play-back a MATLAB array (MEX-file) playback .......... play-back a pre-processed sound file record ............ record and convert into a MATLAB array (MEX-file) rectify ........... rectify input sequence sinc .............. sin({pi}x)/({pi}x) spec_est .......... spectral estimation start ............. initialize global variables stat_plot ......... scatter diagram display","title":"Contents.m"},{"location":"function-guide/comm_tbx/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/comm_tbx/Contents_m/#basic-information","text":"Communications Toolbox. Version 2.0 17-Aug-93 Copyright (c) 1991-93 by Ryerson Polytechnic University RANDOM NUMBER GENERATION binary ............ random binary digits corr_seq .......... first order auto-regressive process exponent .......... exponential random variate gauss ............. Gaussian random variate laplace ........... Laplace random variate uniform ........... uniform random variate realize ........... sinusoidal random process with random phase speech ............ random voiced speech signal PROBABILISTIC ANALYSIS cdf ............... sample cdf of a random sequence. exp_cdf ........... cdf of an exponential random variable exp_pdf ........... pdf of an exponential random variable gamma_pdf ......... pdf of a gamma random variable gaus_cdf .......... cdf of a Gaussian random variable gaus_pdf .......... pdf of a Gaussian random variable lapl_cdf .......... cdf of a Laplacian random variable lapl_pdf .......... pdf of a Laplacian random variable meansq ............ mean-square power pdf ............... sample pdf of a random sequence q_function ........ Q function rayl_cdf .......... cdf of a Rayleigh random variable rayl_pdf .......... pdf of a Rayleigh random variable unif_cdf .......... cdf of a uniform random variable unif_pdf .......... pdf of a uniform random variable var ............... variance PROBABILITY & RANDOM PROCESS GAMES dice .............. random experiment with a die dart .............. visual depiction of a dart game guess ............. guess personal information data integral .......... integration of a function by Monte-Carlo simulation new_born .......... sample function representing new born babies person_data ....... generation of personal records temperature ....... sample function representing day time temperature GENERAL PURPOSE ANALYSIS TOOLS acf ............... autocorrelation function acf_plot .......... autocorrelation function display ecorr ............. ensemble autocorrelation function psd ............... power spectral density function psd_plot .......... power spectral density function display QUANTIZATION a2d ............... analog-to-digital conversion d2a ............... digital-to-analog conversion mu_inv ............ mu-law expansion mu_law ............ mu-law companding quant_ch .......... quantizer characteristics quant_ef .......... quantizer efficiency quantize .......... uniform quantization BINARY DATA PROCESSING bcd ............... binary-coded-decimal coding bin_enc ........... natural binary source coding bin_dec ........... natural binary source decoding bin2gray .......... natural binary to gray-code conversion gray2bin .......... gray-code to natural binary conversion bin2pol ........... binary to polar transformation bin2bipo .......... binary to bipolar transformation diff_dec .......... differential decoding diff_enc .......... differential encoding invert ............ 1's complement of a binary sequence par2ser ........... parallel-to-serial conversion pol2bin ........... polar to binary transformation ser2par ........... serial-to-parallel conversion xor ............... exclusive OR BINARY SIGNALLING FORMATS manchest .......... Manchester pulse rect_nrz .......... rectangular NRZ pulse rect_rz ........... rectangular RZ pulse triangle .......... triangular pulse nyquist ........... Nyquist pulse nyq_gen ........... generate Nyquist waveform duob_gen .......... generate duobinary waveform duobinar .......... modified duobinary pulse modulate .......... digital modulated wave (ASK,BPSK,FSK) osc ............... sinusoidal oscillator vco ............... voltage controlled oscillator wave_gen .......... binary signal waveform generation waveplot .......... display binary signal waveform DATA TRANSMISSION bpf ............... band-pass filter channel ........... data communication channel eye_diag .......... eye diagram generation and display lpf ............... low-pass filter rc ................ 1-st order RC-filter detect ............ binary data detection envelope .......... envelope detector int_dump .......... integrate-and-dump filter mixer ............. two input mixer match ............. matched filter rx ................ receiver function tx ................ transmitter function UTILITY FUNCTIONS blackbox .......... filter with unknown order and bandwidth check ............. check initialization of global variables exp5_c6 ........... compute signal power and SQNR fftsize ........... determine FFT size fx_menu ........... sample functions to be integrated limiter ........... limit input sequence to a user specified range mc_int ............ basic integration function used by integral normalize ......... scale input sequence play .............. play-back a MATLAB array (MEX-file) playback .......... play-back a pre-processed sound file record ............ record and convert into a MATLAB array (MEX-file) rectify ........... rectify input sequence sinc .............. sin({pi}x)/({pi}x) spec_est .......... spectral estimation start ............. initialize global variables stat_plot ......... scatter diagram display","title":"Basic Information"},{"location":"function-guide/dcontrol/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 \"Digital Control of Dynamic Systems Toolbox\" (from textbook of same name by Franklin, Powell, and Workman) backwd Discrete equivalent via backward rectangular rule bilinr Bilinear tranformation c2dd Continuous to discrete tranformation with delay on control c2dzp Zero-Pole form of c2d chirp Chirp from discrete radian frequency dclqr Discrete feedback LQR gain from continuous cost dioph disrw Discrete equivalent of continuous noise dzfr Discrete z-plane frequency response forwd Discrete equivalent via forward rectangular rule jdequiv Discrete equivalent of continuous cost jury Jury's polynomial stability test output Intersample output and control qrms qss quant Round to q decimal places qwc refi Compute reference command input matrices rststep trieq Triangle hold discrete equivalent z2w W-transform of a discrete system zgrid zlocus Z-plane root-locus zoheq C2D, except C and D are returned too. zohplot ZOH plot zpeq Discrete equivalent via pole-zero mapping","title":"Contents.m"},{"location":"function-guide/dcontrol/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/dcontrol/Contents_m/#basic-information","text":"\"Digital Control of Dynamic Systems Toolbox\" (from textbook of same name by Franklin, Powell, and Workman) backwd Discrete equivalent via backward rectangular rule bilinr Bilinear tranformation c2dd Continuous to discrete tranformation with delay on control c2dzp Zero-Pole form of c2d chirp Chirp from discrete radian frequency dclqr Discrete feedback LQR gain from continuous cost dioph disrw Discrete equivalent of continuous noise dzfr Discrete z-plane frequency response forwd Discrete equivalent via forward rectangular rule jdequiv Discrete equivalent of continuous cost jury Jury's polynomial stability test output Intersample output and control qrms qss quant Round to q decimal places qwc refi Compute reference command input matrices rststep trieq Triangle hold discrete equivalent z2w W-transform of a discrete system zgrid zlocus Z-plane root-locus zoheq C2D, except C and D are returned too. zohplot ZOH plot zpeq Discrete equivalent via pole-zero mapping","title":"Basic Information"},{"location":"function-guide/design/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Control design tools (These tools are under development, so not all are reliable.) build_design_model - build state-space model with PS, tokamak/plasma, diagnostics build_filter_system - create filter/delay LTI ss system build_gap_response - build gap response model build_isoflux_response - build model of isoflux response to coil currents build_linest_response - Connect design system components into a single system calc_isoflux_plasma_response - calculate control point response to coils,Ip, and disturbances calc_Mmatrix_isoflux - Calculate M-matrix for inversion approach to determining isoflux gains compress_isoflux_response - compress isoflux response to a single row connect_design_systems - Connect individual design system components into a single system define_rtefit_objects - get definitions and locations for objects used in rtefit designeq - Design an equilibrium get_isoflux_filename - Get the unique filename for a given segment or grid get_isoflux_grid_data - retrieve grid names, usage, and algorithms for given shot/time get_isoflux_ref_data - Retrieves reference flux sources for given shot/time get_isoflux_segment_data - retrieve segment names, usage, & algorithms for given shot/time get_linest_from_ematrix - Return linear estimator definitions from PCS Ematrix parse_rtefitsizes - Return rtEFIT variables (array sizes, directory names, etc...) read_response - read response info for control segment or grid read_util - Read response info for control segments or grids symmetrize_eq - Create up/down symmetric equilibrium structure from asymmetric source","title":"Contents.m"},{"location":"function-guide/design/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/design/Contents_m/#basic-information","text":"Control design tools (These tools are under development, so not all are reliable.) build_design_model - build state-space model with PS, tokamak/plasma, diagnostics build_filter_system - create filter/delay LTI ss system build_gap_response - build gap response model build_isoflux_response - build model of isoflux response to coil currents build_linest_response - Connect design system components into a single system calc_isoflux_plasma_response - calculate control point response to coils,Ip, and disturbances calc_Mmatrix_isoflux - Calculate M-matrix for inversion approach to determining isoflux gains compress_isoflux_response - compress isoflux response to a single row connect_design_systems - Connect individual design system components into a single system define_rtefit_objects - get definitions and locations for objects used in rtefit designeq - Design an equilibrium get_isoflux_filename - Get the unique filename for a given segment or grid get_isoflux_grid_data - retrieve grid names, usage, and algorithms for given shot/time get_isoflux_ref_data - Retrieves reference flux sources for given shot/time get_isoflux_segment_data - retrieve segment names, usage, & algorithms for given shot/time get_linest_from_ematrix - Return linear estimator definitions from PCS Ematrix parse_rtefitsizes - Return rtEFIT variables (array sizes, directory names, etc...) read_response - read response info for control segment or grid read_util - Read response info for control segments or grids symmetrize_eq - Create up/down symmetric equilibrium structure from asymmetric source","title":"Basic Information"},{"location":"function-guide/design/build_design_model_m/","text":"build_design_model.m \u00b6 Basic Information \u00b6 SYNTAX: design_model = build_design_model(design_model_in) PURPOSE: Builds single state-space model incorporating power supply system (optional),plasma system,and filter/delay system (optional). Connections between systems can be arbitrarily specified, and INPUTS: design_model_in = structure tokname = Tokamak name (e.g. 'D3D','NSTX','KSTAR') use_ps = Include power supply system (1:YES 0:NO) use_fiters = Include filter/delay system (1:YES 0:NO) use_disturb = Include distrubance inputs (1:YES 0:NO) psbuild_in = Struct of parameters for PS build macro sysbuild_in = Struct of parameters for tokamak system build macro control_in = Struct of parameters defining control output response filter_in = Struct of parameters defining filter/delay system sys_outputs = Names of outputs from combined system post_proc = Statements to evaluate at end of function (optional) OUTPUTS: design_model = LTI model","title":"build_design_model.m"},{"location":"function-guide/design/build_design_model_m/#build_design_modelm","text":"","title":"build_design_model.m"},{"location":"function-guide/design/build_design_model_m/#basic-information","text":"SYNTAX: design_model = build_design_model(design_model_in) PURPOSE: Builds single state-space model incorporating power supply system (optional),plasma system,and filter/delay system (optional). Connections between systems can be arbitrarily specified, and INPUTS: design_model_in = structure tokname = Tokamak name (e.g. 'D3D','NSTX','KSTAR') use_ps = Include power supply system (1:YES 0:NO) use_fiters = Include filter/delay system (1:YES 0:NO) use_disturb = Include distrubance inputs (1:YES 0:NO) psbuild_in = Struct of parameters for PS build macro sysbuild_in = Struct of parameters for tokamak system build macro control_in = Struct of parameters defining control output response filter_in = Struct of parameters defining filter/delay system sys_outputs = Names of outputs from combined system post_proc = Statements to evaluate at end of function (optional) OUTPUTS: design_model = LTI model","title":"Basic Information"},{"location":"function-guide/design/build_filter_system_m/","text":"build_filter_system.m \u00b6 Basic Information \u00b6 SYNTAX: filter_sys = build_filter_system(filter_inputs) Purpose: Create filter/delay LTI ss system. INPUT: filter_inputs = structure input_name = Filter signal input names (nfilt x 1 cell array) filter_type = Filter type list (nfilt x 1 array) 0 = None 1 = Bessel 2 = Butterworth 3 = Cheby1 4 = Cheby2 filter_arg = Input arguments for filters (nfiltx1 cell array) delay = filter output delay time (s) (nfiltx1 array) [0] post_proc = Statements to evaluate at end of function (optional) OUTPUT: filter_sys = ss system of filters with output delays. See properties ('get(filter_sys)') to get input & output names, delays,filter type & settings. RESTRICTIONS: METHOD: Appends multiple SISO filters into one large system with many outputs","title":"build_filter_system.m"},{"location":"function-guide/design/build_filter_system_m/#build_filter_systemm","text":"","title":"build_filter_system.m"},{"location":"function-guide/design/build_filter_system_m/#basic-information","text":"SYNTAX: filter_sys = build_filter_system(filter_inputs) Purpose: Create filter/delay LTI ss system. INPUT: filter_inputs = structure input_name = Filter signal input names (nfilt x 1 cell array) filter_type = Filter type list (nfilt x 1 array) 0 = None 1 = Bessel 2 = Butterworth 3 = Cheby1 4 = Cheby2 filter_arg = Input arguments for filters (nfiltx1 cell array) delay = filter output delay time (s) (nfiltx1 array) [0] post_proc = Statements to evaluate at end of function (optional) OUTPUT: filter_sys = ss system of filters with output delays. See properties ('get(filter_sys)') to get input & output names, delays,filter type & settings. RESTRICTIONS: METHOD: Appends multiple SISO filters into one large system with many outputs","title":"Basic Information"},{"location":"function-guide/design/build_gap_response_m/","text":"build_gap_response.m \u00b6 Basic Information \u00b6 SYNTAX: gap_response = build_gap_response(gap_in) PURPOSE: Build gap response for gaps defined in gap_in INPUT: gap_in = structure gapspec = [r z gr gz] for each gap (4 x ngap) (see calc_gap.m) gapnames = Names of gaps (optional) tok_data_struct = Toksys vacuum object (from make_tok_objects.m) resp = Plasma system response model (rzrig or gspert) equil_data = Equilibrium data structure post_proc = Statements to evaluate at end of function. OUTPUT: gap_response = structure gapresp = response structure with fields: dgapdis: gap response to conductors [m/A] dgapdip,*dli,*dbetap, etc: exogenous responses gaps: distances from boundary to wall through r,z along gr,gz [m] gapspec: New gap specification on form [r z gr gz] gapnames = Gap names METHOD:","title":"build_gap_response.m"},{"location":"function-guide/design/build_gap_response_m/#build_gap_responsem","text":"","title":"build_gap_response.m"},{"location":"function-guide/design/build_gap_response_m/#basic-information","text":"SYNTAX: gap_response = build_gap_response(gap_in) PURPOSE: Build gap response for gaps defined in gap_in INPUT: gap_in = structure gapspec = [r z gr gz] for each gap (4 x ngap) (see calc_gap.m) gapnames = Names of gaps (optional) tok_data_struct = Toksys vacuum object (from make_tok_objects.m) resp = Plasma system response model (rzrig or gspert) equil_data = Equilibrium data structure post_proc = Statements to evaluate at end of function. OUTPUT: gap_response = structure gapresp = response structure with fields: dgapdis: gap response to conductors [m/A] dgapdip,*dli,*dbetap, etc: exogenous responses gaps: distances from boundary to wall through r,z along gr,gz [m] gapspec: New gap specification on form [r z gr gz] gapnames = Gap names METHOD:","title":"Basic Information"},{"location":"function-guide/design/build_isoflux_response_m/","text":"build_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: isoflux_response = build_isoflux_response(isoflux_input) PURPOSE: Build isoflux response for elements listed in isoflux_input. Response objects include plasma response if vacuum_model=0 in iso_presp_in. INPUT: isoflux_input = (structure) tokname = Tokamak name segment_resp_flag = Cell array of flags determining how response on ctrl segments computed (see compress_isoflux_response.m) segment_alg = Segment algorithm (1:Flux 2:Br 3:Bz) segment_usage = Segment usage (0: Ignored, 1-4:with reference #N, 5:no ref) (returned by get_isoflux_segment_data) grid_resp_flag = Cell array of flags determining how response on grid computed (see compress_isoflux_response.m) grid_usage = Grid \" \" (returned by get_isoflux_grid_data) ref_flux_source = Sources for reference flux, maximum 4 elements. Sources specificed by an index number, where indices access the array: [segments[1:nseg] grids[1:ngrid]. iso_presp_in = Isoflux plasma response input structure (see calc_isoflux_plasma_response.m, excludes response_data and rtefit_def) use_pcs_isoflux = (WHAT DOES THIS DO??) default 0 Optional inputs: exe_dir = Path to compiled pcs executable directory (how does this get set?) segment_names = Cell array of isoflux segment names (defined by ?? if use_pcs_isoflux=1) grid_names = Cell array of isoflux grid names (defined by ?? if use_pcs_isoflux=1) post_proc = Statements to evaluate at end of function (not used if not set?). OUTPUT: isoflux_response = structure isoflux_input = Input structure (see above) rtefit_defns = rtEFIT definition structure (see define_rtefit_objects.m) nseg = # segments ngrid = # grids isodata = Array of response_data structures [nseg + ngrid] (see read_response.m) Gcntl = Response of flux at isoflux control points and field at Xpts to changes in conductor currents. Outputs = [nsegments fluxes(Wb),flux,Br,Bz at Xpt1(Wb,T), flux,Br,Bz at Xpt2(Wb,T)...] Inputs = currents conductors (E,F,vv,Ip) corresponding to conductors in iso_presp_in.vacuum_objs. Units = A. Gcntlbetap = Isoflux response to betap disturbance Gcntlli = \" \" \" li \" Gcntl_err = Gcntlbetap_err= Gcntlli_err = all_response = cell array of all PCS response structures processed during calculation METHOD:","title":"build_isoflux_response.m"},{"location":"function-guide/design/build_isoflux_response_m/#build_isoflux_responsem","text":"","title":"build_isoflux_response.m"},{"location":"function-guide/design/build_isoflux_response_m/#basic-information","text":"SYNTAX: isoflux_response = build_isoflux_response(isoflux_input) PURPOSE: Build isoflux response for elements listed in isoflux_input. Response objects include plasma response if vacuum_model=0 in iso_presp_in. INPUT: isoflux_input = (structure) tokname = Tokamak name segment_resp_flag = Cell array of flags determining how response on ctrl segments computed (see compress_isoflux_response.m) segment_alg = Segment algorithm (1:Flux 2:Br 3:Bz) segment_usage = Segment usage (0: Ignored, 1-4:with reference #N, 5:no ref) (returned by get_isoflux_segment_data) grid_resp_flag = Cell array of flags determining how response on grid computed (see compress_isoflux_response.m) grid_usage = Grid \" \" (returned by get_isoflux_grid_data) ref_flux_source = Sources for reference flux, maximum 4 elements. Sources specificed by an index number, where indices access the array: [segments[1:nseg] grids[1:ngrid]. iso_presp_in = Isoflux plasma response input structure (see calc_isoflux_plasma_response.m, excludes response_data and rtefit_def) use_pcs_isoflux = (WHAT DOES THIS DO??) default 0 Optional inputs: exe_dir = Path to compiled pcs executable directory (how does this get set?) segment_names = Cell array of isoflux segment names (defined by ?? if use_pcs_isoflux=1) grid_names = Cell array of isoflux grid names (defined by ?? if use_pcs_isoflux=1) post_proc = Statements to evaluate at end of function (not used if not set?). OUTPUT: isoflux_response = structure isoflux_input = Input structure (see above) rtefit_defns = rtEFIT definition structure (see define_rtefit_objects.m) nseg = # segments ngrid = # grids isodata = Array of response_data structures [nseg + ngrid] (see read_response.m) Gcntl = Response of flux at isoflux control points and field at Xpts to changes in conductor currents. Outputs = [nsegments fluxes(Wb),flux,Br,Bz at Xpt1(Wb,T), flux,Br,Bz at Xpt2(Wb,T)...] Inputs = currents conductors (E,F,vv,Ip) corresponding to conductors in iso_presp_in.vacuum_objs. Units = A. Gcntlbetap = Isoflux response to betap disturbance Gcntlli = \" \" \" li \" Gcntl_err = Gcntlbetap_err= Gcntlli_err = all_response = cell array of all PCS response structures processed during calculation METHOD:","title":"Basic Information"},{"location":"function-guide/design/build_linest_response_m/","text":"build_linest_response.m \u00b6 Basic Information \u00b6 SYNTAX: linest_response = build_linest_reponse(linest_in) PURPOSE: Connect design system components into a single system. INPUT: linest_in = structure linest_defs = structure array est_name = Name of linear estimator input_names = Cell array of inputs with non-zero coefficients coeff = Array of input coefficients pl_sys = Plasma system providing inputs (output of build_***_sys) post_proc = Statement strings to run at end of function OUTPUT: linest_response = structure outputs = Array of linear estimator names cmat, dmat, hmat = Response matrices to be appended to plasma system matrices RESTRICTIONS: Connection function will assume that all inputs are from plasma system. Using other inputs will lead to errors. Linest names must match pl_out elements (case insensitive). METHOD:","title":"build_linest_response.m"},{"location":"function-guide/design/build_linest_response_m/#build_linest_responsem","text":"","title":"build_linest_response.m"},{"location":"function-guide/design/build_linest_response_m/#basic-information","text":"SYNTAX: linest_response = build_linest_reponse(linest_in) PURPOSE: Connect design system components into a single system. INPUT: linest_in = structure linest_defs = structure array est_name = Name of linear estimator input_names = Cell array of inputs with non-zero coefficients coeff = Array of input coefficients pl_sys = Plasma system providing inputs (output of build_***_sys) post_proc = Statement strings to run at end of function OUTPUT: linest_response = structure outputs = Array of linear estimator names cmat, dmat, hmat = Response matrices to be appended to plasma system matrices RESTRICTIONS: Connection function will assume that all inputs are from plasma system. Using other inputs will lead to errors. Linest names must match pl_out elements (case insensitive). METHOD:","title":"Basic Information"},{"location":"function-guide/design/calc_Mmatrix_isoflux_m/","text":"calc_Mmatrix_isoflux.m \u00b6 Basic Information \u00b6 THIS VERSION WORKS FOR D3D","title":"calc_Mmatrix_isoflux.m"},{"location":"function-guide/design/calc_Mmatrix_isoflux_m/#calc_mmatrix_isofluxm","text":"","title":"calc_Mmatrix_isoflux.m"},{"location":"function-guide/design/calc_Mmatrix_isoflux_m/#basic-information","text":"THIS VERSION WORKS FOR D3D","title":"Basic Information"},{"location":"function-guide/design/calc_isoflux_plasma_response_m/","text":"calc_isoflux_plasma_response.m \u00b6 Basic Information \u00b6 USAGE: iso_presp = calc_isoflux_plasma_response(isoflux_plasma_response_input) PURPOSE: Calculates control point response to coils,Ip, and disturbances (includes plasam response) INPUT: isoflux_plasma_response_input = structure response_data = Isoflux segment/grid response structure Enter [r;z] vectors in response_data.cntl_pts. usage_data = concatenation of segment_usage and grid_usage resp_mdl = Plasma reponse model structure (e.g. TOKNAME_sys.gspert_data or .rzrig_data) equil_data = Plasma equilbrium data structure (e.g. TOKANME_sys.equil_data) vacuum_objs = Vacuum system structure (output of make_tok_objects.m = tok_data_struct) vacuum_model = set to 1 to produce only the vacuum model (default = 0)","title":"calc_isoflux_plasma_response.m"},{"location":"function-guide/design/calc_isoflux_plasma_response_m/#calc_isoflux_plasma_responsem","text":"","title":"calc_isoflux_plasma_response.m"},{"location":"function-guide/design/calc_isoflux_plasma_response_m/#basic-information","text":"USAGE: iso_presp = calc_isoflux_plasma_response(isoflux_plasma_response_input) PURPOSE: Calculates control point response to coils,Ip, and disturbances (includes plasam response) INPUT: isoflux_plasma_response_input = structure response_data = Isoflux segment/grid response structure Enter [r;z] vectors in response_data.cntl_pts. usage_data = concatenation of segment_usage and grid_usage resp_mdl = Plasma reponse model structure (e.g. TOKNAME_sys.gspert_data or .rzrig_data) equil_data = Plasma equilbrium data structure (e.g. TOKANME_sys.equil_data) vacuum_objs = Vacuum system structure (output of make_tok_objects.m = tok_data_struct) vacuum_model = set to 1 to produce only the vacuum model (default = 0)","title":"Basic Information"},{"location":"function-guide/design/compress_isoflux_response_m/","text":"compress_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: [compdata] = compress_isoflux_response(data,cntl_pts,isotype,resp_flag) PURPOSE: Compress isoflux response to a single row using specified method. Can also detect and handle stacked responses (e.g. flux, Br, Bz). INPUT: data = Segment/grid response data (size = ncntl_pts x nstates) cntl_pts = Segment/grid control point (r,z) locations (size = 2 x nctl_pts) isotype = 'G' or 'S' resp_flag = Response compression method flag depndent upon type: if scalar 0 = do not use this segment/grid 1 = use average over entire segment/grid 2 = use response at center of segment/grid if length=2: Use response at pt closest to [r,z] OUTPUT: compdata = Compressed response vectors METHOD: If mod(size(data,1),ncntl_pts)==0, assume multiple response vectors (e.g. flux, Br, Bz).","title":"compress_isoflux_response.m"},{"location":"function-guide/design/compress_isoflux_response_m/#compress_isoflux_responsem","text":"","title":"compress_isoflux_response.m"},{"location":"function-guide/design/compress_isoflux_response_m/#basic-information","text":"SYNTAX: [compdata] = compress_isoflux_response(data,cntl_pts,isotype,resp_flag) PURPOSE: Compress isoflux response to a single row using specified method. Can also detect and handle stacked responses (e.g. flux, Br, Bz). INPUT: data = Segment/grid response data (size = ncntl_pts x nstates) cntl_pts = Segment/grid control point (r,z) locations (size = 2 x nctl_pts) isotype = 'G' or 'S' resp_flag = Response compression method flag depndent upon type: if scalar 0 = do not use this segment/grid 1 = use average over entire segment/grid 2 = use response at center of segment/grid if length=2: Use response at pt closest to [r,z] OUTPUT: compdata = Compressed response vectors METHOD: If mod(size(data,1),ncntl_pts)==0, assume multiple response vectors (e.g. flux, Br, Bz).","title":"Basic Information"},{"location":"function-guide/design/connect_design_systems_m/","text":"connect_design_systems.m \u00b6 Basic Information \u00b6 SYNTAX: systot = connect_design_systems(connect_sys_in) PURPOSE: Connect individual design system components into a single system. INPUT: connect_sys_in = structure use_disturb = Disturbance input flag (1:Use 0:Do not use) tok_model = Model of tokamak system (output of build_XX_sys) plasma_sys = Tokamak syetem state-space model ps_sys = Power system state-space model (optional) filter_sys = Filter system state-sapce model (optional) outputs = Connected system output names (optional) [If not defined, all PS, plasma, & filter outputs passed] post_proc = Statements to evaluate at end of function (optional) OUTPUT: systot = State space model of combined system METHOD: Connections are determined using InputName and OutputName properties of the state-space models. Names must be a case insensitive match to each other to be properly connected. Duplicate output names in two systems will only match the first name in the order (PS,pl,filt), so avoid duplicate output names to remove any ambiguity,","title":"connect_design_systems.m"},{"location":"function-guide/design/connect_design_systems_m/#connect_design_systemsm","text":"","title":"connect_design_systems.m"},{"location":"function-guide/design/connect_design_systems_m/#basic-information","text":"SYNTAX: systot = connect_design_systems(connect_sys_in) PURPOSE: Connect individual design system components into a single system. INPUT: connect_sys_in = structure use_disturb = Disturbance input flag (1:Use 0:Do not use) tok_model = Model of tokamak system (output of build_XX_sys) plasma_sys = Tokamak syetem state-space model ps_sys = Power system state-space model (optional) filter_sys = Filter system state-sapce model (optional) outputs = Connected system output names (optional) [If not defined, all PS, plasma, & filter outputs passed] post_proc = Statements to evaluate at end of function (optional) OUTPUT: systot = State space model of combined system METHOD: Connections are determined using InputName and OutputName properties of the state-space models. Names must be a case insensitive match to each other to be properly connected. Duplicate output names in two systems will only match the first name in the order (PS,pl,filt), so avoid duplicate output names to remove any ambiguity,","title":"Basic Information"},{"location":"function-guide/design/define_rtefit_objects_m/","text":"define_rtefit_objects.m \u00b6 Basic Information \u00b6 SYNTAX: rtefit_defns = define_rtefit_objects(exe_dir) PURPOSE: Get definitions and locations for objects used in rtefit. INPUT: exe_dir = Path to compiled pcs executable directory OUTPUT: rtefit_defns = structure containing rtefit definitions EF_NESUM = # E (ohmic) coils EF_NFCOIL = # F (poloidal field) coils EF_NVESSEL = # vessel segments EF_NW_MAX = # gridpoint in radial direction EF_NH_MAX = # gridpoint in vertical direction EF_NUM_GRIDPTS_FULLSET_INVESSEL = # gridpoints inside vessel EF_NUM_CURRENT_SOURCES_INVESSEL = # of all current sources EF_ICT_COILCOUNT =: 53 EF_ICT_COILCOUNT_4IZE: 3 EF_DATA_FILE_DIRECTORY = '/p/pcs/ops/data_nstx/rtefit_v7a/' nw = # gridpoint in radial direction nh = # gridpoints in verical direction keep = ??? keep_invessel = ??? keepw = R locations in keep set keeph = Z locations in keep set invessel_indices = indices of grid point within vessel r = R coordinates of keep set r_invessel = R coordinates of invessel grid points rinverse = 1./r rinverse_invessel: rinverse of invessel gridpoints z = Z corrdinates of keep set zero = ??? rgrid = R locations of grid zgrid = Z locations of grid descriptions RESTRICTIONS: METHOD:","title":"define_rtefit_objects.m"},{"location":"function-guide/design/define_rtefit_objects_m/#define_rtefit_objectsm","text":"","title":"define_rtefit_objects.m"},{"location":"function-guide/design/define_rtefit_objects_m/#basic-information","text":"SYNTAX: rtefit_defns = define_rtefit_objects(exe_dir) PURPOSE: Get definitions and locations for objects used in rtefit. INPUT: exe_dir = Path to compiled pcs executable directory OUTPUT: rtefit_defns = structure containing rtefit definitions EF_NESUM = # E (ohmic) coils EF_NFCOIL = # F (poloidal field) coils EF_NVESSEL = # vessel segments EF_NW_MAX = # gridpoint in radial direction EF_NH_MAX = # gridpoint in vertical direction EF_NUM_GRIDPTS_FULLSET_INVESSEL = # gridpoints inside vessel EF_NUM_CURRENT_SOURCES_INVESSEL = # of all current sources EF_ICT_COILCOUNT =: 53 EF_ICT_COILCOUNT_4IZE: 3 EF_DATA_FILE_DIRECTORY = '/p/pcs/ops/data_nstx/rtefit_v7a/' nw = # gridpoint in radial direction nh = # gridpoints in verical direction keep = ??? keep_invessel = ??? keepw = R locations in keep set keeph = Z locations in keep set invessel_indices = indices of grid point within vessel r = R coordinates of keep set r_invessel = R coordinates of invessel grid points rinverse = 1./r rinverse_invessel: rinverse of invessel gridpoints z = Z corrdinates of keep set zero = ??? rgrid = R locations of grid zgrid = Z locations of grid descriptions RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/design/designeq_gui_m/","text":"designeq_gui.m \u00b6 Basic Information \u00b6 designeq_gui M-file for designeq_gui.fig designeq_gui, by itself, creates new designeq_gui or raises existing singleton*. H = designeq_gui returns handle to new designeq_gui or to existing singleton*. designeq_gui('CALLBACK',hObject,eventData,handles,...) calls the local function named CALLBACK in designeq_gui.M with the given input arguments. designeq_gui('Property','Value',...) creates new designeq_gui or raises existing singleton*. Starting from the left, property value pairs are applied to the GUI before designeq_gui_OpeningFunction gets called. An unrecognized property name or invalid value makes property application stop. All inputs are passed to designeq_gui_OpeningFcn via varargin. See also: GUIDE, GUIDATA, GUIHANDLES","title":"designeq_gui.m"},{"location":"function-guide/design/designeq_gui_m/#designeq_guim","text":"","title":"designeq_gui.m"},{"location":"function-guide/design/designeq_gui_m/#basic-information","text":"designeq_gui M-file for designeq_gui.fig designeq_gui, by itself, creates new designeq_gui or raises existing singleton*. H = designeq_gui returns handle to new designeq_gui or to existing singleton*. designeq_gui('CALLBACK',hObject,eventData,handles,...) calls the local function named CALLBACK in designeq_gui.M with the given input arguments. designeq_gui('Property','Value',...) creates new designeq_gui or raises existing singleton*. Starting from the left, property value pairs are applied to the GUI before designeq_gui_OpeningFunction gets called. An unrecognized property name or invalid value makes property application stop. All inputs are passed to designeq_gui_OpeningFcn via varargin. See also: GUIDE, GUIDATA, GUIHANDLES","title":"Basic Information"},{"location":"function-guide/design/designeq_m/","text":"designeq.m \u00b6 Basic Information \u00b6 USAGE: [eq,eqx] = designeq(spec,tok,options,guiflag) PURPOSE: Design an equilibrium, designeq by itself opens a GUI for specification INPUTS: spec, structure with targets, weights, limits, locks, template tok, Toksys description of the tokamak options, settings and flags guiflag, flag to open the GUI (default 0 = no GUI) For deadstart: spec = 'circle' or 'ellipse' or 'lsn' or 'usn' or 'dn' spec may contain structures: targets, weights, limits, locks The solution is minimized deviation from weights*targets within limits. Implemented targets: cc, presr (pressure versus rho), jparar (j_parallel versus rho), rbbbs, zbbbs, rsurf, zsurf, aminor, kappa0, cpasma, betap, li, rcur, zcur, rx1, zx1, rx2, zx2, drsep, psibry, x1rleg, x1zleg, x2rleg, x2zleg (divertor leg coords), fun1, ..., fun9 (expressions, e.g. betap+li/2) Set spec.template = eq0 for same turnfc, fcid, cc format, etc. as eq0 spec.cccirc assigns a circuit (with sign) to each coil in cc For DIII-D do: PP_objs=get_PP_objs(shot), spec.buscode = [0 0 PP_objs.bus_code] options may contain fields: nkn, number of knots in splines for pres, fpol (default is 1) psikn, normalized flux values from 0 to 1 for knots (default equally spaced) idoplot, flag to plot progress of equilibrium design (default 1) maxiter, maximum iterations (25 by default) use_template_presr, use pressure vs rho of template equilibrium use_template_presr_normalized, use pressure vs rho of template equilibrium but scale magnitude depending on betap or similar targets use_template_jparar, use the j_parallel vs rho of template equilibrium use_template_jparar_normalized, use the j_parallel vs rho of template equilibrium but scale by: (kj1+kj2*linspace(1,0,nr)) depending on Ip, li, or similar targets iframe4movie, creates bitmap picture files of iteration progress OUTPUTS: eq, designed equilibrium eqx, extra information METHOD: Equilibrium fitted to weighted design objectives by Newton-Rhapson iterations","title":"designeq.m"},{"location":"function-guide/design/designeq_m/#designeqm","text":"","title":"designeq.m"},{"location":"function-guide/design/designeq_m/#basic-information","text":"USAGE: [eq,eqx] = designeq(spec,tok,options,guiflag) PURPOSE: Design an equilibrium, designeq by itself opens a GUI for specification INPUTS: spec, structure with targets, weights, limits, locks, template tok, Toksys description of the tokamak options, settings and flags guiflag, flag to open the GUI (default 0 = no GUI) For deadstart: spec = 'circle' or 'ellipse' or 'lsn' or 'usn' or 'dn' spec may contain structures: targets, weights, limits, locks The solution is minimized deviation from weights*targets within limits. Implemented targets: cc, presr (pressure versus rho), jparar (j_parallel versus rho), rbbbs, zbbbs, rsurf, zsurf, aminor, kappa0, cpasma, betap, li, rcur, zcur, rx1, zx1, rx2, zx2, drsep, psibry, x1rleg, x1zleg, x2rleg, x2zleg (divertor leg coords), fun1, ..., fun9 (expressions, e.g. betap+li/2) Set spec.template = eq0 for same turnfc, fcid, cc format, etc. as eq0 spec.cccirc assigns a circuit (with sign) to each coil in cc For DIII-D do: PP_objs=get_PP_objs(shot), spec.buscode = [0 0 PP_objs.bus_code] options may contain fields: nkn, number of knots in splines for pres, fpol (default is 1) psikn, normalized flux values from 0 to 1 for knots (default equally spaced) idoplot, flag to plot progress of equilibrium design (default 1) maxiter, maximum iterations (25 by default) use_template_presr, use pressure vs rho of template equilibrium use_template_presr_normalized, use pressure vs rho of template equilibrium but scale magnitude depending on betap or similar targets use_template_jparar, use the j_parallel vs rho of template equilibrium use_template_jparar_normalized, use the j_parallel vs rho of template equilibrium but scale by: (kj1+kj2*linspace(1,0,nr)) depending on Ip, li, or similar targets iframe4movie, creates bitmap picture files of iteration progress OUTPUTS: eq, designed equilibrium eqx, extra information METHOD: Equilibrium fitted to weighted design objectives by Newton-Rhapson iterations","title":"Basic Information"},{"location":"function-guide/design/get_isoflux_filename_m/","text":"get_isoflux_filename.m \u00b6 Basic Information \u00b6 SYNTAX: filename = get_isoflux_filename(name,typeflag,rtefit_defns) PURPOSE: Get the unique filename for a given segment or grid INPUT: isoname = Base name of segment/grid (e.g. \"bot_3cm\") isotype = Designates object type: segment ('S') or grid ('G') rtefit_defns = structure (see define_rtefit_objects.m) OUTPUT: filename = Filename for given object, excluding prefixes & suffixes (e.g. grid \"bot_3cm\" returns \"bot_3cm_grid_00003\") ier = 0: file(s) found 1: No file found METHOD:","title":"get_isoflux_filename.m"},{"location":"function-guide/design/get_isoflux_filename_m/#get_isoflux_filenamem","text":"","title":"get_isoflux_filename.m"},{"location":"function-guide/design/get_isoflux_filename_m/#basic-information","text":"SYNTAX: filename = get_isoflux_filename(name,typeflag,rtefit_defns) PURPOSE: Get the unique filename for a given segment or grid INPUT: isoname = Base name of segment/grid (e.g. \"bot_3cm\") isotype = Designates object type: segment ('S') or grid ('G') rtefit_defns = structure (see define_rtefit_objects.m) OUTPUT: filename = Filename for given object, excluding prefixes & suffixes (e.g. grid \"bot_3cm\" returns \"bot_3cm_grid_00003\") ier = 0: file(s) found 1: No file found METHOD:","title":"Basic Information"},{"location":"function-guide/design/get_isoflux_grid_data_m/","text":"get_isoflux_grid_data.m \u00b6 Basic Information \u00b6 SYNTAX: [gridRZ,gridusage,gp,gd,gi,tp,td,ti] = get_isoflux_grid_data(shot,t0,datafunc,dt,algID) PURPOSE: Retrieves grid names, usage, and algorithms for a given shot & time INPUT: shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function dt = Interval around time to collect target data (s) [0.02] (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) algID = algorithm identifier, e.g., 'D' for isodnull, 'S' for isosnull (needed only if gains and tau values requested) OUTPUT: gridRZ = [R,Z] coordinates of segment control points at time t0 gridusage = Usage specification (0:Ignored, 1-4:Ref 1-4) RESTRICTIONS: Usage/alg targets must not change in interval [t0-dt,t0+dt] METHOD:","title":"get_isoflux_grid_data.m"},{"location":"function-guide/design/get_isoflux_grid_data_m/#get_isoflux_grid_datam","text":"","title":"get_isoflux_grid_data.m"},{"location":"function-guide/design/get_isoflux_grid_data_m/#basic-information","text":"SYNTAX: [gridRZ,gridusage,gp,gd,gi,tp,td,ti] = get_isoflux_grid_data(shot,t0,datafunc,dt,algID) PURPOSE: Retrieves grid names, usage, and algorithms for a given shot & time INPUT: shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function dt = Interval around time to collect target data (s) [0.02] (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) algID = algorithm identifier, e.g., 'D' for isodnull, 'S' for isosnull (needed only if gains and tau values requested) OUTPUT: gridRZ = [R,Z] coordinates of segment control points at time t0 gridusage = Usage specification (0:Ignored, 1-4:Ref 1-4) RESTRICTIONS: Usage/alg targets must not change in interval [t0-dt,t0+dt] METHOD:","title":"Basic Information"},{"location":"function-guide/design/get_isoflux_ref_data_m/","text":"get_isoflux_ref_data.m \u00b6 Basic Information \u00b6 SYNTAX: ref_flux_src = get_isoflux_ref_data(shot,t0,datafunc,dt) PURPOSE: Retrieves reference flux sources for a given shot & time INPUT: [default] shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) dt = Interval around time to collect target data (s) [0.02] OUTPUT: ref_flux_src = Reference flux indices (length = 4). Indices #1-18 refer to segments 1-18. Indices 19 & 20 refer to grid1 & 2, respectively. RESTRICTIONS: Reference targets must not change in interval [t0-dt,t0+dt]","title":"get_isoflux_ref_data.m"},{"location":"function-guide/design/get_isoflux_ref_data_m/#get_isoflux_ref_datam","text":"","title":"get_isoflux_ref_data.m"},{"location":"function-guide/design/get_isoflux_ref_data_m/#basic-information","text":"SYNTAX: ref_flux_src = get_isoflux_ref_data(shot,t0,datafunc,dt) PURPOSE: Retrieves reference flux sources for a given shot & time INPUT: [default] shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) dt = Interval around time to collect target data (s) [0.02] OUTPUT: ref_flux_src = Reference flux indices (length = 4). Indices #1-18 refer to segments 1-18. Indices 19 & 20 refer to grid1 & 2, respectively. RESTRICTIONS: Reference targets must not change in interval [t0-dt,t0+dt]","title":"Basic Information"},{"location":"function-guide/design/get_isoflux_segment_data_m/","text":"get_isoflux_segment_data.m \u00b6 Basic Information \u00b6 SYNTAX: [segRZ,segusage,segalg,gp,gd,gi,tp,td,ti] = get_isoflux_segment_data(shot,t0,datafunc,dt,nseg,algD) PURPOSE: Retrieves segment names, usage, and algorithms for a given shot & time INPUT: [default] shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function dt = Interval around time to collect target data (s) [0.02] (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) nseg = number of isoflux segments (optional, default=18) algID = algorithm identifier, e.g., 'D' for isodnull, 'S' for isosnull (needed only if gains and tau values requested) OUTPUT: segRZ = [R,Z] coordinates of segment control points at time t0 (m) segusage = Usage specification (0:Ignored, 1-4:Ref 1-4, 5:No Ref) segalg = Segment algorithm (1: Flux, 2: Br, 3: Bz 4: Locate touch point) (Note this is in build_design_model format and does not distinguish between \"at control point\" and \"at target\" at this time) gp,gd,gi = PID gains at the time t0 tp,td,di = PID tau values at the time t0 RESTRICTIONS: Usage/alg targets must not change in interval [t0-dt,t0+dt] METHOD:","title":"get_isoflux_segment_data.m"},{"location":"function-guide/design/get_isoflux_segment_data_m/#get_isoflux_segment_datam","text":"","title":"get_isoflux_segment_data.m"},{"location":"function-guide/design/get_isoflux_segment_data_m/#basic-information","text":"SYNTAX: [segRZ,segusage,segalg,gp,gd,gi,tp,td,ti] = get_isoflux_segment_data(shot,t0,datafunc,dt,nseg,algD) PURPOSE: Retrieves segment names, usage, and algorithms for a given shot & time INPUT: [default] shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function dt = Interval around time to collect target data (s) [0.02] (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) nseg = number of isoflux segments (optional, default=18) algID = algorithm identifier, e.g., 'D' for isodnull, 'S' for isosnull (needed only if gains and tau values requested) OUTPUT: segRZ = [R,Z] coordinates of segment control points at time t0 (m) segusage = Usage specification (0:Ignored, 1-4:Ref 1-4, 5:No Ref) segalg = Segment algorithm (1: Flux, 2: Br, 3: Bz 4: Locate touch point) (Note this is in build_design_model format and does not distinguish between \"at control point\" and \"at target\" at this time) gp,gd,gi = PID gains at the time t0 tp,td,di = PID tau values at the time t0 RESTRICTIONS: Usage/alg targets must not change in interval [t0-dt,t0+dt] METHOD:","title":"Basic Information"},{"location":"function-guide/design/get_linest_from_ematrix_m/","text":"get_linest_from_ematrix.m \u00b6 Basic Information \u00b6 GET_LINEST_FROM_EMATRIX Returns inear estimator definitions from PCS Ematrix SYNTAX: linest_defs = get_linest_from_ematrix(shot,category,phase,matname) PURPOSE: Return linear estimator definitions from PCS Ematrix INPUT: shot = Shot number category = Category name phase = Isoflux phase name ematname = Ematrix name OUTPUT: linest_defs = ??","title":"get_linest_from_ematrix.m"},{"location":"function-guide/design/get_linest_from_ematrix_m/#get_linest_from_ematrixm","text":"","title":"get_linest_from_ematrix.m"},{"location":"function-guide/design/get_linest_from_ematrix_m/#basic-information","text":"GET_LINEST_FROM_EMATRIX Returns inear estimator definitions from PCS Ematrix SYNTAX: linest_defs = get_linest_from_ematrix(shot,category,phase,matname) PURPOSE: Return linear estimator definitions from PCS Ematrix INPUT: shot = Shot number category = Category name phase = Isoflux phase name ematname = Ematrix name OUTPUT: linest_defs = ??","title":"Basic Information"},{"location":"function-guide/design/parse_rtefitsizes_m/","text":"parse_rtefitsizes.m \u00b6 Basic Information \u00b6 SYNTAX: [rtefit_defns,ier] = parse_rtefitsizes(filename) PURPOSE: Returns rtEFIT variables (array sizes, directory names, etc...) contained within rtefitsizes.pro. This file is located with the PCS executable directory. INPUT: filename = Full path to valid rtefitsizes.pro file OUTPUT: rtefit_defns = Structure containing varname/value pairs from rtefitsizes.pro RESTRICTIONS: METHOD:","title":"parse_rtefitsizes.m"},{"location":"function-guide/design/parse_rtefitsizes_m/#parse_rtefitsizesm","text":"","title":"parse_rtefitsizes.m"},{"location":"function-guide/design/parse_rtefitsizes_m/#basic-information","text":"SYNTAX: [rtefit_defns,ier] = parse_rtefitsizes(filename) PURPOSE: Returns rtEFIT variables (array sizes, directory names, etc...) contained within rtefitsizes.pro. This file is located with the PCS executable directory. INPUT: filename = Full path to valid rtefitsizes.pro file OUTPUT: rtefit_defns = Structure containing varname/value pairs from rtefitsizes.pro RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/design/plot_mmatrix_data_m/","text":"plot_mmatrix_data.m \u00b6 Basic Information \u00b6 THIS VERSION WORKS FOR D3D","title":"plot_mmatrix_data.m"},{"location":"function-guide/design/plot_mmatrix_data_m/#plot_mmatrix_datam","text":"","title":"plot_mmatrix_data.m"},{"location":"function-guide/design/plot_mmatrix_data_m/#basic-information","text":"THIS VERSION WORKS FOR D3D","title":"Basic Information"},{"location":"function-guide/design/read_response_m/","text":"read_response.m \u00b6 Basic Information \u00b6 SYNTAX: response_data = read_response(filename,rtefit_defns) PURPOSE: Read response info for control segment or grid. INPUT: filename = root name of file containing response data (doesn't include prefix \"ef_psi\", \"ef_br\", etc. or suffix \".dat\"). rtefit_defns = structure (see define_rtefit_objects.m) OUTPUT: response_data = structure isotype = String specifying grid (\"G\") or segment (\"S\") filename = Source file for raw response data cntl_pts= list of locations (r,z) of control points mutuals = mutual inductances between conductors and control points brg = greens function values from conductors to Br at control pts bzg = greens function values from conductors to Bz at control pts First coordinate in data objects mutuals, brgreens, bzgreens corresponds to conductors, in the following order: F-coils, next E-coils, next vessel elts, last nz x nr = grid elements. UNITS are Amp-turns, Wb/rad, and Tesla. (NOTE!! RTEFIT treats E-coils as having only 1 turn, so returned data assumes that also.) METHOD: Note that this function takes care of conversion from the rtefit convention, which uses a row-first indexing to the efit/matlab convention, which uses a column-first indexing.","title":"read_response.m"},{"location":"function-guide/design/read_response_m/#read_responsem","text":"","title":"read_response.m"},{"location":"function-guide/design/read_response_m/#basic-information","text":"SYNTAX: response_data = read_response(filename,rtefit_defns) PURPOSE: Read response info for control segment or grid. INPUT: filename = root name of file containing response data (doesn't include prefix \"ef_psi\", \"ef_br\", etc. or suffix \".dat\"). rtefit_defns = structure (see define_rtefit_objects.m) OUTPUT: response_data = structure isotype = String specifying grid (\"G\") or segment (\"S\") filename = Source file for raw response data cntl_pts= list of locations (r,z) of control points mutuals = mutual inductances between conductors and control points brg = greens function values from conductors to Br at control pts bzg = greens function values from conductors to Bz at control pts First coordinate in data objects mutuals, brgreens, bzgreens corresponds to conductors, in the following order: F-coils, next E-coils, next vessel elts, last nz x nr = grid elements. UNITS are Amp-turns, Wb/rad, and Tesla. (NOTE!! RTEFIT treats E-coils as having only 1 turn, so returned data assumes that also.) METHOD: Note that this function takes care of conversion from the rtefit convention, which uses a row-first indexing to the efit/matlab convention, which uses a column-first indexing.","title":"Basic Information"},{"location":"function-guide/design/read_util_m/","text":"read_util.m \u00b6 Basic Information \u00b6 SYNTAX: [control_pts,response] = read_util(rtefit_defns,filename) PURPOSE: Read response info for control segments or grids INPUT: rtefit_defns = rtEFIT data definiton structure (see define_rtefit_objects.m) filename = File containing response data OUTPUT: cntrl_pts = list of locations (r,z) of control points response = brg,bzg,or mutuals between control point and current sources First coordinate in data objects mutuals, brgreens, bzgreens corresponds to conductors, in the following order: F-coils, E-coils, next vessel elts, last nz x nr = grid elements. UNITS are Amp-turns, Wb/rad, and Tesla METHOD: Note that this function takes care of conversion from the rtefit convention, which uses a row-first indexing to the efit/matlab convention, which uses a column-first indexing.","title":"read_util.m"},{"location":"function-guide/design/read_util_m/#read_utilm","text":"","title":"read_util.m"},{"location":"function-guide/design/read_util_m/#basic-information","text":"SYNTAX: [control_pts,response] = read_util(rtefit_defns,filename) PURPOSE: Read response info for control segments or grids INPUT: rtefit_defns = rtEFIT data definiton structure (see define_rtefit_objects.m) filename = File containing response data OUTPUT: cntrl_pts = list of locations (r,z) of control points response = brg,bzg,or mutuals between control point and current sources First coordinate in data objects mutuals, brgreens, bzgreens corresponds to conductors, in the following order: F-coils, E-coils, next vessel elts, last nz x nr = grid elements. UNITS are Amp-turns, Wb/rad, and Tesla METHOD: Note that this function takes care of conversion from the rtefit convention, which uses a row-first indexing to the efit/matlab convention, which uses a column-first indexing.","title":"Basic Information"},{"location":"function-guide/design/symmetrize_eq_m/","text":"symmetrize_eq.m \u00b6 Basic Information \u00b6 SYNTAX: [eq,eqx] = symmetrize_eq(eq0,vacObj,options) PURPOSE: Create up/down symmetric equlibrium structure from asymmetric source. INPUTS: eq0 = Original (asymmetric) equilbrium data structure vacObjs = Vacuum objects (e.g. tok_data_struct) options: mirrorBase = Basis for mirroring (-1:bottom 1:top) cccirc = cccirc to force symmetric coils idxExclude = Non-equilbrium coil states to exclude (e.g. IVC) OUTPUTS: eq = Symmeterized equilibrium eqx = Additional equilibrium data (see designeq.m)","title":"symmetrize_eq.m"},{"location":"function-guide/design/symmetrize_eq_m/#symmetrize_eqm","text":"","title":"symmetrize_eq.m"},{"location":"function-guide/design/symmetrize_eq_m/#basic-information","text":"SYNTAX: [eq,eqx] = symmetrize_eq(eq0,vacObj,options) PURPOSE: Create up/down symmetric equlibrium structure from asymmetric source. INPUTS: eq0 = Original (asymmetric) equilbrium data structure vacObjs = Vacuum objects (e.g. tok_data_struct) options: mirrorBase = Basis for mirroring (-1:bottom 1:top) cccirc = cccirc to force symmetric coils idxExclude = Non-equilbrium coil states to exclude (e.g. IVC) OUTPUTS: eq = Symmeterized equilibrium eqx = Additional equilibrium data (see designeq.m)","title":"Basic Information"},{"location":"function-guide/dmp/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Matlab DMP tools: breakup_contour_matrix - Breaks up the ContourMatrix of a contour graph object into its individual contour traces for storage or plotting bulk_save_fig_dmp - Saves a series of figures to DIII-D DMP hdf5 files and applies given publication info to them so the files can be uploaded easily to the DIII-D DMP site check_dmphdf5_struct - Performs some basic checks of dmphdf5 structs for DIII-D DMP compliance dmphdf5_struct - Create an empty dmphdf5 structure with all the required fields for DIII-D DMP compliance fig2dmp - Extract the data from a figure, axes, or a combination of multiple figures and/or axes and save the data into a dmphdf5 struct of the type defined by dmphdf5_struct.m get_graph_data - Tool used by fig2dmp to extract data from a plot object like lines and contours. See internal documentation for specifics of which plot objects are currently supported. save_dmp_hdf5 - Save a dmphdf5_struct to an hdf5 file write_struct_to_hdf5 - Tool used by save_dmp_hdf5 stat saves a structure to an hdf5 file in the current directory. struct elements inside the structure are used to define sub-groups inside the HDF5 file. Other than groups, only strings and data arrays are supported.","title":"Contents.m"},{"location":"function-guide/dmp/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/dmp/Contents_m/#basic-information","text":"Matlab DMP tools: breakup_contour_matrix - Breaks up the ContourMatrix of a contour graph object into its individual contour traces for storage or plotting bulk_save_fig_dmp - Saves a series of figures to DIII-D DMP hdf5 files and applies given publication info to them so the files can be uploaded easily to the DIII-D DMP site check_dmphdf5_struct - Performs some basic checks of dmphdf5 structs for DIII-D DMP compliance dmphdf5_struct - Create an empty dmphdf5 structure with all the required fields for DIII-D DMP compliance fig2dmp - Extract the data from a figure, axes, or a combination of multiple figures and/or axes and save the data into a dmphdf5 struct of the type defined by dmphdf5_struct.m get_graph_data - Tool used by fig2dmp to extract data from a plot object like lines and contours. See internal documentation for specifics of which plot objects are currently supported. save_dmp_hdf5 - Save a dmphdf5_struct to an hdf5 file write_struct_to_hdf5 - Tool used by save_dmp_hdf5 stat saves a structure to an hdf5 file in the current directory. struct elements inside the structure are used to define sub-groups inside the HDF5 file. Other than groups, only strings and data arrays are supported.","title":"Basic Information"},{"location":"function-guide/dmp/breakup_contour_matrix_m/","text":"breakup_contour_matrix.m \u00b6 Basic Information \u00b6 SYNTAX: breakup_contour_matrix(ContourMatrix) PURPOSE: Breakup a ContourMatrix of the type stored as the \".ContourMatrix\" property in contour graph objects in Matlab, and return the various lines that define the contours as a combination of X, Y, and Z points. INPUTS: ContourMatrix: The ContourMatrix from a Matlab contour chart object from which the X, Y and Z data of the contours is to be extracted. OUTPUTS: XData: The X-values of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. YData: The Y-values of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. ZData: The Z-values (levels) of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"breakup_contour_matrix.m"},{"location":"function-guide/dmp/breakup_contour_matrix_m/#breakup_contour_matrixm","text":"","title":"breakup_contour_matrix.m"},{"location":"function-guide/dmp/breakup_contour_matrix_m/#basic-information","text":"SYNTAX: breakup_contour_matrix(ContourMatrix) PURPOSE: Breakup a ContourMatrix of the type stored as the \".ContourMatrix\" property in contour graph objects in Matlab, and return the various lines that define the contours as a combination of X, Y, and Z points. INPUTS: ContourMatrix: The ContourMatrix from a Matlab contour chart object from which the X, Y and Z data of the contours is to be extracted. OUTPUTS: XData: The X-values of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. YData: The Y-values of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. ZData: The Z-values (levels) of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/bulk_save_fig_dmp_m/","text":"bulk_save_fig_dmp.m \u00b6 Basic Information \u00b6 SYNTAX: bulk_save_fig_dmp(dmp_fields,fig_paths) PURPOSE: Generate DIII-D DMP HDF5 files from matlab figures. INPUTS: *** If dmp_fields & fig_paths not provided, looks for a file in this directory called 'dmp_config.m' which defines them dmp_fields (optional): string path to matlab file defining structures dmp_fields and fig_paths as defined below. -or- dmp_fields (optional): a struct with these fields defined: dmp_fields.author_last [str]: Your last name dmp_fields.data_provider [str]: Name of data provider dmp_fields.publication_year [str]: Year of publication dmp_fields.journal [str]: Name of journal dmp_fields.doc_number [str]: DIII-D doc number for pubs tracker dmp_fields.citation [str]: Full citation fig_paths (optional): a cell-array of strings to map figures to .fig files: fig_paths{:,1} [str]: First column is figure numbers, a string like: '1', '2b', or '3abc' fig_paths{:,2} [str]: Second column is file paths to .fig file, like '~/figs/figure3.fig' ** Alternately, this column can be a cell array of multiple string file paths. In this case, it is assumed that the figure in the publication is a compound figure containing multiple .fig files. OUTPUTS: None in matlab - but will generate .hdf5 files in the current directory for each requested figure. RESTRICTIONS: Not all figure elements are currently support, but most are. See get_graph_data.m for the most up to date list of what is and what is not supported. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"bulk_save_fig_dmp.m"},{"location":"function-guide/dmp/bulk_save_fig_dmp_m/#bulk_save_fig_dmpm","text":"","title":"bulk_save_fig_dmp.m"},{"location":"function-guide/dmp/bulk_save_fig_dmp_m/#basic-information","text":"SYNTAX: bulk_save_fig_dmp(dmp_fields,fig_paths) PURPOSE: Generate DIII-D DMP HDF5 files from matlab figures. INPUTS: *** If dmp_fields & fig_paths not provided, looks for a file in this directory called 'dmp_config.m' which defines them dmp_fields (optional): string path to matlab file defining structures dmp_fields and fig_paths as defined below. -or- dmp_fields (optional): a struct with these fields defined: dmp_fields.author_last [str]: Your last name dmp_fields.data_provider [str]: Name of data provider dmp_fields.publication_year [str]: Year of publication dmp_fields.journal [str]: Name of journal dmp_fields.doc_number [str]: DIII-D doc number for pubs tracker dmp_fields.citation [str]: Full citation fig_paths (optional): a cell-array of strings to map figures to .fig files: fig_paths{:,1} [str]: First column is figure numbers, a string like: '1', '2b', or '3abc' fig_paths{:,2} [str]: Second column is file paths to .fig file, like '~/figs/figure3.fig' ** Alternately, this column can be a cell array of multiple string file paths. In this case, it is assumed that the figure in the publication is a compound figure containing multiple .fig files. OUTPUTS: None in matlab - but will generate .hdf5 files in the current directory for each requested figure. RESTRICTIONS: Not all figure elements are currently support, but most are. See get_graph_data.m for the most up to date list of what is and what is not supported. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/check_dmphdf5_struct_m/","text":"check_dmphdf5_struct.m \u00b6 Basic Information \u00b6 SYNTAX: check_dmphdf5_struct(hdf5_struct) PURPOSE: Check a structure to see if it has the required fields and layout for the DIII-D DMP HDF5 file requirements. INPUTS: hdf5_struct: A structure to test OUTPUTS: warnings: A cell array of strings of warnings on missing fields or other problems with the structure. RESTRICTIONS: Additional checks may be done by the DIII-D DMP uploader. Also does not check if additional un-needed information is in the structure. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"check_dmphdf5_struct.m"},{"location":"function-guide/dmp/check_dmphdf5_struct_m/#check_dmphdf5_structm","text":"","title":"check_dmphdf5_struct.m"},{"location":"function-guide/dmp/check_dmphdf5_struct_m/#basic-information","text":"SYNTAX: check_dmphdf5_struct(hdf5_struct) PURPOSE: Check a structure to see if it has the required fields and layout for the DIII-D DMP HDF5 file requirements. INPUTS: hdf5_struct: A structure to test OUTPUTS: warnings: A cell array of strings of warnings on missing fields or other problems with the structure. RESTRICTIONS: Additional checks may be done by the DIII-D DMP uploader. Also does not check if additional un-needed information is in the structure. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/dmphdf5_struct_m/","text":"dmphdf5_struct.m \u00b6 Basic Information \u00b6 SYNTAX: dmphdf5_struct(varargin) PURPOSE: Make a structure to hold data and plot information for exporting to the hdf5 format used for the DIII-D DMP. With no options the output structure has all of the required fields, but set to empty strings as an initialized template. INPUTS: varagin: Pairs of strings defining fields to define in the output structure in addition to the data incorporated from the figures. For example, to add info for the data provider these two added args would work: dmphdf5_struct('data_provider','John Doe') OUTPUTS: dmphdf5: The output structure for exporting to the DIII-D DMP hdf5 format. By default the fields are: -author_last: [string] The author's last name -journal: [string] the journal published in -publication_year: [string] the year of publication as a string -data_provider: [string] the name of the person person that provided the data in this graph -doc_number: [string] the DIII-D doc number for this article or document - it is assigned by the DIII-D publications tracker. -figure_number: [string] the figure number in the document. Ex: '1', '2b', '3abc' -citation: [string] a full citation for the publication that the figure appears in. -DATA: [struct] a structure in which the data from a figure is stored. Datasets from a figure are to be labeled DATA.dataset#, and should each have a corresponding DATA.dataheader# which has comma-separated header information defining each column of the data. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"dmphdf5_struct.m"},{"location":"function-guide/dmp/dmphdf5_struct_m/#dmphdf5_structm","text":"","title":"dmphdf5_struct.m"},{"location":"function-guide/dmp/dmphdf5_struct_m/#basic-information","text":"SYNTAX: dmphdf5_struct(varargin) PURPOSE: Make a structure to hold data and plot information for exporting to the hdf5 format used for the DIII-D DMP. With no options the output structure has all of the required fields, but set to empty strings as an initialized template. INPUTS: varagin: Pairs of strings defining fields to define in the output structure in addition to the data incorporated from the figures. For example, to add info for the data provider these two added args would work: dmphdf5_struct('data_provider','John Doe') OUTPUTS: dmphdf5: The output structure for exporting to the DIII-D DMP hdf5 format. By default the fields are: -author_last: [string] The author's last name -journal: [string] the journal published in -publication_year: [string] the year of publication as a string -data_provider: [string] the name of the person person that provided the data in this graph -doc_number: [string] the DIII-D doc number for this article or document - it is assigned by the DIII-D publications tracker. -figure_number: [string] the figure number in the document. Ex: '1', '2b', '3abc' -citation: [string] a full citation for the publication that the figure appears in. -DATA: [struct] a structure in which the data from a figure is stored. Datasets from a figure are to be labeled DATA.dataset#, and should each have a corresponding DATA.dataheader# which has comma-separated header information defining each column of the data. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/fig2dmp_m/","text":"fig2dmp.m \u00b6 Basic Information \u00b6 SYNTAX: fig2dmp(figOrAxesHandles, contoursJustLevels, varargin) PURPOSE: Exteract the data from a figure, axes object, or combination of figure and axes objects, and store the data in a struture format that can be saved as an HDF5 in the DIII-D DMP format. INPUTS: figOrAxesHandles: Any number or combination of figure or axes objects. It will be assumed that all included figs/axes are a part of a final figure which should be included together in a single DMP hdf5 file. contoursJustLevels: (default=1) Option to just extract contour traces at the levels displayed in a figure, as opposed to all included data in the underlying matrix from which contours are displayed. For example: if an EFIT flux grid is in the figure, setting to 0 will include the entire flux grid in the output structure. Setting to 1 will just include the contours of flux displayed in the figure itself. varagin: Pairs of strings defining fields to define in the output structure in addition to the data incorporated from the figures. For example, to add info for the data provider these two added args would work: fig2dmp(fig_handles, 1, 'data_provider','John Doe') OUTPUTS: dmpstruct: A structure which can be exported to an hdf5 file in the format used for DIII-D DMP files. See dmphdf5_struct.m for more info on the format of the structure. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"fig2dmp.m"},{"location":"function-guide/dmp/fig2dmp_m/#fig2dmpm","text":"","title":"fig2dmp.m"},{"location":"function-guide/dmp/fig2dmp_m/#basic-information","text":"SYNTAX: fig2dmp(figOrAxesHandles, contoursJustLevels, varargin) PURPOSE: Exteract the data from a figure, axes object, or combination of figure and axes objects, and store the data in a struture format that can be saved as an HDF5 in the DIII-D DMP format. INPUTS: figOrAxesHandles: Any number or combination of figure or axes objects. It will be assumed that all included figs/axes are a part of a final figure which should be included together in a single DMP hdf5 file. contoursJustLevels: (default=1) Option to just extract contour traces at the levels displayed in a figure, as opposed to all included data in the underlying matrix from which contours are displayed. For example: if an EFIT flux grid is in the figure, setting to 0 will include the entire flux grid in the output structure. Setting to 1 will just include the contours of flux displayed in the figure itself. varagin: Pairs of strings defining fields to define in the output structure in addition to the data incorporated from the figures. For example, to add info for the data provider these two added args would work: fig2dmp(fig_handles, 1, 'data_provider','John Doe') OUTPUTS: dmpstruct: A structure which can be exported to an hdf5 file in the format used for DIII-D DMP files. See dmphdf5_struct.m for more info on the format of the structure. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/get_graph_data_m/","text":"get_graph_data.m \u00b6 Basic Information \u00b6 SYNTAX: get_graph_data(gObj, contoursJustLevels) PURPOSE: Exteract the data from a chart object in a figure. INPUTS: gObj: A chart object (like a line or surface) on a figure to extract the data from. See restrictions below for supported figure types. contoursJustLevels: (default=1) Option to just extract contour traces at the levels displayed in a figure, as opposed to all included data in the underlying matrix from which contours are displayed. For example: if an EFIT flux grid is in the figure, setting to 0 will include the entire flux grid in the output structure. Setting to 1 will just include the contours of flux displayed in the figure itself. OUTPUTS: ier: 0 if no failures to extract data, 1 if there was a problem (like the plot type is not supported, for example). DisplayName: The DisplayName of the chart object, if it was defined (usually defined by calling legend()). Type: The object type XData: The XData from the plotting object. If a polar plot, this corresponds to RData. If a lat-lot type plot, this corresponds to LongitudeData. YData: The YData from the plotting object. If a polar plot, this corresponds to ThetaData. If a lat-lot type plot, this corresponds to LattitudeData. ZData: The ZData from the plotting object, if it exists for this type of plot object. XNegativeDelta: For error-bars, the nagative X delta. XPositiveDelta: For error-bars, the positive X delta. YNegativeDelta: For error-bars, the nagative Y delta. YPositiveDelta: For error-bars, the positive Y delta. CData: For surface plots the color can be set to be data dependent, so it is stored if the user set the color to vary with the data. Exception: if the user set the color to just vary with the Z-data, then don't repeat this by just storing it again. RESTRICTIONS: Currently supported chart objects: -Area -Bar -Contour* -ErrorBar -Histogram/Histogram2: XData is BinEdges, YData is Values -Line -Scatter -Stair -Stem -Surface**: only type with CData & CDataMode * Contour plots only return data of displayed contours! (unless option \"contoursFullData\" is applied!) ** Only returns color data if CData & CDataMode are defined and CDataMode is set to 'manual' (aka user supplied data, not just a repeat of ZData) (future add option to force color?) *** If polar axes: XData contains RData values, YData contains ThetaData values. *** If lat/lon axes: XData contains LongitudeData values, YData contains LatitudeData values. **** Does NOT return symbol size or alpha data! Currently DOES NOT SUPPORT: -GeographicBubbleChart -Heatmap -Quiver -StackedAxes -StackedLineChart -WordCloudChart WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"get_graph_data.m"},{"location":"function-guide/dmp/get_graph_data_m/#get_graph_datam","text":"","title":"get_graph_data.m"},{"location":"function-guide/dmp/get_graph_data_m/#basic-information","text":"SYNTAX: get_graph_data(gObj, contoursJustLevels) PURPOSE: Exteract the data from a chart object in a figure. INPUTS: gObj: A chart object (like a line or surface) on a figure to extract the data from. See restrictions below for supported figure types. contoursJustLevels: (default=1) Option to just extract contour traces at the levels displayed in a figure, as opposed to all included data in the underlying matrix from which contours are displayed. For example: if an EFIT flux grid is in the figure, setting to 0 will include the entire flux grid in the output structure. Setting to 1 will just include the contours of flux displayed in the figure itself. OUTPUTS: ier: 0 if no failures to extract data, 1 if there was a problem (like the plot type is not supported, for example). DisplayName: The DisplayName of the chart object, if it was defined (usually defined by calling legend()). Type: The object type XData: The XData from the plotting object. If a polar plot, this corresponds to RData. If a lat-lot type plot, this corresponds to LongitudeData. YData: The YData from the plotting object. If a polar plot, this corresponds to ThetaData. If a lat-lot type plot, this corresponds to LattitudeData. ZData: The ZData from the plotting object, if it exists for this type of plot object. XNegativeDelta: For error-bars, the nagative X delta. XPositiveDelta: For error-bars, the positive X delta. YNegativeDelta: For error-bars, the nagative Y delta. YPositiveDelta: For error-bars, the positive Y delta. CData: For surface plots the color can be set to be data dependent, so it is stored if the user set the color to vary with the data. Exception: if the user set the color to just vary with the Z-data, then don't repeat this by just storing it again. RESTRICTIONS: Currently supported chart objects: -Area -Bar -Contour* -ErrorBar -Histogram/Histogram2: XData is BinEdges, YData is Values -Line -Scatter -Stair -Stem -Surface**: only type with CData & CDataMode * Contour plots only return data of displayed contours! (unless option \"contoursFullData\" is applied!) ** Only returns color data if CData & CDataMode are defined and CDataMode is set to 'manual' (aka user supplied data, not just a repeat of ZData) (future add option to force color?) *** If polar axes: XData contains RData values, YData contains ThetaData values. *** If lat/lon axes: XData contains LongitudeData values, YData contains LatitudeData values. **** Does NOT return symbol size or alpha data! Currently DOES NOT SUPPORT: -GeographicBubbleChart -Heatmap -Quiver -StackedAxes -StackedLineChart -WordCloudChart WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/save_dmp_hdf5_m/","text":"save_dmp_hdf5.m \u00b6 Basic Information \u00b6 SYNTAX: save_dmp_hdf5(hdf5_struct, alt_name, append, verbose) PURPOSE: Save a structure of the type defined by dmphdf5_struct.m as an hdf5 file of the format for the DIII-D DMP hdf5 format. INPUTS: hdf5_struct: The struct containing publication informations and figure data of the format defined in dmphdf5_struct. alt_name: By default, the hdf5 file is named following a convention set by the DIII-D DMP. This allows a user to use a different filename if they should choose. The default which is used for DIII-D DMP is: DIII-D_[AuthorLastName]_[JournalName]_[PublicationYear]_Fig[figNumber].h5 append: [default = 0] Append new datasets and update information in a pre-existing hdf5 file with the same name. Default is 0, which will delete the previouds version of the hdf5 file before creating a new one. verbose: [default = 1] Print all warnings in addition to returning them. OUTPUTS: ier: 0 if no warnings after checking the structure before saving, otherwise 1. warnings: A cell array of strings of warnings on missing fields or other problems with the structure. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"save_dmp_hdf5.m"},{"location":"function-guide/dmp/save_dmp_hdf5_m/#save_dmp_hdf5m","text":"","title":"save_dmp_hdf5.m"},{"location":"function-guide/dmp/save_dmp_hdf5_m/#basic-information","text":"SYNTAX: save_dmp_hdf5(hdf5_struct, alt_name, append, verbose) PURPOSE: Save a structure of the type defined by dmphdf5_struct.m as an hdf5 file of the format for the DIII-D DMP hdf5 format. INPUTS: hdf5_struct: The struct containing publication informations and figure data of the format defined in dmphdf5_struct. alt_name: By default, the hdf5 file is named following a convention set by the DIII-D DMP. This allows a user to use a different filename if they should choose. The default which is used for DIII-D DMP is: DIII-D_[AuthorLastName]_[JournalName]_[PublicationYear]_Fig[figNumber].h5 append: [default = 0] Append new datasets and update information in a pre-existing hdf5 file with the same name. Default is 0, which will delete the previouds version of the hdf5 file before creating a new one. verbose: [default = 1] Print all warnings in addition to returning them. OUTPUTS: ier: 0 if no warnings after checking the structure before saving, otherwise 1. warnings: A cell array of strings of warnings on missing fields or other problems with the structure. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/write_struct_to_hdf5_m/","text":"write_struct_to_hdf5.m \u00b6 Basic Information \u00b6 SYNTAX: write_struct_to_hdf5(file_name,hdf5_struct,hdf5_path) PURPOSE: Write a structure to an hdf5 file. Note that the only elements that are supported are strings, arrays (up to 2-D), and sub-structures. Structures are used to define groups in the output hdf5 file. Strings are stored as variable length strings (not attributes). INPUTS: file_name: The filename to save the hdf5 file as. hdf5_struct: The structure to be exported to hdf5 format. hdf5_path: (optional - default='/') A path in the hdf5 file denoting the top-level group under which all data is to be stored under. This function is called recursively using this option to denote moving into a lower group. OUTPUTS: None RESTRICTIONS: Note that the only elements that are supported are strings, arrays (up to 2-D), and sub-structures. Structures are used to define groups in the output hdf5 file. Strings are stored as variable length strings (not attributes). Currently breaks if trying to update a previously existing hdf5 file and any elements overlap between the old and new data. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"write_struct_to_hdf5.m"},{"location":"function-guide/dmp/write_struct_to_hdf5_m/#write_struct_to_hdf5m","text":"","title":"write_struct_to_hdf5.m"},{"location":"function-guide/dmp/write_struct_to_hdf5_m/#basic-information","text":"SYNTAX: write_struct_to_hdf5(file_name,hdf5_struct,hdf5_path) PURPOSE: Write a structure to an hdf5 file. Note that the only elements that are supported are strings, arrays (up to 2-D), and sub-structures. Structures are used to define groups in the output hdf5 file. Strings are stored as variable length strings (not attributes). INPUTS: file_name: The filename to save the hdf5 file as. hdf5_struct: The structure to be exported to hdf5 format. hdf5_path: (optional - default='/') A path in the hdf5 file denoting the top-level group under which all data is to be stored under. This function is called recursively using this option to denote moving into a lower group. OUTPUTS: None RESTRICTIONS: Note that the only elements that are supported are strings, arrays (up to 2-D), and sub-structures. Structures are used to define groups in the output hdf5 file. Strings are stored as variable length strings (not attributes). Currently breaks if trying to update a previously existing hdf5 file and any elements overlap between the old and new data. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/efit/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Matlab EFIT Area cc_efit_to_tok converts data fetched from mdsplus or gfile to toksys units efit_lp Calculate plasma inductance from gfile information efit_movie Make movie from EFIT flux data get_efit_data1 Gets data for lots of EFIT slices and plots it get_efit_profile Get EFIT current profile parametrization from esave.dat plasma_field Calculate plasma flux and field at arbitrary rpt,zpt points plot_efit Plots efit flux contours Note: Conflict with daves get_efit_data in /plasma_models 7/03 read_afile Reads a0-eqdsk file and puts variables in Matlab env read_gfile Reads g0-eqdsk file and puts variables in Matlab env read_gfile_func Same as read_gfile but function call & structure output read_gfile_tok read gfile structure for particular machines d3d,kstar... read_mds_eqdsk Return data like output of read_gfile_tok.m from mdsplus read_mds_eq_func Return data like output of read_gfile_func.m from mdsplus read_mfile_func read mfile in netcdf format into struct (ONLY for Matlab 7 V14) read_esave Read the esave.dat file (fortran mex function) run_efit Runs EFIT from inside Matlab much as EFIT runs from unix shot_from_gfile returns shot,time,dir (or tree,server) based on gfile name New Routines to extract EFIT \"eq.\" structure from MDS: (work in progress) eq_mk_time_last Modifies eq. to put time index as last index in all vectors gdata_to_eq Reads gdata from read_gfile_tok and puts into \"eq.\" structure equil_to_gdata Identical output as read_gfile_func but reads from mds+ Below eq. routines work in progress: eq_time_lim Reduces time data in sructure eq. within limits; also makes var eq_plasma_cur Generates the plasma current from flux inside eq. plasma_current Generates plasma current and current density from efit psi inside_plasma Function Determines all points inside plasma eq_ga_env Makes standard G (& later A file) variables from eq. into env. Misc EFIT scripts calc_fpcurr Emulates fpcurr in efit (ffprime calculation from polynom.) calc_ppcurr Emulates ppcurr in efit (pprime calculation from polynom.) calc_bsffel Emulates bsffel in efit (iparm'th term of poly representation) calc_bsppel Emulates bsppel in efit (iparm'th term of poly rep. of pprime) gfile_def Generates structure of EFIT gfile variable definitions test_get_efit_profile - Example for get_efit_profile.m,current reconstruction Emmanuel Joffrin's EFIT tools: fluxfun - function to extract profile data from EFIT and make flux mappings fluxmoy - called by fluxfun... isoflux - called by fluxfun...","title":"Contents.m"},{"location":"function-guide/efit/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/efit/Contents_m/#basic-information","text":"Matlab EFIT Area cc_efit_to_tok converts data fetched from mdsplus or gfile to toksys units efit_lp Calculate plasma inductance from gfile information efit_movie Make movie from EFIT flux data get_efit_data1 Gets data for lots of EFIT slices and plots it get_efit_profile Get EFIT current profile parametrization from esave.dat plasma_field Calculate plasma flux and field at arbitrary rpt,zpt points plot_efit Plots efit flux contours Note: Conflict with daves get_efit_data in /plasma_models 7/03 read_afile Reads a0-eqdsk file and puts variables in Matlab env read_gfile Reads g0-eqdsk file and puts variables in Matlab env read_gfile_func Same as read_gfile but function call & structure output read_gfile_tok read gfile structure for particular machines d3d,kstar... read_mds_eqdsk Return data like output of read_gfile_tok.m from mdsplus read_mds_eq_func Return data like output of read_gfile_func.m from mdsplus read_mfile_func read mfile in netcdf format into struct (ONLY for Matlab 7 V14) read_esave Read the esave.dat file (fortran mex function) run_efit Runs EFIT from inside Matlab much as EFIT runs from unix shot_from_gfile returns shot,time,dir (or tree,server) based on gfile name New Routines to extract EFIT \"eq.\" structure from MDS: (work in progress) eq_mk_time_last Modifies eq. to put time index as last index in all vectors gdata_to_eq Reads gdata from read_gfile_tok and puts into \"eq.\" structure equil_to_gdata Identical output as read_gfile_func but reads from mds+ Below eq. routines work in progress: eq_time_lim Reduces time data in sructure eq. within limits; also makes var eq_plasma_cur Generates the plasma current from flux inside eq. plasma_current Generates plasma current and current density from efit psi inside_plasma Function Determines all points inside plasma eq_ga_env Makes standard G (& later A file) variables from eq. into env. Misc EFIT scripts calc_fpcurr Emulates fpcurr in efit (ffprime calculation from polynom.) calc_ppcurr Emulates ppcurr in efit (pprime calculation from polynom.) calc_bsffel Emulates bsffel in efit (iparm'th term of poly representation) calc_bsppel Emulates bsppel in efit (iparm'th term of poly rep. of pprime) gfile_def Generates structure of EFIT gfile variable definitions test_get_efit_profile - Example for get_efit_profile.m,current reconstruction Emmanuel Joffrin's EFIT tools: fluxfun - function to extract profile data from EFIT and make flux mappings fluxmoy - called by fluxfun... isoflux - called by fluxfun...","title":"Basic Information"},{"location":"function-guide/efit/cc_efit_to_tok_m/","text":"cc_efit_to_tok.m \u00b6 Basic Information \u00b6 SYNTAX: equil_I = cc_efit_to_tok(vac_objs,equil_data) PURPOSE: Convert equilibrium conductor currents in internal EFIT representation (contained in equil_data) into a representation compatible with toksys environment. INPUT: vac_objs = vacuum model data object structure equil_data = equilibrium data structure idx_efit_to_tok = optional map of efit pf coil indices to toksys indices, s.t. if I=currents in efit order, then ` I(idx_efit_to_tok)=currents in toksys order idxvv_efit_to_tok = \" vv indices \" \" \" OUTPUT: (units defined by imks, iterminal in vac_objs) equil_I = structure containing: cc0t = coil current equilibrium vector, toksys conductors cc0e = coil current equilibrium vector, EFIT conductors vc0t = vessel current equilibrium vector, toksys conductors vc0e = vessel current equilibrium vector, EFIT conductors cprojet = mapping: cc0t = cprojet*cc0e cprojte = mapping: cc0e = cprojte*cc0t vprojte = mapping: vc0e = vprojte*vc0t (Equilibrium vessel currents are usually all zero. In those cases, vc0e and vprojte are not produced.)","title":"cc_efit_to_tok.m"},{"location":"function-guide/efit/cc_efit_to_tok_m/#cc_efit_to_tokm","text":"","title":"cc_efit_to_tok.m"},{"location":"function-guide/efit/cc_efit_to_tok_m/#basic-information","text":"SYNTAX: equil_I = cc_efit_to_tok(vac_objs,equil_data) PURPOSE: Convert equilibrium conductor currents in internal EFIT representation (contained in equil_data) into a representation compatible with toksys environment. INPUT: vac_objs = vacuum model data object structure equil_data = equilibrium data structure idx_efit_to_tok = optional map of efit pf coil indices to toksys indices, s.t. if I=currents in efit order, then ` I(idx_efit_to_tok)=currents in toksys order idxvv_efit_to_tok = \" vv indices \" \" \" OUTPUT: (units defined by imks, iterminal in vac_objs) equil_I = structure containing: cc0t = coil current equilibrium vector, toksys conductors cc0e = coil current equilibrium vector, EFIT conductors vc0t = vessel current equilibrium vector, toksys conductors vc0e = vessel current equilibrium vector, EFIT conductors cprojet = mapping: cc0t = cprojet*cc0e cprojte = mapping: cc0e = cprojte*cc0t vprojte = mapping: vc0e = vprojte*vc0t (Equilibrium vessel currents are usually all zero. In those cases, vc0e and vprojte are not produced.)","title":"Basic Information"},{"location":"function-guide/efit/efit_movie_m/","text":"efit_movie.m \u00b6 Basic Information \u00b6 USAGE: >>efit_movie PURPOSE: Script to display movie of EFIT flux patterns from set of EFITs. INPUTS: eqdir = string giving directory containing EFIT g-files (final character is '/', e.g. '/u/humphrys/efit/') shot = integer shot number t1ms = initial EFIT slice time (msec) t2ms = final EFIT slice time (msec) dtms = EFIT slices time interval (msec) OUTPUTS: EFIT movie displayed. RESTRICTIONS: EFIT g0-files identified by shot, t1ms, t2ms, dtms must exist in eqdir. Input variables must be defined; no defaults provided EXCEPT for eqdir, defaulted to './' (so uses default directory). METHOD:","title":"efit_movie.m"},{"location":"function-guide/efit/efit_movie_m/#efit_moviem","text":"","title":"efit_movie.m"},{"location":"function-guide/efit/efit_movie_m/#basic-information","text":"USAGE: >>efit_movie PURPOSE: Script to display movie of EFIT flux patterns from set of EFITs. INPUTS: eqdir = string giving directory containing EFIT g-files (final character is '/', e.g. '/u/humphrys/efit/') shot = integer shot number t1ms = initial EFIT slice time (msec) t2ms = final EFIT slice time (msec) dtms = EFIT slices time interval (msec) OUTPUTS: EFIT movie displayed. RESTRICTIONS: EFIT g0-files identified by shot, t1ms, t2ms, dtms must exist in eqdir. Input variables must be defined; no defaults provided EXCEPT for eqdir, defaulted to './' (so uses default directory). METHOD:","title":"Basic Information"},{"location":"function-guide/efit/eq_mod_m/","text":"eq_mod.m \u00b6 Basic Information \u00b6 SYNTAX: eqmod= eq_mod(eq); PURPOSE: Puts time index as last index of each array. INPUT: <default> eq = structure from mds_eq OUTPUT: eqmod = structure containing EFIT eqdsk variables with time last entry Example: eq.BCENTR(255,1) => eqmod.BCENTER(1,255) see also mds_eq WRITTEN BY: Jim Leuer ON 6/11/03 ========================================================================== Defaults","title":"eq_mod.m"},{"location":"function-guide/efit/eq_mod_m/#eq_modm","text":"","title":"eq_mod.m"},{"location":"function-guide/efit/eq_mod_m/#basic-information","text":"SYNTAX: eqmod= eq_mod(eq); PURPOSE: Puts time index as last index of each array. INPUT: <default> eq = structure from mds_eq OUTPUT: eqmod = structure containing EFIT eqdsk variables with time last entry Example: eq.BCENTR(255,1) => eqmod.BCENTER(1,255) see also mds_eq WRITTEN BY: Jim Leuer ON 6/11/03 ========================================================================== Defaults","title":"Basic Information"},{"location":"function-guide/efit/equil_to_gdata_m/","text":"equil_to_gdata.m \u00b6 Basic Information \u00b6 USAGE: [gdata,ireadok] = equil_to_gdata(equil, tms); USAGE: [gdata,ireadok] = equil_to_gdata(mds_string); calls read_mds_func PURPOSE: Convert equil data generated by read_mds_eq_func to read_gfile_func INPUTS: <default> equil= equilibrium data: equil=read_mds_eq_func(shot,tree,server); mds_string= optionally if equil is a string containing MDS+ tree information: format: <Server><.><tree>.shot.time Examples: 'D3D.EFIT09.g131498.02600' 'D3D.EFITRT1.131498.02600' '.g131498.02600' => 'D3D.EFIT01.g131498.02600' tms= time [ms] to use from equil data OUTPUTS: gdata = data structure containing EFIT G-file variables ireadok = flag to report good read of gfile (0=bad, 1=good) RESTRICTIONS: MDS EFIT Tree must exist for call with mds_string string convention NOTE TESTED WITH ANY MDS+ except D3D","title":"equil_to_gdata.m"},{"location":"function-guide/efit/equil_to_gdata_m/#equil_to_gdatam","text":"","title":"equil_to_gdata.m"},{"location":"function-guide/efit/equil_to_gdata_m/#basic-information","text":"USAGE: [gdata,ireadok] = equil_to_gdata(equil, tms); USAGE: [gdata,ireadok] = equil_to_gdata(mds_string); calls read_mds_func PURPOSE: Convert equil data generated by read_mds_eq_func to read_gfile_func INPUTS: <default> equil= equilibrium data: equil=read_mds_eq_func(shot,tree,server); mds_string= optionally if equil is a string containing MDS+ tree information: format: <Server><.><tree>.shot.time Examples: 'D3D.EFIT09.g131498.02600' 'D3D.EFITRT1.131498.02600' '.g131498.02600' => 'D3D.EFIT01.g131498.02600' tms= time [ms] to use from equil data OUTPUTS: gdata = data structure containing EFIT G-file variables ireadok = flag to report good read of gfile (0=bad, 1=good) RESTRICTIONS: MDS EFIT Tree must exist for call with mds_string string convention NOTE TESTED WITH ANY MDS+ except D3D","title":"Basic Information"},{"location":"function-guide/efit/get_efit_data1_m/","text":"get_efit_data1.m \u00b6 Basic Information \u00b6 SYNTAX: get_efit_data PURPOSE: Script to extract many slices of EFIT data from set of a0-eqdsk files assumed present in default directory and plot selected data. INPUT: eqdir = directory for EFIT data files (default='./'); eqdir string must end in \"/\" (eg '/users/humphrys/matlab/') shot = shot number iplot = 1 if want to plot many frames on one plot (default) = 2 if want to plot Z,R,Ip(t) on different plots = 0 to skip plotting EFIT time slices are specified using EITHER of the following methods: tmiefit = 1st efit time slice (msec) dt = delta time (msec) nslices = # of efit slices OR: tefit = vector of efit times (msec) to read from a0 files. If tefit is specified, input variables tmiefit, dt, nslices are ignored. ipltref = present figure if want to start plotting after present fig (default=0) e.g. if ipltref=2, EFIT plots start at fig 3 Currently used only for iplot=1 OUTPUT: Extracts data from a0 files and plots things.","title":"get_efit_data1.m"},{"location":"function-guide/efit/get_efit_data1_m/#get_efit_data1m","text":"","title":"get_efit_data1.m"},{"location":"function-guide/efit/get_efit_data1_m/#basic-information","text":"SYNTAX: get_efit_data PURPOSE: Script to extract many slices of EFIT data from set of a0-eqdsk files assumed present in default directory and plot selected data. INPUT: eqdir = directory for EFIT data files (default='./'); eqdir string must end in \"/\" (eg '/users/humphrys/matlab/') shot = shot number iplot = 1 if want to plot many frames on one plot (default) = 2 if want to plot Z,R,Ip(t) on different plots = 0 to skip plotting EFIT time slices are specified using EITHER of the following methods: tmiefit = 1st efit time slice (msec) dt = delta time (msec) nslices = # of efit slices OR: tefit = vector of efit times (msec) to read from a0 files. If tefit is specified, input variables tmiefit, dt, nslices are ignored. ipltref = present figure if want to start plotting after present fig (default=0) e.g. if ipltref=2, EFIT plots start at fig 3 Currently used only for iplot=1 OUTPUT: Extracts data from a0 files and plots things.","title":"Basic Information"},{"location":"function-guide/efit/gfile_def_m/","text":"gfile_def.m \u00b6 Basic Information \u00b6 SYNTAX: gdef = gfile_def PURPOSE: Produces G-file variable definition structure for inclusion in gfile structure INPUT: (none) OUTPUT: gdef = data structure containing EFIT G-file variable definitions","title":"gfile_def.m"},{"location":"function-guide/efit/gfile_def_m/#gfile_defm","text":"","title":"gfile_def.m"},{"location":"function-guide/efit/gfile_def_m/#basic-information","text":"SYNTAX: gdef = gfile_def PURPOSE: Produces G-file variable definition structure for inclusion in gfile structure INPUT: (none) OUTPUT: gdef = data structure containing EFIT G-file variable definitions","title":"Basic Information"},{"location":"function-guide/efit/inside_plasma_m/","text":"inside_plasma.m \u00b6 Basic Information \u00b6 inside_plasma sets matrix \"inside\" to 0's & 1's for outside & inside plasma SYNTAX: inside= inside_plasma(psizr, rgefit,zgefit, rbbbs,zbbbs,... psimag,psibnd, iplot,dofast); inside= inside_plasma(psirz, rgefit,zgefit, rbbbs,zbbbs); minimum input PURPOSE: set matrix \"inside\" with 0's or 1's depending if inside or outside plasma. Uses same input as typically generated by read_gfile INPUTS: <default> [optional] psizr= Flux on plasma grid in (nz,nr) array format (Wb) rgefit= Radius vector of plasma grid (m) zgefit= Z vector of plasma grid (m) rbbbs= Radius vector of closed polygon plasma boundary (m) zbbbs= Z vector of closed polygon plasma boundary (m) nbbbs= number of elements to use in rbbbs,zbbbs [psimag]= Flux on axis (Wb) <max(max(psizr))> [psibnd]= Flux on boundary (Wb) <average of psi on boundary> [iplot]= 1; plot results <0>, 2= outside plasma only [dofast]= 1; increases algorithm speed at risk of including some private flux in solution. Only extreme shapes like crescents and beans are expected to need dofast=0. Default is dofast=0 since speed is still very fast. <0> OUTPUTS: inside= Matrix of 1's & 0's for inside or outside plasma (nz,nr) RESTRICTIONS: rb,zb adjacent elements cant be identical. Not tested for coarse plasma boundary polygon mesh. METHOD: uses limits to do most screening and finally FE triangular formula","title":"inside_plasma.m"},{"location":"function-guide/efit/inside_plasma_m/#inside_plasmam","text":"","title":"inside_plasma.m"},{"location":"function-guide/efit/inside_plasma_m/#basic-information","text":"inside_plasma sets matrix \"inside\" to 0's & 1's for outside & inside plasma SYNTAX: inside= inside_plasma(psizr, rgefit,zgefit, rbbbs,zbbbs,... psimag,psibnd, iplot,dofast); inside= inside_plasma(psirz, rgefit,zgefit, rbbbs,zbbbs); minimum input PURPOSE: set matrix \"inside\" with 0's or 1's depending if inside or outside plasma. Uses same input as typically generated by read_gfile INPUTS: <default> [optional] psizr= Flux on plasma grid in (nz,nr) array format (Wb) rgefit= Radius vector of plasma grid (m) zgefit= Z vector of plasma grid (m) rbbbs= Radius vector of closed polygon plasma boundary (m) zbbbs= Z vector of closed polygon plasma boundary (m) nbbbs= number of elements to use in rbbbs,zbbbs [psimag]= Flux on axis (Wb) <max(max(psizr))> [psibnd]= Flux on boundary (Wb) <average of psi on boundary> [iplot]= 1; plot results <0>, 2= outside plasma only [dofast]= 1; increases algorithm speed at risk of including some private flux in solution. Only extreme shapes like crescents and beans are expected to need dofast=0. Default is dofast=0 since speed is still very fast. <0> OUTPUTS: inside= Matrix of 1's & 0's for inside or outside plasma (nz,nr) RESTRICTIONS: rb,zb adjacent elements cant be identical. Not tested for coarse plasma boundary polygon mesh. METHOD: uses limits to do most screening and finally FE triangular formula","title":"Basic Information"},{"location":"function-guide/efit/make_mhdindat_from_tds_m/","text":"make_mhdindat_from_tds.m \u00b6 Basic Information \u00b6 SYNTAX: make_mhdindat_from_tds(tok_data_struct,options) PURPOSE: Creates EFUND input file mhdin.dat from Toksys tok_data_struct INPUT: tok_data_struct options = structure fcid = Connections between fcoils (see cccirc in build_tokamak_system) [1:nc] use_vv = 1:Add VV elements as coils 0:Don't [0] vvid = VV element conenctions (see vvid in build_tokamamk_system) [1:nv] OUTPUT: mhdin.dat file RESTRICTIONS:","title":"make_mhdindat_from_tds.m"},{"location":"function-guide/efit/make_mhdindat_from_tds_m/#make_mhdindat_from_tdsm","text":"","title":"make_mhdindat_from_tds.m"},{"location":"function-guide/efit/make_mhdindat_from_tds_m/#basic-information","text":"SYNTAX: make_mhdindat_from_tds(tok_data_struct,options) PURPOSE: Creates EFUND input file mhdin.dat from Toksys tok_data_struct INPUT: tok_data_struct options = structure fcid = Connections between fcoils (see cccirc in build_tokamak_system) [1:nc] use_vv = 1:Add VV elements as coils 0:Don't [0] vvid = VV element conenctions (see vvid in build_tokamamk_system) [1:nv] OUTPUT: mhdin.dat file RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/efit/plasma_current_m/","text":"plasma_current.m \u00b6 Basic Information \u00b6 Function generates plasma current (pcurrt) from flux (psizr) SYNTAX: [pcur,jphi,cpasma]= plasma_current(psizr, pprime, ffprim,... psimag,psibnd,... rgefit,zgefit,... rbbbs,zbbbs,nbbbs,... iplot,dofast) PURPOSE: Generate plasma current from flux and current profile information Input is same as read_gfile input or mds_eq => eq_ga_env pcur is almost identical to that obtained using iecurr=2 in EFIT (error <~ 0.2 and max near boundary) INPUTS: [default] <optional> psizr= true flux on grid (Wb) pprime= p' vector (pprime from read_gfile) (nt/m^2)/(Vs/rad) ffprim= ff' vector (ffprim in read_gfile) (mT)^2/(Vs/rad) psimag= Flux on axis (Wb) [max(max(psizr))] psibnd= Flux on boundary (Wb) [average of flux on boundary] rgefit= Radius vector of grid (m) zgefit= Z vector of grid (m) rbbbs= Radius vector of boundary (m) zbbbs= Z vector of boundary (m) nbbbs= number of elements in rbbbs zbbbs [length(rbbbs] iplot= 2; 1= plot boundary, 2= contour jphi; 3= clabel [0] dofast= 1; increases algorithm speed at risk of including some private flux in solution. Only extreme shapes like crescents and beans are expected to need dofast=0. Default is dofast=0 since speed is still very fast. [0] <cpasma>= Plasma Current (A) OUTPUTS: pcur = plasma current on nr,nz grid [A] jphi= plasma current density on nr,nz grid [MA/m^2] cpasma= plasma current = sum(sum(pcur)) Warning messages displayed if sum(sum(pcur)) and existing cpasma are widely different. cpasma then overwritten. NOTE: ALL UNITS ARE MKS (except jphi is MA/m^2) CAUTION: Overwrites pcur, jphi & cpasma if read_gfile read from gfile RESTRICTIONS: SEE ALSO: inside_plasma","title":"plasma_current.m"},{"location":"function-guide/efit/plasma_current_m/#plasma_currentm","text":"","title":"plasma_current.m"},{"location":"function-guide/efit/plasma_current_m/#basic-information","text":"Function generates plasma current (pcurrt) from flux (psizr) SYNTAX: [pcur,jphi,cpasma]= plasma_current(psizr, pprime, ffprim,... psimag,psibnd,... rgefit,zgefit,... rbbbs,zbbbs,nbbbs,... iplot,dofast) PURPOSE: Generate plasma current from flux and current profile information Input is same as read_gfile input or mds_eq => eq_ga_env pcur is almost identical to that obtained using iecurr=2 in EFIT (error <~ 0.2 and max near boundary) INPUTS: [default] <optional> psizr= true flux on grid (Wb) pprime= p' vector (pprime from read_gfile) (nt/m^2)/(Vs/rad) ffprim= ff' vector (ffprim in read_gfile) (mT)^2/(Vs/rad) psimag= Flux on axis (Wb) [max(max(psizr))] psibnd= Flux on boundary (Wb) [average of flux on boundary] rgefit= Radius vector of grid (m) zgefit= Z vector of grid (m) rbbbs= Radius vector of boundary (m) zbbbs= Z vector of boundary (m) nbbbs= number of elements in rbbbs zbbbs [length(rbbbs] iplot= 2; 1= plot boundary, 2= contour jphi; 3= clabel [0] dofast= 1; increases algorithm speed at risk of including some private flux in solution. Only extreme shapes like crescents and beans are expected to need dofast=0. Default is dofast=0 since speed is still very fast. [0] <cpasma>= Plasma Current (A) OUTPUTS: pcur = plasma current on nr,nz grid [A] jphi= plasma current density on nr,nz grid [MA/m^2] cpasma= plasma current = sum(sum(pcur)) Warning messages displayed if sum(sum(pcur)) and existing cpasma are widely different. cpasma then overwritten. NOTE: ALL UNITS ARE MKS (except jphi is MA/m^2) CAUTION: Overwrites pcur, jphi & cpasma if read_gfile read from gfile RESTRICTIONS: SEE ALSO: inside_plasma","title":"Basic Information"},{"location":"function-guide/efit/read_afile_func_m/","text":"read_afile_func.m \u00b6 Basic Information \u00b6 USAGE: [adata,ireadok] = read_afile_func(filename,nfcoil,nesum,old_efit) PURPOSE: Read efit a-file INPUTS: <default> filename = a-file filename. Ex. 'a085352.03000' nsilop = Number of Psi loops. Default = 41 magpri = Number of mag probes. Default = 60 nfcoil = Number of fcoils. Default = 18 nesum = Number of e-coil circuits. Default = 6 OUTPUTS: adata = data structure containing EFIT A-file variables (all variables in a file with names based on EFIT convention) aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx ireadok = flag to report good read of afile (0=bad, 1=good) RESTRICTIONS: METHOD: WRITTEN BY: Luke Stagner (9/16/2020)","title":"read_afile_func.m"},{"location":"function-guide/efit/read_afile_func_m/#read_afile_funcm","text":"","title":"read_afile_func.m"},{"location":"function-guide/efit/read_afile_func_m/#basic-information","text":"USAGE: [adata,ireadok] = read_afile_func(filename,nfcoil,nesum,old_efit) PURPOSE: Read efit a-file INPUTS: <default> filename = a-file filename. Ex. 'a085352.03000' nsilop = Number of Psi loops. Default = 41 magpri = Number of mag probes. Default = 60 nfcoil = Number of fcoils. Default = 18 nesum = Number of e-coil circuits. Default = 6 OUTPUTS: adata = data structure containing EFIT A-file variables (all variables in a file with names based on EFIT convention) aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx ireadok = flag to report good read of afile (0=bad, 1=good) RESTRICTIONS: METHOD: WRITTEN BY: Luke Stagner (9/16/2020)","title":"Basic Information"},{"location":"function-guide/efit/read_afile_m/","text":"read_afile.m \u00b6 Basic Information \u00b6 read_afile.m: reads efit ASCII a file with form: A_shot#.time# produced from read_a.for in [.efit] area efit must be run with eqdsk output file set to ASCII (normal mode is binary) READ OF A______._____ FILE PRODUCED BY EFIT READS FILE: a085352.03000 by default WARNING: # OF E-COIL SEGMENTS HARDWIRED BELOW!!!!!! --------------------------------------------- Input: (Internally default to D3D values) filename= 'a085352.03000 ' = a file name nsilop= 41 = number of psi loops magpri= 60 = number of mag probes nfcoil= 18 = number of fcoils nesum= 6 = number of e-coil circuits(A,B, for d3d) Output: (all variables in a file with names based on EFIT convention) aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx","title":"read_afile.m"},{"location":"function-guide/efit/read_afile_m/#read_afilem","text":"","title":"read_afile.m"},{"location":"function-guide/efit/read_afile_m/#basic-information","text":"read_afile.m: reads efit ASCII a file with form: A_shot#.time# produced from read_a.for in [.efit] area efit must be run with eqdsk output file set to ASCII (normal mode is binary) READ OF A______._____ FILE PRODUCED BY EFIT READS FILE: a085352.03000 by default WARNING: # OF E-COIL SEGMENTS HARDWIRED BELOW!!!!!! --------------------------------------------- Input: (Internally default to D3D values) filename= 'a085352.03000 ' = a file name nsilop= 41 = number of psi loops magpri= 60 = number of mag probes nfcoil= 18 = number of fcoils nesum= 6 = number of e-coil circuits(A,B, for d3d) Output: (all variables in a file with names based on EFIT convention) aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx","title":"Basic Information"},{"location":"function-guide/efit/read_eq_m/","text":"read_eq.m \u00b6 Basic Information \u00b6 USAGE: eq = read_eq(shot,times,source,tokamak) PURPOSE: Read equilibrium data from many possible sources and make structure according to toksys convention. Implemented sources are: 1. mds 2. A directory with efit g-files 3. A directory with corsica flat files INPUTS: shot is the shot number (no surprise there) times: times to fetch [sec] If empty or 'all' then all equilibria are fetched If single time specified, closest available time fetched If two times are specified they are tmin and tmax If >2 times are specified, only those exact times are fetched source: mds tree or directory with g files or directory with corsica flatfiles If source begins with a '/' it is a directory name, otherwise mds tree If server is 'corsica', source should contain flatfiles by create_corsica_flat_files tokamak: name of the tokamak, default 'DIII-D' server: optional mds server name. Default is standard mds server for tokamak. Use 'local' for data from GA test server (currently soas). OUTPUTS: eq = equilibrium data on toksys form, that can be used with cc_efit_to_tok and build_tokamak_system neq = number of equilibria returned eqraw = 'raw' eq data on original form before conversion to toksys convention RESTRICTIONS: Needs modification to work with Corsica files for tokamaks other than ITER METHOD:","title":"read_eq.m"},{"location":"function-guide/efit/read_eq_m/#read_eqm","text":"","title":"read_eq.m"},{"location":"function-guide/efit/read_eq_m/#basic-information","text":"USAGE: eq = read_eq(shot,times,source,tokamak) PURPOSE: Read equilibrium data from many possible sources and make structure according to toksys convention. Implemented sources are: 1. mds 2. A directory with efit g-files 3. A directory with corsica flat files INPUTS: shot is the shot number (no surprise there) times: times to fetch [sec] If empty or 'all' then all equilibria are fetched If single time specified, closest available time fetched If two times are specified they are tmin and tmax If >2 times are specified, only those exact times are fetched source: mds tree or directory with g files or directory with corsica flatfiles If source begins with a '/' it is a directory name, otherwise mds tree If server is 'corsica', source should contain flatfiles by create_corsica_flat_files tokamak: name of the tokamak, default 'DIII-D' server: optional mds server name. Default is standard mds server for tokamak. Use 'local' for data from GA test server (currently soas). OUTPUTS: eq = equilibrium data on toksys form, that can be used with cc_efit_to_tok and build_tokamak_system neq = number of equilibria returned eqraw = 'raw' eq data on original form before conversion to toksys convention RESTRICTIONS: Needs modification to work with Corsica files for tokamaks other than ITER METHOD:","title":"Basic Information"},{"location":"function-guide/efit/read_gfile_func_m/","text":"read_gfile_func.m \u00b6 Basic Information \u00b6 USAGE: [gdata,ireadok] = read_gfile_func(filename,nfcoil,nesum,old_efit) [gdata,ireadok] = read_gfile_func(mds_string, ...); NEW MDS+ OPTION PURPOSE: Read efit ASCII g-eqdsk file w/ flag iecurr=2 set INPUTS: <default> filename = gfile filename [Ex: '/u/leuer/efit/diiid/s87977/g087977.02620'] nfcoil = number of F-coils <18 for DIII-D> nesum = number of E-coils <6 for DIII-D> old_efit= For iecurr=2 several different flavors of efit output exists. <Optional, default=0> For old versions of efit (e.g. NSTX) use old_efit=1 since it uses older efit version. NEW MDS READ OPTION: If directory of filename not found then looks in mds mds_string= string: Server.tree.shot.time [ex: 'D3D.EFIT01.g131498.02600'] OUTPUTS: gdata = data structure containing EFIT G-file variables ireadok = flag to report good read of gfile (0=bad, 1=good) RESTRICTIONS: gfile must be produced by EFIT run with flag iecurr=2 in order to write current density distribution on plasma grid & coil currents. (NEW versions of EFIT use iplcout=2 instead of iecurr)","title":"read_gfile_func.m"},{"location":"function-guide/efit/read_gfile_func_m/#read_gfile_funcm","text":"","title":"read_gfile_func.m"},{"location":"function-guide/efit/read_gfile_func_m/#basic-information","text":"USAGE: [gdata,ireadok] = read_gfile_func(filename,nfcoil,nesum,old_efit) [gdata,ireadok] = read_gfile_func(mds_string, ...); NEW MDS+ OPTION PURPOSE: Read efit ASCII g-eqdsk file w/ flag iecurr=2 set INPUTS: <default> filename = gfile filename [Ex: '/u/leuer/efit/diiid/s87977/g087977.02620'] nfcoil = number of F-coils <18 for DIII-D> nesum = number of E-coils <6 for DIII-D> old_efit= For iecurr=2 several different flavors of efit output exists. <Optional, default=0> For old versions of efit (e.g. NSTX) use old_efit=1 since it uses older efit version. NEW MDS READ OPTION: If directory of filename not found then looks in mds mds_string= string: Server.tree.shot.time [ex: 'D3D.EFIT01.g131498.02600'] OUTPUTS: gdata = data structure containing EFIT G-file variables ireadok = flag to report good read of gfile (0=bad, 1=good) RESTRICTIONS: gfile must be produced by EFIT run with flag iecurr=2 in order to write current density distribution on plasma grid & coil currents. (NEW versions of EFIT use iplcout=2 instead of iecurr)","title":"Basic Information"},{"location":"function-guide/efit/read_gfile_m/","text":"read_gfile.m \u00b6 Basic Information \u00b6 USAGE: >>read_gfile PURPOSE: Script to read efit ASCII g-eqdsk file w/ flag iecurr=2 set INPUTS: [default] filename = ['g083750.04838']; g0-eqdsk filename - Can contain directory nfcoil = [18]; # of F-coils; must be specified for non-D3D (Optional) defaults to D3D values of nfcoil=18 nesum = [6]; # of E-coils; must be specified for non-D3D (Optional) defaults to D3D value of nesum=6 (for > 6seg case) old_efit=[0]; For iecurr=2 several different flavors of efit output exists. (Optional) For old versions of efit (i.e. NSTX) you want old_efit=1 since they use older efit version. OUTPUTS: (Produces large set of data objects from g0-file in Matlab environment.) ireadok = flag to report good read of gfile (0=bad, 1=good) jphi=current density on grid MA/m^2 psizr = true total flux on grid in Wb psimag = axis flux in true Wb psibnd = boundary flux in true Wb (psibry also defined same) cc = E/F coil currents in MA-turns cc2 = E/F coil currents in MA-turns (for 2-segment E-coil) CAUTION: cc2 has min(2,nesum) E-coil elements (could be 1 vs std: 2) RESTRICTIONS: g0 file must be produced by EFIT run with flag iecurr=2 in order to write current density distribution on grid. Must set nesum to correct number of e-coil segments at top of file. May overwrite some data objects in D3D environment from load_d3denv. METHOD: Follows write/read format of EFIT file weqdskx.for, reads usual g-file data, reads coil current and jphi data (if iecurr was set =2 in EFIT run), defines some flux variables and converts some variables to D3D Matlab data environment standards.","title":"read_gfile.m"},{"location":"function-guide/efit/read_gfile_m/#read_gfilem","text":"","title":"read_gfile.m"},{"location":"function-guide/efit/read_gfile_m/#basic-information","text":"USAGE: >>read_gfile PURPOSE: Script to read efit ASCII g-eqdsk file w/ flag iecurr=2 set INPUTS: [default] filename = ['g083750.04838']; g0-eqdsk filename - Can contain directory nfcoil = [18]; # of F-coils; must be specified for non-D3D (Optional) defaults to D3D values of nfcoil=18 nesum = [6]; # of E-coils; must be specified for non-D3D (Optional) defaults to D3D value of nesum=6 (for > 6seg case) old_efit=[0]; For iecurr=2 several different flavors of efit output exists. (Optional) For old versions of efit (i.e. NSTX) you want old_efit=1 since they use older efit version. OUTPUTS: (Produces large set of data objects from g0-file in Matlab environment.) ireadok = flag to report good read of gfile (0=bad, 1=good) jphi=current density on grid MA/m^2 psizr = true total flux on grid in Wb psimag = axis flux in true Wb psibnd = boundary flux in true Wb (psibry also defined same) cc = E/F coil currents in MA-turns cc2 = E/F coil currents in MA-turns (for 2-segment E-coil) CAUTION: cc2 has min(2,nesum) E-coil elements (could be 1 vs std: 2) RESTRICTIONS: g0 file must be produced by EFIT run with flag iecurr=2 in order to write current density distribution on grid. Must set nesum to correct number of e-coil segments at top of file. May overwrite some data objects in D3D environment from load_d3denv. METHOD: Follows write/read format of EFIT file weqdskx.for, reads usual g-file data, reads coil current and jphi data (if iecurr was set =2 in EFIT run), defines some flux variables and converts some variables to D3D Matlab data environment standards.","title":"Basic Information"},{"location":"function-guide/efit/read_gfile_tok_m/","text":"read_gfile_tok.m \u00b6 Basic Information \u00b6 USAGE: gfile_data = ... read_gfile_tok(filename,tokamak,nfcoil,nesum,nves,old_efit,cc_file) gfile_data = read_gfile_tok(filename); default DIII-D read PURPOSE: Read efit ASCII g-eqdsk file for specific tokamak. INPUTS: <default> filename= g0-eqdsk filename (printed with iecurr=2 or iplcout=1) Note: filename= gShot.Time name is parced to get shot number tokamak = one of 'DIII-D','d3d','NSTX','EAST','KSTAR','ITER','CTF' PEGASUS, (Not CASE sensitive so DIII-D <=> diii-d) if not one of above then need nfcoil,nesum,... <'DIII-D'>) nfcoil = number of F-coils <default specific to each machine - below> nesum = number of E-coils <default specific to each machine - below> nves = number of vessel elements included in efit data <defaults below> old_efit= For iecurr=2 several different flavors of efit output exists. (Optional, default=0) For old versions of efit (e.g. NSTX) use old_efit=1 since it uses older efit version. cc_file= coil current file name [cc=load(cc_file)] or coil current vector use when coil currents not available from efit (or to override) (units = MA-turns) Current Machine Defaults: (Default tokamak is DIII-D) Tokamak nfcoil nesum nves old_efit Size(cc) Note DIII-D 18 6 0 0 18+6=24 6-seg E-coil NSTX 11 1 30 1 41+1=42 1E+11F+30VV after shot 115265, April 2 2005 set old_efit=0 or shot#>=115265 NSTX 17 1 35 1 1+17+35=42 1E+17F+35VV NSTX internally switches on shot # determined from gfile name ex: /g120423.00533 => shot= 120423 => old_efit=0 KSTAR 14 1 0 0 14+4=18 no E; 4IC's sab10 14 1 60+24 0 14+4=18 12 VV Groups rtefit 18 1 60+10 0 18 ic included 33x33 14VCefit EAST 12 1 0 0 14 no E; IC's? CTF 14 1 24 0 14 NO E; FDF 14 0 24 0 14 NO E; FDF2009? 22 0 24 0 22 FDF2011 PEGASUS 17 1 0 0 17 ITER 12 1 113 0 12 NO E HL2M 16 1 24 0 16 1E other nfcoil nesum 0 0 nfcoil+nesum need coil #'s Note: Including nfcoil, nesum ... in argument list with a particular machine overrides the machine default numbers Note: filename= \"..../gShot.Time\" format is parced to get shot number if needed to differentiate between machine configurations (i.e. NSTX) OUTPUTS: gfile_data = structure containing data read directly from g-file and variables derived from this original data. RESTRICTIONS: g0 file must be produced by EFIT run with flag iecurr=2 or iplcout=1 in order to write current density distribution on grid and coil cc's","title":"read_gfile_tok.m"},{"location":"function-guide/efit/read_gfile_tok_m/#read_gfile_tokm","text":"","title":"read_gfile_tok.m"},{"location":"function-guide/efit/read_gfile_tok_m/#basic-information","text":"USAGE: gfile_data = ... read_gfile_tok(filename,tokamak,nfcoil,nesum,nves,old_efit,cc_file) gfile_data = read_gfile_tok(filename); default DIII-D read PURPOSE: Read efit ASCII g-eqdsk file for specific tokamak. INPUTS: <default> filename= g0-eqdsk filename (printed with iecurr=2 or iplcout=1) Note: filename= gShot.Time name is parced to get shot number tokamak = one of 'DIII-D','d3d','NSTX','EAST','KSTAR','ITER','CTF' PEGASUS, (Not CASE sensitive so DIII-D <=> diii-d) if not one of above then need nfcoil,nesum,... <'DIII-D'>) nfcoil = number of F-coils <default specific to each machine - below> nesum = number of E-coils <default specific to each machine - below> nves = number of vessel elements included in efit data <defaults below> old_efit= For iecurr=2 several different flavors of efit output exists. (Optional, default=0) For old versions of efit (e.g. NSTX) use old_efit=1 since it uses older efit version. cc_file= coil current file name [cc=load(cc_file)] or coil current vector use when coil currents not available from efit (or to override) (units = MA-turns) Current Machine Defaults: (Default tokamak is DIII-D) Tokamak nfcoil nesum nves old_efit Size(cc) Note DIII-D 18 6 0 0 18+6=24 6-seg E-coil NSTX 11 1 30 1 41+1=42 1E+11F+30VV after shot 115265, April 2 2005 set old_efit=0 or shot#>=115265 NSTX 17 1 35 1 1+17+35=42 1E+17F+35VV NSTX internally switches on shot # determined from gfile name ex: /g120423.00533 => shot= 120423 => old_efit=0 KSTAR 14 1 0 0 14+4=18 no E; 4IC's sab10 14 1 60+24 0 14+4=18 12 VV Groups rtefit 18 1 60+10 0 18 ic included 33x33 14VCefit EAST 12 1 0 0 14 no E; IC's? CTF 14 1 24 0 14 NO E; FDF 14 0 24 0 14 NO E; FDF2009? 22 0 24 0 22 FDF2011 PEGASUS 17 1 0 0 17 ITER 12 1 113 0 12 NO E HL2M 16 1 24 0 16 1E other nfcoil nesum 0 0 nfcoil+nesum need coil #'s Note: Including nfcoil, nesum ... in argument list with a particular machine overrides the machine default numbers Note: filename= \"..../gShot.Time\" format is parced to get shot number if needed to differentiate between machine configurations (i.e. NSTX) OUTPUTS: gfile_data = structure containing data read directly from g-file and variables derived from this original data. RESTRICTIONS: g0 file must be produced by EFIT run with flag iecurr=2 or iplcout=1 in order to write current density distribution on grid and coil cc's","title":"Basic Information"},{"location":"function-guide/efit/read_mds_eq_func_m/","text":"read_mds_eq_func.m \u00b6 Basic Information \u00b6 SYNTAX: [equil,neq,eq,ier] = read_mds_eq_func(shotnum,tree,server) PURPOSE: Generic read of geqdsk and aeqdsk data, returning data in approximately the same form as read_gfile_func.m. (data needed from aeqdsk not well-defined yet) INPUT: <default> shotnum = shot number tree = mdsplus tree containing efit data server = mdsplus server name verbose= 1; print out progressive info. during MDS READ, 0=no print <[]> OUTPUT: equil = structure containing: gdef = text description of variables shotnum = shot number of equilibria time = array of times of equilibria gdata = array of structures containing geqdsk data (same data produced by read_equil_func) adata = array of structureus containing aeqdsk data neq = number of equilibria found eq = equilibrium structure returned by get_mds_tree ier = error code RESTRICTIONS: The bzero and ecase entries of equil.gdata are empty.","title":"read_mds_eq_func.m"},{"location":"function-guide/efit/read_mds_eq_func_m/#read_mds_eq_funcm","text":"","title":"read_mds_eq_func.m"},{"location":"function-guide/efit/read_mds_eq_func_m/#basic-information","text":"SYNTAX: [equil,neq,eq,ier] = read_mds_eq_func(shotnum,tree,server) PURPOSE: Generic read of geqdsk and aeqdsk data, returning data in approximately the same form as read_gfile_func.m. (data needed from aeqdsk not well-defined yet) INPUT: <default> shotnum = shot number tree = mdsplus tree containing efit data server = mdsplus server name verbose= 1; print out progressive info. during MDS READ, 0=no print <[]> OUTPUT: equil = structure containing: gdef = text description of variables shotnum = shot number of equilibria time = array of times of equilibria gdata = array of structures containing geqdsk data (same data produced by read_equil_func) adata = array of structureus containing aeqdsk data neq = number of equilibria found eq = equilibrium structure returned by get_mds_tree ier = error code RESTRICTIONS: The bzero and ecase entries of equil.gdata are empty.","title":"Basic Information"},{"location":"function-guide/efit/read_mds_eqdsk_m/","text":"read_mds_eqdsk.m \u00b6 Basic Information \u00b6 SYNTAX: [eqdata,neq,eq,ier] = read_mds_eqdsk(shotnum,times,efit_source,tokamak,server) PURPOSE: Read geqdsk and aeqdsk data from mdsplus, return data like read_gfile_tok.m. (data needed from aeqdsk not well-defined yet) INPUT: <default> shotnum = shot number times = equilibrium time(s), one of: if single float#: closest time available in mds (s) if pair [t1,t2]: times between t1 and t2 (s) if 'all': return all times in tree <'ALL'> efit_source = source tree for EFIT (e.g. <'EFIT01'>, 'EFITRT1') tokamak = tokamak name. <DIII-D> server = optional server name. Default is to use standard mds server for tokamak. Use 'local' to get data from the GA test server (currently vidar). OUTPUT: eqdata = array of structures, each containing info from 1 eqdsk (single time causes structure returned to be like read_gfile_tok; others return extended structures) neq = number of eqdsk's returned eq = entire tree containing efit equilibrium data ier = error code RESTRICTIONS: Only handles D3D, EAST, KSTAR, and NSTX(EFITRT only) right now. Need to add code for the other devices supported by read_gfile_tok.m.","title":"read_mds_eqdsk.m"},{"location":"function-guide/efit/read_mds_eqdsk_m/#read_mds_eqdskm","text":"","title":"read_mds_eqdsk.m"},{"location":"function-guide/efit/read_mds_eqdsk_m/#basic-information","text":"SYNTAX: [eqdata,neq,eq,ier] = read_mds_eqdsk(shotnum,times,efit_source,tokamak,server) PURPOSE: Read geqdsk and aeqdsk data from mdsplus, return data like read_gfile_tok.m. (data needed from aeqdsk not well-defined yet) INPUT: <default> shotnum = shot number times = equilibrium time(s), one of: if single float#: closest time available in mds (s) if pair [t1,t2]: times between t1 and t2 (s) if 'all': return all times in tree <'ALL'> efit_source = source tree for EFIT (e.g. <'EFIT01'>, 'EFITRT1') tokamak = tokamak name. <DIII-D> server = optional server name. Default is to use standard mds server for tokamak. Use 'local' to get data from the GA test server (currently vidar). OUTPUT: eqdata = array of structures, each containing info from 1 eqdsk (single time causes structure returned to be like read_gfile_tok; others return extended structures) neq = number of eqdsk's returned eq = entire tree containing efit equilibrium data ier = error code RESTRICTIONS: Only handles D3D, EAST, KSTAR, and NSTX(EFITRT only) right now. Need to add code for the other devices supported by read_gfile_tok.m.","title":"Basic Information"},{"location":"function-guide/efit/read_mds_g_func_m/","text":"read_mds_g_func.m \u00b6 Basic Information \u00b6 SYNTAX: [gfile,neq,eq] = read_mds_g_func(shotnum,tree,server) PURPOSE: Read geqdsk generic function, returning data in approximately the same form as read_gfile_func.m. INPUT: shotnum = shot number tree = mdsplus tree containing efit data server = mdsplus server name OUTPUT: gfile = structure containing: gdef = text description of variables shotnum = shot number of equilibria time = array of times of equilibria data = array of structures containing data (same data produced by read_gfile_func) neq = number of equilibria found eq = equilibrium structure returned by eq_mds RESTRICTIONS: The bzero and ecase entries of gfile.data are empty.","title":"read_mds_g_func.m"},{"location":"function-guide/efit/read_mds_g_func_m/#read_mds_g_funcm","text":"","title":"read_mds_g_func.m"},{"location":"function-guide/efit/read_mds_g_func_m/#basic-information","text":"SYNTAX: [gfile,neq,eq] = read_mds_g_func(shotnum,tree,server) PURPOSE: Read geqdsk generic function, returning data in approximately the same form as read_gfile_func.m. INPUT: shotnum = shot number tree = mdsplus tree containing efit data server = mdsplus server name OUTPUT: gfile = structure containing: gdef = text description of variables shotnum = shot number of equilibria time = array of times of equilibria data = array of structures containing data (same data produced by read_gfile_func) neq = number of equilibria found eq = equilibrium structure returned by eq_mds RESTRICTIONS: The bzero and ecase entries of gfile.data are empty.","title":"Basic Information"},{"location":"function-guide/efit/read_mhdin_m/","text":"read_mhdin.m \u00b6 Basic Information \u00b6 USAGE: >>read_mhdin PURPOSE: reads efit file mhdin.dat. All variables are added in UPPER CASE INPUTS: [default] filename = ['mhdin.dat']; EFIT mhdin.dat file name Can contain directory Note: below dimensions are needed only if geometry is read below namelist defaults for D3D nfcoil = [18]; # of F-coils; must be specified for non-D3D (Opt.) defaults to D3D values of nfcoil=18 necoil = [122]; # number of E-coils elements specify for non-D3D (Opt.) defaults to D3D value of nesum=6 nsilop = [41]; # flux loops, needed if not read in namelist (opt.) nvesel = [24]; # vessels, needed if not read in namelist (opt.) OUTPUTS: all name list items: IGRID, RLEFT, RRIGHT, ... FCID, FCTURN, ... PF coil geometry if nfcoil>0, E-coil geometry if nesum>0 ireadok = flag to report good read of gfile (0=bad, 1=good) CAUTION: Namelist is read with to_upper=+1 which makes all variables UPPER CASE. New read_namelist in /thor/leuer/matlab/util/read_namelist.m allows change of case. We want to read and make all variables UC To change UPPER CASE to lower case use: mhdin_list= mk_uc_lc_var; makes all lower case variables (nothing to UPCASE) mhdin_list= mk_uc_lc_var('-remove_upper','*'); remove upper case","title":"read_mhdin.m"},{"location":"function-guide/efit/read_mhdin_m/#read_mhdinm","text":"","title":"read_mhdin.m"},{"location":"function-guide/efit/read_mhdin_m/#basic-information","text":"USAGE: >>read_mhdin PURPOSE: reads efit file mhdin.dat. All variables are added in UPPER CASE INPUTS: [default] filename = ['mhdin.dat']; EFIT mhdin.dat file name Can contain directory Note: below dimensions are needed only if geometry is read below namelist defaults for D3D nfcoil = [18]; # of F-coils; must be specified for non-D3D (Opt.) defaults to D3D values of nfcoil=18 necoil = [122]; # number of E-coils elements specify for non-D3D (Opt.) defaults to D3D value of nesum=6 nsilop = [41]; # flux loops, needed if not read in namelist (opt.) nvesel = [24]; # vessels, needed if not read in namelist (opt.) OUTPUTS: all name list items: IGRID, RLEFT, RRIGHT, ... FCID, FCTURN, ... PF coil geometry if nfcoil>0, E-coil geometry if nesum>0 ireadok = flag to report good read of gfile (0=bad, 1=good) CAUTION: Namelist is read with to_upper=+1 which makes all variables UPPER CASE. New read_namelist in /thor/leuer/matlab/util/read_namelist.m allows change of case. We want to read and make all variables UC To change UPPER CASE to lower case use: mhdin_list= mk_uc_lc_var; makes all lower case variables (nothing to UPCASE) mhdin_list= mk_uc_lc_var('-remove_upper','*'); remove upper case","title":"Basic Information"},{"location":"function-guide/efit/run_efit_m/","text":"run_efit.m \u00b6 Basic Information \u00b6 SYNTAX: run_efit(shot,tims,dtms,nslices,snap,snapidx,efitver,efitdir) PURPOSE: Run EFIT from inside Matlab: uses basic input format just as in standard invokation from command line (so will perform many slices as usual with starting time, delta time, nslices). INPUTS: shot = shot number tims = starting time (in ms) at which to calculate EFIT dtms = delta time (in ms) between each slice nslices = # of slices to calculate snap = (optional) string specifying: if snapidx=2: data file to read input data from if snapidx=3: use snap file in default directory (or in /link) if snapidx=7: snap file extension (eg 'jta_t') snapidx = (optional) EFIT input mode (2=input file, 3=snap file) Default=3 (used if nargin<6). Note if snapidx=2, the shot, tims,dtms,nslices inputs are ignored, and snap specifies the input file to use. efitver = (optional) string specifying EFIT version (eg 'efitd65yd' or 'efitd6565d') efitdir = (optional) string specifying directory in which EFIT version is to be found (default = /link/efit/ or /d/linux/efit/) OUTPUTS: None RESTRICTIONS: METHOD: Uses Matlab unix() command to execute command string built in this function for desired inputs.","title":"run_efit.m"},{"location":"function-guide/efit/run_efit_m/#run_efitm","text":"","title":"run_efit.m"},{"location":"function-guide/efit/run_efit_m/#basic-information","text":"SYNTAX: run_efit(shot,tims,dtms,nslices,snap,snapidx,efitver,efitdir) PURPOSE: Run EFIT from inside Matlab: uses basic input format just as in standard invokation from command line (so will perform many slices as usual with starting time, delta time, nslices). INPUTS: shot = shot number tims = starting time (in ms) at which to calculate EFIT dtms = delta time (in ms) between each slice nslices = # of slices to calculate snap = (optional) string specifying: if snapidx=2: data file to read input data from if snapidx=3: use snap file in default directory (or in /link) if snapidx=7: snap file extension (eg 'jta_t') snapidx = (optional) EFIT input mode (2=input file, 3=snap file) Default=3 (used if nargin<6). Note if snapidx=2, the shot, tims,dtms,nslices inputs are ignored, and snap specifies the input file to use. efitver = (optional) string specifying EFIT version (eg 'efitd65yd' or 'efitd6565d') efitdir = (optional) string specifying directory in which EFIT version is to be found (default = /link/efit/ or /d/linux/efit/) OUTPUTS: None RESTRICTIONS: METHOD: Uses Matlab unix() command to execute command string built in this function for desired inputs.","title":"Basic Information"},{"location":"function-guide/efit/shot_from_gfile_m/","text":"shot_from_gfile.m \u00b6 Basic Information \u00b6 SYNTAX: [shot,tms,dr] = shot_from_gfile(gfile) pointer to file [shot,tms,tree,server] = shot_from_gfile(gfile) pointer to MDS+ tree PURPOSE: look at string in gfile name and extract shot, tms, etc INPUT: <default> gfile = string contining gfile name or \"dot\" pointer to MDS tree ex: '/u/leuer/efit/d3d/shot131498/g131498.02000' file pointer 'D3D.EFITRT1.g131498.02000' MDS+ pointer OUTPUT: <default> shot = shot number tms = shot time [ms] dr = directory if pointer to gfile tree = EFIT Tree if pointer to MDS tree <'EFIT01'> server= MDS server for efit data <'D3D'>","title":"shot_from_gfile.m"},{"location":"function-guide/efit/shot_from_gfile_m/#shot_from_gfilem","text":"","title":"shot_from_gfile.m"},{"location":"function-guide/efit/shot_from_gfile_m/#basic-information","text":"SYNTAX: [shot,tms,dr] = shot_from_gfile(gfile) pointer to file [shot,tms,tree,server] = shot_from_gfile(gfile) pointer to MDS+ tree PURPOSE: look at string in gfile name and extract shot, tms, etc INPUT: <default> gfile = string contining gfile name or \"dot\" pointer to MDS tree ex: '/u/leuer/efit/d3d/shot131498/g131498.02000' file pointer 'D3D.EFITRT1.g131498.02000' MDS+ pointer OUTPUT: <default> shot = shot number tms = shot time [ms] dr = directory if pointer to gfile tree = EFIT Tree if pointer to MDS tree <'EFIT01'> server= MDS server for efit data <'D3D'>","title":"Basic Information"},{"location":"function-guide/efit/std_efit_units_m/","text":"std_efit_units.m \u00b6 Basic Information \u00b6 SYNTAX: gfile_data = std_efit_units(gdata,tokamak) PURPOSE: Do device-dependent conversions of eqdsk data to a common set of units and conventions. INPUT: gdata = structure containing g eqdsk data tokamak = name of device options = parameters needed to customize logic for a particular device OUTPUT: gfile_data = structure containing g eqdsk data with standard units (i.e., MA-turns)","title":"std_efit_units.m"},{"location":"function-guide/efit/std_efit_units_m/#std_efit_unitsm","text":"","title":"std_efit_units.m"},{"location":"function-guide/efit/std_efit_units_m/#basic-information","text":"SYNTAX: gfile_data = std_efit_units(gdata,tokamak) PURPOSE: Do device-dependent conversions of eqdsk data to a common set of units and conventions. INPUT: gdata = structure containing g eqdsk data tokamak = name of device options = parameters needed to customize logic for a particular device OUTPUT: gfile_data = structure containing g eqdsk data with standard units (i.e., MA-turns)","title":"Basic Information"},{"location":"function-guide/efit/trace_boundary_m/","text":"trace_boundary.m \u00b6 Basic Information \u00b6 USAGE: [rb,zb,rx,zx,ra,za,r0,z0,ilimited,psimag,psibry]=trace_boundary(psizr,rg,zg,limdata) PURPOSE: Find boundary INPUTS: psizr OUTPUTS: Coordinates of boundary: rb, zb Coordinates of x or touch point: r0,z0 Coordinates of axis: ra, za RESTRICTIONS: METHOD:","title":"trace_boundary.m"},{"location":"function-guide/efit/trace_boundary_m/#trace_boundarym","text":"","title":"trace_boundary.m"},{"location":"function-guide/efit/trace_boundary_m/#basic-information","text":"USAGE: [rb,zb,rx,zx,ra,za,r0,z0,ilimited,psimag,psibry]=trace_boundary(psizr,rg,zg,limdata) PURPOSE: Find boundary INPUTS: psizr OUTPUTS: Coordinates of boundary: rb, zb Coordinates of x or touch point: r0,z0 Coordinates of axis: ra, za RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/efit/write_afile_m/","text":"write_afile.m \u00b6 Basic Information \u00b6 USAGE: write_afile(equil,eqversion,aday) PURPOSE: write afiles INPUTS: equil: equilibrium on the toksys format (that is returned by read_mds_eqdsk) eqversion: (optional) source of equilibrium (default is TOKSYS) aday: (optional) the date the equilibrium was created OUTPUTS: afiles to disk A-EQDSK File Variables aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx RESTRICTIONS: VERSION @(#)write_afile.m 1.3 10/09/14 WRITTEN BY: Anders Welander ON 6/1/11 MODIFICATION HISTORY: Luke Stagner ON 9/28/2020","title":"write_afile.m"},{"location":"function-guide/efit/write_afile_m/#write_afilem","text":"","title":"write_afile.m"},{"location":"function-guide/efit/write_afile_m/#basic-information","text":"USAGE: write_afile(equil,eqversion,aday) PURPOSE: write afiles INPUTS: equil: equilibrium on the toksys format (that is returned by read_mds_eqdsk) eqversion: (optional) source of equilibrium (default is TOKSYS) aday: (optional) the date the equilibrium was created OUTPUTS: afiles to disk A-EQDSK File Variables aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx RESTRICTIONS: VERSION @(#)write_afile.m 1.3 10/09/14 WRITTEN BY: Anders Welander ON 6/1/11 MODIFICATION HISTORY: Luke Stagner ON 9/28/2020","title":"Basic Information"},{"location":"function-guide/efit/write_cc_file_m/","text":"write_cc_file.m \u00b6 Basic Information \u00b6 USAGE: [cc_filename,ier] = write_cc_file(equilibria); PURPOSE: return absolute path to newly generated cc_file INPUTS: filename:name of geqdsk file OUTPUTS: cc_filename: string containing name of cc_file RESTRICTIONS: METHOD: cc_file= coil current file name [cc=load(cc_file)] or coil current vector use when coil currents not available from efit (or to override) ohmic coil current is first, then poloidal shaping currents (units = MA-turns) WRITTEN BY: Matthew J. Lanctot","title":"write_cc_file.m"},{"location":"function-guide/efit/write_cc_file_m/#write_cc_filem","text":"","title":"write_cc_file.m"},{"location":"function-guide/efit/write_cc_file_m/#basic-information","text":"USAGE: [cc_filename,ier] = write_cc_file(equilibria); PURPOSE: return absolute path to newly generated cc_file INPUTS: filename:name of geqdsk file OUTPUTS: cc_filename: string containing name of cc_file RESTRICTIONS: METHOD: cc_file= coil current file name [cc=load(cc_file)] or coil current vector use when coil currents not available from efit (or to override) ohmic coil current is first, then poloidal shaping currents (units = MA-turns) WRITTEN BY: Matthew J. Lanctot","title":"Basic Information"},{"location":"function-guide/efit/write_eqdsk_m/","text":"write_eqdsk.m \u00b6 Basic Information \u00b6 USAGE: [equilibria, neq, eqraw] = write_eqdsk(shotnum,tefit,efit_source,tokamak,write_cc) PURPOSE: Retrieves eqdsk data from MDS and saves g,a files to dir INPUTS: shotnum: Shotnumber for equilibrium eg. 146970 tefit: time of efit, can be two element array specifying time range as in read_eq efit_source: EFIT source eg. 'EFIT01' tokamak: device name eg. 'd3d' OUTPUTS: eq = equilibrium data on toksys form, that can be used with cc_efit_to_tok and build_tokamak_system neq = number of equilibria returned eqraw = 'raw' eq data on original form before conversion to toksys convention RESTRICTIONS: METHOD: WRITTEN BY: Matthew J. Lanctot MODIFICATION HISTORY:","title":"write_eqdsk.m"},{"location":"function-guide/efit/write_eqdsk_m/#write_eqdskm","text":"","title":"write_eqdsk.m"},{"location":"function-guide/efit/write_eqdsk_m/#basic-information","text":"USAGE: [equilibria, neq, eqraw] = write_eqdsk(shotnum,tefit,efit_source,tokamak,write_cc) PURPOSE: Retrieves eqdsk data from MDS and saves g,a files to dir INPUTS: shotnum: Shotnumber for equilibrium eg. 146970 tefit: time of efit, can be two element array specifying time range as in read_eq efit_source: EFIT source eg. 'EFIT01' tokamak: device name eg. 'd3d' OUTPUTS: eq = equilibrium data on toksys form, that can be used with cc_efit_to_tok and build_tokamak_system neq = number of equilibria returned eqraw = 'raw' eq data on original form before conversion to toksys convention RESTRICTIONS: METHOD: WRITTEN BY: Matthew J. Lanctot MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/efit/write_gfile_m/","text":"write_gfile.m \u00b6 Basic Information \u00b6 USAGE: write_gfile(eq) PURPOSE: write gfiles INPUTS: eq: equilibrium on the toksys format (that is returned by read_mds_eqdsk) OUTPUTS: gfiles to disk RESTRICTIONS:","title":"write_gfile.m"},{"location":"function-guide/efit/write_gfile_m/#write_gfilem","text":"","title":"write_gfile.m"},{"location":"function-guide/efit/write_gfile_m/#basic-information","text":"USAGE: write_gfile(eq) PURPOSE: write gfiles INPUTS: eq: equilibrium on the toksys format (that is returned by read_mds_eqdsk) OUTPUTS: gfiles to disk RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/efit/write_kfile_m/","text":"write_kfile.m \u00b6 Basic Information \u00b6 USAGE: write_kfile(eq) Creates k file from TokSys equilibrium Alternatively, create k file with exact content of variables: write_kfile(IN1,INWANT,INS,efitin) PURPOSE: write k-files INPUTS: eq, TokSys equilibrium with fields List shows: field name, alternative names, description Note that some alternatives aren't exactly the same things shot, a shot number time, a time in seconds plasma, rog, cpasma, MEASURED total plasma current [A] expmp2, bp MEASURED signals from magnetic probes coils, fl, MEASURED signals from flux loops btor, bzero, toroidal field at rcentr, rzero rcentr, rzero, radius where btor, bzero is measured psibit, physics units per digitizer bit for flux loops bitmpi, physics units per digitizer bit for probes bitip, physics units per digitizer bit for rogowski bitfc, physics units per digitizer bit for F coil currents bitec, physics units per digitizer bit for E coil currents tgamma, tangent for measured pitch angles sgamma, uncertainties in tgamma fitdelz, boolean flag","title":"write_kfile.m"},{"location":"function-guide/efit/write_kfile_m/#write_kfilem","text":"","title":"write_kfile.m"},{"location":"function-guide/efit/write_kfile_m/#basic-information","text":"USAGE: write_kfile(eq) Creates k file from TokSys equilibrium Alternatively, create k file with exact content of variables: write_kfile(IN1,INWANT,INS,efitin) PURPOSE: write k-files INPUTS: eq, TokSys equilibrium with fields List shows: field name, alternative names, description Note that some alternatives aren't exactly the same things shot, a shot number time, a time in seconds plasma, rog, cpasma, MEASURED total plasma current [A] expmp2, bp MEASURED signals from magnetic probes coils, fl, MEASURED signals from flux loops btor, bzero, toroidal field at rcentr, rzero rcentr, rzero, radius where btor, bzero is measured psibit, physics units per digitizer bit for flux loops bitmpi, physics units per digitizer bit for probes bitip, physics units per digitizer bit for rogowski bitfc, physics units per digitizer bit for F coil currents bitec, physics units per digitizer bit for E coil currents tgamma, tangent for measured pitch angles sgamma, uncertainties in tgamma fitdelz, boolean flag","title":"Basic Information"},{"location":"function-guide/equil/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 General Equilibrium Codes (Humphreys) (/m/GAtools/matlab/equil) calc_li - Calculate internal inductance from general equilibrium objects","title":"Contents.m"},{"location":"function-guide/equil/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/equil/Contents_m/#basic-information","text":"General Equilibrium Codes (Humphreys) (/m/GAtools/matlab/equil) calc_li - Calculate internal inductance from general equilibrium objects","title":"Basic Information"},{"location":"function-guide/equil/calc_li_m/","text":"calc_li.m \u00b6 Basic Information \u00b6 SYNTAX: [li,li_vec,output_struct] = calc_li(input_struct); PURPOSE: Calculate li value(s) from an equilibrum current distribution, flux on the grid, and grid geometry. INPUTS: input_struct = structure (like gfile_data) containing: jphi = current density on grid (nz x nr or nz*nr vec) [A/m^2] psizr = flux on grid (nz x nr or nz*nr vec) [Wb] rg = major radius vector for grid (nr x 1) [m] zg = vertical position vector for grid (nz x 1) [m] rmaxis = major radius of mag axis [m] (optional; need for li(2)) OUTPUTS: li = actual internal inductance li == <Bp^2>_V/<Bp>_C^2 li_vec = vector of [li(1); li(2); li(3)] RESTRICTIONS: METHOD: Notation: V denotes plasma volume, C denotes contour of plasma boundary, <X>_V means volume-averaged X, <X>_C means line-averaged X along contour of plasma boundary. Bp is total poloidal field. K is kappa at plasma boundary. R is geometrical major radius of plasma boundary. Raxis is major radius of magnetic axis. li == <Bp^2>_V/<Bp>_C^2 = volume-avg of square of poloidal field over plasma volume divided by line-avg poloidal field squared. li(1) == (2*V*<Bp^2>_V/(R*(mu0*I)^2)) * 0.5*(1+K^2)/K li(2) = (2*V*<Bp^2>_V/(Raxis*(mu0*I)^2)) li(3) == (2*V*<Bp^2>_V/(R*(mu0*I)^2))","title":"calc_li.m"},{"location":"function-guide/equil/calc_li_m/#calc_lim","text":"","title":"calc_li.m"},{"location":"function-guide/equil/calc_li_m/#basic-information","text":"SYNTAX: [li,li_vec,output_struct] = calc_li(input_struct); PURPOSE: Calculate li value(s) from an equilibrum current distribution, flux on the grid, and grid geometry. INPUTS: input_struct = structure (like gfile_data) containing: jphi = current density on grid (nz x nr or nz*nr vec) [A/m^2] psizr = flux on grid (nz x nr or nz*nr vec) [Wb] rg = major radius vector for grid (nr x 1) [m] zg = vertical position vector for grid (nz x 1) [m] rmaxis = major radius of mag axis [m] (optional; need for li(2)) OUTPUTS: li = actual internal inductance li == <Bp^2>_V/<Bp>_C^2 li_vec = vector of [li(1); li(2); li(3)] RESTRICTIONS: METHOD: Notation: V denotes plasma volume, C denotes contour of plasma boundary, <X>_V means volume-averaged X, <X>_C means line-averaged X along contour of plasma boundary. Bp is total poloidal field. K is kappa at plasma boundary. R is geometrical major radius of plasma boundary. Raxis is major radius of magnetic axis. li == <Bp^2>_V/<Bp>_C^2 = volume-avg of square of poloidal field over plasma volume divided by line-avg poloidal field squared. li(1) == (2*V*<Bp^2>_V/(R*(mu0*I)^2)) * 0.5*(1+K^2)/K li(2) = (2*V*<Bp^2>_V/(Raxis*(mu0*I)^2)) li(3) == (2*V*<Bp^2>_V/(R*(mu0*I)^2))","title":"Basic Information"},{"location":"function-guide/geom/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Geometrical Tools: 2D: arc_xy - generate n (x,y) pairs from arc rc,zc,rad,t0,t1 area_quad - area of a quadrilateral calc_dimensions - find physical dimensions from scale drawing dee - generate [r,z] for Dee shaped crossection dee_shape - generate [r,z] using dee.m to make equal poloidal spacing dist2bdry - Compute (min) distance from a point to a boundary field - contour plots from set of axisymmetric coils force - calculates force on set of rectangular coils gpoly - Interactively enter points/lines (polygon) into figure lim2vv - make trapozoid vessel elements from limiter description make_rect2 - make rectangle from 2 corners and a width make_ves_elt - construct standard vessel element object mk_dee - uses make_dee.m in m_n_error area to make breakdown dee prlgrm_pts - make efit parallogram from rz end points and thickness perp2lim - generates new limiter points dperp perpendicular to lim. rect_conv - convert GAQ parallogram geom to simple rectangles 3D: brpt_to_bxyz - generate B field in x,y,z direction from B in r,z,phi(rad) dir_cosine - direction cosines of a line segment from point [1] to [2] fil_plot - Plot filament [x1,y1,z1,x2,y2,z2] with color & line width fil_to_filc - filament [x1,y1,z1,x2,y2,z2] center:[xc,yc,zc,dx,dy,dz] fil_regrid - increase the number of filaments n times filc_to_fil - filament [xc,yc,zc,dx,dy,dz] start/end:[x1,y1,z1,x2,y2,z2] fil_to_filcdc - filament [x1,y1,z1,x2,y2,z2] to center & direction cosines mk_rectangle - polygon (x,y,z) for a rectangle at origin & sides (a,b,c) pts_to_fil - Points [x,y,z] to end point filaments [x1,y1,z1,x2,y2,z2] ptsn_to_fil - same as pts_to_fil except n filaments per point read_fil_file - reads filament file written by write_fil_file rec_translate - translate point x1,y1,z1 by z0,y0,z0 to x,y,z rot_3angles - 3 rotates of alp,bet,gam of (xp,yp,zp) about Z, X', Z\" rot_obj - Rotate x,y,z about dir_cos line thru origin, angle alpha rotation - rotation matrix for rot. about dir_cos line, angle alpha rzp_to_pts - Converts from toroidal rzp=[r,z,phi] to xpt=[x,y,z] rpz_to_xyz - Converts from toroidal rpz=[r,phi,z] to xyz=[x,y,z] rzpn_to_pts - same as rzp_to_pts adding n points between each rzp point translation - translate (x,y,z) by (x0,y0,z0) write_fil_file - writes ascii filament file for read with read_fil_file z_dircos - rotation vector for x,y,z from dircos of line, map to z Utility / Read / Write / Misc main - similar to field =>reads coils and generates contours main_iter - similar to main but for iter (check out which is recent) main_ripple - reads a modified rip_out2.dat & generates contour plots make_start - makes 4 subplot of START Voltage at startup mk_grid - makes linear grid from z0 to z1 with n points mk_tpx_tf - makes (x,y) points from arc's for TPX TF coils mk_virt_coil - script to make virtual coils plot_d3d - script to plot D3D f,e,b,limiter,psi_loop,b_probes read_coil - reads coil geometry and current from file read_field - reads mhdfld.dat or field.dat generated by mhdfld3.exe read_iter_diag - reads ITER Diagnostic Geometry data tf_overturn - Overturning Loads on TF coil from plasma and PF pt_on_curve - x,y & distance between point in 2 space to curve pleq - plot an equilibrium drawgrid - overlay a plot with the grid rg, zg shape_create - create a plasma shape from scratch shape_edit - edit a plasma shape shape_params - return shape parameters for a plasma boundary","title":"Contents.m"},{"location":"function-guide/geom/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/geom/Contents_m/#basic-information","text":"Geometrical Tools: 2D: arc_xy - generate n (x,y) pairs from arc rc,zc,rad,t0,t1 area_quad - area of a quadrilateral calc_dimensions - find physical dimensions from scale drawing dee - generate [r,z] for Dee shaped crossection dee_shape - generate [r,z] using dee.m to make equal poloidal spacing dist2bdry - Compute (min) distance from a point to a boundary field - contour plots from set of axisymmetric coils force - calculates force on set of rectangular coils gpoly - Interactively enter points/lines (polygon) into figure lim2vv - make trapozoid vessel elements from limiter description make_rect2 - make rectangle from 2 corners and a width make_ves_elt - construct standard vessel element object mk_dee - uses make_dee.m in m_n_error area to make breakdown dee prlgrm_pts - make efit parallogram from rz end points and thickness perp2lim - generates new limiter points dperp perpendicular to lim. rect_conv - convert GAQ parallogram geom to simple rectangles 3D: brpt_to_bxyz - generate B field in x,y,z direction from B in r,z,phi(rad) dir_cosine - direction cosines of a line segment from point [1] to [2] fil_plot - Plot filament [x1,y1,z1,x2,y2,z2] with color & line width fil_to_filc - filament [x1,y1,z1,x2,y2,z2] center:[xc,yc,zc,dx,dy,dz] fil_regrid - increase the number of filaments n times filc_to_fil - filament [xc,yc,zc,dx,dy,dz] start/end:[x1,y1,z1,x2,y2,z2] fil_to_filcdc - filament [x1,y1,z1,x2,y2,z2] to center & direction cosines mk_rectangle - polygon (x,y,z) for a rectangle at origin & sides (a,b,c) pts_to_fil - Points [x,y,z] to end point filaments [x1,y1,z1,x2,y2,z2] ptsn_to_fil - same as pts_to_fil except n filaments per point read_fil_file - reads filament file written by write_fil_file rec_translate - translate point x1,y1,z1 by z0,y0,z0 to x,y,z rot_3angles - 3 rotates of alp,bet,gam of (xp,yp,zp) about Z, X', Z\" rot_obj - Rotate x,y,z about dir_cos line thru origin, angle alpha rotation - rotation matrix for rot. about dir_cos line, angle alpha rzp_to_pts - Converts from toroidal rzp=[r,z,phi] to xpt=[x,y,z] rpz_to_xyz - Converts from toroidal rpz=[r,phi,z] to xyz=[x,y,z] rzpn_to_pts - same as rzp_to_pts adding n points between each rzp point translation - translate (x,y,z) by (x0,y0,z0) write_fil_file - writes ascii filament file for read with read_fil_file z_dircos - rotation vector for x,y,z from dircos of line, map to z Utility / Read / Write / Misc main - similar to field =>reads coils and generates contours main_iter - similar to main but for iter (check out which is recent) main_ripple - reads a modified rip_out2.dat & generates contour plots make_start - makes 4 subplot of START Voltage at startup mk_grid - makes linear grid from z0 to z1 with n points mk_tpx_tf - makes (x,y) points from arc's for TPX TF coils mk_virt_coil - script to make virtual coils plot_d3d - script to plot D3D f,e,b,limiter,psi_loop,b_probes read_coil - reads coil geometry and current from file read_field - reads mhdfld.dat or field.dat generated by mhdfld3.exe read_iter_diag - reads ITER Diagnostic Geometry data tf_overturn - Overturning Loads on TF coil from plasma and PF pt_on_curve - x,y & distance between point in 2 space to curve pleq - plot an equilibrium drawgrid - overlay a plot with the grid rg, zg shape_create - create a plasma shape from scratch shape_edit - edit a plasma shape shape_params - return shape parameters for a plasma boundary","title":"Basic Information"},{"location":"function-guide/geom/arc_xy_m/","text":"arc_xy.m \u00b6 Basic Information \u00b6 [x,y]= arc_xy(rc,zc,rad,t0,t1,n): generate n x,y pairs from arc rc,zc,rad,t0,t1","title":"arc_xy.m"},{"location":"function-guide/geom/arc_xy_m/#arc_xym","text":"","title":"arc_xy.m"},{"location":"function-guide/geom/arc_xy_m/#basic-information","text":"[x,y]= arc_xy(rc,zc,rad,t0,t1,n): generate n x,y pairs from arc rc,zc,rad,t0,t1","title":"Basic Information"},{"location":"function-guide/geom/area_quad_m/","text":"area_quad.m \u00b6 Basic Information \u00b6 SYNTAX: area = area_quad(center,corners,rotate_angle) PURPOSE: calculate area of quadrilateral INPUT: center = center of mass of quadrilateral corners = 2 x 4 matrix of quadrilateral corners ([x,y] x 4) rotate_angle = angle of centerline of quad from positive x-axis, to be used to rotate onto x-axis OUTPUT: area = approximate area of quadrilateral RESTRICTIONS: Requires rotation to \"center\" the quad on x-axis. METHOD: Rotates quad to put 2 vertices each above and below axis. Area is approximated by using trapezoid area formula on shape above and below axis.","title":"area_quad.m"},{"location":"function-guide/geom/area_quad_m/#area_quadm","text":"","title":"area_quad.m"},{"location":"function-guide/geom/area_quad_m/#basic-information","text":"SYNTAX: area = area_quad(center,corners,rotate_angle) PURPOSE: calculate area of quadrilateral INPUT: center = center of mass of quadrilateral corners = 2 x 4 matrix of quadrilateral corners ([x,y] x 4) rotate_angle = angle of centerline of quad from positive x-axis, to be used to rotate onto x-axis OUTPUT: area = approximate area of quadrilateral RESTRICTIONS: Requires rotation to \"center\" the quad on x-axis. METHOD: Rotates quad to put 2 vertices each above and below axis. Area is approximated by using trapezoid area formula on shape above and below axis.","title":"Basic Information"},{"location":"function-guide/geom/brpz_to_bxyz_m/","text":"brpz_to_bxyz.m \u00b6 Basic Information \u00b6 PURPOSE: convert a vector of fields brpz to rectangular coordinates bxyz brpz = [Br, Bphi, Bz] to xyz points: xpt = [x, y, z]. SYNTAX: bxyz= brpz_to_bxyz(rpz,brpz); INPUT: rpz = toroidal coordinates of each point 3 columns: [r,phi(radians),z] NOTE THIS IS IN CORRECT RIGHT HAND ROTATION (Not rzp) brpz = Field in each direction [Br, Bphi, Bz] NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D has Phi clockwise) OUTPUT: bxyz = Field in rectangular coordinates in 3-space. [Bx,By,Bz] SEE ALSO: rzp_to_pts rzpn_to_pts pts_to_fil ptsn_to_fil","title":"brpz_to_bxyz.m"},{"location":"function-guide/geom/brpz_to_bxyz_m/#brpz_to_bxyzm","text":"","title":"brpz_to_bxyz.m"},{"location":"function-guide/geom/brpz_to_bxyz_m/#basic-information","text":"PURPOSE: convert a vector of fields brpz to rectangular coordinates bxyz brpz = [Br, Bphi, Bz] to xyz points: xpt = [x, y, z]. SYNTAX: bxyz= brpz_to_bxyz(rpz,brpz); INPUT: rpz = toroidal coordinates of each point 3 columns: [r,phi(radians),z] NOTE THIS IS IN CORRECT RIGHT HAND ROTATION (Not rzp) brpz = Field in each direction [Br, Bphi, Bz] NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D has Phi clockwise) OUTPUT: bxyz = Field in rectangular coordinates in 3-space. [Bx,By,Bz] SEE ALSO: rzp_to_pts rzpn_to_pts pts_to_fil ptsn_to_fil","title":"Basic Information"},{"location":"function-guide/geom/calc_dimensions_m/","text":"calc_dimensions.m \u00b6 Basic Information \u00b6 SYNTAX: [xy_phys] = calc_dimensions(xy_pairs,scale_orig,scale) PURPOSE: compute dimensions from units in scale drawing INPUT: xy_pairs = coordinates in scaled drawing (2 x npairs) scale_orig = coords of point in scaled drawing corresp. to phys origin scale = x/y multipliers of scaled drawing to give physical dimensions OUTPUT: xy_phys = coordinates of actual device","title":"calc_dimensions.m"},{"location":"function-guide/geom/calc_dimensions_m/#calc_dimensionsm","text":"","title":"calc_dimensions.m"},{"location":"function-guide/geom/calc_dimensions_m/#basic-information","text":"SYNTAX: [xy_phys] = calc_dimensions(xy_pairs,scale_orig,scale) PURPOSE: compute dimensions from units in scale drawing INPUT: xy_pairs = coordinates in scaled drawing (2 x npairs) scale_orig = coords of point in scaled drawing corresp. to phys origin scale = x/y multipliers of scaled drawing to give physical dimensions OUTPUT: xy_phys = coordinates of actual device","title":"Basic Information"},{"location":"function-guide/geom/calc_force1_m/","text":"calc_force1.m \u00b6 Basic Information \u00b6 calc_force.m calculated eddy current force contours assumes field1 has been run and some of the following objects saved:","title":"calc_force1.m"},{"location":"function-guide/geom/calc_force1_m/#calc_force1m","text":"","title":"calc_force1.m"},{"location":"function-guide/geom/calc_force1_m/#basic-information","text":"calc_force.m calculated eddy current force contours assumes field1 has been run and some of the following objects saved:","title":"Basic Information"},{"location":"function-guide/geom/calc_force2_m/","text":"calc_force2.m \u00b6 Basic Information \u00b6 calc_force.m calculated eddy current force contours assumes field1 has been run and some of the following objects saved:","title":"calc_force2.m"},{"location":"function-guide/geom/calc_force2_m/#calc_force2m","text":"","title":"calc_force2.m"},{"location":"function-guide/geom/calc_force2_m/#basic-information","text":"calc_force.m calculated eddy current force contours assumes field1 has been run and some of the following objects saved:","title":"Basic Information"},{"location":"function-guide/geom/calc_force3_m/","text":"calc_force3.m \u00b6 Basic Information \u00b6 calc_force.m calculated eddy current force contours assumes field1 has been run and some of the following objects saved:","title":"calc_force3.m"},{"location":"function-guide/geom/calc_force3_m/#calc_force3m","text":"","title":"calc_force3.m"},{"location":"function-guide/geom/calc_force3_m/#basic-information","text":"calc_force.m calculated eddy current force contours assumes field1 has been run and some of the following objects saved:","title":"Basic Information"},{"location":"function-guide/geom/calc_force_m/","text":"calc_force.m \u00b6 Basic Information \u00b6 calc_force.m calculated eddy current force contours assumes field1 has been run and some of the following objects saved:","title":"calc_force.m"},{"location":"function-guide/geom/calc_force_m/#calc_forcem","text":"","title":"calc_force.m"},{"location":"function-guide/geom/calc_force_m/#basic-information","text":"calc_force.m calculated eddy current force contours assumes field1 has been run and some of the following objects saved:","title":"Basic Information"},{"location":"function-guide/geom/dee_m/","text":"dee.m \u00b6 Basic Information \u00b6 Parametric equation for Dee shaped plasma R= Ro + a*cos(theta + d*sin(theta)); Z= Zo + a*k*sin(theta); SYNTAX [r,z]= dee(ro,zo,a,k,d,theta) INPUT: ro= Major Radius zo= Z Center a= Minor Radius k= Elongation d= Triangularity theta= Angle","title":"dee.m"},{"location":"function-guide/geom/dee_m/#deem","text":"","title":"dee.m"},{"location":"function-guide/geom/dee_m/#basic-information","text":"Parametric equation for Dee shaped plasma R= Ro + a*cos(theta + d*sin(theta)); Z= Zo + a*k*sin(theta); SYNTAX [r,z]= dee(ro,zo,a,k,d,theta) INPUT: ro= Major Radius zo= Z Center a= Minor Radius k= Elongation d= Triangularity theta= Angle","title":"Basic Information"},{"location":"function-guide/geom/dee_shape_m/","text":"dee_shape.m \u00b6 Basic Information \u00b6 dee_shape makes dee with equally poloidal spaced points SYNTAX [rpt,zpt]= dee_shape(ro,zo,a,k,d,t1,t2,n); INPUT: ro= Major Radius zo= Z Center a= Minor Radius k= Elongation d= Triangularity t1= Starting Theta (deg) t2= Ending Theta (deg) n= Number of Poloidal Points OUTPUT: rpt,zpt= r,z position of equally spaced points on Dee shape NOTE: See function for extra stuff like print to file and plot GA-Jim Leuer 9-00","title":"dee_shape.m"},{"location":"function-guide/geom/dee_shape_m/#dee_shapem","text":"","title":"dee_shape.m"},{"location":"function-guide/geom/dee_shape_m/#basic-information","text":"dee_shape makes dee with equally poloidal spaced points SYNTAX [rpt,zpt]= dee_shape(ro,zo,a,k,d,t1,t2,n); INPUT: ro= Major Radius zo= Z Center a= Minor Radius k= Elongation d= Triangularity t1= Starting Theta (deg) t2= Ending Theta (deg) n= Number of Poloidal Points OUTPUT: rpt,zpt= r,z position of equally spaced points on Dee shape NOTE: See function for extra stuff like print to file and plot GA-Jim Leuer 9-00","title":"Basic Information"},{"location":"function-guide/geom/dir_cosine_m/","text":"dir_cosine.m \u00b6 Basic Information \u00b6 SYNTAX: [ax,ay,az]= dir_cosine(x1,y1,z1,x2,y2,z2) PURPOSE: generates direction cosines [ax,ay,az] of a line segment from point x1,y1,z1 to point x2,y2,z2 If only 3 arguments are passed then it assumes these are x2,y2,z2 and computes direction cosines from origin: (i.e. x1= y1= z1 = 0).","title":"dir_cosine.m"},{"location":"function-guide/geom/dir_cosine_m/#dir_cosinem","text":"","title":"dir_cosine.m"},{"location":"function-guide/geom/dir_cosine_m/#basic-information","text":"SYNTAX: [ax,ay,az]= dir_cosine(x1,y1,z1,x2,y2,z2) PURPOSE: generates direction cosines [ax,ay,az] of a line segment from point x1,y1,z1 to point x2,y2,z2 If only 3 arguments are passed then it assumes these are x2,y2,z2 and computes direction cosines from origin: (i.e. x1= y1= z1 = 0).","title":"Basic Information"},{"location":"function-guide/geom/dircos_m/","text":"dircos.m \u00b6 Basic Information \u00b6 SYNTAX: dir_cos= dircos(x,y,z,origin); PURPOSE: Generate direction cosines from line segment defined by [x,y,z] - origin INPUT: x,y,z= end points of line segment origin= vector [3] defining start of line segment Note: if not present assumes [0,0,0] OUTPUT dir_cos= row vectors of length 3 which contains the direction cosine for each entry in x,y,z NOTE: x,y,z can be matrix but output is matrix [n,3] where n=prod(size(x))","title":"dircos.m"},{"location":"function-guide/geom/dircos_m/#dircosm","text":"","title":"dircos.m"},{"location":"function-guide/geom/dircos_m/#basic-information","text":"SYNTAX: dir_cos= dircos(x,y,z,origin); PURPOSE: Generate direction cosines from line segment defined by [x,y,z] - origin INPUT: x,y,z= end points of line segment origin= vector [3] defining start of line segment Note: if not present assumes [0,0,0] OUTPUT dir_cos= row vectors of length 3 which contains the direction cosine for each entry in x,y,z NOTE: x,y,z can be matrix but output is matrix [n,3] where n=prod(size(x))","title":"Basic Information"},{"location":"function-guide/geom/dist2bdry_m/","text":"dist2bdry.m \u00b6 Basic Information \u00b6 SYNTAX: [distance,nearest_pt] = dist2bdry(bdry,point,closed) PURPOSE: Compute (min) distance from a point to a boundary. Boundary is assumed be defined by the vertices specified in bdry and by linear interpolation between these points, in the order specified. INPUT: bdry = n x 2 array specifying x,y pairs which define boundary point = [x,y] data point closed = set to 1 if first and last vertex in bdry list should be connected to form a closed boundary(optional,default=0) OUTPUT: distance = minimum distance from point to boundary nearest_pt = [x,y] point on boundary nearest to point specified RESTRICTIONS: (1) Works for \"normal\" cases where you can locate the closest boundary point by first finding the first vertex on boundary. Won't work for \"pathological\" cases where boundary closest to the point is defined by two vertices far away from the point. (2) Not well tested yet. (Not at all for closed boundaries.)","title":"dist2bdry.m"},{"location":"function-guide/geom/dist2bdry_m/#dist2bdrym","text":"","title":"dist2bdry.m"},{"location":"function-guide/geom/dist2bdry_m/#basic-information","text":"SYNTAX: [distance,nearest_pt] = dist2bdry(bdry,point,closed) PURPOSE: Compute (min) distance from a point to a boundary. Boundary is assumed be defined by the vertices specified in bdry and by linear interpolation between these points, in the order specified. INPUT: bdry = n x 2 array specifying x,y pairs which define boundary point = [x,y] data point closed = set to 1 if first and last vertex in bdry list should be connected to form a closed boundary(optional,default=0) OUTPUT: distance = minimum distance from point to boundary nearest_pt = [x,y] point on boundary nearest to point specified RESTRICTIONS: (1) Works for \"normal\" cases where you can locate the closest boundary point by first finding the first vertex on boundary. Won't work for \"pathological\" cases where boundary closest to the point is defined by two vertices far away from the point. (2) Not well tested yet. (Not at all for closed boundaries.)","title":"Basic Information"},{"location":"function-guide/geom/drawgrid_m/","text":"drawgrid.m \u00b6 Basic Information \u00b6 USAGE: drawgrid(rg,zg) drawgrid(c) c is struct with fields rg, zg [h1, h2, h3] = drawgrid(rg,zg) PURPOSE: draw grid rg,zg in current figure window INPUTS: rg, zg or c.rg, c.zg = grid coordinates OUTPUTS: h1 = handle to lines plotted along grid lines h2 = handle to lines plotted half-way between grid lines h3 = handle to points plotted at grid points","title":"drawgrid.m"},{"location":"function-guide/geom/drawgrid_m/#drawgridm","text":"","title":"drawgrid.m"},{"location":"function-guide/geom/drawgrid_m/#basic-information","text":"USAGE: drawgrid(rg,zg) drawgrid(c) c is struct with fields rg, zg [h1, h2, h3] = drawgrid(rg,zg) PURPOSE: draw grid rg,zg in current figure window INPUTS: rg, zg or c.rg, c.zg = grid coordinates OUTPUTS: h1 = handle to lines plotted along grid lines h2 = handle to lines plotted half-way between grid lines h3 = handle to points plotted at grid points","title":"Basic Information"},{"location":"function-guide/geom/field1_m/","text":"field1.m \u00b6 Basic Information \u00b6 field.m: calculates field matrix from coil currents","title":"field1.m"},{"location":"function-guide/geom/field1_m/#field1m","text":"","title":"field1.m"},{"location":"function-guide/geom/field1_m/#basic-information","text":"field.m: calculates field matrix from coil currents","title":"Basic Information"},{"location":"function-guide/geom/field2_m/","text":"field2.m \u00b6 Basic Information \u00b6 field.m: calculates field matrix from coil currents","title":"field2.m"},{"location":"function-guide/geom/field2_m/#field2m","text":"","title":"field2.m"},{"location":"function-guide/geom/field2_m/#basic-information","text":"field.m: calculates field matrix from coil currents","title":"Basic Information"},{"location":"function-guide/geom/field_d3d_m/","text":"field_d3d.m \u00b6 Basic Information \u00b6 field_d3d.m: calculates field matrix from d3d coil currents","title":"field_d3d.m"},{"location":"function-guide/geom/field_d3d_m/#field_d3dm","text":"","title":"field_d3d.m"},{"location":"function-guide/geom/field_d3d_m/#basic-information","text":"field_d3d.m: calculates field matrix from d3d coil currents","title":"Basic Information"},{"location":"function-guide/geom/field_m/","text":"field.m \u00b6 Basic Information \u00b6 field.m: calculates field matrix from coil currents Jim Leuer, General Atomics, 4-95 scripts and functions used: read_lines.m reads boxes and lines from pf; lim; tf; sep plot_lines.m plots lines of array containing many lines read_field.m reads field.dat produced from mhdfld3.exe plot_contor.m plots contour generated by contourc.m (for separtrix) mk_grid.m makes field point R,Z grid variables: rgrid & zgrid clear_var.m removes unwanted variables from work space pt_on_curve.m finds closest point on line from input rpt,zpt mod 1-95 to plot 3-d bfield now can read coil_file and curent_file seperately - good for efit","title":"field.m"},{"location":"function-guide/geom/field_m/#fieldm","text":"","title":"field.m"},{"location":"function-guide/geom/field_m/#basic-information","text":"field.m: calculates field matrix from coil currents Jim Leuer, General Atomics, 4-95 scripts and functions used: read_lines.m reads boxes and lines from pf; lim; tf; sep plot_lines.m plots lines of array containing many lines read_field.m reads field.dat produced from mhdfld3.exe plot_contor.m plots contour generated by contourc.m (for separtrix) mk_grid.m makes field point R,Z grid variables: rgrid & zgrid clear_var.m removes unwanted variables from work space pt_on_curve.m finds closest point on line from input rpt,zpt mod 1-95 to plot 3-d bfield now can read coil_file and curent_file seperately - good for efit","title":"Basic Information"},{"location":"function-guide/geom/fil_plot_arrow_m/","text":"fil_plot_arrow.m \u00b6 Basic Information \u00b6 PURPOSE: plots a set of vectors: xfil = [x1,y1,z1,x2,y2,z2] using arrows SYNTAX: hdl= fil_plot_arrow(xfil,s,cl,lw) INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end s= scale factor s=0 no scale, s=-1 matlab scale, s>0 actual scale cl= line color (optional)['r'] lw= line width (optional) [1] OUTPUT: hdl= handle to all graphics elements produced NOTE: can use hdl and rotations to rotate object","title":"fil_plot_arrow.m"},{"location":"function-guide/geom/fil_plot_arrow_m/#fil_plot_arrowm","text":"","title":"fil_plot_arrow.m"},{"location":"function-guide/geom/fil_plot_arrow_m/#basic-information","text":"PURPOSE: plots a set of vectors: xfil = [x1,y1,z1,x2,y2,z2] using arrows SYNTAX: hdl= fil_plot_arrow(xfil,s,cl,lw) INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end s= scale factor s=0 no scale, s=-1 matlab scale, s>0 actual scale cl= line color (optional)['r'] lw= line width (optional) [1] OUTPUT: hdl= handle to all graphics elements produced NOTE: can use hdl and rotations to rotate object","title":"Basic Information"},{"location":"function-guide/geom/fil_plot_m/","text":"fil_plot.m \u00b6 Basic Information \u00b6 PURPOSE: plots a set of filaments: xfil = [x1,y1,z1,x2,y2,z2] SYNTAX: hdl= fil_plot(xfil,cl,lw) INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end cl= line color (optional)['r'] lw= line width (optional) [1] OUTPUT: hdl= handle to all graphics elements produced NOTE: can use hdl and rotations to rotate object","title":"fil_plot.m"},{"location":"function-guide/geom/fil_plot_m/#fil_plotm","text":"","title":"fil_plot.m"},{"location":"function-guide/geom/fil_plot_m/#basic-information","text":"PURPOSE: plots a set of filaments: xfil = [x1,y1,z1,x2,y2,z2] SYNTAX: hdl= fil_plot(xfil,cl,lw) INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end cl= line color (optional)['r'] lw= line width (optional) [1] OUTPUT: hdl= handle to all graphics elements produced NOTE: can use hdl and rotations to rotate object","title":"Basic Information"},{"location":"function-guide/geom/fil_regrid_m/","text":"fil_regrid.m \u00b6 Basic Information \u00b6 PURPOSE: Increases the number of filaments n times. The filament matrix is composed of start to end points: xfil = [x1,y1,z1,x2,y2,z2] The output matrix has n times more rows SYNTAX: xnfil= fil_regrid(xfil,n) INPUT: xfilc= filament coordinates start to end [x1,y1,z1,x2,y2,z2] n = number of filaments split each filament into SCALAR OUTPUT: xnfil= filament matrix increased by nfil times [x1,y1,z1,x2,y2,z2] NOTE: See filc_to_fil for conversion from center to end filaments","title":"fil_regrid.m"},{"location":"function-guide/geom/fil_regrid_m/#fil_regridm","text":"","title":"fil_regrid.m"},{"location":"function-guide/geom/fil_regrid_m/#basic-information","text":"PURPOSE: Increases the number of filaments n times. The filament matrix is composed of start to end points: xfil = [x1,y1,z1,x2,y2,z2] The output matrix has n times more rows SYNTAX: xnfil= fil_regrid(xfil,n) INPUT: xfilc= filament coordinates start to end [x1,y1,z1,x2,y2,z2] n = number of filaments split each filament into SCALAR OUTPUT: xnfil= filament matrix increased by nfil times [x1,y1,z1,x2,y2,z2] NOTE: See filc_to_fil for conversion from center to end filaments","title":"Basic Information"},{"location":"function-guide/geom/fil_to_filc_m/","text":"fil_to_filc.m \u00b6 Basic Information \u00b6 PURPOSE: convert end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] to center xc= [xc,yc,zc] and delta= [dx,dy,dz] SYNTAX: [xfilc]= fil_to_filc(xfil) INPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end OUTPUT: xfilc= filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] NOTE: See fil_to_filcdc for output of center, direction cos, & line length","title":"fil_to_filc.m"},{"location":"function-guide/geom/fil_to_filc_m/#fil_to_filcm","text":"","title":"fil_to_filc.m"},{"location":"function-guide/geom/fil_to_filc_m/#basic-information","text":"PURPOSE: convert end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] to center xc= [xc,yc,zc] and delta= [dx,dy,dz] SYNTAX: [xfilc]= fil_to_filc(xfil) INPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end OUTPUT: xfilc= filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] NOTE: See fil_to_filcdc for output of center, direction cos, & line length","title":"Basic Information"},{"location":"function-guide/geom/fil_to_filcdc_m/","text":"fil_to_filcdc.m \u00b6 Basic Information \u00b6 PURPOSE: convert end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] to center & direction cosines xcdc= [xc,yc,zc,dcx,dcy,dcz] also outputs filament length ll SYNTAX: [xcdc,ll]= fil_to_filcdc(xfil) INPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end OUTPUT: xcdc = filament center & direciton cosines: [xc,yc,zc,dcx,dcy,dcz] ll = filament length","title":"fil_to_filcdc.m"},{"location":"function-guide/geom/fil_to_filcdc_m/#fil_to_filcdcm","text":"","title":"fil_to_filcdc.m"},{"location":"function-guide/geom/fil_to_filcdc_m/#basic-information","text":"PURPOSE: convert end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] to center & direction cosines xcdc= [xc,yc,zc,dcx,dcy,dcz] also outputs filament length ll SYNTAX: [xcdc,ll]= fil_to_filcdc(xfil) INPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end OUTPUT: xcdc = filament center & direciton cosines: [xc,yc,zc,dcx,dcy,dcz] ll = filament length","title":"Basic Information"},{"location":"function-guide/geom/filc_to_fil_m/","text":"filc_to_fil.m \u00b6 Basic Information \u00b6 PURPOSE: convert center/delta description of filament xfilc=[xc,yc,zc,dx,dx,dy] to end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] SYNTAX: xfil= fil_to_filc(xfilc) INPUT: xfilc= filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] OUTPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end NOTE: See fil_to_filc for reverse transform See fil_to_filcdc for output of center, direction cos, & line length","title":"filc_to_fil.m"},{"location":"function-guide/geom/filc_to_fil_m/#filc_to_film","text":"","title":"filc_to_fil.m"},{"location":"function-guide/geom/filc_to_fil_m/#basic-information","text":"PURPOSE: convert center/delta description of filament xfilc=[xc,yc,zc,dx,dx,dy] to end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] SYNTAX: xfil= fil_to_filc(xfilc) INPUT: xfilc= filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] OUTPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end NOTE: See fil_to_filc for reverse transform See fil_to_filcdc for output of center, direction cos, & line length","title":"Basic Information"},{"location":"function-guide/geom/fils2filcs_m/","text":"fils2filcs.m \u00b6 Basic Information \u00b6 PURPOSE: Convert end point description of filaments fils = [x1,y1,z1,x2,y2,z2] to center xc= [xc,yc,zc] and delta= [dx,dy,dz] SYNTAX: filcs = fils2filcs(fils) INPUT: fils = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end Alternatively fils can be a CELL with several filament matrices OUTPUT: filcs = filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] if fils is a cell then so is filcs NOTE:","title":"fils2filcs.m"},{"location":"function-guide/geom/fils2filcs_m/#fils2filcsm","text":"","title":"fils2filcs.m"},{"location":"function-guide/geom/fils2filcs_m/#basic-information","text":"PURPOSE: Convert end point description of filaments fils = [x1,y1,z1,x2,y2,z2] to center xc= [xc,yc,zc] and delta= [dx,dy,dz] SYNTAX: filcs = fils2filcs(fils) INPUT: fils = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end Alternatively fils can be a CELL with several filament matrices OUTPUT: filcs = filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] if fils is a cell then so is filcs NOTE:","title":"Basic Information"},{"location":"function-guide/geom/force_m/","text":"force.m \u00b6 Basic Information \u00b6 force.m: calculates force on set of rectangular coils","title":"force.m"},{"location":"function-guide/geom/force_m/#forcem","text":"","title":"force.m"},{"location":"function-guide/geom/force_m/#basic-information","text":"force.m: calculates force on set of rectangular coils","title":"Basic Information"},{"location":"function-guide/geom/gpoly_m/","text":"gpoly.m \u00b6 Basic Information \u00b6 gpoly allows interactive generation of x,y points of a polygon in current figure. Usage: hdl= gpoly(fig); After Interactive input of points access points using: x= get(hdl,'Xdata')'; y= get(hdl,'Ydata')'; Description gpoly Interactively draws a series of connected lines to form a polygon in the current figure gpoly(FIG) draws a line segment by clicking the mouse at a points in the figure FIG. A rubberband line tracks the mouse movement if multiple points are input. h = gpoly(FIG) Returns the handle to the polygon. NOTE: Clicking outside the axis limits to end polygon inputs gpoly with no input arguments draws in the current figure. INPUT: fig= figure number for polygon [current figure] OUTPUT: hdl= handle to line object in figure. Get Points using x= get(hdl,'Xdata')'; y= get(hdl,'Ydata')';","title":"gpoly.m"},{"location":"function-guide/geom/gpoly_m/#gpolym","text":"","title":"gpoly.m"},{"location":"function-guide/geom/gpoly_m/#basic-information","text":"gpoly allows interactive generation of x,y points of a polygon in current figure. Usage: hdl= gpoly(fig); After Interactive input of points access points using: x= get(hdl,'Xdata')'; y= get(hdl,'Ydata')'; Description gpoly Interactively draws a series of connected lines to form a polygon in the current figure gpoly(FIG) draws a line segment by clicking the mouse at a points in the figure FIG. A rubberband line tracks the mouse movement if multiple points are input. h = gpoly(FIG) Returns the handle to the polygon. NOTE: Clicking outside the axis limits to end polygon inputs gpoly with no input arguments draws in the current figure. INPUT: fig= figure number for polygon [current figure] OUTPUT: hdl= handle to line object in figure. Get Points using x= get(hdl,'Xdata')'; y= get(hdl,'Ydata')';","title":"Basic Information"},{"location":"function-guide/geom/lim2vv_m/","text":"lim2vv.m \u00b6 Basic Information \u00b6 SYNTAX: [vvdata,dirnu,iacnu,fracnu]=lim2vv(limdata,dperp,dw,idir,frac,iac); PURPOSE: Calculate vessel elements from limiter specification given by limdata = set of vertices in limiter, between which will be located vessel elements. INPUTS: limdata = set of vertices in limiter, between which will be located vessel elements. limdata has format [[r1 z1];[r2 z2]...] dperp = amount vessel elements are displaced from limiter dw = width of vessel elements idir = (optional) direction indices corr to each vessel element (nvv = nlim - 1). Default corresponds to +1; reverses direction of wall displacement if set element of idir to -1. frac = (optional) fraction by which to scale each VVelement iac = (optional) indices telling if AC or AC2 type element. Default = all AC (index 1) elements. Note that automatically sets vertical or horizontal elements to type 0... OUTPUTS: vvdata = vvdata array with standard format idirnu = new idir vector (actually used) iacnu = new iac vector (which was used in specifying actual vvdata) fracnu = new frac vector (actually used) plots of corresponding geometry RESTRICTIONS: METHOD:","title":"lim2vv.m"},{"location":"function-guide/geom/lim2vv_m/#lim2vvm","text":"","title":"lim2vv.m"},{"location":"function-guide/geom/lim2vv_m/#basic-information","text":"SYNTAX: [vvdata,dirnu,iacnu,fracnu]=lim2vv(limdata,dperp,dw,idir,frac,iac); PURPOSE: Calculate vessel elements from limiter specification given by limdata = set of vertices in limiter, between which will be located vessel elements. INPUTS: limdata = set of vertices in limiter, between which will be located vessel elements. limdata has format [[r1 z1];[r2 z2]...] dperp = amount vessel elements are displaced from limiter dw = width of vessel elements idir = (optional) direction indices corr to each vessel element (nvv = nlim - 1). Default corresponds to +1; reverses direction of wall displacement if set element of idir to -1. frac = (optional) fraction by which to scale each VVelement iac = (optional) indices telling if AC or AC2 type element. Default = all AC (index 1) elements. Note that automatically sets vertical or horizontal elements to type 0... OUTPUTS: vvdata = vvdata array with standard format idirnu = new idir vector (actually used) iacnu = new iac vector (which was used in specifying actual vvdata) fracnu = new frac vector (actually used) plots of corresponding geometry RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/geom/main_iter_m/","text":"main_iter.m \u00b6 Basic Information \u00b6 main_iter.m: reads iter geometry and a mhdfld.dat file if it exists and generates contour plots","title":"main_iter.m"},{"location":"function-guide/geom/main_iter_m/#main_iterm","text":"","title":"main_iter.m"},{"location":"function-guide/geom/main_iter_m/#basic-information","text":"main_iter.m: reads iter geometry and a mhdfld.dat file if it exists and generates contour plots","title":"Basic Information"},{"location":"function-guide/geom/main_m/","text":"main.m \u00b6 Basic Information \u00b6 main.m: reads a mhdfld.dat file and generates contour plots","title":"main.m"},{"location":"function-guide/geom/main_m/#mainm","text":"","title":"main.m"},{"location":"function-guide/geom/main_m/#basic-information","text":"main.m: reads a mhdfld.dat file and generates contour plots","title":"Basic Information"},{"location":"function-guide/geom/main_ripple_m/","text":"main_ripple.m \u00b6 Basic Information \u00b6 main_ripple.m: reads a modified rip_out2.dat and generates contour plots must remove top 2 lines of rip_out2.dat","title":"main_ripple.m"},{"location":"function-guide/geom/main_ripple_m/#main_ripplem","text":"","title":"main_ripple.m"},{"location":"function-guide/geom/main_ripple_m/#basic-information","text":"main_ripple.m: reads a modified rip_out2.dat and generates contour plots must remove top 2 lines of rip_out2.dat","title":"Basic Information"},{"location":"function-guide/geom/make_d3d_vv_fine_m/","text":"make_d3d_vv_fine.m \u00b6 Basic Information \u00b6 make_d3d_vv_fine reads the 24 element vv and makes a fine meshed one caluclates resistance to maintain one turn resistance 1/R = sum(1/Ri) uses D3D angles to generate line segements","title":"make_d3d_vv_fine.m"},{"location":"function-guide/geom/make_d3d_vv_fine_m/#make_d3d_vv_finem","text":"","title":"make_d3d_vv_fine.m"},{"location":"function-guide/geom/make_d3d_vv_fine_m/#basic-information","text":"make_d3d_vv_fine reads the 24 element vv and makes a fine meshed one caluclates resistance to maintain one turn resistance 1/R = sum(1/Ri) uses D3D angles to generate line segements","title":"Basic Information"},{"location":"function-guide/geom/make_dee_m/","text":"make_dee.m \u00b6 Basic Information \u00b6 make_dee.m make_dee makes dee with equally poloidal spaced points (used in m_n_error) SYNTAX make_dee INPUT: [default] ro= Major Radius [2.25] zo= Z Center [0] a= Minor Radius [0.5] k= Elongation [1.8] d= Triangularity [0.5] mpol= Number of Poloidal Points [12] OUTPUT: dee.dat data file containing r,z points equal spaced poloidally","title":"make_dee.m"},{"location":"function-guide/geom/make_dee_m/#make_deem","text":"","title":"make_dee.m"},{"location":"function-guide/geom/make_dee_m/#basic-information","text":"make_dee.m make_dee makes dee with equally poloidal spaced points (used in m_n_error) SYNTAX make_dee INPUT: [default] ro= Major Radius [2.25] zo= Z Center [0] a= Minor Radius [0.5] k= Elongation [1.8] d= Triangularity [0.5] mpol= Number of Poloidal Points [12] OUTPUT: dee.dat data file containing r,z points equal spaced poloidally","title":"Basic Information"},{"location":"function-guide/geom/make_rect2_m/","text":"make_rect2.m \u00b6 Basic Information \u00b6 SYNTAX: corners = make_rect2(corner1, corner2, width, scale, direction) PURPOSE: Make rectangle from 2 corners and a width INPUT: corner1, corner2 = 2 corners in form [x;y] (drawing units) width = width of rectangle to grow from these 2 corners (physical units) direction = set to +1 to grow rectangle in positive x direction, -1 to grow in negative x direction OUTPUT: corners = corners defining rectangle ([x1;y1] [x2;y2] [x3;y3] [x4;y4])","title":"make_rect2.m"},{"location":"function-guide/geom/make_rect2_m/#make_rect2m","text":"","title":"make_rect2.m"},{"location":"function-guide/geom/make_rect2_m/#basic-information","text":"SYNTAX: corners = make_rect2(corner1, corner2, width, scale, direction) PURPOSE: Make rectangle from 2 corners and a width INPUT: corner1, corner2 = 2 corners in form [x;y] (drawing units) width = width of rectangle to grow from these 2 corners (physical units) direction = set to +1 to grow rectangle in positive x direction, -1 to grow in negative x direction OUTPUT: corners = corners defining rectangle ([x1;y1] [x2;y2] [x3;y3] [x4;y4])","title":"Basic Information"},{"location":"function-guide/geom/make_start_m/","text":"make_start.m \u00b6 Basic Information \u00b6 make_start: makes 4 subplot of START VOLTAGE J. Leuer 12-19-96","title":"make_start.m"},{"location":"function-guide/geom/make_start_m/#make_startm","text":"","title":"make_start.m"},{"location":"function-guide/geom/make_start_m/#basic-information","text":"make_start: makes 4 subplot of START VOLTAGE J. Leuer 12-19-96","title":"Basic Information"},{"location":"function-guide/geom/make_ves_elt_m/","text":"make_ves_elt.m \u00b6 Basic Information \u00b6 SYNTAX: elt = make_ves_elt(type,corners,scale,scale_orig) PURPOSE: make vessel element from coordinates in scaled drawing INPUT: type = element type: 0 = angles AC=AC2=0 1 = 0<AC<90 deg., AC2 = 0 2 = AC = 0, 0<AC2<90 deg. -1 = AC>90 deg. , AC2 = 0 -2 = AC = 0, AC2>90 deg. corners = [[R1;Z1] [R2;Z2] [R3;Z3] [R4;Z4]] scale = 2x1 vector (r,z) which scales drawing to physical units scale_orig = coordinates of physical origin (r=z=0) in scale drawing OUTPUT: elt = [Z;R;dZ;dR;AC;AC2]","title":"make_ves_elt.m"},{"location":"function-guide/geom/make_ves_elt_m/#make_ves_eltm","text":"","title":"make_ves_elt.m"},{"location":"function-guide/geom/make_ves_elt_m/#basic-information","text":"SYNTAX: elt = make_ves_elt(type,corners,scale,scale_orig) PURPOSE: make vessel element from coordinates in scaled drawing INPUT: type = element type: 0 = angles AC=AC2=0 1 = 0<AC<90 deg., AC2 = 0 2 = AC = 0, 0<AC2<90 deg. -1 = AC>90 deg. , AC2 = 0 -2 = AC = 0, AC2>90 deg. corners = [[R1;Z1] [R2;Z2] [R3;Z3] [R4;Z4]] scale = 2x1 vector (r,z) which scales drawing to physical units scale_orig = coordinates of physical origin (r=z=0) in scale drawing OUTPUT: elt = [Z;R;dZ;dR;AC;AC2]","title":"Basic Information"},{"location":"function-guide/geom/mk_dee_m/","text":"mk_dee.m \u00b6 Basic Information \u00b6 mk_dee.m uses make_dee.m in m_n_error area to make a dee for breakdown","title":"mk_dee.m"},{"location":"function-guide/geom/mk_dee_m/#mk_deem","text":"","title":"mk_dee.m"},{"location":"function-guide/geom/mk_dee_m/#basic-information","text":"mk_dee.m uses make_dee.m in m_n_error area to make a dee for breakdown","title":"Basic Information"},{"location":"function-guide/geom/mk_grid_m/","text":"mk_grid.m \u00b6 Basic Information \u00b6 mk__grid.m: makes linear grid starting at z0 and ending at z1 with n points","title":"mk_grid.m"},{"location":"function-guide/geom/mk_grid_m/#mk_gridm","text":"","title":"mk_grid.m"},{"location":"function-guide/geom/mk_grid_m/#basic-information","text":"mk__grid.m: makes linear grid starting at z0 and ending at z1 with n points","title":"Basic Information"},{"location":"function-guide/geom/mk_rectangle_m/","text":"mk_rectangle.m \u00b6 Basic Information \u00b6 SYNTAX: [x,y,z]= mk_rectangle(a,b,c) PURPOSE: Generates surfaces polygons of a rectangle at the origin with side dimensions a,b,c in the x,y,z directions. Output for for use in patch to plot rectangle","title":"mk_rectangle.m"},{"location":"function-guide/geom/mk_rectangle_m/#mk_rectanglem","text":"","title":"mk_rectangle.m"},{"location":"function-guide/geom/mk_rectangle_m/#basic-information","text":"SYNTAX: [x,y,z]= mk_rectangle(a,b,c) PURPOSE: Generates surfaces polygons of a rectangle at the origin with side dimensions a,b,c in the x,y,z directions. Output for for use in patch to plot rectangle","title":"Basic Information"},{"location":"function-guide/geom/mk_tpx_tf_m/","text":"mk_tpx_tf.m \u00b6 Basic Information \u00b6 mk_tpx_tf.m: Makes TPX TF Coil R,Z curve from arcs Arcs are from TPX-E-941301","title":"mk_tpx_tf.m"},{"location":"function-guide/geom/mk_tpx_tf_m/#mk_tpx_tfm","text":"","title":"mk_tpx_tf.m"},{"location":"function-guide/geom/mk_tpx_tf_m/#basic-information","text":"mk_tpx_tf.m: Makes TPX TF Coil R,Z curve from arcs Arcs are from TPX-E-941301","title":"Basic Information"},{"location":"function-guide/geom/mk_virt_coil_m/","text":"mk_virt_coil.m \u00b6 Basic Information \u00b6 mk_virt_coil.m script to make virtual coils","title":"mk_virt_coil.m"},{"location":"function-guide/geom/mk_virt_coil_m/#mk_virt_coilm","text":"","title":"mk_virt_coil.m"},{"location":"function-guide/geom/mk_virt_coil_m/#basic-information","text":"mk_virt_coil.m script to make virtual coils","title":"Basic Information"},{"location":"function-guide/geom/mk_z_rect_m/","text":"mk_z_rect.m \u00b6 Basic Information \u00b6 SYNTAX: [x,y,z]= mk_z_rect(a,b,c) PURPOSE: Generate a rectangle with unit current in z-direction with dimensions a,b,c in the x,y,z directions and centered about xo,yo,zo.","title":"mk_z_rect.m"},{"location":"function-guide/geom/mk_z_rect_m/#mk_z_rectm","text":"","title":"mk_z_rect.m"},{"location":"function-guide/geom/mk_z_rect_m/#basic-information","text":"SYNTAX: [x,y,z]= mk_z_rect(a,b,c) PURPOSE: Generate a rectangle with unit current in z-direction with dimensions a,b,c in the x,y,z directions and centered about xo,yo,zo.","title":"Basic Information"},{"location":"function-guide/geom/parlgram_end_m/","text":"parlgram_end.m \u00b6 Basic Information \u00b6 parlgram_end converts the efit parallelogram coils to end point r,z and t&l SYANTAX: data_end= parlgram_end(data) INPUT: data= Array of [R,Z,dR,dZ,A1,A2] OUTPUT: data_end= Array of [R1,Z1, R2, Z2, thick, length];","title":"parlgram_end.m"},{"location":"function-guide/geom/parlgram_end_m/#parlgram_endm","text":"","title":"parlgram_end.m"},{"location":"function-guide/geom/parlgram_end_m/#basic-information","text":"parlgram_end converts the efit parallelogram coils to end point r,z and t&l SYANTAX: data_end= parlgram_end(data) INPUT: data= Array of [R,Z,dR,dZ,A1,A2] OUTPUT: data_end= Array of [R1,Z1, R2, Z2, thick, length];","title":"Basic Information"},{"location":"function-guide/geom/perp2lim_m/","text":"perp2lim.m \u00b6 Basic Information \u00b6 SYNTAX: [rz_out]= perp2lim(rz_in,dperp); PURPOSE: Generates 2-D (r,z) perpendicular boundary displaced dperp from rz_in . INPUTS: rz_in = r,z index of input boundary rz_in= [r,z] or [r;z] dperp = Perpendicular distance (+ outward, - inward) scaler or size(r) iplot = 1 => plot new rz_out, -1 plot _in & _out geometry <0>= no plot OUTPUTS: rz_out = output data with dperp perpendicular displacement from rz_in RESTRICTIONS: rz_in must have at least 2 points if rz_in has only 2 points direction of vector is taken from r=0,z=0 for negative (inward displacement) watch out for crossing of center METHOD: uses mean of r and z to determine centroid r0, z0 and displaces dperp along radial from r0,z0 to ri,zi, based on dperp drperp= + displace away from center = - displace toward center","title":"perp2lim.m"},{"location":"function-guide/geom/perp2lim_m/#perp2limm","text":"","title":"perp2lim.m"},{"location":"function-guide/geom/perp2lim_m/#basic-information","text":"SYNTAX: [rz_out]= perp2lim(rz_in,dperp); PURPOSE: Generates 2-D (r,z) perpendicular boundary displaced dperp from rz_in . INPUTS: rz_in = r,z index of input boundary rz_in= [r,z] or [r;z] dperp = Perpendicular distance (+ outward, - inward) scaler or size(r) iplot = 1 => plot new rz_out, -1 plot _in & _out geometry <0>= no plot OUTPUTS: rz_out = output data with dperp perpendicular displacement from rz_in RESTRICTIONS: rz_in must have at least 2 points if rz_in has only 2 points direction of vector is taken from r=0,z=0 for negative (inward displacement) watch out for crossing of center METHOD: uses mean of r and z to determine centroid r0, z0 and displaces dperp along radial from r0,z0 to ri,zi, based on dperp drperp= + displace away from center = - displace toward center","title":"Basic Information"},{"location":"function-guide/geom/pleq_m/","text":"pleq.m \u00b6 Basic Information \u00b6 USAGE: pleq(eqs) PURPOSE: Plot equilibrium information in eqs INPUTS: eqs, structure with equilibrium information","title":"pleq.m"},{"location":"function-guide/geom/pleq_m/#pleqm","text":"","title":"pleq.m"},{"location":"function-guide/geom/pleq_m/#basic-information","text":"USAGE: pleq(eqs) PURPOSE: Plot equilibrium information in eqs INPUTS: eqs, structure with equilibrium information","title":"Basic Information"},{"location":"function-guide/geom/plot2_m/","text":"plot2.m \u00b6 Basic Information \u00b6 plot2.m","title":"plot2.m"},{"location":"function-guide/geom/plot2_m/#plot2m","text":"","title":"plot2.m"},{"location":"function-guide/geom/plot2_m/#basic-information","text":"plot2.m","title":"Basic Information"},{"location":"function-guide/geom/plot_box_old_m/","text":"plot_box_old.m \u00b6 Basic Information \u00b6 plot_box.m: plots rectangular boxes given r,z,dr,dz and generates outer geometry: ri,ro,zl,zu Input: r= Radius of center of box z= Vertical location of center of box dr= Radial width of box dz= Axial height of box Output: ri= Inner Radius of box ro= Outer Radius of box zl= Lower Z of box zu= Upper Z of box","title":"plot_box_old.m"},{"location":"function-guide/geom/plot_box_old_m/#plot_box_oldm","text":"","title":"plot_box_old.m"},{"location":"function-guide/geom/plot_box_old_m/#basic-information","text":"plot_box.m: plots rectangular boxes given r,z,dr,dz and generates outer geometry: ri,ro,zl,zu Input: r= Radius of center of box z= Vertical location of center of box dr= Radial width of box dz= Axial height of box Output: ri= Inner Radius of box ro= Outer Radius of box zl= Lower Z of box zu= Upper Z of box","title":"Basic Information"},{"location":"function-guide/geom/plot_d3d_m/","text":"plot_d3d.m \u00b6 Basic Information \u00b6 plot_d3d.m script for plotting d3d Geometry includes: f_coil, e_coil, b_coil, limiter [psi_loop & b_probe] Input: [Default_Value] f_coil= plot f_coils [2=red] e_coil= plot e_coils [2=red] b_coil= plot b_coils [3=blue] septrx= plot plasma seperatrix [0=red] limiter= plot limiter [1=black] vv= plot vacuum vessel [=1black] psi_loop= plot psi_loop [0] b_probe= plot b_probes [0] by changing name to default files below you can plot different geom: f_file, e_file, b_file, septrx_file, lim_file, vv_file, psi_file bprobe_file","title":"plot_d3d.m"},{"location":"function-guide/geom/plot_d3d_m/#plot_d3dm","text":"","title":"plot_d3d.m"},{"location":"function-guide/geom/plot_d3d_m/#basic-information","text":"plot_d3d.m script for plotting d3d Geometry includes: f_coil, e_coil, b_coil, limiter [psi_loop & b_probe] Input: [Default_Value] f_coil= plot f_coils [2=red] e_coil= plot e_coils [2=red] b_coil= plot b_coils [3=blue] septrx= plot plasma seperatrix [0=red] limiter= plot limiter [1=black] vv= plot vacuum vessel [=1black] psi_loop= plot psi_loop [0] b_probe= plot b_probes [0] by changing name to default files below you can plot different geom: f_file, e_file, b_file, septrx_file, lim_file, vv_file, psi_file bprobe_file","title":"Basic Information"},{"location":"function-guide/geom/prlgrm_pts_m/","text":"prlgrm_pts.m \u00b6 Basic Information \u00b6 SYNTAX: prlgrm = prlgrm_pts(rz_end,t); PURPOSE: make efit type parallegram from rz end points and thickness INPUT: rz_end= array of [r,z] end points to construct parallegram t = thickness (array) same size as rz_end or scaler OUTPUT: prlgrm = [Z;R;dZ;dR;AC;AC2] (see figure 6-4 GA-A14490) note size(plgrm,1) = size(rz_end)-1 Note: This routine automatically uses Type 1 parallograms for angles <=45 and Type 2 parallograms for angles >45","title":"prlgrm_pts.m"},{"location":"function-guide/geom/prlgrm_pts_m/#prlgrm_ptsm","text":"","title":"prlgrm_pts.m"},{"location":"function-guide/geom/prlgrm_pts_m/#basic-information","text":"SYNTAX: prlgrm = prlgrm_pts(rz_end,t); PURPOSE: make efit type parallegram from rz end points and thickness INPUT: rz_end= array of [r,z] end points to construct parallegram t = thickness (array) same size as rz_end or scaler OUTPUT: prlgrm = [Z;R;dZ;dR;AC;AC2] (see figure 6-4 GA-A14490) note size(plgrm,1) = size(rz_end)-1 Note: This routine automatically uses Type 1 parallograms for angles <=45 and Type 2 parallograms for angles >45","title":"Basic Information"},{"location":"function-guide/geom/pt_on_curve_m/","text":"pt_on_curve.m \u00b6 Basic Information \u00b6 function [x,y,d]= pt_on_curve(xcur,ycur,xpt,ypt) locates closest intersection point (x,y) on the line segements defined by the vectors [xcur,ycur] from point xpt,ypt. The curve [xcur,ycur] is a closed polygon if the 1st and last elements Contain the same point. xpt,ypt represents the coordinates of the a point x,y returned is a point on one of the line segements closest to xpt,ypt d represents the distance between [x,y] and [xpt,ypt] written by: J. Leuer, General Atomics 11-3-94","title":"pt_on_curve.m"},{"location":"function-guide/geom/pt_on_curve_m/#pt_on_curvem","text":"","title":"pt_on_curve.m"},{"location":"function-guide/geom/pt_on_curve_m/#basic-information","text":"function [x,y,d]= pt_on_curve(xcur,ycur,xpt,ypt) locates closest intersection point (x,y) on the line segements defined by the vectors [xcur,ycur] from point xpt,ypt. The curve [xcur,ycur] is a closed polygon if the 1st and last elements Contain the same point. xpt,ypt represents the coordinates of the a point x,y returned is a point on one of the line segements closest to xpt,ypt d represents the distance between [x,y] and [xpt,ypt] written by: J. Leuer, General Atomics 11-3-94","title":"Basic Information"},{"location":"function-guide/geom/pts_to_fil_m/","text":"pts_to_fil.m \u00b6 Basic Information \u00b6 PURPOSE: convert a vector of points defined by xpt = [xpt,ypt,zpt] to filaments xfil [x1,y1,z1,x2,y2,z2] from point to point. This creats one less filament than the number of points SYNTAX: xfil= pts_to_fil(xpt) INPUT: xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] OUTPUT: xfil = filament constructed beteen points contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end","title":"pts_to_fil.m"},{"location":"function-guide/geom/pts_to_fil_m/#pts_to_film","text":"","title":"pts_to_fil.m"},{"location":"function-guide/geom/pts_to_fil_m/#basic-information","text":"PURPOSE: convert a vector of points defined by xpt = [xpt,ypt,zpt] to filaments xfil [x1,y1,z1,x2,y2,z2] from point to point. This creats one less filament than the number of points SYNTAX: xfil= pts_to_fil(xpt) INPUT: xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] OUTPUT: xfil = filament constructed beteen points contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end","title":"Basic Information"},{"location":"function-guide/geom/ptsn_to_fil_m/","text":"ptsn_to_fil.m \u00b6 Basic Information \u00b6 PURPOSE: convert a vector of points defined by xpt = [xpt,ypt,zpt] to filaments xfil [x1,y1,z1,x2,y2,z2] from point to point. this interpolates between points to to add n filaments for each point This creats one less filament than the number of points SYNTAX: xfil= ptsn_to_fil(xpt,n) INPUT: [default] xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] n = number of filaments per point [ones(length(xpt),1)] scalar or column vector same length as xpt OUTPUT: xfil = filament constructed beteen points contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end","title":"ptsn_to_fil.m"},{"location":"function-guide/geom/ptsn_to_fil_m/#ptsn_to_film","text":"","title":"ptsn_to_fil.m"},{"location":"function-guide/geom/ptsn_to_fil_m/#basic-information","text":"PURPOSE: convert a vector of points defined by xpt = [xpt,ypt,zpt] to filaments xfil [x1,y1,z1,x2,y2,z2] from point to point. this interpolates between points to to add n filaments for each point This creats one less filament than the number of points SYNTAX: xfil= ptsn_to_fil(xpt,n) INPUT: [default] xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] n = number of filaments per point [ones(length(xpt),1)] scalar or column vector same length as xpt OUTPUT: xfil = filament constructed beteen points contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end","title":"Basic Information"},{"location":"function-guide/geom/quiver3_ga_m/","text":"quiver3_ga.m \u00b6 Basic Information \u00b6 QUIVER3 3-D quiver plot. QUIVER3(X,Y,Z,U,V,W) plots velocity vectors as arrows with components (u,v,w) at the points (x,y,z). The matrices X,Y,Z,U,V,W must all be the same size and contain the corresponding position and velocity components. QUIVER3 automatically scales the arrows to fit. QUIVER3(Z,U,V,W) plots velocity vectors at the equally spaced surface points specified by the matrix Z. QUIVER3(Z,U,V,W,S) or QUIVER3(X,Y,Z,U,V,W,S) automatically scales the arrows to fit and then stretches them by S. Use S=0 to plot the arrows without the automatic scaling. QUIVER3(...,LINESPEC) uses the plot linestyle specified for the velocity vectors. Any marker in LINESPEC is drawn at the base instead of an arrow on the tip. Use a marker of '.' to specify no marker at all. See PLOT for other possibilities. QUIVER3(...,'filled') fills any markers specified. H = QUIVER3(...) returns a vector of line handles. Example: [x,y] = meshgrid(-2:.2:2,-1:.15:1); z = x .* exp(-x.^2 - y.^2); [u,v,w] = surfnorm(x,y,z); quiver3(x,y,z,u,v,w); hold on, surf(x,y,z), hold off See also QUIVER, PLOT, PLOT3, SCATTER.","title":"quiver3_ga.m"},{"location":"function-guide/geom/quiver3_ga_m/#quiver3_gam","text":"","title":"quiver3_ga.m"},{"location":"function-guide/geom/quiver3_ga_m/#basic-information","text":"QUIVER3 3-D quiver plot. QUIVER3(X,Y,Z,U,V,W) plots velocity vectors as arrows with components (u,v,w) at the points (x,y,z). The matrices X,Y,Z,U,V,W must all be the same size and contain the corresponding position and velocity components. QUIVER3 automatically scales the arrows to fit. QUIVER3(Z,U,V,W) plots velocity vectors at the equally spaced surface points specified by the matrix Z. QUIVER3(Z,U,V,W,S) or QUIVER3(X,Y,Z,U,V,W,S) automatically scales the arrows to fit and then stretches them by S. Use S=0 to plot the arrows without the automatic scaling. QUIVER3(...,LINESPEC) uses the plot linestyle specified for the velocity vectors. Any marker in LINESPEC is drawn at the base instead of an arrow on the tip. Use a marker of '.' to specify no marker at all. See PLOT for other possibilities. QUIVER3(...,'filled') fills any markers specified. H = QUIVER3(...) returns a vector of line handles. Example: [x,y] = meshgrid(-2:.2:2,-1:.15:1); z = x .* exp(-x.^2 - y.^2); [u,v,w] = surfnorm(x,y,z); quiver3(x,y,z,u,v,w); hold on, surf(x,y,z), hold off See also QUIVER, PLOT, PLOT3, SCATTER.","title":"Basic Information"},{"location":"function-guide/geom/read_coil_m/","text":"read_coil.m \u00b6 Basic Information \u00b6 read_coil.m: script reads coil geometry and current from file SYNTAX: read_coil Input: coil_file= name of geometry file (can contain current also) current_file= name of current file (optional) i_pf_id= column number of current vector (optional, 0= none) flat_file= 1; load as flat file other wise reads with read_line [0] by default .dat & .data files set flat_file=0 .flt & .flat files set flat_file=1 Output: r_pf= radius of coil center z_pf= Z dimension of coil center dr_pf= Radial Build of coil dz_pf= vertical build of coil i_pf= current (amp-turns) in coil n_pf= number of pf coil vectors; ri= Inner radius of coil ro= Outer radius of coil zu= Upper edge of coil zl= Bottom edgy of coil pf_title= title record of last read file ireadok= 1= coil file read ok i_have_i= 1= coil current vector has been read i_ok= indicator of how far things are read in file","title":"read_coil.m"},{"location":"function-guide/geom/read_coil_m/#read_coilm","text":"","title":"read_coil.m"},{"location":"function-guide/geom/read_coil_m/#basic-information","text":"read_coil.m: script reads coil geometry and current from file SYNTAX: read_coil Input: coil_file= name of geometry file (can contain current also) current_file= name of current file (optional) i_pf_id= column number of current vector (optional, 0= none) flat_file= 1; load as flat file other wise reads with read_line [0] by default .dat & .data files set flat_file=0 .flt & .flat files set flat_file=1 Output: r_pf= radius of coil center z_pf= Z dimension of coil center dr_pf= Radial Build of coil dz_pf= vertical build of coil i_pf= current (amp-turns) in coil n_pf= number of pf coil vectors; ri= Inner radius of coil ro= Outer radius of coil zu= Upper edge of coil zl= Bottom edgy of coil pf_title= title record of last read file ireadok= 1= coil file read ok i_have_i= 1= coil current vector has been read i_ok= indicator of how far things are read in file","title":"Basic Information"},{"location":"function-guide/geom/read_dxf_file_m/","text":"read_dxf_file.m \u00b6 Basic Information \u00b6 PURPOSE: Crude read of Autocad DXF files SYNTAX: [xyz,type]= read_dxf_file(filename,two_d); INPUT: [default] filename= ['dfx_file.dxf']; dxf file name two_d= 1; dont read and load any 3rd Z components [0] OUTPUT: xyz = point matrix defined by end points of lines contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of line and 2 is end type = type of entity, 1=point(vertex), 2=line, 3=arc NOTE: ONLY SET UP FOR LINE'S easily can be set up to read other components using LINE example","title":"read_dxf_file.m"},{"location":"function-guide/geom/read_dxf_file_m/#read_dxf_filem","text":"","title":"read_dxf_file.m"},{"location":"function-guide/geom/read_dxf_file_m/#basic-information","text":"PURPOSE: Crude read of Autocad DXF files SYNTAX: [xyz,type]= read_dxf_file(filename,two_d); INPUT: [default] filename= ['dfx_file.dxf']; dxf file name two_d= 1; dont read and load any 3rd Z components [0] OUTPUT: xyz = point matrix defined by end points of lines contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of line and 2 is end type = type of entity, 1=point(vertex), 2=line, 3=arc NOTE: ONLY SET UP FOR LINE'S easily can be set up to read other components using LINE example","title":"Basic Information"},{"location":"function-guide/geom/read_dxf_line_m/","text":"read_dxf_line.m \u00b6 Basic Information \u00b6 read_dxf_line.m reads rip_out.dxf file produced by rippla code and plots in 3D","title":"read_dxf_line.m"},{"location":"function-guide/geom/read_dxf_line_m/#read_dxf_linem","text":"","title":"read_dxf_line.m"},{"location":"function-guide/geom/read_dxf_line_m/#basic-information","text":"read_dxf_line.m reads rip_out.dxf file produced by rippla code and plots in 3D","title":"Basic Information"},{"location":"function-guide/geom/read_eddyci_m/","text":"read_eddyci.m \u00b6 Basic Information \u00b6 read_eddyci.m reads eddyci file and determines current trajectories","title":"read_eddyci.m"},{"location":"function-guide/geom/read_eddyci_m/#read_eddycim","text":"","title":"read_eddyci.m"},{"location":"function-guide/geom/read_eddyci_m/#basic-information","text":"read_eddyci.m reads eddyci file and determines current trajectories","title":"Basic Information"},{"location":"function-guide/geom/read_field_m/","text":"read_field.m \u00b6 Basic Information \u00b6 read_field.m: reads mhdfld.dat or field.dat generated by mhdfld3.exe","title":"read_field.m"},{"location":"function-guide/geom/read_field_m/#read_fieldm","text":"","title":"read_field.m"},{"location":"function-guide/geom/read_field_m/#basic-information","text":"read_field.m: reads mhdfld.dat or field.dat generated by mhdfld3.exe","title":"Basic Information"},{"location":"function-guide/geom/read_fil_file_m/","text":"read_fil_file.m \u00b6 Basic Information \u00b6 PURPOSE: Read filament geometry and current from file note can also be read using general read_lines.m SYNTAX: [xfil,ifil]= read_fil_file(filename); INPUT: [default] filename= filename, [filament.dat] OUTPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end ifil = current in each filament, one row for each filament in xfil","title":"read_fil_file.m"},{"location":"function-guide/geom/read_fil_file_m/#read_fil_filem","text":"","title":"read_fil_file.m"},{"location":"function-guide/geom/read_fil_file_m/#basic-information","text":"PURPOSE: Read filament geometry and current from file note can also be read using general read_lines.m SYNTAX: [xfil,ifil]= read_fil_file(filename); INPUT: [default] filename= filename, [filament.dat] OUTPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end ifil = current in each filament, one row for each filament in xfil","title":"Basic Information"},{"location":"function-guide/geom/read_iter_diag_m/","text":"read_iter_diag.m \u00b6 Basic Information \u00b6 read_iter_diag.m: reads ITER Diagnostic Geometry data makes: floop,mprobe Input: [Default_Value] plot_mp= =1 plot mprobes = 2 number on plot (Magnetic Probes) [1] plot_fl= =1 plot floop >=2 number on plot (Flux Loops) [1] =3 start index following mp (total diag meas) scale_mp= =1 use for scaling of magnetic probes for plot [15]","title":"read_iter_diag.m"},{"location":"function-guide/geom/read_iter_diag_m/#read_iter_diagm","text":"","title":"read_iter_diag.m"},{"location":"function-guide/geom/read_iter_diag_m/#basic-information","text":"read_iter_diag.m: reads ITER Diagnostic Geometry data makes: floop,mprobe Input: [Default_Value] plot_mp= =1 plot mprobes = 2 number on plot (Magnetic Probes) [1] plot_fl= =1 plot floop >=2 number on plot (Flux Loops) [1] =3 start index following mp (total diag meas) scale_mp= =1 use for scaling of magnetic probes for plot [15]","title":"Basic Information"},{"location":"function-guide/geom/rec_translate_m/","text":"rec_translate.m \u00b6 Basic Information \u00b6 translate point x1,y1,z1 by z0,y0,z0 to x,y,z","title":"rec_translate.m"},{"location":"function-guide/geom/rec_translate_m/#rec_translatem","text":"","title":"rec_translate.m"},{"location":"function-guide/geom/rec_translate_m/#basic-information","text":"translate point x1,y1,z1 by z0,y0,z0 to x,y,z","title":"Basic Information"},{"location":"function-guide/geom/rect_convert_m/","text":"rect_convert.m \u00b6 Basic Information \u00b6 rect_convert converts the efit parallogram coils to a rectangular Xsection it makes a horizontal or vertical rectangle of equal area and length INPUT: data= Array of [R,Z,dR,dZ,A1,A2] OUTPUT: data1= Array of [R,Z,dR,dZ]; Leuer 9-11-00","title":"rect_convert.m"},{"location":"function-guide/geom/rect_convert_m/#rect_convertm","text":"","title":"rect_convert.m"},{"location":"function-guide/geom/rect_convert_m/#basic-information","text":"rect_convert converts the efit parallogram coils to a rectangular Xsection it makes a horizontal or vertical rectangle of equal area and length INPUT: data= Array of [R,Z,dR,dZ,A1,A2] OUTPUT: data1= Array of [R,Z,dR,dZ]; Leuer 9-11-00","title":"Basic Information"},{"location":"function-guide/geom/rot_3angles_m/","text":"rot_3angles.m \u00b6 Basic Information \u00b6 SYNTAX: [rot]= rot_3angles(alp,bet,gam); PURPOSE: Generate rotation tansfer function from 3 rotations: 1) rotate alp about Z axis => X Y Z => X' Y' Z' 2) rotate bet about X' axis => X' Y' Z' => X\" Y\" Z\" 3) rotate gam about Z\" axis => X\" Y\" Z\" => X\"' Y\"' Z\"' The rotation matrix is the transform between X Y Z and the X\"' Y\"' Z\"' The transform from global to local coordinates is: [X\"' Y\"' Z\"'] = [rot] * [X Y Z]' INPUT: alp,bet,gam= angles in degrees for rotations OUTPUT: rot= Coordinate transform matrix [3x3] [X' Y' Z']= [rot]*[X Y Z] NOTE: the transpose of rot is the reverse transform","title":"rot_3angles.m"},{"location":"function-guide/geom/rot_3angles_m/#rot_3anglesm","text":"","title":"rot_3angles.m"},{"location":"function-guide/geom/rot_3angles_m/#basic-information","text":"SYNTAX: [rot]= rot_3angles(alp,bet,gam); PURPOSE: Generate rotation tansfer function from 3 rotations: 1) rotate alp about Z axis => X Y Z => X' Y' Z' 2) rotate bet about X' axis => X' Y' Z' => X\" Y\" Z\" 3) rotate gam about Z\" axis => X\" Y\" Z\" => X\"' Y\"' Z\"' The rotation matrix is the transform between X Y Z and the X\"' Y\"' Z\"' The transform from global to local coordinates is: [X\"' Y\"' Z\"'] = [rot] * [X Y Z]' INPUT: alp,bet,gam= angles in degrees for rotations OUTPUT: rot= Coordinate transform matrix [3x3] [X' Y' Z']= [rot]*[X Y Z] NOTE: the transpose of rot is the reverse transform","title":"Basic Information"},{"location":"function-guide/geom/rot_obj_m/","text":"rot_obj.m \u00b6 Basic Information \u00b6 SYNTAX: [x,y,z]= rot_obj(x,y,z,dir_cos,alpha,origin); PURPOSE: Rotation of an object described by [x,y,z] coordinates in 3-D Euclidean space, {X,Y,Z}, about a line described by direction cosines (dir_cos) [3x1] and passing thru origin [3x1] thru angle (alpha) {degrees}. INPUT: x,y,z= x,y,z coordinates of object, {vector or matrix allowed} note: x,y,z must all be the same size dir_cos= Row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] Note: rotation is about + direction of line alpha= Angle in degrees to rotate using the right hand rule origin= Vector [3] containing the origin about which to rotate Note: if origin is not present it assumes [0,0,0] OUTPUT: x,y,z= new coordinates of object following rotation","title":"rot_obj.m"},{"location":"function-guide/geom/rot_obj_m/#rot_objm","text":"","title":"rot_obj.m"},{"location":"function-guide/geom/rot_obj_m/#basic-information","text":"SYNTAX: [x,y,z]= rot_obj(x,y,z,dir_cos,alpha,origin); PURPOSE: Rotation of an object described by [x,y,z] coordinates in 3-D Euclidean space, {X,Y,Z}, about a line described by direction cosines (dir_cos) [3x1] and passing thru origin [3x1] thru angle (alpha) {degrees}. INPUT: x,y,z= x,y,z coordinates of object, {vector or matrix allowed} note: x,y,z must all be the same size dir_cos= Row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] Note: rotation is about + direction of line alpha= Angle in degrees to rotate using the right hand rule origin= Vector [3] containing the origin about which to rotate Note: if origin is not present it assumes [0,0,0] OUTPUT: x,y,z= new coordinates of object following rotation","title":"Basic Information"},{"location":"function-guide/geom/rotation_m/","text":"rotation.m \u00b6 Basic Information \u00b6 SYNTAX: [rot]= rotation(dir_cos,alpha); PURPOSE: Generate rotation matrix (rot) [3x3] in 3-D Euclidean space {X,Y,Z} for rotation of [x,y,z] objects about line described by direction cosines (dir_cos) [3x1] thru angle (alpha) {degrees}. Use of rotational transform is: [X_new,Y_new,Z_new] = [X, Y, Z] * a INPUT: dir_cos= row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] note: rotation is about + direction of line alpha= angle in degrees to rotate using the right hand rule OUTPUT: rot= Rotational transform matrix [3x3] NOTE: This rotates the coordinate system. To rotate object use -alpha","title":"rotation.m"},{"location":"function-guide/geom/rotation_m/#rotationm","text":"","title":"rotation.m"},{"location":"function-guide/geom/rotation_m/#basic-information","text":"SYNTAX: [rot]= rotation(dir_cos,alpha); PURPOSE: Generate rotation matrix (rot) [3x3] in 3-D Euclidean space {X,Y,Z} for rotation of [x,y,z] objects about line described by direction cosines (dir_cos) [3x1] thru angle (alpha) {degrees}. Use of rotational transform is: [X_new,Y_new,Z_new] = [X, Y, Z] * a INPUT: dir_cos= row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] note: rotation is about + direction of line alpha= angle in degrees to rotate using the right hand rule OUTPUT: rot= Rotational transform matrix [3x3] NOTE: This rotates the coordinate system. To rotate object use -alpha","title":"Basic Information"},{"location":"function-guide/geom/rpz_to_xyz_m/","text":"rpz_to_xyz.m \u00b6 Basic Information \u00b6 PURPOSE: convert a cylindrical vector rpz = [R,Phi,Z] to rectangular coordinates xyz = [X, Y, Z] SYNTAX: xyz= rpz_to_xyz(rpz); INPUT: rpz = cylindrical coordinates in 3 columns: [r,phi(radians),z] NOTE THIS IS IN CORRECT RIGHT HAND ROTATION (Not rzp) NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D has Phi clockwise) OUTPUT: xyz = rectangular coordinates in 3-space. [X,Y,Z] SEE ALSO: rzp_to_pts brpz_to_bxyz rzp_to_pts rzpn_to_pts pts_to_fil ptsn_to_fil","title":"rpz_to_xyz.m"},{"location":"function-guide/geom/rpz_to_xyz_m/#rpz_to_xyzm","text":"","title":"rpz_to_xyz.m"},{"location":"function-guide/geom/rpz_to_xyz_m/#basic-information","text":"PURPOSE: convert a cylindrical vector rpz = [R,Phi,Z] to rectangular coordinates xyz = [X, Y, Z] SYNTAX: xyz= rpz_to_xyz(rpz); INPUT: rpz = cylindrical coordinates in 3 columns: [r,phi(radians),z] NOTE THIS IS IN CORRECT RIGHT HAND ROTATION (Not rzp) NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D has Phi clockwise) OUTPUT: xyz = rectangular coordinates in 3-space. [X,Y,Z] SEE ALSO: rzp_to_pts brpz_to_bxyz rzp_to_pts rzpn_to_pts pts_to_fil ptsn_to_fil","title":"Basic Information"},{"location":"function-guide/geom/rzp_to_pts_m/","text":"rzp_to_pts.m \u00b6 Basic Information \u00b6 PURPOSE: convert a vector of points defined in toroidal geometry as: rzp = [r,z,phi] to xyz points: xpt = [x, y, z]. SYNTAX: xpt= rzp_to_pts(rzp) INPUT: rzp = toroidal coordinates of each point 3 columns: [r,z,phi(radians)] NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D hase Phi clockwise) NOTE: You should use Right Hand R,Phi,Z order rather than R,Z,Phi (left hand) OUTPUT: xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] SEE ALSO: rpz_to_xyz rzpn_to_pts pts_to_fil ptsn_to_fil","title":"rzp_to_pts.m"},{"location":"function-guide/geom/rzp_to_pts_m/#rzp_to_ptsm","text":"","title":"rzp_to_pts.m"},{"location":"function-guide/geom/rzp_to_pts_m/#basic-information","text":"PURPOSE: convert a vector of points defined in toroidal geometry as: rzp = [r,z,phi] to xyz points: xpt = [x, y, z]. SYNTAX: xpt= rzp_to_pts(rzp) INPUT: rzp = toroidal coordinates of each point 3 columns: [r,z,phi(radians)] NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D hase Phi clockwise) NOTE: You should use Right Hand R,Phi,Z order rather than R,Z,Phi (left hand) OUTPUT: xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] SEE ALSO: rpz_to_xyz rzpn_to_pts pts_to_fil ptsn_to_fil","title":"Basic Information"},{"location":"function-guide/geom/rzpn_to_pts_m/","text":"rzpn_to_pts.m \u00b6 Basic Information \u00b6 PURPOSE: convert a vector of points defined in toroidal geometry as: rzp = [r,z,phi] to xyz points: xpt = [x, y, z]. this interpolates between points to add n additional points interpolation is in r,z,phi so this will make torodal archs SYNTAX: xpt= rzpn_to_pts(rzp,n) INPUT: [default] rzp = toroidal coordinates of each point 3 columns: [r,z,phi(radians)] n = number of filaments per point [ones(length(rzp),1)] scalar or column vector same length as rzp NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D hase Phi clockwise)","title":"rzpn_to_pts.m"},{"location":"function-guide/geom/rzpn_to_pts_m/#rzpn_to_ptsm","text":"","title":"rzpn_to_pts.m"},{"location":"function-guide/geom/rzpn_to_pts_m/#basic-information","text":"PURPOSE: convert a vector of points defined in toroidal geometry as: rzp = [r,z,phi] to xyz points: xpt = [x, y, z]. this interpolates between points to add n additional points interpolation is in r,z,phi so this will make torodal archs SYNTAX: xpt= rzpn_to_pts(rzp,n) INPUT: [default] rzp = toroidal coordinates of each point 3 columns: [r,z,phi(radians)] n = number of filaments per point [ones(length(rzp),1)] scalar or column vector same length as rzp NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D hase Phi clockwise)","title":"Basic Information"},{"location":"function-guide/geom/shape_create_m/","text":"shape_create.m \u00b6 Basic Information \u00b6 USAGE: [r,z] = shape_create(s) PURPOSE: Create a plasma shape INPUTS: s, structure with the extreme points on the shape: rout, zout, rtop, ztop, rinn, zinn, rbot, zbot Squareness params can also be included: squo, squi, sqli, sqlo (defaults = 0) OUTPUTS: r,z, boundary coordinates NOTE: Special call: official ITER boundary, limiter, and full separatrix [r,z,Rlim,Zlim,rsep,zsep] = shape_create('ITER'); See also SHAPE_PARAMS, SHAPE_EDIT","title":"shape_create.m"},{"location":"function-guide/geom/shape_create_m/#shape_createm","text":"","title":"shape_create.m"},{"location":"function-guide/geom/shape_create_m/#basic-information","text":"USAGE: [r,z] = shape_create(s) PURPOSE: Create a plasma shape INPUTS: s, structure with the extreme points on the shape: rout, zout, rtop, ztop, rinn, zinn, rbot, zbot Squareness params can also be included: squo, squi, sqli, sqlo (defaults = 0) OUTPUTS: r,z, boundary coordinates NOTE: Special call: official ITER boundary, limiter, and full separatrix [r,z,Rlim,Zlim,rsep,zsep] = shape_create('ITER'); See also SHAPE_PARAMS, SHAPE_EDIT","title":"Basic Information"},{"location":"function-guide/geom/shape_edit_m/","text":"shape_edit.m \u00b6 Basic Information \u00b6 USAGE: [r,z] = shape_edit(r0,z0,s) PURPOSE: Edit a plasma shape by specifying new shape parameters Original shape parameters can be found with s0 = shape_params(r0,z0) INPUTS: s, structure with new shape parameters, these can be edited: rsurf, zsurf, aminor, bminor, elong, triu, tril, squo, squi, sqli, sqlo Omit fields or set value to nan for parameters to be ignored One of aminor, bminor, elong must be ignored (default bminor) OUTPUTS: r,z, modified boundary coordinates See also SHAPE_CREATE, SHAPE_PARAMS","title":"shape_edit.m"},{"location":"function-guide/geom/shape_edit_m/#shape_editm","text":"","title":"shape_edit.m"},{"location":"function-guide/geom/shape_edit_m/#basic-information","text":"USAGE: [r,z] = shape_edit(r0,z0,s) PURPOSE: Edit a plasma shape by specifying new shape parameters Original shape parameters can be found with s0 = shape_params(r0,z0) INPUTS: s, structure with new shape parameters, these can be edited: rsurf, zsurf, aminor, bminor, elong, triu, tril, squo, squi, sqli, sqlo Omit fields or set value to nan for parameters to be ignored One of aminor, bminor, elong must be ignored (default bminor) OUTPUTS: r,z, modified boundary coordinates See also SHAPE_CREATE, SHAPE_PARAMS","title":"Basic Information"},{"location":"function-guide/geom/shape_params_m/","text":"shape_params.m \u00b6 Basic Information \u00b6 USAGE: s = shape_params(r,z) PURPOSE: Return shape parameters for a boundary INPUTS: r, z, boundary coordinates OUTPUTS: s, structure with shape parameters See also SHAPE_CREATE, SHAPE_EDIT","title":"shape_params.m"},{"location":"function-guide/geom/shape_params_m/#shape_paramsm","text":"","title":"shape_params.m"},{"location":"function-guide/geom/shape_params_m/#basic-information","text":"USAGE: s = shape_params(r,z) PURPOSE: Return shape parameters for a boundary INPUTS: r, z, boundary coordinates OUTPUTS: s, structure with shape parameters See also SHAPE_CREATE, SHAPE_EDIT","title":"Basic Information"},{"location":"function-guide/geom/startup_old_m/","text":"startup_old.m \u00b6 Basic Information \u00b6 startup.m for /geom/","title":"startup_old.m"},{"location":"function-guide/geom/startup_old_m/#startup_oldm","text":"","title":"startup_old.m"},{"location":"function-guide/geom/startup_old_m/#basic-information","text":"startup.m for /geom/","title":"Basic Information"},{"location":"function-guide/geom/test_m/","text":"test.m \u00b6 Basic Information \u00b6 test.m test calc_force.m","title":"test.m"},{"location":"function-guide/geom/test_m/#testm","text":"","title":"test.m"},{"location":"function-guide/geom/test_m/#basic-information","text":"test.m test calc_force.m","title":"Basic Information"},{"location":"function-guide/geom/tf_overturn_m/","text":"tf_overturn.m \u00b6 Basic Information \u00b6 tf_overturn.m: Calculates Overturning Loads on TF coil from plasma and PF assumes main has been run and mhdfld.dat read in flux variables: BRFIELD, BZFIELD & FLUXFIELD also needs outer and inner contours of TF coil:","title":"tf_overturn.m"},{"location":"function-guide/geom/tf_overturn_m/#tf_overturnm","text":"","title":"tf_overturn.m"},{"location":"function-guide/geom/tf_overturn_m/#basic-information","text":"tf_overturn.m: Calculates Overturning Loads on TF coil from plasma and PF assumes main has been run and mhdfld.dat read in flux variables: BRFIELD, BZFIELD & FLUXFIELD also needs outer and inner contours of TF coil:","title":"Basic Information"},{"location":"function-guide/geom/translation_m/","text":"translation.m \u00b6 Basic Information \u00b6 translate point x1,y1,z1 by x0,y0,z0 to give x,y,z","title":"translation.m"},{"location":"function-guide/geom/translation_m/#translationm","text":"","title":"translation.m"},{"location":"function-guide/geom/translation_m/#basic-information","text":"translate point x1,y1,z1 by x0,y0,z0 to give x,y,z","title":"Basic Information"},{"location":"function-guide/geom/write_fil_file_m/","text":"write_fil_file.m \u00b6 Basic Information \u00b6 PURPOSE: output filament geometry and current to file for read in with read_lines.m SYNTAX: num= write_fil_file(xfil,ifil,filename); INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end ifil = current in each filament, one row for each filament in xfil filename= filename, [filament.dat] OUTPUT: num = number of filaments written to file","title":"write_fil_file.m"},{"location":"function-guide/geom/write_fil_file_m/#write_fil_filem","text":"","title":"write_fil_file.m"},{"location":"function-guide/geom/write_fil_file_m/#basic-information","text":"PURPOSE: output filament geometry and current to file for read in with read_lines.m SYNTAX: num= write_fil_file(xfil,ifil,filename); INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end ifil = current in each filament, one row for each filament in xfil filename= filename, [filament.dat] OUTPUT: num = number of filaments written to file","title":"Basic Information"},{"location":"function-guide/geom/wrt_fil_m/","text":"wrt_fil.m \u00b6 Basic Information \u00b6 wrt_fil.m outputs filament type file","title":"wrt_fil.m"},{"location":"function-guide/geom/wrt_fil_m/#wrt_film","text":"","title":"wrt_fil.m"},{"location":"function-guide/geom/wrt_fil_m/#basic-information","text":"wrt_fil.m outputs filament type file","title":"Basic Information"},{"location":"function-guide/geom/z_dircos_m/","text":"z_dircos.m \u00b6 Basic Information \u00b6 SYNTAX: rot= z_dircos(dir_cos); PURPOSE: Find the direction cosines of an axis system (X', Y', Z') with Z' axis direction cosines input and the X' axis lying in the X, Y plane in the global (X,Y,Z) coordinate system INPUT: dir_cos= row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] OUTPUT: rot= Coordinate transform matrix [3x3] [X' Y' Z']= [rot]*[X Y Z] CAUTION: input of dir_cos=[0,0,1] is \"gimbal lock\" condition and the first transform angle (alpha) cannot be determined - rot set to eye(3) Jim Leuer 1-13-97; Ref: Korn&Korn 1968 & Escibal'65 Pg 77","title":"z_dircos.m"},{"location":"function-guide/geom/z_dircos_m/#z_dircosm","text":"","title":"z_dircos.m"},{"location":"function-guide/geom/z_dircos_m/#basic-information","text":"SYNTAX: rot= z_dircos(dir_cos); PURPOSE: Find the direction cosines of an axis system (X', Y', Z') with Z' axis direction cosines input and the X' axis lying in the X, Y plane in the global (X,Y,Z) coordinate system INPUT: dir_cos= row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] OUTPUT: rot= Coordinate transform matrix [3x3] [X' Y' Z']= [rot]*[X Y Z] CAUTION: input of dir_cos=[0,0,1] is \"gimbal lock\" condition and the first transform angle (alpha) cannot be determined - rot set to eye(3) Jim Leuer 1-13-97; Ref: Korn&Korn 1968 & Escibal'65 Pg 77","title":"Basic Information"},{"location":"function-guide/jfit/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 JFIT Magnetics Fitting Code (Humphreys) (/users/humphrys/matlab/jfit) (JFIT fits magnetic diagnostic data to determine flux surfaces inside VV) get_all_diags - Get DIII-D diagnostic data for JFIT calculation jfit - Present JFIT code jfit_1196 - JFIT code under development jfit_postpr - Postprocessor for JFIT jfit_slice - Plot flux,Jphi, other results for single time slice f/ JFIT jfit_slices = Plot flux contours for many slices f/ JFIT on one frame (WARNING: lots of plot data produced in EPS files!!!) calc_qa - function to calculate safety factor (kappa-corrected cylindrical) from geometry quantities Ip,Bt,R,a,kappa Generic JFIT (2008) jfit_fun_dev - generic JFIT function called by machine-specific functions like jfit_d3d plot_jfit_results - plot many time traces for JFIT run (from jfit_fun_dev) plot_jfit_slice = plot single JFIT slice result plot_jfit_slices = plot many JFIT slices on single sheet draw_dshape = draw contour with standard tokamak-like trinagular shape","title":"Contents.m"},{"location":"function-guide/jfit/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/jfit/Contents_m/#basic-information","text":"JFIT Magnetics Fitting Code (Humphreys) (/users/humphrys/matlab/jfit) (JFIT fits magnetic diagnostic data to determine flux surfaces inside VV) get_all_diags - Get DIII-D diagnostic data for JFIT calculation jfit - Present JFIT code jfit_1196 - JFIT code under development jfit_postpr - Postprocessor for JFIT jfit_slice - Plot flux,Jphi, other results for single time slice f/ JFIT jfit_slices = Plot flux contours for many slices f/ JFIT on one frame (WARNING: lots of plot data produced in EPS files!!!) calc_qa - function to calculate safety factor (kappa-corrected cylindrical) from geometry quantities Ip,Bt,R,a,kappa Generic JFIT (2008) jfit_fun_dev - generic JFIT function called by machine-specific functions like jfit_d3d plot_jfit_results - plot many time traces for JFIT run (from jfit_fun_dev) plot_jfit_slice = plot single JFIT slice result plot_jfit_slices = plot many JFIT slices on single sheet draw_dshape = draw contour with standard tokamak-like trinagular shape","title":"Basic Information"},{"location":"function-guide/jfit/findclosedDH_m/","text":"findclosedDH.m \u00b6 Basic Information \u00b6 findclosedDH.m SYNTAX: [iclosed,nclosed,xcl,ycl] = findclosedDH(rg,zg,psi,level,xlim,ylim) see if contour is closed input: rg, zg = r, z coordinates of grid psi = psi matrix cooresponding to rg,zg grid level = contour level value to check xlim = (opt) limiter x pts ylim = (opt) limiter y pts output: iclosed = 0 for open, 1 if one or more contours are closed nclosed = number of closed contours xcl = 1st closed contour x coords ycl = 1st closed contour y coords P.L. Taylor 30-OCT-97 Modified DAH 8/27/01 Uses input limiter spec","title":"findclosedDH.m"},{"location":"function-guide/jfit/findclosedDH_m/#findcloseddhm","text":"","title":"findclosedDH.m"},{"location":"function-guide/jfit/findclosedDH_m/#basic-information","text":"findclosedDH.m SYNTAX: [iclosed,nclosed,xcl,ycl] = findclosedDH(rg,zg,psi,level,xlim,ylim) see if contour is closed input: rg, zg = r, z coordinates of grid psi = psi matrix cooresponding to rg,zg grid level = contour level value to check xlim = (opt) limiter x pts ylim = (opt) limiter y pts output: iclosed = 0 for open, 1 if one or more contours are closed nclosed = number of closed contours xcl = 1st closed contour x coords ycl = 1st closed contour y coords P.L. Taylor 30-OCT-97 Modified DAH 8/27/01 Uses input limiter spec","title":"Basic Information"},{"location":"function-guide/jfit/findclosedDS_m/","text":"findclosedDS.m \u00b6 Basic Information \u00b6 findclosedDH.m SYNTAX: [iclosed,nclosed,xcl,ycl] = findclosedDH(rg,zg,psi,level,xlim,ylim) see if contour is closed input: rg, zg = r, z coordinates of grid psi = psi matrix cooresponding to rg,zg grid level = contour level value to check xlim = (opt) limiter x pts ylim = (opt) limiter y pts output: iclosed = 0 for open, 1 if one or more contours are closed nclosed = number of closed contours xcl = 1st closed contour x coords ycl = 1st closed contour y coords P.L. Taylor 30-OCT-97 Modified DAH 8/27/01 Uses input limiter spec D. Shiraki 2015 Better check for interior points NWE 1/8/2016 Uses inpolygon instead of is_in","title":"findclosedDS.m"},{"location":"function-guide/jfit/findclosedDS_m/#findcloseddsm","text":"","title":"findclosedDS.m"},{"location":"function-guide/jfit/findclosedDS_m/#basic-information","text":"findclosedDH.m SYNTAX: [iclosed,nclosed,xcl,ycl] = findclosedDH(rg,zg,psi,level,xlim,ylim) see if contour is closed input: rg, zg = r, z coordinates of grid psi = psi matrix cooresponding to rg,zg grid level = contour level value to check xlim = (opt) limiter x pts ylim = (opt) limiter y pts output: iclosed = 0 for open, 1 if one or more contours are closed nclosed = number of closed contours xcl = 1st closed contour x coords ycl = 1st closed contour y coords P.L. Taylor 30-OCT-97 Modified DAH 8/27/01 Uses input limiter spec D. Shiraki 2015 Better check for interior points NWE 1/8/2016 Uses inpolygon instead of is_in","title":"Basic Information"},{"location":"function-guide/jfit/findclosed_m/","text":"findclosed.m \u00b6 Basic Information \u00b6 findclosed.m SYNTAX: [iclosed, nclosed] = findclosed(rg,zg,psi,level) see if contour is closed input: rg, zg = r, z coordinates of grid psi = psi matrix cooresponding to rg,zg grid level = contour level value to check output: iclosed = 0 for open, 1 if one or more contours are closed nclosed = number of closed contours P.L. Taylor 30-OCT-97","title":"findclosed.m"},{"location":"function-guide/jfit/findclosed_m/#findclosedm","text":"","title":"findclosed.m"},{"location":"function-guide/jfit/findclosed_m/#basic-information","text":"findclosed.m SYNTAX: [iclosed, nclosed] = findclosed(rg,zg,psi,level) see if contour is closed input: rg, zg = r, z coordinates of grid psi = psi matrix cooresponding to rg,zg grid level = contour level value to check output: iclosed = 0 for open, 1 if one or more contours are closed nclosed = number of closed contours P.L. Taylor 30-OCT-97","title":"Basic Information"},{"location":"function-guide/jfit/findlcfs_m/","text":"findlcfs.m \u00b6 Basic Information \u00b6 USAGE: >> [psilc,isclosed] = findlcfs(rg,zg,xlim,ylim,psig) PURPOSE: Function to find last closed flux surface inside limiter on grid INPUTS: rg,zg = grid geometry xlim,ylim = limiter R,Z psig = flux matrix on zg,rg grid (nz x nr) OUTPUTS: psilc = flux on LCFS (if found; otherwise last surface found) isclosed = flag to identify if psilc corr to closed surface RESTRICTIONS: METHOD: If fails to find closed contour, psilc = max of flux on limiter","title":"findlcfs.m"},{"location":"function-guide/jfit/findlcfs_m/#findlcfsm","text":"","title":"findlcfs.m"},{"location":"function-guide/jfit/findlcfs_m/#basic-information","text":"USAGE: >> [psilc,isclosed] = findlcfs(rg,zg,xlim,ylim,psig) PURPOSE: Function to find last closed flux surface inside limiter on grid INPUTS: rg,zg = grid geometry xlim,ylim = limiter R,Z psig = flux matrix on zg,rg grid (nz x nr) OUTPUTS: psilc = flux on LCFS (if found; otherwise last surface found) isclosed = flag to identify if psilc corr to closed surface RESTRICTIONS: METHOD: If fails to find closed contour, psilc = max of flux on limiter","title":"Basic Information"},{"location":"function-guide/jfit/findsep_m/","text":"findsep.m \u00b6 Basic Information \u00b6 findsep.m SYNTAX: [level, iclosed] = findsep(rg,zg,psi,levelstrt) find last closed flux surface by iterating from guess input: rg, zg = r, z coordinates of grid psi = psi matrix cooresponding to rg,zg grid levelstrt = contour level to start from output: level = final level iclosed = 1 if level closed P.L. Taylor 30-OCT-97","title":"findsep.m"},{"location":"function-guide/jfit/findsep_m/#findsepm","text":"","title":"findsep.m"},{"location":"function-guide/jfit/findsep_m/#basic-information","text":"findsep.m SYNTAX: [level, iclosed] = findsep(rg,zg,psi,levelstrt) find last closed flux surface by iterating from guess input: rg, zg = r, z coordinates of grid psi = psi matrix cooresponding to rg,zg grid levelstrt = contour level to start from output: level = final level iclosed = 1 if level closed P.L. Taylor 30-OCT-97","title":"Basic Information"},{"location":"function-guide/jfit/jfit_fun_dev_m/","text":"jfit_fun_dev.m \u00b6 Basic Information \u00b6 SYNTAX: function [ipgdat,ivvdat,iccdat,psidat,wmat,Up,idxpp_out,chi2,debugdat] = ... jfit_fun(magdata_struct,tok_data_struct,input_struct); PURPOSE: Function to calculate flux distribution on grid from magnetic diagnostics (after extracting with get_all_diags or other tool). Derived from jfit.m, and made generic for any machine system model. INPUTS: Arguments: magdata_struct = magnetics data structure that contains fldat, bpdat, ipdat,ccdat,tdat (Note that *dat time data objects are of shape [nt,ndat]) tok_data_struct = standard data structure with mutuals, geometry objects for tokamak system. input_struct = structure containing: idxfl = idx vector of good FL's idxbp = idx vector of good BP's idxpf = idx vector of good PF's ipfecoil = 1 to fit F-coil currents in matching magnetics, 0 to subtract contribution from measured E/F currents mggd_file = Good grid to grid mutual matrix .mat file containing mggd, Up, idxpp. Presence of the variable prevents calculation of GoodGrid mggd, Up, and replaces input of idxpp in function arg list. If this variable doesn't exist or is [], jfit_fun will calculate and save those quantities to file mggd_tmp.mat. Then must re-run jfit with mggd_file pointed to correct mggd.mat file. Be sure to set nsvdp to desired *maximum* number of princ components to keep in mggd.mat (after saving that file, in future can choose subset of components for actual JFIT calculations later). idxpp = (optional) if no mggd_file is given, idxpp specifies which grid elements to use for Good Grid (ie elements to use for fitting plasma current distribution). idoplots = (optional) do check plots for grid basis, etc...","title":"jfit_fun_dev.m"},{"location":"function-guide/jfit/jfit_fun_dev_m/#jfit_fun_devm","text":"","title":"jfit_fun_dev.m"},{"location":"function-guide/jfit/jfit_fun_dev_m/#basic-information","text":"SYNTAX: function [ipgdat,ivvdat,iccdat,psidat,wmat,Up,idxpp_out,chi2,debugdat] = ... jfit_fun(magdata_struct,tok_data_struct,input_struct); PURPOSE: Function to calculate flux distribution on grid from magnetic diagnostics (after extracting with get_all_diags or other tool). Derived from jfit.m, and made generic for any machine system model. INPUTS: Arguments: magdata_struct = magnetics data structure that contains fldat, bpdat, ipdat,ccdat,tdat (Note that *dat time data objects are of shape [nt,ndat]) tok_data_struct = standard data structure with mutuals, geometry objects for tokamak system. input_struct = structure containing: idxfl = idx vector of good FL's idxbp = idx vector of good BP's idxpf = idx vector of good PF's ipfecoil = 1 to fit F-coil currents in matching magnetics, 0 to subtract contribution from measured E/F currents mggd_file = Good grid to grid mutual matrix .mat file containing mggd, Up, idxpp. Presence of the variable prevents calculation of GoodGrid mggd, Up, and replaces input of idxpp in function arg list. If this variable doesn't exist or is [], jfit_fun will calculate and save those quantities to file mggd_tmp.mat. Then must re-run jfit with mggd_file pointed to correct mggd.mat file. Be sure to set nsvdp to desired *maximum* number of princ components to keep in mggd.mat (after saving that file, in future can choose subset of components for actual JFIT calculations later). idxpp = (optional) if no mggd_file is given, idxpp specifies which grid elements to use for Good Grid (ie elements to use for fitting plasma current distribution). idoplots = (optional) do check plots for grid basis, etc...","title":"Basic Information"},{"location":"function-guide/jfit/jfit_m/","text":"jfit.m \u00b6 Basic Information \u00b6 jfit.m: Script to calculate flux distribution on grid from magnetic diagnostics (after extracting with get_all_diags). Produces and plots comparison between ZP and zp_cal calculated with the expression here. Modification History: Derived from previous Matlab script zpcal.m. DAH 10/5/95 jfit_0796 updated from jfit_gold1018.m to be consistent with new get_all_diags with corrected ld_full_diags bug. DAH 7/96 Changing mggd algorithm to use distributed elements now (jfit_0896) DAH 8/96 Adding option to use 6-segment E-coil instead of orig Ea/Eb (jfit_0996) DAH 9/96 Addressing bugs and comments f/ AlHyatt (jfit_1096) DAH 10/96 jfit_1196: version under development to try to resolve Ivv problems. Ivv problems (at least main one: rank of VV fit) now resolved. DAH 11/96 jfit.m (7/31/97) cp'd from jfit_1196; using for Halo/Gamma exp. 8/1/97 DAH 7/97 Replacing the QP call with QUADPROG (new quadratic programming tool) DAH 8/1/03 Going back to QP from worthless QUADPROG: quadprog doesn't work on thor... DAH 3/14/05 Returning to QUADPROG (Matlab R14 requires now...) DAH 4/13/07 Inputs: Must have run get_all_diags previously with correct shotnum and tmin/max. shotnum and tmin, tmax must still be present from run of get_all_diags nsvdp = # of principal components to retain for grid coupling svd nsvdv = # of principal components to retain for vessel coupling svd nsvdc = # of principal components to retain for F coupling svd (if nsvdc >= 18, uses exact F-coils, not svd) tpsit = time at which to plot current contours; doesn't affect analysis itrunc = 1 if truncate coupling matrices, 0 if don't ipfecoil = 1 to fit allowing F-coil currents to vary in matching magnetics, 0 to subtract contribustion from measured E/F currents (NOTE if itrunc=0, ipfecoil MUST be 1, but ipfecoil=1 is okay if itrunc=1) idomggd = 1 to force mggd calculation, 0 to calc if ~exist or if wrong dim ildmggd = 1,once mggd.mat created, loads mggd (if=1, set idomggd=0); ichzalg = Chooses algorithm for solving linear minimization/constraint prob: 1=>pinv, 2=>QR, 3=>NNLS, 4=>QP isave = 1 to save data file at end for use in jfit_postpr idoplots = 1 to plot plots, 0 to skip all plotting. savetype = (optional) 'MAT' for standard (present Matlab version) format, or (e.g.) 'V13' for R13 format Set plasma current reference data extraction and resampling (if nec) at beginning of script. Outputs: plots comparison between experimental zp and zp_cal calculated here. Restrictions: NO LONGER need valid ip_probes or ipprobesf data available, but desireable for plotting. Modifications: 8/1/03 DAH Changed all resamplevec calls to resamplev","title":"jfit.m"},{"location":"function-guide/jfit/jfit_m/#jfitm","text":"","title":"jfit.m"},{"location":"function-guide/jfit/jfit_m/#basic-information","text":"jfit.m: Script to calculate flux distribution on grid from magnetic diagnostics (after extracting with get_all_diags). Produces and plots comparison between ZP and zp_cal calculated with the expression here. Modification History: Derived from previous Matlab script zpcal.m. DAH 10/5/95 jfit_0796 updated from jfit_gold1018.m to be consistent with new get_all_diags with corrected ld_full_diags bug. DAH 7/96 Changing mggd algorithm to use distributed elements now (jfit_0896) DAH 8/96 Adding option to use 6-segment E-coil instead of orig Ea/Eb (jfit_0996) DAH 9/96 Addressing bugs and comments f/ AlHyatt (jfit_1096) DAH 10/96 jfit_1196: version under development to try to resolve Ivv problems. Ivv problems (at least main one: rank of VV fit) now resolved. DAH 11/96 jfit.m (7/31/97) cp'd from jfit_1196; using for Halo/Gamma exp. 8/1/97 DAH 7/97 Replacing the QP call with QUADPROG (new quadratic programming tool) DAH 8/1/03 Going back to QP from worthless QUADPROG: quadprog doesn't work on thor... DAH 3/14/05 Returning to QUADPROG (Matlab R14 requires now...) DAH 4/13/07 Inputs: Must have run get_all_diags previously with correct shotnum and tmin/max. shotnum and tmin, tmax must still be present from run of get_all_diags nsvdp = # of principal components to retain for grid coupling svd nsvdv = # of principal components to retain for vessel coupling svd nsvdc = # of principal components to retain for F coupling svd (if nsvdc >= 18, uses exact F-coils, not svd) tpsit = time at which to plot current contours; doesn't affect analysis itrunc = 1 if truncate coupling matrices, 0 if don't ipfecoil = 1 to fit allowing F-coil currents to vary in matching magnetics, 0 to subtract contribustion from measured E/F currents (NOTE if itrunc=0, ipfecoil MUST be 1, but ipfecoil=1 is okay if itrunc=1) idomggd = 1 to force mggd calculation, 0 to calc if ~exist or if wrong dim ildmggd = 1,once mggd.mat created, loads mggd (if=1, set idomggd=0); ichzalg = Chooses algorithm for solving linear minimization/constraint prob: 1=>pinv, 2=>QR, 3=>NNLS, 4=>QP isave = 1 to save data file at end for use in jfit_postpr idoplots = 1 to plot plots, 0 to skip all plotting. savetype = (optional) 'MAT' for standard (present Matlab version) format, or (e.g.) 'V13' for R13 format Set plasma current reference data extraction and resampling (if nec) at beginning of script. Outputs: plots comparison between experimental zp and zp_cal calculated here. Restrictions: NO LONGER need valid ip_probes or ipprobesf data available, but desireable for plotting. Modifications: 8/1/03 DAH Changed all resamplevec calls to resamplev","title":"Basic Information"},{"location":"function-guide/jfit/jfit_slice_m/","text":"jfit_slice.m \u00b6 Basic Information \u00b6 jfit_slice: Script to use output of jfit_postpr to plot flux contours for single slice. Assumes existence of mggd along with everything from jfit_postpr","title":"jfit_slice.m"},{"location":"function-guide/jfit/jfit_slice_m/#jfit_slicem","text":"","title":"jfit_slice.m"},{"location":"function-guide/jfit/jfit_slice_m/#basic-information","text":"jfit_slice: Script to use output of jfit_postpr to plot flux contours for single slice. Assumes existence of mggd along with everything from jfit_postpr","title":"Basic Information"},{"location":"function-guide/jfit/jfit_slices_m/","text":"jfit_slices.m \u00b6 Basic Information \u00b6 zrcalc_slices: Script to use output of zrcalc_postpr to plot flux contours for MANY slices. Prompts for # of rows, # of columns to display. Only plots boundary flux contour, not current distribution... Assumes existence of mggd along with everything from zrcalc_postpr","title":"jfit_slices.m"},{"location":"function-guide/jfit/jfit_slices_m/#jfit_slicesm","text":"","title":"jfit_slices.m"},{"location":"function-guide/jfit/jfit_slices_m/#basic-information","text":"zrcalc_slices: Script to use output of zrcalc_postpr to plot flux contours for MANY slices. Prompts for # of rows, # of columns to display. Only plots boundary flux contour, not current distribution... Assumes existence of mggd along with everything from zrcalc_postpr","title":"Basic Information"},{"location":"function-guide/jfit/plot_jfit_slice_m/","text":"plot_jfit_slice.m \u00b6 Basic Information \u00b6 USAGE: >> plot_jfit_slice PURPOSE: Script to plot JFIT single slice INPUTS: In Matlab environment: jfit_file = JFIT data file written by jfit_fun tok_dat_struct (object structure file: must match JFIT calc) input_time (opt) = 1 to select to input time at prompt (def=1) OUTPUTS: Plots RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD:","title":"plot_jfit_slice.m"},{"location":"function-guide/jfit/plot_jfit_slice_m/#plot_jfit_slicem","text":"","title":"plot_jfit_slice.m"},{"location":"function-guide/jfit/plot_jfit_slice_m/#basic-information","text":"USAGE: >> plot_jfit_slice PURPOSE: Script to plot JFIT single slice INPUTS: In Matlab environment: jfit_file = JFIT data file written by jfit_fun tok_dat_struct (object structure file: must match JFIT calc) input_time (opt) = 1 to select to input time at prompt (def=1) OUTPUTS: Plots RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD:","title":"Basic Information"},{"location":"function-guide/jfit/plot_jfit_slices_m/","text":"plot_jfit_slices.m \u00b6 Basic Information \u00b6 USAGE: >> plot_jfit_slices PURPOSE: Script to plot JFIT many slices on one figure INPUTS: In Matlab environment: jfit_file = JFIT data file written by jfit_fun tok_dat_struct (object structure file: must match JFIT calc) OUTPUTS: Plots RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD:","title":"plot_jfit_slices.m"},{"location":"function-guide/jfit/plot_jfit_slices_m/#plot_jfit_slicesm","text":"","title":"plot_jfit_slices.m"},{"location":"function-guide/jfit/plot_jfit_slices_m/#basic-information","text":"USAGE: >> plot_jfit_slices PURPOSE: Script to plot JFIT many slices on one figure INPUTS: In Matlab environment: jfit_file = JFIT data file written by jfit_fun tok_dat_struct (object structure file: must match JFIT calc) OUTPUTS: Plots RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD:","title":"Basic Information"},{"location":"function-guide/jfit/postpr_jfit_dev_m/","text":"postpr_jfit_dev.m \u00b6 Basic Information \u00b6 USAGE: >> postpr_jfit_dev PURPOSE: Script to post-process JFIT results to get q, Ihalo, etc... (replaces old jfit_postpr script; updated for 2009 JFIT) INPUTS: jfit_file = JFIT data file written by jfit_fun tipsit = time for plotting of equilibrium flux/field [s] (tipsit takes precedence over ipsit if exists) ipsit = (optional) index for time to plot eq flux/field if tipsit doesn't exist... ilcfs=flag to select LCFS finding algorithm. 1=anglebased, 2=line segment intersection alg., 0=omit lcfs calc (psi only; AlHyatt flag) idopsit = flag to accumulate psi_grid(t) in Wb/rad (1=do, 0=skip) savetype = (optional) 'MAT' for standard (present Matlab version) format, or (e.g.) 'V13' for R13 format isave = save postpr*.mat file qelim = max plot limit for qa, qe (def=20) Defined in jfit_file data: jfit_obj_file = file containing tok_dat_struct (must match JFIT calc) OUTPUTS: Save file \"postpr_tmp_<shot>.mat\" and plots... RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD:","title":"postpr_jfit_dev.m"},{"location":"function-guide/jfit/postpr_jfit_dev_m/#postpr_jfit_devm","text":"","title":"postpr_jfit_dev.m"},{"location":"function-guide/jfit/postpr_jfit_dev_m/#basic-information","text":"USAGE: >> postpr_jfit_dev PURPOSE: Script to post-process JFIT results to get q, Ihalo, etc... (replaces old jfit_postpr script; updated for 2009 JFIT) INPUTS: jfit_file = JFIT data file written by jfit_fun tipsit = time for plotting of equilibrium flux/field [s] (tipsit takes precedence over ipsit if exists) ipsit = (optional) index for time to plot eq flux/field if tipsit doesn't exist... ilcfs=flag to select LCFS finding algorithm. 1=anglebased, 2=line segment intersection alg., 0=omit lcfs calc (psi only; AlHyatt flag) idopsit = flag to accumulate psi_grid(t) in Wb/rad (1=do, 0=skip) savetype = (optional) 'MAT' for standard (present Matlab version) format, or (e.g.) 'V13' for R13 format isave = save postpr*.mat file qelim = max plot limit for qa, qe (def=20) Defined in jfit_file data: jfit_obj_file = file containing tok_dat_struct (must match JFIT calc) OUTPUTS: Save file \"postpr_tmp_<shot>.mat\" and plots... RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD:","title":"Basic Information"},{"location":"function-guide/mag/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Magnetics Tools bgreens_distrib B-field between d3d parallelogram type coils and Bprobes bgreens_fine Like bgreens_distrib but uses \"FINE\" for lowest level (fast) bgreens_conway Like bgreens_distrib but uses \"Conway\" for lowest level calc_ohmic_res Coil resistance needed to produce uniform plasma flux plateau calc_bgreens Br, Bz green functions calculation calc_mpp calculate mutuals between plasma grid points cfil_3d_b B-field at [X,Y,Z] from filament circle coil cir_filament Axisymmetric magnetics from a point to a point crect2bprobe B-probe signal from uniform current dens. rectangle coil crect_3d B-field at [X,Y,Z] from rectangular X-section circle coil fine Flux and B field from axisymmetric rectangular X sec coil fil_a Vector potential Az from filament in Z direction, with 1 Amp fil_3d_b B-field at [X,Y,Z] from straight filament filr_3d_b B-field at [X,Y,Z] from straight filament with finite radius green_near Br, Bz green function for point close to rectang. coil induc_rect Inductance of a rectangle of sides axb and wire radius r mag_fil_pt 3D magnetic fields at x,y,z pt from 3-D filament mindbf Mutual Inductance and Br, Bz from loop to point far from loop mindbf_gen Mutual Inductance and Br,m loop, handles <close> points mut_fil_fil Mutual Inductance from a filament set A to filament set B mutind Mutual Inductance of two coaxial circular current loops mutind_near low level function, mutuals calculation, current loops mutind_fine like mutind_near but uses FINE for low level magnetics (FAST) mutind_conway like mutind_near but uses \"Conway\" for low level magnetics mut_coil_set Mutual inductance rect. axi. coil system: FINE & 3rd ord quad mut_ladder computes mutual inductance of a ladder structure mutind_distrib Mutuals between d3d parallelogram type coils ohmic_dist Calculate Ohmic distribution in coils based on plasma shape rectl self inductance for rectangular current source rect_2d B-field at [X,Y] from straight rectangular X-sect. conductor rect_3d_b B-field at [X,Y,Z] from box shaped straight filament self_fil Self Inductance of filament set (ONLY APPROX) sind Self Inductance of a axisymmetic elongated coil (Uniform J)","title":"Contents.m"},{"location":"function-guide/mag/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/mag/Contents_m/#basic-information","text":"Magnetics Tools bgreens_distrib B-field between d3d parallelogram type coils and Bprobes bgreens_fine Like bgreens_distrib but uses \"FINE\" for lowest level (fast) bgreens_conway Like bgreens_distrib but uses \"Conway\" for lowest level calc_ohmic_res Coil resistance needed to produce uniform plasma flux plateau calc_bgreens Br, Bz green functions calculation calc_mpp calculate mutuals between plasma grid points cfil_3d_b B-field at [X,Y,Z] from filament circle coil cir_filament Axisymmetric magnetics from a point to a point crect2bprobe B-probe signal from uniform current dens. rectangle coil crect_3d B-field at [X,Y,Z] from rectangular X-section circle coil fine Flux and B field from axisymmetric rectangular X sec coil fil_a Vector potential Az from filament in Z direction, with 1 Amp fil_3d_b B-field at [X,Y,Z] from straight filament filr_3d_b B-field at [X,Y,Z] from straight filament with finite radius green_near Br, Bz green function for point close to rectang. coil induc_rect Inductance of a rectangle of sides axb and wire radius r mag_fil_pt 3D magnetic fields at x,y,z pt from 3-D filament mindbf Mutual Inductance and Br, Bz from loop to point far from loop mindbf_gen Mutual Inductance and Br,m loop, handles <close> points mut_fil_fil Mutual Inductance from a filament set A to filament set B mutind Mutual Inductance of two coaxial circular current loops mutind_near low level function, mutuals calculation, current loops mutind_fine like mutind_near but uses FINE for low level magnetics (FAST) mutind_conway like mutind_near but uses \"Conway\" for low level magnetics mut_coil_set Mutual inductance rect. axi. coil system: FINE & 3rd ord quad mut_ladder computes mutual inductance of a ladder structure mutind_distrib Mutuals between d3d parallelogram type coils ohmic_dist Calculate Ohmic distribution in coils based on plasma shape rectl self inductance for rectangular current source rect_2d B-field at [X,Y] from straight rectangular X-sect. conductor rect_3d_b B-field at [X,Y,Z] from box shaped straight filament self_fil Self Inductance of filament set (ONLY APPROX) sind Self Inductance of a axisymmetic elongated coil (Uniform J)","title":"Basic Information"},{"location":"function-guide/mag/bgreens_conway_m/","text":"bgreens_conway.m \u00b6 Basic Information \u00b6 SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_fine(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. This version of code is based on low level calculation using fine.m. Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bpdata(1:5,:)=[Z;R;Ang;length(m);Ip coeff] (5th row is ignored, so 4 x number probes also works) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"bgreens_conway.m"},{"location":"function-guide/mag/bgreens_conway_m/#bgreens_conwaym","text":"","title":"bgreens_conway.m"},{"location":"function-guide/mag/bgreens_conway_m/#basic-information","text":"SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_fine(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. This version of code is based on low level calculation using fine.m. Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bpdata(1:5,:)=[Z;R;Ang;length(m);Ip coeff] (5th row is ignored, so 4 x number probes also works) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/bgreens_distrib_m/","text":"bgreens_distrib.m \u00b6 Basic Information \u00b6 SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_distrib(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. (Use mutind_distrib with bcoil_data = filaments to compute Greens functions for flux.) Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bpdata(1:5,:)=[Z;R;Ang;length(m);Ip coeff] (5th row is ignored, so 4 x number probes also works) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"bgreens_distrib.m"},{"location":"function-guide/mag/bgreens_distrib_m/#bgreens_distribm","text":"","title":"bgreens_distrib.m"},{"location":"function-guide/mag/bgreens_distrib_m/#basic-information","text":"SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_distrib(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. (Use mutind_distrib with bcoil_data = filaments to compute Greens functions for flux.) Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bpdata(1:5,:)=[Z;R;Ang;length(m);Ip coeff] (5th row is ignored, so 4 x number probes also works) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/bgreens_fine_m/","text":"bgreens_fine.m \u00b6 Basic Information \u00b6 @(#)bgreens_fine.m 1.4 02/11/08 SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_fine(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. This version of code is based on low level calculation using fine.m. Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bprobe_data(1:6,:)=[Z;R;Ang;length(m);Ip coeff;width(m)] (abs(4th row) specifies width if < 0) (5th row is ignored, so 4 x number probes also works) (6th row is optional, assumed 0.02m if not provided) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: If probe width is specified in 6 row bprobe_data AND there is length<0 in row 4, the row 4 specified length prevails. Probe will be treated as flat if width specified in row 4 (6 row convention allows l & w) METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation. WRITTEN BY: Mike Walker ON 7/26/99 10/03/03 JAL1 remove one line commented below 10/30/07 NWE length=0 \"saddle probes\" treated as single point 02/08/08 NWE applies probe cross section width if specified in bprobe_data(6,:) or length<0 in bprobe_data(4,:).","title":"bgreens_fine.m"},{"location":"function-guide/mag/bgreens_fine_m/#bgreens_finem","text":"","title":"bgreens_fine.m"},{"location":"function-guide/mag/bgreens_fine_m/#basic-information","text":"@(#)bgreens_fine.m 1.4 02/11/08 SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_fine(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. This version of code is based on low level calculation using fine.m. Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bprobe_data(1:6,:)=[Z;R;Ang;length(m);Ip coeff;width(m)] (abs(4th row) specifies width if < 0) (5th row is ignored, so 4 x number probes also works) (6th row is optional, assumed 0.02m if not provided) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: If probe width is specified in 6 row bprobe_data AND there is length<0 in row 4, the row 4 specified length prevails. Probe will be treated as flat if width specified in row 4 (6 row convention allows l & w) METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation. WRITTEN BY: Mike Walker ON 7/26/99 10/03/03 JAL1 remove one line commented below 10/30/07 NWE length=0 \"saddle probes\" treated as single point 02/08/08 NWE applies probe cross section width if specified in bprobe_data(6,:) or length<0 in bprobe_data(4,:).","title":"Basic Information"},{"location":"function-guide/mag/bld_subelements_m/","text":"bld_subelements.m \u00b6 Basic Information \u00b6 SYNTAX: [geometry,lnrect,snrect] = ... bld_subelements(cond_data,nrect,allow_filaments) PURPOSE: Split conductors into rectangular subelements. INPUT: cond_data = data describing geometry of conductor Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrect = number of rectangles to partition conductors. Interpretation depends on size of this object: scalar: nrect = number of rectangles across largest of conductor minimum dimensions (thickest conductor). All partitioning automatically computed from this. (Gives roughly constant subrectangle size over all conductors.) length vector == 2: nrect specifies FIXED nshort x nlong partitioning, nshort refers to min(dR,dZ) 2 x nconductors or nconductors x 2: nrect specifies FIXED values of (nshort, nlong) for each conductor nconductors length vector: nrect specifies fixed nshort for each conductor, nlong computed by dR/dZ scaling allow_filaments = set to 1 to allow filament (dR=dZ=0) coils, otherwise an error message will be printed if this is detected OUTPUT: geometry = 7 x n matrix describing all subelements of all conductors Each column has the following information: [z of current element; r of current element; conductor number; dz of subelement; dr of subelement; row number of element within conductor; column number of element within conductor] lnrect = number of rectangles in longer dimension, for each conductor","title":"bld_subelements.m"},{"location":"function-guide/mag/bld_subelements_m/#bld_subelementsm","text":"","title":"bld_subelements.m"},{"location":"function-guide/mag/bld_subelements_m/#basic-information","text":"SYNTAX: [geometry,lnrect,snrect] = ... bld_subelements(cond_data,nrect,allow_filaments) PURPOSE: Split conductors into rectangular subelements. INPUT: cond_data = data describing geometry of conductor Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrect = number of rectangles to partition conductors. Interpretation depends on size of this object: scalar: nrect = number of rectangles across largest of conductor minimum dimensions (thickest conductor). All partitioning automatically computed from this. (Gives roughly constant subrectangle size over all conductors.) length vector == 2: nrect specifies FIXED nshort x nlong partitioning, nshort refers to min(dR,dZ) 2 x nconductors or nconductors x 2: nrect specifies FIXED values of (nshort, nlong) for each conductor nconductors length vector: nrect specifies fixed nshort for each conductor, nlong computed by dR/dZ scaling allow_filaments = set to 1 to allow filament (dR=dZ=0) coils, otherwise an error message will be printed if this is detected OUTPUT: geometry = 7 x n matrix describing all subelements of all conductors Each column has the following information: [z of current element; r of current element; conductor number; dz of subelement; dr of subelement; row number of element within conductor; column number of element within conductor] lnrect = number of rectangles in longer dimension, for each conductor","title":"Basic Information"},{"location":"function-guide/mag/calc_bgreens_m/","text":"calc_bgreens.m \u00b6 Basic Information \u00b6 SYNTAX: [Br,Bz,dBrdr,dBrdz,dBzdr,dBzdz] = calc_bgreens(ra,rb,za,zb,k,Ek,Kk) PURPOSE: Calculate Br, Bz green functions with the option of using already computed elliptic integrals. [Kk,Ek]=ellipke(m) k=sqrt(m); where m=((rb+ra).^2 - (rb-ra).^2)./((rb+ra).^2 + (za-zb).^2); INPUT: ra = radius of source element (m) rb = radius of measurement point (m) za = z position of source element (m) zb = z position of measurement point (m) k = parameter that is argument to elliptic integrals (optional) Ek = calculated value of elliptic integral E(k) (optional) Kk = calculated value of elliptic integral K(k) (optional) All inputs must be same size (scalars, vectors, or matrices). If k,Ek,Kk not specified, they are computed here. OUTPUT: Br = radial field at measurement point due to current in filament at source location Bz = vertical field at measurement point due to current in filament at source location dBrdr = derivative of Br w.r.t. rb at measurement point dBrdz = derivative of Br w.r.t. zb at measurement point dBzdr = derivative of Bz w.r.t. rb at measurement point dBzdz = derivative of Bz w.r.t. zb at measurement point RESTRICTIONS: This is a \"filament-to-filament\" calculation and is not correct for distributed current sources. The filament calculation is singular for \"point b\" equal to \"point a\".","title":"calc_bgreens.m"},{"location":"function-guide/mag/calc_bgreens_m/#calc_bgreensm","text":"","title":"calc_bgreens.m"},{"location":"function-guide/mag/calc_bgreens_m/#basic-information","text":"SYNTAX: [Br,Bz,dBrdr,dBrdz,dBzdr,dBzdz] = calc_bgreens(ra,rb,za,zb,k,Ek,Kk) PURPOSE: Calculate Br, Bz green functions with the option of using already computed elliptic integrals. [Kk,Ek]=ellipke(m) k=sqrt(m); where m=((rb+ra).^2 - (rb-ra).^2)./((rb+ra).^2 + (za-zb).^2); INPUT: ra = radius of source element (m) rb = radius of measurement point (m) za = z position of source element (m) zb = z position of measurement point (m) k = parameter that is argument to elliptic integrals (optional) Ek = calculated value of elliptic integral E(k) (optional) Kk = calculated value of elliptic integral K(k) (optional) All inputs must be same size (scalars, vectors, or matrices). If k,Ek,Kk not specified, they are computed here. OUTPUT: Br = radial field at measurement point due to current in filament at source location Bz = vertical field at measurement point due to current in filament at source location dBrdr = derivative of Br w.r.t. rb at measurement point dBrdz = derivative of Br w.r.t. zb at measurement point dBzdr = derivative of Bz w.r.t. rb at measurement point dBzdz = derivative of Bz w.r.t. zb at measurement point RESTRICTIONS: This is a \"filament-to-filament\" calculation and is not correct for distributed current sources. The filament calculation is singular for \"point b\" equal to \"point a\".","title":"Basic Information"},{"location":"function-guide/mag/calc_eddy_flux_m/","text":"calc_eddy_flux.m \u00b6 Basic Information \u00b6 SYNTAX: [flux,B,Br,Bz,ivv,t_ivv,imc]= calc_eddy_flux(shotnum,tok_data_struct,rtimes,t,Icoils,... psidata,probedata,options,plasma) PURPOSE: Compute flux/field in vacuum region for multiple rtimes using a fit to measured diagnostics, then compute approximate loop voltage. Fit may optionally use eigenmode approximation of vessel or do full integration of VV eddy currents for fitting vessel effects, include axisymmetric magnetic materials, and/or include Ip effects. INPUT: [default] shotnum = number of shot to reconstruct rtimes = time steps at which to reconstruct vacuum flux/field t = time vector for data signals Icoils = PF coil current data psidata = flux loop data probedata = magnetic probe data options cccirc = PF coils circuit connection mapping Pcc = mapping from coil states to all PF coils (only one of cccirc or Pcc should be provided) clevels = # levels on contour plots [10] idxbp = indices of B-probes to fit [all=1:nbp] idxfl = indices of flux loops to fit [all=1:nfl] idxvv = indices of VV elements to use [all=1:nv] ieddy = 0: Use eigenmode expansion of VV to fit vv currents 1: Use integrated VV eddy currents for fitting navg = # time points over which measurements are averaged [3] neig = # eigenmods to reating if ieddy=0 [10] pause_it = pause after plots for inspection (1=yes 0=no) [0] plotb = plot magnetic fields (1=yes 0=no) [1] plotfl = plot magnetic flux (1=yes 0=no) [1] (SEE calc_vv_eddy for further options) plasma (see calc_vv_eddy) NOTE: To reproduce results of calc_vac_flux simply put ieddy=0. OUTPUT: flux = magnetic flux at plasma grid points for each time step B,Br,Bz = magnetic field \"\"\"\" ivv = calculated vessel currents (if ieddy = 1) t_ivv = time vector for calculated vessel currents imc = magnetization currents Plots: 1. contour plots of magnetic flux and field over the kstar x-section RESTRICTIONS: 1. Assumes that all data is uniformly sampled & in same time intervals WRITTEN BY: Jim Leuer ON 9/22/06 Optimization part taken from M. Walkers calc_vac_flux and modified. also different plot features @(#)calc_eddy_flux.m 1.7 02/02/10","title":"calc_eddy_flux.m"},{"location":"function-guide/mag/calc_eddy_flux_m/#calc_eddy_fluxm","text":"","title":"calc_eddy_flux.m"},{"location":"function-guide/mag/calc_eddy_flux_m/#basic-information","text":"SYNTAX: [flux,B,Br,Bz,ivv,t_ivv,imc]= calc_eddy_flux(shotnum,tok_data_struct,rtimes,t,Icoils,... psidata,probedata,options,plasma) PURPOSE: Compute flux/field in vacuum region for multiple rtimes using a fit to measured diagnostics, then compute approximate loop voltage. Fit may optionally use eigenmode approximation of vessel or do full integration of VV eddy currents for fitting vessel effects, include axisymmetric magnetic materials, and/or include Ip effects. INPUT: [default] shotnum = number of shot to reconstruct rtimes = time steps at which to reconstruct vacuum flux/field t = time vector for data signals Icoils = PF coil current data psidata = flux loop data probedata = magnetic probe data options cccirc = PF coils circuit connection mapping Pcc = mapping from coil states to all PF coils (only one of cccirc or Pcc should be provided) clevels = # levels on contour plots [10] idxbp = indices of B-probes to fit [all=1:nbp] idxfl = indices of flux loops to fit [all=1:nfl] idxvv = indices of VV elements to use [all=1:nv] ieddy = 0: Use eigenmode expansion of VV to fit vv currents 1: Use integrated VV eddy currents for fitting navg = # time points over which measurements are averaged [3] neig = # eigenmods to reating if ieddy=0 [10] pause_it = pause after plots for inspection (1=yes 0=no) [0] plotb = plot magnetic fields (1=yes 0=no) [1] plotfl = plot magnetic flux (1=yes 0=no) [1] (SEE calc_vv_eddy for further options) plasma (see calc_vv_eddy) NOTE: To reproduce results of calc_vac_flux simply put ieddy=0. OUTPUT: flux = magnetic flux at plasma grid points for each time step B,Br,Bz = magnetic field \"\"\"\" ivv = calculated vessel currents (if ieddy = 1) t_ivv = time vector for calculated vessel currents imc = magnetization currents Plots: 1. contour plots of magnetic flux and field over the kstar x-section RESTRICTIONS: 1. Assumes that all data is uniformly sampled & in same time intervals WRITTEN BY: Jim Leuer ON 9/22/06 Optimization part taken from M. Walkers calc_vac_flux and modified. also different plot features @(#)calc_eddy_flux.m 1.7 02/02/10","title":"Basic Information"},{"location":"function-guide/mag/calc_mpp_m/","text":"calc_mpp.m \u00b6 Basic Information \u00b6 SYNTAX: [mpp,gbr2p,gbz2p] = calc_mpp(rgg,zgg,dr,dz,nz,nr) PURPOSE: calculate mutuals between all plasma gridpoints INPUT: rgg = r coords of all grids zgg = z coords of all grids dr = r width of all grid \"current elements\" dz = z width of all grid \"current elements\" nz = number of grids in z direction nr = number of grids in r direction OUTPUT: mpp = mutuals between all plasma gridpoints (uH) gbr2p = Br greens functions from plasma grid to itself (T/MA) gbz2p = Bz greens functions from plasma grid to itself (T/MA) !!NOTE!!: This data is stored in a compressed format using the fact that it is only the difference in z coordinates which enters the mutual and Greens' function calculations: All output matrices are of size (nz*nr) by nr, where columns represent different values of radial coordinate. To extract a mutual inductance or Green's function value for the kth grid point (measurement point) versus the jth grid point (current source), do the following: (1) calculate the number of grids n that grid point k is above the jth grid point in z direction (negative value n if kth is below jth) (2) calculate the column number m (m=1,...,nr) that grid point k is in. (3) mutual inductance = mpp((m-1)*nz+|n|+1,j) (4) Br greens function = sign(n) * gbr2p((m-1)*nz+|n|+1,j) where sign(n) = 1, if n>=0 = -1, if n<0. (5) Bz greens function = gbz2p((m-1)*nz+|n|+1,j) Note that it is only important to distinguish between the source and measurement point for Br Green's function values. This \"uncompress\" procedure is implemented in get_plasma_greens.m.","title":"calc_mpp.m"},{"location":"function-guide/mag/calc_mpp_m/#calc_mppm","text":"","title":"calc_mpp.m"},{"location":"function-guide/mag/calc_mpp_m/#basic-information","text":"SYNTAX: [mpp,gbr2p,gbz2p] = calc_mpp(rgg,zgg,dr,dz,nz,nr) PURPOSE: calculate mutuals between all plasma gridpoints INPUT: rgg = r coords of all grids zgg = z coords of all grids dr = r width of all grid \"current elements\" dz = z width of all grid \"current elements\" nz = number of grids in z direction nr = number of grids in r direction OUTPUT: mpp = mutuals between all plasma gridpoints (uH) gbr2p = Br greens functions from plasma grid to itself (T/MA) gbz2p = Bz greens functions from plasma grid to itself (T/MA) !!NOTE!!: This data is stored in a compressed format using the fact that it is only the difference in z coordinates which enters the mutual and Greens' function calculations: All output matrices are of size (nz*nr) by nr, where columns represent different values of radial coordinate. To extract a mutual inductance or Green's function value for the kth grid point (measurement point) versus the jth grid point (current source), do the following: (1) calculate the number of grids n that grid point k is above the jth grid point in z direction (negative value n if kth is below jth) (2) calculate the column number m (m=1,...,nr) that grid point k is in. (3) mutual inductance = mpp((m-1)*nz+|n|+1,j) (4) Br greens function = sign(n) * gbr2p((m-1)*nz+|n|+1,j) where sign(n) = 1, if n>=0 = -1, if n<0. (5) Bz greens function = gbz2p((m-1)*nz+|n|+1,j) Note that it is only important to distinguish between the source and measurement point for Br Green's function values. This \"uncompress\" procedure is implemented in get_plasma_greens.m.","title":"Basic Information"},{"location":"function-guide/mag/calc_ohmic_res_m/","text":"calc_ohmic_res.m \u00b6 Basic Information \u00b6 PURPOSE: Calculates Best Coil resistances to produce constant flux decay USAGE: rcc= calc_ohmic_res(mcc,icc); INPUTS: [default] mcc= coil mutual inductance matrix icc= Optimum initial magnetization current vector OUTPUTS: rcc = optimum resistance matrix METHOD: [I]^-1 is diaganal matrix made up of 1/I_i currents R/gamma = [I]^-1 [M] I LIMITATIONS: Assumes the initial current distrubution is Ohmic (i.e. produces constant flux plateau in plasma region. icc is typically generated using ohmic_dist see also ohmic_dist.m","title":"calc_ohmic_res.m"},{"location":"function-guide/mag/calc_ohmic_res_m/#calc_ohmic_resm","text":"","title":"calc_ohmic_res.m"},{"location":"function-guide/mag/calc_ohmic_res_m/#basic-information","text":"PURPOSE: Calculates Best Coil resistances to produce constant flux decay USAGE: rcc= calc_ohmic_res(mcc,icc); INPUTS: [default] mcc= coil mutual inductance matrix icc= Optimum initial magnetization current vector OUTPUTS: rcc = optimum resistance matrix METHOD: [I]^-1 is diaganal matrix made up of 1/I_i currents R/gamma = [I]^-1 [M] I LIMITATIONS: Assumes the initial current distrubution is Ohmic (i.e. produces constant flux plateau in plasma region. icc is typically generated using ohmic_dist see also ohmic_dist.m","title":"Basic Information"},{"location":"function-guide/mag/calc_vv_eddy_m/","text":"calc_vv_eddy.m \u00b6 Basic Information \u00b6 @(#)calc_vv_eddy.m 1.3 04/21/08 SYNTAX: [ivv,t_ivv] ... = calc_vv_eddy(shotnum,tok_data_struct,t,icoils,options,plasma) PURPOSE: Calculates VV eddy currents from PF coil ramps, with plasma effects optionally included. INPUT: [default] shotnum = shot number tok_data_struct = TokSys vacuum object t = time vector for current waveforms icoils = coil current matrix (A) (dim = [ntimes,ncoils] options cutoff = Cutoff frequency for filtering I_dot (Hz) [100Hz] cor_offdrf = dI/dt data correction (0=none 1=offset 2=drift) [0] idxvv = indices of VV elements to use in calculation [1:nv] inc_pl = include Ip effects (1=yes 0=no) [0] (requires plasma structure if 1) ivv0 = initial vv currents (size = length(idxvv)) (A) [0] n_offdrf = # points to use for offset or drift correction [100] pause_it = pause after plots for inspection (1=yes 0=no) [0] ploted = plot eddy current analysis (1=yes 0=no) [1] resv_fac = multiplication factor for VV resistance [1] t0 = starting time for VV current integration (s) [0] plasma ip = plasma current vector (A) r_pl = plasma major radius (m) a_pl = plasma minor radius (m) k_pl = plasma elongations [1.0] d_pl = plasma triangularity [0] n_pl = # pts defining plasma edge [100] z_pl = plasma vertical positions (m) [0] OUTPUT: ivv = VV eddy current vectors (size = [nt,nv]); t_ivv = VV eddy current time vector (size = nt) RESTRICTIONS: 1. Assumes that all data is uniformly sampled & in same time intervals METHOD: WRITTEN BY: Jim Leuer ON 9/28/06 taken from calc_eddy_flux MODIFICATIONS: 2008-03-03 NWE generalized to use with any tokamak, removed data retrieval =============================================================================","title":"calc_vv_eddy.m"},{"location":"function-guide/mag/calc_vv_eddy_m/#calc_vv_eddym","text":"","title":"calc_vv_eddy.m"},{"location":"function-guide/mag/calc_vv_eddy_m/#basic-information","text":"@(#)calc_vv_eddy.m 1.3 04/21/08 SYNTAX: [ivv,t_ivv] ... = calc_vv_eddy(shotnum,tok_data_struct,t,icoils,options,plasma) PURPOSE: Calculates VV eddy currents from PF coil ramps, with plasma effects optionally included. INPUT: [default] shotnum = shot number tok_data_struct = TokSys vacuum object t = time vector for current waveforms icoils = coil current matrix (A) (dim = [ntimes,ncoils] options cutoff = Cutoff frequency for filtering I_dot (Hz) [100Hz] cor_offdrf = dI/dt data correction (0=none 1=offset 2=drift) [0] idxvv = indices of VV elements to use in calculation [1:nv] inc_pl = include Ip effects (1=yes 0=no) [0] (requires plasma structure if 1) ivv0 = initial vv currents (size = length(idxvv)) (A) [0] n_offdrf = # points to use for offset or drift correction [100] pause_it = pause after plots for inspection (1=yes 0=no) [0] ploted = plot eddy current analysis (1=yes 0=no) [1] resv_fac = multiplication factor for VV resistance [1] t0 = starting time for VV current integration (s) [0] plasma ip = plasma current vector (A) r_pl = plasma major radius (m) a_pl = plasma minor radius (m) k_pl = plasma elongations [1.0] d_pl = plasma triangularity [0] n_pl = # pts defining plasma edge [100] z_pl = plasma vertical positions (m) [0] OUTPUT: ivv = VV eddy current vectors (size = [nt,nv]); t_ivv = VV eddy current time vector (size = nt) RESTRICTIONS: 1. Assumes that all data is uniformly sampled & in same time intervals METHOD: WRITTEN BY: Jim Leuer ON 9/28/06 taken from calc_eddy_flux MODIFICATIONS: 2008-03-03 NWE generalized to use with any tokamak, removed data retrieval =============================================================================","title":"Basic Information"},{"location":"function-guide/mag/cfil_3d_b_m/","text":"cfil_3d_b.m \u00b6 Basic Information \u00b6 PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] produced by a circular filament with radius a located with center at 0,0,0 and center line in +Z direction. Unit current (1A) in counter clockwise The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= cfil_3d_b(x,y,z,a) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [a] == vector of filament radius one filament per row Note: If x,y,z & a are matrix or vectors they must be same size. Any of the components can be a scalar. OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use cfilr_3b_b if [X] is inside the filament","title":"cfil_3d_b.m"},{"location":"function-guide/mag/cfil_3d_b_m/#cfil_3d_bm","text":"","title":"cfil_3d_b.m"},{"location":"function-guide/mag/cfil_3d_b_m/#basic-information","text":"PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] produced by a circular filament with radius a located with center at 0,0,0 and center line in +Z direction. Unit current (1A) in counter clockwise The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= cfil_3d_b(x,y,z,a) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [a] == vector of filament radius one filament per row Note: If x,y,z & a are matrix or vectors they must be same size. Any of the components can be a scalar. OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use cfilr_3b_b if [X] is inside the filament","title":"Basic Information"},{"location":"function-guide/mag/cir_filament_m/","text":"cir_filament.m \u00b6 Basic Information \u00b6 Computes the field: [br,bz] at field point rp,zp from a circular filament located at rc,zc with current ic usage: [br,bz]= cir_filament(rc,zc,ic,rp,zp) where: rc= radius of filament [m] zc= z position of filament [m] ic= current in filament [A] rp= radial position of field point [m] zp= z position of field point [m] br= radial field at field point [T] bz= axial field at field point [T]","title":"cir_filament.m"},{"location":"function-guide/mag/cir_filament_m/#cir_filamentm","text":"","title":"cir_filament.m"},{"location":"function-guide/mag/cir_filament_m/#basic-information","text":"Computes the field: [br,bz] at field point rp,zp from a circular filament located at rc,zc with current ic usage: [br,bz]= cir_filament(rc,zc,ic,rp,zp) where: rc= radius of filament [m] zc= z position of filament [m] ic= current in filament [A] rp= radial position of field point [m] zp= z position of field point [m] br= radial field at field point [T] bz= axial field at field point [T]","title":"Basic Information"},{"location":"function-guide/mag/crect2bprobe_m/","text":"crect2bprobe.m \u00b6 Basic Information \u00b6 PURPOSE: Generated B-field at magnetic probe located at rp,zp with angle theta and length l from circular coil locatd at rc,zc with rectanular width and height dr and dz and carrying current cur. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [b]= crect2bprobe(rc,zc,dr,dz,i,r,z,theta,leng) INPUT: rc,zc= coordinates of center of rectangular coil dr,dz= width and height of coil cur= current in coil (+=counter clockwise) rp,zp= coordinates of the center of the probe angle= Angle of the coil with the horozontal (deg) leng= length of the probe in the theta direction OUTPUT: [b] == B field at probes CAUTION: Present version does not use leng. It computes field only at center NOTE: uses magnetics routing fine.m which is single precision","title":"crect2bprobe.m"},{"location":"function-guide/mag/crect2bprobe_m/#crect2bprobem","text":"","title":"crect2bprobe.m"},{"location":"function-guide/mag/crect2bprobe_m/#basic-information","text":"PURPOSE: Generated B-field at magnetic probe located at rp,zp with angle theta and length l from circular coil locatd at rc,zc with rectanular width and height dr and dz and carrying current cur. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [b]= crect2bprobe(rc,zc,dr,dz,i,r,z,theta,leng) INPUT: rc,zc= coordinates of center of rectangular coil dr,dz= width and height of coil cur= current in coil (+=counter clockwise) rp,zp= coordinates of the center of the probe angle= Angle of the coil with the horozontal (deg) leng= length of the probe in the theta direction OUTPUT: [b] == B field at probes CAUTION: Present version does not use leng. It computes field only at center NOTE: uses magnetics routing fine.m which is single precision","title":"Basic Information"},{"location":"function-guide/mag/crect_3d_m/","text":"crect_3d.m \u00b6 Basic Information \u00b6 PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] at point xp,yp,zp produced by a uniform current density coil located at rc,zc with axis in +Z and having a rectangular cross section dr x dz and carrying current cur. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= crect_3d(rc,zc,dr,dz,cur,xp,yp,zp) rc,zc = center of rectangle dr,dz = radial width and height of rectangle cur = current in rectangle xp,yp,zp= location of field point to determine field Note: Works for vectors all of the same size OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use fine so see limintations in fine.m","title":"crect_3d.m"},{"location":"function-guide/mag/crect_3d_m/#crect_3dm","text":"","title":"crect_3d.m"},{"location":"function-guide/mag/crect_3d_m/#basic-information","text":"PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] at point xp,yp,zp produced by a uniform current density coil located at rc,zc with axis in +Z and having a rectangular cross section dr x dz and carrying current cur. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= crect_3d(rc,zc,dr,dz,cur,xp,yp,zp) rc,zc = center of rectangle dr,dz = radial width and height of rectangle cur = current in rectangle xp,yp,zp= location of field point to determine field Note: Works for vectors all of the same size OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use fine so see limintations in fine.m","title":"Basic Information"},{"location":"function-guide/mag/fil_3d_b_m/","text":"fil_3d_b.m \u00b6 Basic Information \u00b6 PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] produced by a straight filament with length [c] in the z direction carrying Unit current (I=1A) in the +z direction The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= fil_3d_b(x,y,z,c) INPUT: [x,y,z] == [X] coordinates of field point for calculation of B [c] == length of filament (scalar or same size as X) Note: x,y,z or c can be a scalar or matrix but all matricies must be same size. Any of the components can be a scalar. Caution: if x and y are both zero answer is NAN (use fil_3d_b_rad) OUTPUT: [bx,by,bz] == [B] B-field at point X NOTE: see filr_3d_b for filaments with finite radius computation inside rad.","title":"fil_3d_b.m"},{"location":"function-guide/mag/fil_3d_b_m/#fil_3d_bm","text":"","title":"fil_3d_b.m"},{"location":"function-guide/mag/fil_3d_b_m/#basic-information","text":"PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] produced by a straight filament with length [c] in the z direction carrying Unit current (I=1A) in the +z direction The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= fil_3d_b(x,y,z,c) INPUT: [x,y,z] == [X] coordinates of field point for calculation of B [c] == length of filament (scalar or same size as X) Note: x,y,z or c can be a scalar or matrix but all matricies must be same size. Any of the components can be a scalar. Caution: if x and y are both zero answer is NAN (use fil_3d_b_rad) OUTPUT: [bx,by,bz] == [B] B-field at point X NOTE: see filr_3d_b for filaments with finite radius computation inside rad.","title":"Basic Information"},{"location":"function-guide/mag/fil_a_m/","text":"fil_a.m \u00b6 Basic Information \u00b6 PURPOSE: Generates the Z directed vector potential Az from by a straight filament centered at the origin [0,0,0] carrying Unit current (1A) in the +Z direction Filament limits are z=-c/2 to z=+c/2 Only component is Az, All other components are zero (Ax, Ay == 0) Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: az= fil_a(x,y,z,c) INPUT: x,y,z = coordinates of field point for calculation of Az [m] c = length of filament (scalar or same length as x) [m] Note: x,y,z or c can be a scalar or matrix but all matricies must be same size. Any of the components can be a scalar. OUTPUT: az == Vector Potential, Az, at point x,y,z [Web/m] Caution: On filament (x=y=0) solution is infinite between -a/2<=z<=a/2 solution gives INF. On axis (r=0), above and below the filament the solution is finite and correctly calculated DO NOT USE FOR SELF INDUCT.","title":"fil_a.m"},{"location":"function-guide/mag/fil_a_m/#fil_am","text":"","title":"fil_a.m"},{"location":"function-guide/mag/fil_a_m/#basic-information","text":"PURPOSE: Generates the Z directed vector potential Az from by a straight filament centered at the origin [0,0,0] carrying Unit current (1A) in the +Z direction Filament limits are z=-c/2 to z=+c/2 Only component is Az, All other components are zero (Ax, Ay == 0) Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: az= fil_a(x,y,z,c) INPUT: x,y,z = coordinates of field point for calculation of Az [m] c = length of filament (scalar or same length as x) [m] Note: x,y,z or c can be a scalar or matrix but all matricies must be same size. Any of the components can be a scalar. OUTPUT: az == Vector Potential, Az, at point x,y,z [Web/m] Caution: On filament (x=y=0) solution is infinite between -a/2<=z<=a/2 solution gives INF. On axis (r=0), above and below the filament the solution is finite and correctly calculated DO NOT USE FOR SELF INDUCT.","title":"Basic Information"},{"location":"function-guide/mag/filr_3d_b_m/","text":"filr_3d_b.m \u00b6 Basic Information \u00b6 PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] from straight filament Filament has finite radius [d] and length [c] in z direction. Inside r<d the field is proportional to r rather than 1/r for filament. Filament has uniform current density and carries unit current (I=1A) in the +z direction. The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= filr_3d_b(x,y,z,c,d) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [c] == vector of filament lengths one filament per row [d] == vector of filament radius one filament per row Note: If x,y,z & c,d are matrix or vectors they must be same size. Any of the components can be a scalar. OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use fil_3b_b if [X] is outside filament for faster execution","title":"filr_3d_b.m"},{"location":"function-guide/mag/filr_3d_b_m/#filr_3d_bm","text":"","title":"filr_3d_b.m"},{"location":"function-guide/mag/filr_3d_b_m/#basic-information","text":"PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] from straight filament Filament has finite radius [d] and length [c] in z direction. Inside r<d the field is proportional to r rather than 1/r for filament. Filament has uniform current density and carries unit current (I=1A) in the +z direction. The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= filr_3d_b(x,y,z,c,d) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [c] == vector of filament lengths one filament per row [d] == vector of filament radius one filament per row Note: If x,y,z & c,d are matrix or vectors they must be same size. Any of the components can be a scalar. OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use fil_3b_b if [X] is outside filament for faster execution","title":"Basic Information"},{"location":"function-guide/mag/fine_m/","text":"fine.m \u00b6 Basic Information \u00b6 fine.m: Axisymmetric Magnetics from uniform current rectangle to point SYNTAX: [hr,hz,fl] =fine(ri,ro,zl,zu,cur,rp,zp,<idebug>) Magnetics function to determine the fields from an axisymmetric rectangular uniform current region (ri,ro,zl,zu,cur) to a point (rp,zp). SYNTAX: [hr,hz,fl] =fine(ri,ro,zl,zu,cur,rp,zp,<idebug>) INPUTS: ri,ro,zl,zu = inner,outer,lower,upper dimensions of region [m] cur = current [Amp] rp,zp = receiving point [m] idebug = debug parameter, 0=no, >0 = debug print out NOTE: FINE accepts vectors as long as all vectors are same size (ie ri(10),ro(100,zl(10),zu(10),cur(10),rp(10),zp(10) OUTPUTS: hr, hz = fields at points rp,zp [Amp/m] fl = flux at point [Weber/mu_o] NOTE: multiply results by mu_o= 4*pi*1e-7 to get Tesla and Weber CAUTION: Accuracy of routine becomes problematic for highly elongated rectangles at small radius - SOLUTION: break up into group of smaller rectangles NOTE: same routine can be executed as a MEX file (for faster execution) SYNTAX: [hr,hz,fl] =fine1(ri,ro,zl,zu,cur,rp,zp,<idebug>)","title":"fine.m"},{"location":"function-guide/mag/fine_m/#finem","text":"","title":"fine.m"},{"location":"function-guide/mag/fine_m/#basic-information","text":"fine.m: Axisymmetric Magnetics from uniform current rectangle to point SYNTAX: [hr,hz,fl] =fine(ri,ro,zl,zu,cur,rp,zp,<idebug>) Magnetics function to determine the fields from an axisymmetric rectangular uniform current region (ri,ro,zl,zu,cur) to a point (rp,zp). SYNTAX: [hr,hz,fl] =fine(ri,ro,zl,zu,cur,rp,zp,<idebug>) INPUTS: ri,ro,zl,zu = inner,outer,lower,upper dimensions of region [m] cur = current [Amp] rp,zp = receiving point [m] idebug = debug parameter, 0=no, >0 = debug print out NOTE: FINE accepts vectors as long as all vectors are same size (ie ri(10),ro(100,zl(10),zu(10),cur(10),rp(10),zp(10) OUTPUTS: hr, hz = fields at points rp,zp [Amp/m] fl = flux at point [Weber/mu_o] NOTE: multiply results by mu_o= 4*pi*1e-7 to get Tesla and Weber CAUTION: Accuracy of routine becomes problematic for highly elongated rectangles at small radius - SOLUTION: break up into group of smaller rectangles NOTE: same routine can be executed as a MEX file (for faster execution) SYNTAX: [hr,hz,fl] =fine1(ri,ro,zl,zu,cur,rp,zp,<idebug>)","title":"Basic Information"},{"location":"function-guide/mag/green_near_m/","text":"green_near.m \u00b6 Basic Information \u00b6 SYNTAX: [br,bz,dbrdr,dbrdz,dbzdr,dbzdz] = ... green_near(rcurr,zcurr,rdim,zdim,rb,zb,nsplit) PURPOSE: Calculate green function from current flowing in a loop of rectangular cross-section to a filamentary loop which is nearby. This function is meant to handle carefully the evaluation of green functions for loops which are very close to one another. INPUT: rcurr= radius of centroid of current source (m) zcurr= z-dimension (height) of centroid of current source (m) rb = radius of point at which induced field will be measured (m) zb = z-dimension (height) of point where induced field is measured (m) rdim = r dimension of rectangle in which current flows (m) zdim = z dimension of rectangle in which current flows (m) nsplit = number of pieces to split each coordinate (z,r) of current source into for calculation (option, default=[8,8]) Variables rcurr,zcurr, rb, and zb must be same size (scalar or vector). Variables rdim, zdim must be scalar. OUTPUT: br = calculated green function for br (Tesla/Amp) bz = calculated green function for bz (Tesla/Amp) RESTRICTIONS: METHOD: Break up rectangle into small pieces. Use standard method to calculate values for pieces not containing measurement point. Use some other approximation (what?) for piece containing measurement point. Add up all values and divide by number of pieces (i.e. divvy up current evenly into the small pieces).","title":"green_near.m"},{"location":"function-guide/mag/green_near_m/#green_nearm","text":"","title":"green_near.m"},{"location":"function-guide/mag/green_near_m/#basic-information","text":"SYNTAX: [br,bz,dbrdr,dbrdz,dbzdr,dbzdz] = ... green_near(rcurr,zcurr,rdim,zdim,rb,zb,nsplit) PURPOSE: Calculate green function from current flowing in a loop of rectangular cross-section to a filamentary loop which is nearby. This function is meant to handle carefully the evaluation of green functions for loops which are very close to one another. INPUT: rcurr= radius of centroid of current source (m) zcurr= z-dimension (height) of centroid of current source (m) rb = radius of point at which induced field will be measured (m) zb = z-dimension (height) of point where induced field is measured (m) rdim = r dimension of rectangle in which current flows (m) zdim = z dimension of rectangle in which current flows (m) nsplit = number of pieces to split each coordinate (z,r) of current source into for calculation (option, default=[8,8]) Variables rcurr,zcurr, rb, and zb must be same size (scalar or vector). Variables rdim, zdim must be scalar. OUTPUT: br = calculated green function for br (Tesla/Amp) bz = calculated green function for bz (Tesla/Amp) RESTRICTIONS: METHOD: Break up rectangle into small pieces. Use standard method to calculate values for pieces not containing measurement point. Use some other approximation (what?) for piece containing measurement point. Add up all values and divide by number of pieces (i.e. divvy up current evenly into the small pieces).","title":"Basic Information"},{"location":"function-guide/mag/induc_rect_m/","text":"induc_rect.m \u00b6 Basic Information \u00b6 SYNTAXX: ind= induc_rect(a,b,r) PURPOSE: Calculate one-turn, self inductance of plane rectangle made from a circular cross section wire of radius r. The rectangle dimensions are a by b INPUT: a,b = dimensions of rectangle, (vector) [m] r = radius or wire cross (vector) [m] OUTPUT: ind = one turn, self inductance of coil [Henries] Multiply by N^2 if coil has N turns RESTRICTIONS: All input vectors must be the same length (or a scalar)","title":"induc_rect.m"},{"location":"function-guide/mag/induc_rect_m/#induc_rectm","text":"","title":"induc_rect.m"},{"location":"function-guide/mag/induc_rect_m/#basic-information","text":"SYNTAXX: ind= induc_rect(a,b,r) PURPOSE: Calculate one-turn, self inductance of plane rectangle made from a circular cross section wire of radius r. The rectangle dimensions are a by b INPUT: a,b = dimensions of rectangle, (vector) [m] r = radius or wire cross (vector) [m] OUTPUT: ind = one turn, self inductance of coil [Henries] Multiply by N^2 if coil has N turns RESTRICTIONS: All input vectors must be the same length (or a scalar)","title":"Basic Information"},{"location":"function-guide/mag/mag_fil_pt_m/","text":"mag_fil_pt.m \u00b6 Basic Information \u00b6 mag_fil_pt calculates the 3-d magrnetic field from a set of filaments SYNTAX: [rp,zp,phi,br,bz,bt]= mag_fil_pt(xp,yp,zp,x1,y1,z1,x2,y2,z2,cc) INPUT: xp,yp,zp = coordinates of field points [m] x1,y1...z2 = coordinates of starting (1) and end (2) of filament [m] cc = current in filament going from pt 1 to pt 2 [A] NOTE: all input can be vectors OUTPUT: rp,zp = location of field point [m] phi = toroidal location of field point [deg 0-2pi] br,bz,bt = B-field at field point radial,axial,toroidal [T]","title":"mag_fil_pt.m"},{"location":"function-guide/mag/mag_fil_pt_m/#mag_fil_ptm","text":"","title":"mag_fil_pt.m"},{"location":"function-guide/mag/mag_fil_pt_m/#basic-information","text":"mag_fil_pt calculates the 3-d magrnetic field from a set of filaments SYNTAX: [rp,zp,phi,br,bz,bt]= mag_fil_pt(xp,yp,zp,x1,y1,z1,x2,y2,z2,cc) INPUT: xp,yp,zp = coordinates of field points [m] x1,y1...z2 = coordinates of starting (1) and end (2) of filament [m] cc = current in filament going from pt 1 to pt 2 [A] NOTE: all input can be vectors OUTPUT: rp,zp = location of field point [m] phi = toroidal location of field point [deg 0-2pi] br,bz,bt = B-field at field point radial,axial,toroidal [T]","title":"Basic Information"},{"location":"function-guide/mag/mcircle2point_m/","text":"mcircle2point.m \u00b6 Basic Information \u00b6 USAGE: M = mcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma (or other axisymmetric conductor) carrying a uniform current density INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mfcircle2point, mpcircle2point","title":"mcircle2point.m"},{"location":"function-guide/mag/mcircle2point_m/#mcircle2pointm","text":"","title":"mcircle2point.m"},{"location":"function-guide/mag/mcircle2point_m/#basic-information","text":"USAGE: M = mcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma (or other axisymmetric conductor) carrying a uniform current density INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mfcircle2point, mpcircle2point","title":"Basic Information"},{"location":"function-guide/mag/mfcircle2point_m/","text":"mfcircle2point.m \u00b6 Basic Information \u00b6 USAGE: M = mfcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma where current density is proportional to 1/R (as it is for ffprim) INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mcircle2point, mpcircle2point","title":"mfcircle2point.m"},{"location":"function-guide/mag/mfcircle2point_m/#mfcircle2pointm","text":"","title":"mfcircle2point.m"},{"location":"function-guide/mag/mfcircle2point_m/#basic-information","text":"USAGE: M = mfcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma where current density is proportional to 1/R (as it is for ffprim) INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mcircle2point, mpcircle2point","title":"Basic Information"},{"location":"function-guide/mag/mindbf_gen_m/","text":"mindbf_gen.m \u00b6 Basic Information \u00b6 SYNTAX: [mut,br,bz,badindex] = mindbf_gen(ra,rb,za,zb,rdim,zdim,ndist,nsplit) PURPOSE: Calculate mutual inductance, B_r, and B_z from a current source \"a\" which is a coil carrying distributed current to a measurement point \"b\". Note that the fields are calculated at point b due to current at point a. Green functions are Henries and Tesla/Amp. This routine is a generalized version of Dave Humphreys' mindbf.pro which handles carefully all the problems that I could think of having to do with a distributed current source and with points a and b close together. INPUT: ra,za = r and z coordinates of current source(s) (meters) rb,zb = r and z coordinates of \"measurement point(s)\" (meters) rdim = r dimension of rectangular distributed current element source(s) (m) zdim = z dimension of rectangular distributed current element source(s) (m) ndist = number of multiples of rdim in r dimension and zdim in z dimension away from current element that a measurement point point should be in order to use simple filament-to-filament approximation (optional, default=3) nsplit = number of pieces to split each coordinate (z,r) of current source into for \"near\" calculation (optional, default=[8,8]) (Allows input of vectors of ra,za,rb,zb if size of a and b objects equal or one is scalar.) OUTPUT: mut = mutual inductance between 2 loops at locations (ra,za), (rb,zb) (Henries) br = multiplier of current at pt(s) a to produce radial field at pt(s) b (Tesla/Amp) bz = multiplier of current at pt(s) a to produce vertical field at pt(s) b (Tesla/Amp) badindex = if >= 0, index in input vector(s) for which elliptic integral calculator could not give good value. This means values of mut(badindex), br(badindex), and bz(badindex) are NOT VALID. Note: I think I've fixed it so that a bad value is never returned, but I want to leave this in for awhile so I can check if it's ever >=0. RESTRICTIONS: NOTE that this ASSUMES there will be AT MOST ONE instance of points from the a and b vectors which are too close together to calculate responses correctly. If vector input, all vectors ra, rb, za, and zb must be same size. In this case, output corresponds to pairings of elements in sets a and b. For example, mut is calculated between (ra(k),za(k)) and (rb(k),zb(k)), but not between (ra(k),za(k)) and (rb(j),zb(j)) for j different from k. NOTE: A number of \"divide by 0\" messages may be generated on first pass of some calculations. These are fixed later on by recomputation of data for \"too close\" points.","title":"mindbf_gen.m"},{"location":"function-guide/mag/mindbf_gen_m/#mindbf_genm","text":"","title":"mindbf_gen.m"},{"location":"function-guide/mag/mindbf_gen_m/#basic-information","text":"SYNTAX: [mut,br,bz,badindex] = mindbf_gen(ra,rb,za,zb,rdim,zdim,ndist,nsplit) PURPOSE: Calculate mutual inductance, B_r, and B_z from a current source \"a\" which is a coil carrying distributed current to a measurement point \"b\". Note that the fields are calculated at point b due to current at point a. Green functions are Henries and Tesla/Amp. This routine is a generalized version of Dave Humphreys' mindbf.pro which handles carefully all the problems that I could think of having to do with a distributed current source and with points a and b close together. INPUT: ra,za = r and z coordinates of current source(s) (meters) rb,zb = r and z coordinates of \"measurement point(s)\" (meters) rdim = r dimension of rectangular distributed current element source(s) (m) zdim = z dimension of rectangular distributed current element source(s) (m) ndist = number of multiples of rdim in r dimension and zdim in z dimension away from current element that a measurement point point should be in order to use simple filament-to-filament approximation (optional, default=3) nsplit = number of pieces to split each coordinate (z,r) of current source into for \"near\" calculation (optional, default=[8,8]) (Allows input of vectors of ra,za,rb,zb if size of a and b objects equal or one is scalar.) OUTPUT: mut = mutual inductance between 2 loops at locations (ra,za), (rb,zb) (Henries) br = multiplier of current at pt(s) a to produce radial field at pt(s) b (Tesla/Amp) bz = multiplier of current at pt(s) a to produce vertical field at pt(s) b (Tesla/Amp) badindex = if >= 0, index in input vector(s) for which elliptic integral calculator could not give good value. This means values of mut(badindex), br(badindex), and bz(badindex) are NOT VALID. Note: I think I've fixed it so that a bad value is never returned, but I want to leave this in for awhile so I can check if it's ever >=0. RESTRICTIONS: NOTE that this ASSUMES there will be AT MOST ONE instance of points from the a and b vectors which are too close together to calculate responses correctly. If vector input, all vectors ra, rb, za, and zb must be same size. In this case, output corresponds to pairings of elements in sets a and b. For example, mut is calculated between (ra(k),za(k)) and (rb(k),zb(k)), but not between (ra(k),za(k)) and (rb(j),zb(j)) for j different from k. NOTE: A number of \"divide by 0\" messages may be generated on first pass of some calculations. These are fixed later on by recomputation of data for \"too close\" points.","title":"Basic Information"},{"location":"function-guide/mag/mindbf_m/","text":"mindbf.m \u00b6 Basic Information \u00b6 SYNTAX: [mut,br,bz]=mindbf(ra,za,rb,zb) PURPOSE: Calculate mutual inductances and B-field Green functions in Matlab. Fields are calculated at point b due to current at point a. INPUT: ra,za = (meters) rb,zb = (meters) Allows input of vectors of ra,za,rb,zb. OUTPUT: mut = mutual inductance between 2 loops at locations (ra,za), (rb,zb) (Henries) br = multiplier of current at pt(s) a to produce radial field at pt(s) b (Tesla/Amp) bz = multiplier of current at pt(s) a to produce vertical field at pt(s) b (Tesla/Amp) RESTRICTIONS: If vector input, output corresponds to pairings of elements in sets a and b. For example, mut is calculated between (ra(k),za(k)) and (rb(k),zb(k)), but not between (ra(k),za(k)) and (rb(j),zb(j)) for j different from k.","title":"mindbf.m"},{"location":"function-guide/mag/mindbf_m/#mindbfm","text":"","title":"mindbf.m"},{"location":"function-guide/mag/mindbf_m/#basic-information","text":"SYNTAX: [mut,br,bz]=mindbf(ra,za,rb,zb) PURPOSE: Calculate mutual inductances and B-field Green functions in Matlab. Fields are calculated at point b due to current at point a. INPUT: ra,za = (meters) rb,zb = (meters) Allows input of vectors of ra,za,rb,zb. OUTPUT: mut = mutual inductance between 2 loops at locations (ra,za), (rb,zb) (Henries) br = multiplier of current at pt(s) a to produce radial field at pt(s) b (Tesla/Amp) bz = multiplier of current at pt(s) a to produce vertical field at pt(s) b (Tesla/Amp) RESTRICTIONS: If vector input, output corresponds to pairings of elements in sets a and b. For example, mut is calculated between (ra(k),za(k)) and (rb(k),zb(k)), but not between (ra(k),za(k)) and (rb(j),zb(j)) for j different from k.","title":"Basic Information"},{"location":"function-guide/mag/mpcircle2point_m/","text":"mpcircle2point.m \u00b6 Basic Information \u00b6 USAGE: M = mpcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma where current density is proportional to R (as it is for pprime) INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mcircle2point, mfcircle2point","title":"mpcircle2point.m"},{"location":"function-guide/mag/mpcircle2point_m/#mpcircle2pointm","text":"","title":"mpcircle2point.m"},{"location":"function-guide/mag/mpcircle2point_m/#basic-information","text":"USAGE: M = mpcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma where current density is proportional to R (as it is for pprime) INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mcircle2point, mfcircle2point","title":"Basic Information"},{"location":"function-guide/mag/mpolygon2point_m/","text":"mpolygon2point.m \u00b6 Basic Information \u00b6 SYNTAX: [M, Mr, Mz] = mpolygon2point(rpolygon, zpolygon, r, z, D) PURPOSE: Calculate mutual inductances between coaxial loops First loop has cross section described by rpolygon, zpolygon which contain coordinates for the corners Cross section of second loop is a point (thin wire) at r, z INPUTS: rpolygon, zpolygon = coordinates of first current loop [meters] r, z = major radius, height of second loop [meters] D, choice of derivatives in Mr, Mz, see below OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives w.r.t. r, z if D = 1, derivatives are w.r.t. rigid shifts of rp, zp if D = 2, derivatives are w.r.t. r, z RESTRICTIONS: The mutual M is for uniform current density across polygon","title":"mpolygon2point.m"},{"location":"function-guide/mag/mpolygon2point_m/#mpolygon2pointm","text":"","title":"mpolygon2point.m"},{"location":"function-guide/mag/mpolygon2point_m/#basic-information","text":"SYNTAX: [M, Mr, Mz] = mpolygon2point(rpolygon, zpolygon, r, z, D) PURPOSE: Calculate mutual inductances between coaxial loops First loop has cross section described by rpolygon, zpolygon which contain coordinates for the corners Cross section of second loop is a point (thin wire) at r, z INPUTS: rpolygon, zpolygon = coordinates of first current loop [meters] r, z = major radius, height of second loop [meters] D, choice of derivatives in Mr, Mz, see below OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives w.r.t. r, z if D = 1, derivatives are w.r.t. rigid shifts of rp, zp if D = 2, derivatives are w.r.t. r, z RESTRICTIONS: The mutual M is for uniform current density across polygon","title":"Basic Information"},{"location":"function-guide/mag/mpolygon2polygon_m/","text":"mpolygon2polygon.m \u00b6 Basic Information \u00b6 SYNTAX: [M, Mr, Mz] = mpolygon2polygon(ra, za, rb, zb) PURPOSE: Calculate mutual inductances between coaxial loops A & B The cross sections of the loops are polygons INPUTS: ra, za = coordinates for the corners of polygon A [m] rb, zb = coordinates for the corners of polygon B [m] OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives of M w.r.t. rigid shifts of ra and za RESTRICTIONS: Assumes uniform current distribution across both polygons","title":"mpolygon2polygon.m"},{"location":"function-guide/mag/mpolygon2polygon_m/#mpolygon2polygonm","text":"","title":"mpolygon2polygon.m"},{"location":"function-guide/mag/mpolygon2polygon_m/#basic-information","text":"SYNTAX: [M, Mr, Mz] = mpolygon2polygon(ra, za, rb, zb) PURPOSE: Calculate mutual inductances between coaxial loops A & B The cross sections of the loops are polygons INPUTS: ra, za = coordinates for the corners of polygon A [m] rb, zb = coordinates for the corners of polygon B [m] OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives of M w.r.t. rigid shifts of ra and za RESTRICTIONS: Assumes uniform current distribution across both polygons","title":"Basic Information"},{"location":"function-guide/mag/mrectangle2point_m/","text":"mrectangle2point.m \u00b6 Basic Information \u00b6 SYNTAX: [M, Mr, Mz] = mrectangle2point(ri, ro, zl, zu, r, z) PURPOSE: Calculate mutual inductances between coaxial loops First loop has rectangular cross section with edges ri,ro,zl,zu Second loop is a thin wire at r, z To return only Mr or Mz, indicate which with 'r' or 'z' like this Mz = mrectangle2point(ri,ro,zl,zu,r,z,'z') Typical relative error is 1e-12, for more info type: mrectangle2point info Slow very accurate calculation can be made with: [M, Mr, Mz] = mrectangle2point('integral2',ri,ro,zl,zu,r,z) INPUTS: ri, ro = inner and outer radius of rectangles [meters] zl, zu = lower and upper height of rectangles [meters] r, z = major radius, height of thin wire [meters] Size mixing allowed, outputs are sized like ri+ro+zl+zu+r+z OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives of M with respect to r, z","title":"mrectangle2point.m"},{"location":"function-guide/mag/mrectangle2point_m/#mrectangle2pointm","text":"","title":"mrectangle2point.m"},{"location":"function-guide/mag/mrectangle2point_m/#basic-information","text":"SYNTAX: [M, Mr, Mz] = mrectangle2point(ri, ro, zl, zu, r, z) PURPOSE: Calculate mutual inductances between coaxial loops First loop has rectangular cross section with edges ri,ro,zl,zu Second loop is a thin wire at r, z To return only Mr or Mz, indicate which with 'r' or 'z' like this Mz = mrectangle2point(ri,ro,zl,zu,r,z,'z') Typical relative error is 1e-12, for more info type: mrectangle2point info Slow very accurate calculation can be made with: [M, Mr, Mz] = mrectangle2point('integral2',ri,ro,zl,zu,r,z) INPUTS: ri, ro = inner and outer radius of rectangles [meters] zl, zu = lower and upper height of rectangles [meters] r, z = major radius, height of thin wire [meters] Size mixing allowed, outputs are sized like ri+ro+zl+zu+r+z OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives of M with respect to r, z","title":"Basic Information"},{"location":"function-guide/mag/mut_coil_set_m/","text":"mut_coil_set.m \u00b6 Basic Information \u00b6 SYNTAXX: mut= mut_coil_set(rc,zc,dr,dz) PURPOSE: Generate the mutual inductance between all coils in a set Coils are coaxial and axisymmetric, have rectangular cross-section and carry uniform current density INPUT: rc = Radial center of coil [m] zc = Axial center of coil [m] dr = Radial width of coil [m] dz = Axial height of coil [m] OUTPUT: mut = [n,n] matrix of mutual inductance of coils [Henries] RESTRICTIONS: See rectl for Self Inductance Restriction: err<1 for delz/(2*delr) < 1 Coils with aspect ratio approaching 1 are problematic","title":"mut_coil_set.m"},{"location":"function-guide/mag/mut_coil_set_m/#mut_coil_setm","text":"","title":"mut_coil_set.m"},{"location":"function-guide/mag/mut_coil_set_m/#basic-information","text":"SYNTAXX: mut= mut_coil_set(rc,zc,dr,dz) PURPOSE: Generate the mutual inductance between all coils in a set Coils are coaxial and axisymmetric, have rectangular cross-section and carry uniform current density INPUT: rc = Radial center of coil [m] zc = Axial center of coil [m] dr = Radial width of coil [m] dz = Axial height of coil [m] OUTPUT: mut = [n,n] matrix of mutual inductance of coils [Henries] RESTRICTIONS: See rectl for Self Inductance Restriction: err<1 for delz/(2*delr) < 1 Coils with aspect ratio approaching 1 are problematic","title":"Basic Information"},{"location":"function-guide/mag/mut_fil_fil_m/","text":"mut_fil_fil.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the mutual inductance between two sets of filaments A & B. Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. Sending filament set is \"A\", receiving filament set is \"B\" Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: mut_fil_fil(xa,xb,fa,fb) INPUT: (a= sending filament, b= receiving filament) xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] xb = same for receiving filaments [xb,yb,zb,dxb,dyb,dzb] fa,fb= Optional: fraction of current in filament for parallel filaments OUTPUT: m == mutual inductance between filament sets A to B [H] CAUTION: Will not work for filaments on top of each other (ie self inductance)","title":"mut_fil_fil.m"},{"location":"function-guide/mag/mut_fil_fil_m/#mut_fil_film","text":"","title":"mut_fil_fil.m"},{"location":"function-guide/mag/mut_fil_fil_m/#basic-information","text":"PURPOSE: Calculate the mutual inductance between two sets of filaments A & B. Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. Sending filament set is \"A\", receiving filament set is \"B\" Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: mut_fil_fil(xa,xb,fa,fb) INPUT: (a= sending filament, b= receiving filament) xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] xb = same for receiving filaments [xb,yb,zb,dxb,dyb,dzb] fa,fb= Optional: fraction of current in filament for parallel filaments OUTPUT: m == mutual inductance between filament sets A to B [H] CAUTION: Will not work for filaments on top of each other (ie self inductance)","title":"Basic Information"},{"location":"function-guide/mag/mut_ladder_m/","text":"mut_ladder.m \u00b6 Basic Information \u00b6 SYNTAXX: mut= mut_ladder(a,b,r,n) PURPOSE: Generate the mutual inductance between cells in a ladder shaped component made of n cells in the a direction. Each cell has dimensions in the x by y direction of a by b Cells are replicated in the x direction resulting in a ladder structure of length n*a in the x direction and width b in y. Each cell is adjacent to the next cell in the x direction and the rung is common to the left and right cells INPUT: a = side dimension of one cell in the length ladder direction, [m] b = sied dimension of one cell in the width direction, [m] r = radius or wire cross (vector) [m] n = number of rectangular cells OUTPUT: mut = [n,n] matrix of mutual inductance of cells in ladder [Henries] (Order is 1st cell on left to last cell on right) RESTRICTIONS: At present all cells are same size; but could be modified to do variable cell size in x direction by changing vector x internally","title":"mut_ladder.m"},{"location":"function-guide/mag/mut_ladder_m/#mut_ladderm","text":"","title":"mut_ladder.m"},{"location":"function-guide/mag/mut_ladder_m/#basic-information","text":"SYNTAXX: mut= mut_ladder(a,b,r,n) PURPOSE: Generate the mutual inductance between cells in a ladder shaped component made of n cells in the a direction. Each cell has dimensions in the x by y direction of a by b Cells are replicated in the x direction resulting in a ladder structure of length n*a in the x direction and width b in y. Each cell is adjacent to the next cell in the x direction and the rung is common to the left and right cells INPUT: a = side dimension of one cell in the length ladder direction, [m] b = sied dimension of one cell in the width direction, [m] r = radius or wire cross (vector) [m] n = number of rectangular cells OUTPUT: mut = [n,n] matrix of mutual inductance of cells in ladder [Henries] (Order is 1st cell on left to last cell on right) RESTRICTIONS: At present all cells are same size; but could be modified to do variable cell size in x direction by changing vector x internally","title":"Basic Information"},{"location":"function-guide/mag/mutind_conway_m/","text":"mutind_conway.m \u00b6 Basic Information \u00b6 SYNTAX: mutuals=mutind_fine(acoil_data,bcoil_data, ... nrecta,nrectb,verbose) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"mutind_conway.m"},{"location":"function-guide/mag/mutind_conway_m/#mutind_conwaym","text":"","title":"mutind_conway.m"},{"location":"function-guide/mag/mutind_conway_m/#basic-information","text":"SYNTAX: mutuals=mutind_fine(acoil_data,bcoil_data, ... nrecta,nrectb,verbose) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/mutind_distrib_m/","text":"mutind_distrib.m \u00b6 Basic Information \u00b6 SYNTAX: mutuals=mutind_distrib(acoil_data,bcoil_data, ... nrecta,nrectb,make_plot) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) make_plot = set to 1 to plot conductors' cross-sections OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"mutind_distrib.m"},{"location":"function-guide/mag/mutind_distrib_m/#mutind_distribm","text":"","title":"mutind_distrib.m"},{"location":"function-guide/mag/mutind_distrib_m/#basic-information","text":"SYNTAX: mutuals=mutind_distrib(acoil_data,bcoil_data, ... nrecta,nrectb,make_plot) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) make_plot = set to 1 to plot conductors' cross-sections OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/mutind_fine_m/","text":"mutind_fine.m \u00b6 Basic Information \u00b6 SYNTAX: mutuals=mutind_fine(acoil_data,bcoil_data, ... nrecta,nrectb,verbose) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"mutind_fine.m"},{"location":"function-guide/mag/mutind_fine_m/#mutind_finem","text":"","title":"mutind_fine.m"},{"location":"function-guide/mag/mutind_fine_m/#basic-information","text":"SYNTAX: mutuals=mutind_fine(acoil_data,bcoil_data, ... nrecta,nrectb,verbose) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/mutind_m/","text":"mutind.m \u00b6 Basic Information \u00b6 SYNTAX: mut=mutind(ra,za,rb,zb) PURPOSE: Calculate mutual inductances between loops centered at r=0. INPUT: ra,za = vectors of (r,z) coordinates (meters) of first current loops rb,zb = vectors of (r,z) coordinates (meters) of 2nd current loops Note arguments have different ordering convention than IDL function. OUTPUT: mut = vector of mutual inductances between current loops (in micro-Henries), mut(k) = mutual from loop at (ra(k),za(k)) to loop at (rb(k),zb(k)). RESTRICTIONS: Coordinates (r,z) must represent concentric current loops. All input vectors must be the same length.","title":"mutind.m"},{"location":"function-guide/mag/mutind_m/#mutindm","text":"","title":"mutind.m"},{"location":"function-guide/mag/mutind_m/#basic-information","text":"SYNTAX: mut=mutind(ra,za,rb,zb) PURPOSE: Calculate mutual inductances between loops centered at r=0. INPUT: ra,za = vectors of (r,z) coordinates (meters) of first current loops rb,zb = vectors of (r,z) coordinates (meters) of 2nd current loops Note arguments have different ordering convention than IDL function. OUTPUT: mut = vector of mutual inductances between current loops (in micro-Henries), mut(k) = mutual from loop at (ra(k),za(k)) to loop at (rb(k),zb(k)). RESTRICTIONS: Coordinates (r,z) must represent concentric current loops. All input vectors must be the same length.","title":"Basic Information"},{"location":"function-guide/mag/mutind_near_m/","text":"mutind_near.m \u00b6 Basic Information \u00b6 SYNTAX: mutual = mutind_near(rcurr,zcurr,rdim,zdim,rpsi,zpsi) PURPOSE: Calculate mutual inductance from current flowing in a loop of rectangular cross-section to a filamentary loop which is nearby. This function is meant to handle carefully the evaluation of mutual inductances for loops which are very close to one another. INPUT: rcurr= radius of centroid of current source (m) zcurr= z-dimension (height) of centroid of current source (m) rpsi = radius of point at which induced flux will be measured (m) zpsi = z-dimension (height) of point where induced flux is measured (m) rdim = r dimension of rectangle in which current flows (m) zdim = z dimension of rectangle in which current flows (m) nsplit = number of pieces to split each coordinate (z,r) of current source into for calculation (optional, default=[8,8]) Variables rcurr,zcurr, rpsi, and zpsi must be same size (scalar or vector). Variables rdim, zdim must be scalar or same size as rcurr. OUTPUT: mut = calculated mutual inductance (Henries) from the current source at each (rcurr(i),zcurr(i)) to measurement at (rpsi(i),zpsi(i))","title":"mutind_near.m"},{"location":"function-guide/mag/mutind_near_m/#mutind_nearm","text":"","title":"mutind_near.m"},{"location":"function-guide/mag/mutind_near_m/#basic-information","text":"SYNTAX: mutual = mutind_near(rcurr,zcurr,rdim,zdim,rpsi,zpsi) PURPOSE: Calculate mutual inductance from current flowing in a loop of rectangular cross-section to a filamentary loop which is nearby. This function is meant to handle carefully the evaluation of mutual inductances for loops which are very close to one another. INPUT: rcurr= radius of centroid of current source (m) zcurr= z-dimension (height) of centroid of current source (m) rpsi = radius of point at which induced flux will be measured (m) zpsi = z-dimension (height) of point where induced flux is measured (m) rdim = r dimension of rectangle in which current flows (m) zdim = z dimension of rectangle in which current flows (m) nsplit = number of pieces to split each coordinate (z,r) of current source into for calculation (optional, default=[8,8]) Variables rcurr,zcurr, rpsi, and zpsi must be same size (scalar or vector). Variables rdim, zdim must be scalar or same size as rcurr. OUTPUT: mut = calculated mutual inductance (Henries) from the current source at each (rcurr(i),zcurr(i)) to measurement at (rpsi(i),zpsi(i))","title":"Basic Information"},{"location":"function-guide/mag/mutinds_m/","text":"mutinds.m \u00b6 Basic Information \u00b6 SYNTAX: M = mutinds(ra,za,rb,zb) [M,Mr,Mz,Mrr,Mrz,Mzz,Mrrr,Mrrz,Mrzz,Mzzz] = mutinds(ra,za,rb,zb) Mzz = mutinds(ra,za,rb,zb,'zz'), returns a specific derivative S = mutinds(ra,za,rb,zb,3), returns struct matrix of derivatives S(i,j).f is the (i-1)th z, (j-1)th r derivative of M For small distances d = sqrt((rb-ra)^2+(zb-za)^2) < 1e-6*ra the relative error for mutinds(1,0,1+d,0) is 3e-18/d, but M = mutinds((ra+rb)/2,d,[],[]) can be used to get full accuracy PURPOSE: Calculate mutual inductance between coaxial loops INPUTS: ra,za = coordinates of first current loop [meters] rb,zb = coordinates of second current loop [meters] sizes can be mixed, outputs have same size as ra+za+rb+zb flag to request a specific derivative or matrix of derivatives allowed strings: 'r','z','rr','rz','zz','rrr', etc up to 'zzzzzz' allowed integers: 0,1,2,3 OUTPUTS: M = mutual inductance between loops a and b [H] Mr, Mz, Mrr, Mrz, ..., Mzzzzzz = derivatives w.r.t. rb and zb","title":"mutinds.m"},{"location":"function-guide/mag/mutinds_m/#mutindsm","text":"","title":"mutinds.m"},{"location":"function-guide/mag/mutinds_m/#basic-information","text":"SYNTAX: M = mutinds(ra,za,rb,zb) [M,Mr,Mz,Mrr,Mrz,Mzz,Mrrr,Mrrz,Mrzz,Mzzz] = mutinds(ra,za,rb,zb) Mzz = mutinds(ra,za,rb,zb,'zz'), returns a specific derivative S = mutinds(ra,za,rb,zb,3), returns struct matrix of derivatives S(i,j).f is the (i-1)th z, (j-1)th r derivative of M For small distances d = sqrt((rb-ra)^2+(zb-za)^2) < 1e-6*ra the relative error for mutinds(1,0,1+d,0) is 3e-18/d, but M = mutinds((ra+rb)/2,d,[],[]) can be used to get full accuracy PURPOSE: Calculate mutual inductance between coaxial loops INPUTS: ra,za = coordinates of first current loop [meters] rb,zb = coordinates of second current loop [meters] sizes can be mixed, outputs have same size as ra+za+rb+zb flag to request a specific derivative or matrix of derivatives allowed strings: 'r','z','rr','rz','zz','rrr', etc up to 'zzzzzz' allowed integers: 0,1,2,3 OUTPUTS: M = mutual inductance between loops a and b [H] Mr, Mz, Mrr, Mrz, ..., Mzzzzzz = derivatives w.r.t. rb and zb","title":"Basic Information"},{"location":"function-guide/mag/ohmic_dist_m/","text":"ohmic_dist.m \u00b6 Basic Information \u00b6 USAGE: [i_ohmic,fl,br,bz,rbs,zbs,err] = ... ohmic_dist(rbs,zbs,rcc,zcc,drcc,dzcc,mk_bs_uniform,minimize_i) Also can be called as script: ohmic_dist PURPOSE: Calculates the Best Ohmic current distribution for a set of F coils to a plasma boundary to generate 1Vs in boundary INPUTS: [default] rbs, zbs= R,Z Plasma boundary Points (m) rcc,zcc,drcc,dzcc= Rectangular Coil center and widths (m) (e.g. use the 2nd, 1st, 4th, and 3rd rows of standard fcdata object) mk_bs_uniform= Makes rbs, zbs a uniform poloidal grid scale [1] if >1 then makes mk_bs_uniform number of points if =1 then makes length(rbs) number of uniform points minimize_i = =0.1; Includes currents in opts. to reduce +-I [0] The value of minimize_i weights how much I smooting Value of 0.1 reasonably balances I. err~ 0.25 OUTPUTS: i_ohmic = Optimum Ohmic Current Dist. for 1Vs on Boundary (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rbs zbs = R,Z boundary points used in analysis (m) NOTE: rbs,zbs changed to uniform version of input err = Average Error in booundary flux value (Delta_Vs/Vs) RESTRICTIONS: uses square coil for all d3d type trapazoidal coils (small effect) Produces Amp-Turns. Use c_ohmic./fcnturn to convert to coil terminal Amp METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary","title":"ohmic_dist.m"},{"location":"function-guide/mag/ohmic_dist_m/#ohmic_distm","text":"","title":"ohmic_dist.m"},{"location":"function-guide/mag/ohmic_dist_m/#basic-information","text":"USAGE: [i_ohmic,fl,br,bz,rbs,zbs,err] = ... ohmic_dist(rbs,zbs,rcc,zcc,drcc,dzcc,mk_bs_uniform,minimize_i) Also can be called as script: ohmic_dist PURPOSE: Calculates the Best Ohmic current distribution for a set of F coils to a plasma boundary to generate 1Vs in boundary INPUTS: [default] rbs, zbs= R,Z Plasma boundary Points (m) rcc,zcc,drcc,dzcc= Rectangular Coil center and widths (m) (e.g. use the 2nd, 1st, 4th, and 3rd rows of standard fcdata object) mk_bs_uniform= Makes rbs, zbs a uniform poloidal grid scale [1] if >1 then makes mk_bs_uniform number of points if =1 then makes length(rbs) number of uniform points minimize_i = =0.1; Includes currents in opts. to reduce +-I [0] The value of minimize_i weights how much I smooting Value of 0.1 reasonably balances I. err~ 0.25 OUTPUTS: i_ohmic = Optimum Ohmic Current Dist. for 1Vs on Boundary (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rbs zbs = R,Z boundary points used in analysis (m) NOTE: rbs,zbs changed to uniform version of input err = Average Error in booundary flux value (Delta_Vs/Vs) RESTRICTIONS: uses square coil for all d3d type trapazoidal coils (small effect) Produces Amp-Turns. Use c_ohmic./fcnturn to convert to coil terminal Amp METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary","title":"Basic Information"},{"location":"function-guide/mag/rect_2d_m/","text":"rect_2d.m \u00b6 Basic Information \u00b6 PURPOSE: Generates B-field in 2-d planar space [X] == [x,y] at point x,y produced by a uniform current density straight rectangular coil of inifinte length in Z direction having dimensions a and b in the x and y directions and centered at x=y=0 & carrying current cur. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by]= rect_2d(a,b,cur,x,y) a,b = x and y dimensions of infinite length rectangular block cur = current in rectangle x,y = location of field point to determine field Note: Should work for vectors all of the same size OUTPUT: [bx,by] == [B] vectors of B-fields at point X NOTE: Z is the ignorable dimension","title":"rect_2d.m"},{"location":"function-guide/mag/rect_2d_m/#rect_2dm","text":"","title":"rect_2d.m"},{"location":"function-guide/mag/rect_2d_m/#basic-information","text":"PURPOSE: Generates B-field in 2-d planar space [X] == [x,y] at point x,y produced by a uniform current density straight rectangular coil of inifinte length in Z direction having dimensions a and b in the x and y directions and centered at x=y=0 & carrying current cur. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by]= rect_2d(a,b,cur,x,y) a,b = x and y dimensions of infinite length rectangular block cur = current in rectangle x,y = location of field point to determine field Note: Should work for vectors all of the same size OUTPUT: [bx,by] == [B] vectors of B-fields at point X NOTE: Z is the ignorable dimension","title":"Basic Information"},{"location":"function-guide/mag/rect_3d_b_m/","text":"rect_3d_b.m \u00b6 Basic Information \u00b6 PURPOSE: This function generates B-field in carthesian 3-space [X] == [x,y,z] produced by a uniform current density rectangle of dimensions [A] == [a,b,c] contining uniform current in the +Z direction and carrying unit current I=1A. The coordinate system is centered about the geometric center of rectangle. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= rect_3d_b.m(x,y,z,a,b,c) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [a,b,c] == [A] vectors of rectangle dimensions, one rectangle per row Note: X and a should be the same size. If A is a single row its rows are expanded to the rows of x If X is a single row its rows are expanded to the rows of a OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point corresponding to x & a NOTE: Vectorized so can handle vectors of same length and scalers NOTE: Produces double precision solution every where except eps from edges CAUTION: Needs additional Validations at edge discontinuities (Part II)","title":"rect_3d_b.m"},{"location":"function-guide/mag/rect_3d_b_m/#rect_3d_bm","text":"","title":"rect_3d_b.m"},{"location":"function-guide/mag/rect_3d_b_m/#basic-information","text":"PURPOSE: This function generates B-field in carthesian 3-space [X] == [x,y,z] produced by a uniform current density rectangle of dimensions [A] == [a,b,c] contining uniform current in the +Z direction and carrying unit current I=1A. The coordinate system is centered about the geometric center of rectangle. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= rect_3d_b.m(x,y,z,a,b,c) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [a,b,c] == [A] vectors of rectangle dimensions, one rectangle per row Note: X and a should be the same size. If A is a single row its rows are expanded to the rows of x If X is a single row its rows are expanded to the rows of a OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point corresponding to x & a NOTE: Vectorized so can handle vectors of same length and scalers NOTE: Produces double precision solution every where except eps from edges CAUTION: Needs additional Validations at edge discontinuities (Part II)","title":"Basic Information"},{"location":"function-guide/mag/rectl_m/","text":"rectl.m \u00b6 Basic Information \u00b6 SYNTAX: selfind = rectl(rc,delz,delr) PURPOSE: Calculate self inductance of rectangular coil. INPUT: rc = mean radius of the coil (meters) delz = axial height of the coil (meters) delr = radial width of the coil (meters) OUTPUT: selfind = self inductance (in uH) RESTRICTIONS: Accuracy of calculated self inductance will be better than 1 for delz/(2*delr) < 1.0. This is not guaranteed for delz/(2*delr) > 1.0.","title":"rectl.m"},{"location":"function-guide/mag/rectl_m/#rectlm","text":"","title":"rectl.m"},{"location":"function-guide/mag/rectl_m/#basic-information","text":"SYNTAX: selfind = rectl(rc,delz,delr) PURPOSE: Calculate self inductance of rectangular coil. INPUT: rc = mean radius of the coil (meters) delz = axial height of the coil (meters) delr = radial width of the coil (meters) OUTPUT: selfind = self inductance (in uH) RESTRICTIONS: Accuracy of calculated self inductance will be better than 1 for delz/(2*delr) < 1.0. This is not guaranteed for delz/(2*delr) > 1.0.","title":"Basic Information"},{"location":"function-guide/mag/self_fil_m/","text":"self_fil.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero","title":"self_fil.m"},{"location":"function-guide/mag/self_fil_m/#self_film","text":"","title":"self_fil.m"},{"location":"function-guide/mag/self_fil_m/#basic-information","text":"PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero","title":"Basic Information"},{"location":"function-guide/mag/selfind_m/","text":"selfind.m \u00b6 Basic Information \u00b6 SYNTAX: inductance=selfind(rc,radc,kappa) PURPOSE: Self-inductance expression for an axisymmetric coil of major radius RC and minor radius RADC (in uH). INPUT: rc = major radius [m] radc = minor radius [m] kappa = elongation (optional, default=1) OUTPUT: inductance = self inductance of coil","title":"selfind.m"},{"location":"function-guide/mag/selfind_m/#selfindm","text":"","title":"selfind.m"},{"location":"function-guide/mag/selfind_m/#basic-information","text":"SYNTAX: inductance=selfind(rc,radc,kappa) PURPOSE: Self-inductance expression for an axisymmetric coil of major radius RC and minor radius RADC (in uH). INPUT: rc = major radius [m] radc = minor radius [m] kappa = elongation (optional, default=1) OUTPUT: inductance = self inductance of coil","title":"Basic Information"},{"location":"function-guide/mag/fine_dir/fine_f2c/test_fine_m/","text":"test_fine.m \u00b6 Basic Information \u00b6 test_fine.m generic_startup","title":"test_fine.m"},{"location":"function-guide/mag/fine_dir/fine_f2c/test_fine_m/#test_finem","text":"","title":"test_fine.m"},{"location":"function-guide/mag/fine_dir/fine_f2c/test_fine_m/#basic-information","text":"test_fine.m generic_startup","title":"Basic Information"},{"location":"function-guide/mag/fine_dir/fine_vidar/fine1_f/","text":"fine1.F \u00b6 Basic Information \u00b6 ======================================================================","title":"fine1.F"},{"location":"function-guide/mag/fine_dir/fine_vidar/fine1_f/#fine1f","text":"","title":"fine1.F"},{"location":"function-guide/mag/fine_dir/fine_vidar/fine1_f/#basic-information","text":"======================================================================","title":"Basic Information"},{"location":"function-guide/mag/fine_dir/fine_vidar/fine_f/","text":"fine.f \u00b6 Basic Information \u00b6 OMMON/XW/X(182),W(182),N1(40)","title":"fine.f"},{"location":"function-guide/mag/fine_dir/fine_vidar/fine_f/#finef","text":"","title":"fine.f"},{"location":"function-guide/mag/fine_dir/fine_vidar/fine_f/#basic-information","text":"OMMON/XW/X(182),W(182),N1(40)","title":"Basic Information"},{"location":"function-guide/mag/fine_dir/fine_vidar/test_fine_m/","text":"test_fine.m \u00b6 Basic Information \u00b6 test_fine.m generic_startup","title":"test_fine.m"},{"location":"function-guide/mag/fine_dir/fine_vidar/test_fine_m/#test_finem","text":"","title":"test_fine.m"},{"location":"function-guide/mag/fine_dir/fine_vidar/test_fine_m/#basic-information","text":"test_fine.m generic_startup","title":"Basic Information"},{"location":"function-guide/math/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Math Tools line_intersection - Finds where lines cross isinpoly - Similar to inpolygon, checks if point is inside a polygon polycellint - How much area of cells on grid are inside a polygon cubicroots - Alternative to roots for solving cubic equations deriv - Calculates approximate derivitive of vector or matrix deriv2 - Derivatives in two dimensions up to arbitrary order ellipfez - Incomplete elliptic integrals and Jacobi's Zeta function eigsort - Calculates eigenvectors & eigenvalues sorted by real part minvert - Generalized SVD inverse, truncation of SV's, non-square pdipmqpneq2 - Solves quadratic program with inequality constraints","title":"Contents.m"},{"location":"function-guide/math/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/math/Contents_m/#basic-information","text":"Math Tools line_intersection - Finds where lines cross isinpoly - Similar to inpolygon, checks if point is inside a polygon polycellint - How much area of cells on grid are inside a polygon cubicroots - Alternative to roots for solving cubic equations deriv - Calculates approximate derivitive of vector or matrix deriv2 - Derivatives in two dimensions up to arbitrary order ellipfez - Incomplete elliptic integrals and Jacobi's Zeta function eigsort - Calculates eigenvectors & eigenvalues sorted by real part minvert - Generalized SVD inverse, truncation of SV's, non-square pdipmqpneq2 - Solves quadratic program with inequality constraints","title":"Basic Information"},{"location":"function-guide/math/cubicroots_m/","text":"cubicroots.m \u00b6 Basic Information \u00b6 USAGE: [x1, x2, x3] = cubicroots(a, b, c, d) PURPOSE: Find the roots to the cubic equation: a*x^3 + b*x^2 + c*x + d = 0 Can also be used with a = 0 and/or b = 0 INPUTS: a, b, c, d - may be 1 arbitrary size in a mix with scalars OUTPUTS: The roots such that: (x-x1)*(x-x2)*(x-x3) = x^3 + b/a*x^2 + c/a*x + d/a If a == 0 then x3 is nan since polynomial is 2:nd degree If also b == 0 then x2 will also be nan If also c == 0 then x1 will also be nan NOTES: Faster than the function roots, in particular when several equations solved at once. Also more accurate than roots Solutions are in the same order as from function roots If a ~= 0, x1 is always real cubicroots(a,b,c,d,n) iterates n times to reduce tiny errors","title":"cubicroots.m"},{"location":"function-guide/math/cubicroots_m/#cubicrootsm","text":"","title":"cubicroots.m"},{"location":"function-guide/math/cubicroots_m/#basic-information","text":"USAGE: [x1, x2, x3] = cubicroots(a, b, c, d) PURPOSE: Find the roots to the cubic equation: a*x^3 + b*x^2 + c*x + d = 0 Can also be used with a = 0 and/or b = 0 INPUTS: a, b, c, d - may be 1 arbitrary size in a mix with scalars OUTPUTS: The roots such that: (x-x1)*(x-x2)*(x-x3) = x^3 + b/a*x^2 + c/a*x + d/a If a == 0 then x3 is nan since polynomial is 2:nd degree If also b == 0 then x2 will also be nan If also c == 0 then x1 will also be nan NOTES: Faster than the function roots, in particular when several equations solved at once. Also more accurate than roots Solutions are in the same order as from function roots If a ~= 0, x1 is always real cubicroots(a,b,c,d,n) iterates n times to reduce tiny errors","title":"Basic Information"},{"location":"function-guide/math/deriv2_m/","text":"deriv2.m \u00b6 Basic Information \u00b6 SYNTAX: D = deriv2(x,y,f,n) PURPOSE: Calculate derivatives of f w.r.t. x and y INPUTS: x, y = coordinates (need not be equidistant) f = matrix of size(ny,nx) with values on grid x,y n = number of adjacent points to use (default 2) OUTPUTS: D = struct matrix with derivatives up to order n D(i,j).f is (j-1):th x, (i-1):th y derivative","title":"deriv2.m"},{"location":"function-guide/math/deriv2_m/#deriv2m","text":"","title":"deriv2.m"},{"location":"function-guide/math/deriv2_m/#basic-information","text":"SYNTAX: D = deriv2(x,y,f,n) PURPOSE: Calculate derivatives of f w.r.t. x and y INPUTS: x, y = coordinates (need not be equidistant) f = matrix of size(ny,nx) with values on grid x,y n = number of adjacent points to use (default 2) OUTPUTS: D = struct matrix with derivatives up to order n D(i,j).f is (j-1):th x, (i-1):th y derivative","title":"Basic Information"},{"location":"function-guide/math/deriv_m/","text":"deriv.m \u00b6 Basic Information \u00b6 SYNTAX: [xderiv,tderiv] = deriv(x,t,method) PURPOSE: Calculate approximate derivative of vector or matrix. INPUT: x = column vector or matrix to differentiate t = times corresponding to x data (column vector), or time between samples (scalar) method = differentiation method (optional, default=1) 1 = forward difference 2 = backward difference 3 = average of forward and backward difference 4 = produces correct derivative for times BETWEEN input samples (Strictly speaking, derivative is undefined at sample points for piecewise linear signal) OUTPUT: xderiv = approximate derivative vector = dx/dt, at input times if method<4, at constructed time vector tderiv if method=4. tderiv = input t if method<4. Strictly contains t if method=4. If x is a matrix, each column must represent data sampled at times given by vector t. RESTRICTIONS: (1) Time t must column vector with values in ascending order.","title":"deriv.m"},{"location":"function-guide/math/deriv_m/#derivm","text":"","title":"deriv.m"},{"location":"function-guide/math/deriv_m/#basic-information","text":"SYNTAX: [xderiv,tderiv] = deriv(x,t,method) PURPOSE: Calculate approximate derivative of vector or matrix. INPUT: x = column vector or matrix to differentiate t = times corresponding to x data (column vector), or time between samples (scalar) method = differentiation method (optional, default=1) 1 = forward difference 2 = backward difference 3 = average of forward and backward difference 4 = produces correct derivative for times BETWEEN input samples (Strictly speaking, derivative is undefined at sample points for piecewise linear signal) OUTPUT: xderiv = approximate derivative vector = dx/dt, at input times if method<4, at constructed time vector tderiv if method=4. tderiv = input t if method<4. Strictly contains t if method=4. If x is a matrix, each column must represent data sampled at times given by vector t. RESTRICTIONS: (1) Time t must column vector with values in ascending order.","title":"Basic Information"},{"location":"function-guide/math/eigsort_m/","text":"eigsort.m \u00b6 Basic Information \u00b6 SYNTAX: eigsort(A), d = eigsort(A), OR [V,d] = eigsort(A) PURPOSE: Calculate eigenvectors V and vector of eigenvalues d, sorted by real part. Works the same as eig.m, except eigenvectors are always returned as a vector (eig returns sometimes as a vector, sometimes as a diagonal matrix) and eigenvalues are sorted. INPUT: A = matrix to calculate eigenvalues for OUTPUT: (see eig.m) V = eigenvectors of A d = eigenvalues of A, i'th eigenvector corresponds to V(:,i)","title":"eigsort.m"},{"location":"function-guide/math/eigsort_m/#eigsortm","text":"","title":"eigsort.m"},{"location":"function-guide/math/eigsort_m/#basic-information","text":"SYNTAX: eigsort(A), d = eigsort(A), OR [V,d] = eigsort(A) PURPOSE: Calculate eigenvectors V and vector of eigenvalues d, sorted by real part. Works the same as eig.m, except eigenvectors are always returned as a vector (eig returns sometimes as a vector, sometimes as a diagonal matrix) and eigenvalues are sorted. INPUT: A = matrix to calculate eigenvalues for OUTPUT: (see eig.m) V = eigenvectors of A d = eigenvalues of A, i'th eigenvector corresponds to V(:,i)","title":"Basic Information"},{"location":"function-guide/math/ellipfez_m/","text":"ellipfez.m \u00b6 Basic Information \u00b6 [F,E,Z] = ELLIPFEZ(U,M) returns the values of the incomplete elliptic integrals of the first and second kind and Jacobi's Zeta function for arguments U and M. The arrays U and M must be the same size (or either can be scalar). As currently implemented, M is limited to -inf <= M <= 1. Some definitions of the elliptic functions use the modulus k instead of the parameter m. They are related by m = k^2. See also ELLIPKE, ELLIPJ","title":"ellipfez.m"},{"location":"function-guide/math/ellipfez_m/#ellipfezm","text":"","title":"ellipfez.m"},{"location":"function-guide/math/ellipfez_m/#basic-information","text":"[F,E,Z] = ELLIPFEZ(U,M) returns the values of the incomplete elliptic integrals of the first and second kind and Jacobi's Zeta function for arguments U and M. The arrays U and M must be the same size (or either can be scalar). As currently implemented, M is limited to -inf <= M <= 1. Some definitions of the elliptic functions use the modulus k instead of the parameter m. They are related by m = k^2. See also ELLIPKE, ELLIPJ","title":"Basic Information"},{"location":"function-guide/math/gauleg_m/","text":"gauleg.m \u00b6 Basic Information \u00b6 SYNTAX: [x, w] = gauleg(n,x1,x2) PURPOSE: Compute the Gauss-Legendre quadrature abscissas and weights of n internal points for the integration range [x1, x2] INPUTS: n = number of points x1, x2 = lower and upper bound for the integral, defaults -1, +1 OUTPUTS: x = points to evaluate the function at w = weights for each of the points EXAMPLE: [x, w] = gauleg(32, -1, +1); fx = @(x)sin(x).^2; Igl = w*fx(x) Ii = integral(fx, -1, +1) compare Igl and Ii","title":"gauleg.m"},{"location":"function-guide/math/gauleg_m/#gaulegm","text":"","title":"gauleg.m"},{"location":"function-guide/math/gauleg_m/#basic-information","text":"SYNTAX: [x, w] = gauleg(n,x1,x2) PURPOSE: Compute the Gauss-Legendre quadrature abscissas and weights of n internal points for the integration range [x1, x2] INPUTS: n = number of points x1, x2 = lower and upper bound for the integral, defaults -1, +1 OUTPUTS: x = points to evaluate the function at w = weights for each of the points EXAMPLE: [x, w] = gauleg(32, -1, +1); fx = @(x)sin(x).^2; Igl = w*fx(x) Ii = integral(fx, -1, +1) compare Igl and Ii","title":"Basic Information"},{"location":"function-guide/math/isinpoly_m/","text":"isinpoly.m \u00b6 Basic Information \u00b6 USAGE: ft = isinpoly(rt,zt,rp,zp) ft = isinpoly(rt,zt) Second call uses latest supplied polygon and executes faster PURPOSE: Test if point(s) rt, zt are inside polygon rp, zp INPUTS: rt, zt, coordinates of test points rp, zp, coordinates of polygon corners OUTPUTS: ft, flag(s): 0 = outside, 1 = inside","title":"isinpoly.m"},{"location":"function-guide/math/isinpoly_m/#isinpolym","text":"","title":"isinpoly.m"},{"location":"function-guide/math/isinpoly_m/#basic-information","text":"USAGE: ft = isinpoly(rt,zt,rp,zp) ft = isinpoly(rt,zt) Second call uses latest supplied polygon and executes faster PURPOSE: Test if point(s) rt, zt are inside polygon rp, zp INPUTS: rt, zt, coordinates of test points rp, zp, coordinates of polygon corners OUTPUTS: ft, flag(s): 0 = outside, 1 = inside","title":"Basic Information"},{"location":"function-guide/math/line_intersection_m/","text":"line_intersection.m \u00b6 Basic Information \u00b6 USAGE: [x, y, f, tA, tB] = line_intersection(xA, yA, xB, yB); PURPOSE: Return point of intersection between lines A and B INPUTS: xA, yA = x, y for two points on line A, sizes [1,2] xB, yB = x, y for two points on line B, sizes [1,2] If called with multiple line-pairs (n), sizes are [n,2] For this case any input can still be size [1,2] OUTPUTS: x, y = point where lines A and B intersect f = flag regarding segment between specified points 0 = A & B are parallel and never intersect 1 = A & B are the same line but the segments have no overlap 2 = A & B intersect but not between specified points 3 = Line A intersected between specified points 4 = Line B intersected between specified points 5 = Both lines intersect between specified points 6 = A & B are the same line and segments partly overlap (not yet implemented) 7 = Points xA, yA are the same as xB, yB (not yet implemented) tA, fraction given by: x = xA(:,1) + tA.*(xA(:,2)-xA(:,1)) tB, fraction given by: x = xB(:,1) + tB.*(xB(:,2)-xB(:,1))","title":"line_intersection.m"},{"location":"function-guide/math/line_intersection_m/#line_intersectionm","text":"","title":"line_intersection.m"},{"location":"function-guide/math/line_intersection_m/#basic-information","text":"USAGE: [x, y, f, tA, tB] = line_intersection(xA, yA, xB, yB); PURPOSE: Return point of intersection between lines A and B INPUTS: xA, yA = x, y for two points on line A, sizes [1,2] xB, yB = x, y for two points on line B, sizes [1,2] If called with multiple line-pairs (n), sizes are [n,2] For this case any input can still be size [1,2] OUTPUTS: x, y = point where lines A and B intersect f = flag regarding segment between specified points 0 = A & B are parallel and never intersect 1 = A & B are the same line but the segments have no overlap 2 = A & B intersect but not between specified points 3 = Line A intersected between specified points 4 = Line B intersected between specified points 5 = Both lines intersect between specified points 6 = A & B are the same line and segments partly overlap (not yet implemented) 7 = Points xA, yA are the same as xB, yB (not yet implemented) tA, fraction given by: x = xA(:,1) + tA.*(xA(:,2)-xA(:,1)) tB, fraction given by: x = xB(:,1) + tB.*(xB(:,2)-xB(:,1))","title":"Basic Information"},{"location":"function-guide/math/minvert_m/","text":"minvert.m \u00b6 Basic Information \u00b6 SYNTAX: [matinv,minsig,numsig] = minvert(mat,tol,figure_num) PURPOSE: Perform SVD generalized inverse of non-square or square matrix. INPUTS: mat = matrix to invert (can be square or non-square) tol = tolerance for inversion (retains singular values st sv/sv_max>tol) If tol>1, then interprets as # of singular values to keep,, and returns sig(tol)/max(sig) figure_num = specifies figure number of plotting desired (default=no plot) OUTPUTS: matinv = SVD generalized inverse of mat. minsig = minimum singular value retained divided by max singular value numsig = number of singular values retained RESTRICTIONS: None. METHOD: SVD generalized inverse. Adapted from IDL function minvert.pro.","title":"minvert.m"},{"location":"function-guide/math/minvert_m/#minvertm","text":"","title":"minvert.m"},{"location":"function-guide/math/minvert_m/#basic-information","text":"SYNTAX: [matinv,minsig,numsig] = minvert(mat,tol,figure_num) PURPOSE: Perform SVD generalized inverse of non-square or square matrix. INPUTS: mat = matrix to invert (can be square or non-square) tol = tolerance for inversion (retains singular values st sv/sv_max>tol) If tol>1, then interprets as # of singular values to keep,, and returns sig(tol)/max(sig) figure_num = specifies figure number of plotting desired (default=no plot) OUTPUTS: matinv = SVD generalized inverse of mat. minsig = minimum singular value retained divided by max singular value numsig = number of singular values retained RESTRICTIONS: None. METHOD: SVD generalized inverse. Adapted from IDL function minvert.pro.","title":"Basic Information"},{"location":"function-guide/math/pdipmqpneq2_m/","text":"pdipmqpneq2.m \u00b6 Basic Information \u00b6 USAGE: rep = pdipmqpneq2(H,h,E,f,kmax,epstop,eta) PURPOSE: Solve the particular quadratic program (no equality constraint) min_z (0.5*x'*H*x+h'*x), s.t. E*x<=f (QP/neq) INPUTS: H, Hessian term nx-by-nx (decision variable x is nx-by-1) h, linear term nx-by-1 E, inequality constraint matrix nz-by-nx (nz is # constraints) f, inequality constraint rhs data nz-by-1 kmax, maximum number of iterations, range 1 to 200 epstop, relative tolerance, range 1e-12 to 1e-3 (def. 1e-9) eta, dampening factor, 0<eta<1 (default 0.95) Any/all of kmax=[],epstop=[],eta=[] is allowed and sets the parameter to the default; but this generates a message that warns about defaulting behavior. OUTPUTS: rep, structure with solution and other parameters rep.descriptions details the contents of rep METHOD: Uses a primal-dual interior point method based on the standard predictor-corrector technique. The initial point is automatically set. All constraints must be present. This code uses a relative norm stop condition.","title":"pdipmqpneq2.m"},{"location":"function-guide/math/pdipmqpneq2_m/#pdipmqpneq2m","text":"","title":"pdipmqpneq2.m"},{"location":"function-guide/math/pdipmqpneq2_m/#basic-information","text":"USAGE: rep = pdipmqpneq2(H,h,E,f,kmax,epstop,eta) PURPOSE: Solve the particular quadratic program (no equality constraint) min_z (0.5*x'*H*x+h'*x), s.t. E*x<=f (QP/neq) INPUTS: H, Hessian term nx-by-nx (decision variable x is nx-by-1) h, linear term nx-by-1 E, inequality constraint matrix nz-by-nx (nz is # constraints) f, inequality constraint rhs data nz-by-1 kmax, maximum number of iterations, range 1 to 200 epstop, relative tolerance, range 1e-12 to 1e-3 (def. 1e-9) eta, dampening factor, 0<eta<1 (default 0.95) Any/all of kmax=[],epstop=[],eta=[] is allowed and sets the parameter to the default; but this generates a message that warns about defaulting behavior. OUTPUTS: rep, structure with solution and other parameters rep.descriptions details the contents of rep METHOD: Uses a primal-dual interior point method based on the standard predictor-corrector technique. The initial point is automatically set. All constraints must be present. This code uses a relative norm stop condition.","title":"Basic Information"},{"location":"function-guide/math/polycellint_m/","text":"polycellint.m \u00b6 Basic Information \u00b6 USAGE: [Acell, RAcell, ARcell] = polycellint(rg,zg,rp,zp) PURPOSE: Calculate how much area of each cell in grid rg, zg is inside the polygon rp, zp INPUTS: rg, zg, coordinates for centers of rectangles rp, zp, coordinates defining a polygon OUTPUTS: Acell, area of cells that are inside the polygon RAcell, surface integral of R over inside area ARcell, surface integral of 1/R over inside area All output sizes are [length(zg),length(rg)]","title":"polycellint.m"},{"location":"function-guide/math/polycellint_m/#polycellintm","text":"","title":"polycellint.m"},{"location":"function-guide/math/polycellint_m/#basic-information","text":"USAGE: [Acell, RAcell, ARcell] = polycellint(rg,zg,rp,zp) PURPOSE: Calculate how much area of each cell in grid rg, zg is inside the polygon rp, zp INPUTS: rg, zg, coordinates for centers of rectangles rp, zp, coordinates defining a polygon OUTPUTS: Acell, area of cells that are inside the polygon RAcell, surface integral of R over inside area ARcell, surface integral of 1/R over inside area All output sizes are [length(zg),length(rg)]","title":"Basic Information"},{"location":"function-guide/mdsplus/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 MDSplus data manipulation functions. getmds - get data from the MDSplus database get_mds_tree - get entire tree out of mdsplus mdsclose - close an MDSplus tree mdsconnect - connect to MDSplus server mdsdisconnect - disconnect from MDSplus server mdsopen - open an MDSplus tree mdsput - put data in MDSplus database mds_sub_tree - mdsvalue - get data from MDSplus database","title":"Contents.m"},{"location":"function-guide/mdsplus/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/mdsplus/Contents_m/#basic-information","text":"MDSplus data manipulation functions. getmds - get data from the MDSplus database get_mds_tree - get entire tree out of mdsplus mdsclose - close an MDSplus tree mdsconnect - connect to MDSplus server mdsdisconnect - disconnect from MDSplus server mdsopen - open an MDSplus tree mdsput - put data in MDSplus database mds_sub_tree - mdsvalue - get data from MDSplus database","title":"Basic Information"},{"location":"function-guide/mdsplus/get_mds_tree_m/","text":"get_mds_tree.m \u00b6 Basic Information \u00b6 SYNTAX: data= get_mds_tree(shot, tree, server, toupper,verbose); full call data= get_mds_tree(shot); defaults to DIII-D data= get_mds_tree(shot, 'EFIT01', 'NSTX'); for NSTX data= get_mds_tree(shot, 'NB', 'DIII-D'); example other tree PURPOSE: Get entire selected mds tree from mdsplus database. INPUT: <default> shot = shot number tree = tree to use <'EFIT01'> server = MDS+ database to use: 'DIII-D'(default),'NSTX','EAST', 'THOR', 'OPEN'(assumes mdsconnect already called). Other inputs invoke mdsconnect(server) to connect to server. toupper = 1= all variables made upper case, =-1 all var. made lower case [0]= no change, variables made depending on mds case (typical UC) verbose = set to 1 to get diagnostic prints during execution <1> server= 'NSTX' or 'EAST'; (since can take some time to get) <0> server= 'DIII-D' & all others; OUTPUT: data = structure containing all data in MDS+ tree, with same tree structure except that 'TOP' replaced by 'tree' See: data.allnames for list of all variables in full structure Some Extra items added to structure (all lower case) data.id = sting array of important data identifyer enf data.shot = shot number data.server= MDS+ server data.allnames= list of variables in structure with path relative to \"TOP\" data.mdsnames= list of variables in structure with full mds path ier = error code WRITTEN BY: Jim Leuer ON 3/1/05 (original name get_mds_tree) taken from get_mds_tree.m uses sub-structure to store USES: eq_mod To see MDS structure on HYDRA run traverser tested on DIII-D and NSTX data and should work for JET data but not tested CHANGE LOG: SMF 20140923 - Changed getnci call to use nid_numbers due to fullpath not accepting wildcards. ==========================================================================","title":"get_mds_tree.m"},{"location":"function-guide/mdsplus/get_mds_tree_m/#get_mds_treem","text":"","title":"get_mds_tree.m"},{"location":"function-guide/mdsplus/get_mds_tree_m/#basic-information","text":"SYNTAX: data= get_mds_tree(shot, tree, server, toupper,verbose); full call data= get_mds_tree(shot); defaults to DIII-D data= get_mds_tree(shot, 'EFIT01', 'NSTX'); for NSTX data= get_mds_tree(shot, 'NB', 'DIII-D'); example other tree PURPOSE: Get entire selected mds tree from mdsplus database. INPUT: <default> shot = shot number tree = tree to use <'EFIT01'> server = MDS+ database to use: 'DIII-D'(default),'NSTX','EAST', 'THOR', 'OPEN'(assumes mdsconnect already called). Other inputs invoke mdsconnect(server) to connect to server. toupper = 1= all variables made upper case, =-1 all var. made lower case [0]= no change, variables made depending on mds case (typical UC) verbose = set to 1 to get diagnostic prints during execution <1> server= 'NSTX' or 'EAST'; (since can take some time to get) <0> server= 'DIII-D' & all others; OUTPUT: data = structure containing all data in MDS+ tree, with same tree structure except that 'TOP' replaced by 'tree' See: data.allnames for list of all variables in full structure Some Extra items added to structure (all lower case) data.id = sting array of important data identifyer enf data.shot = shot number data.server= MDS+ server data.allnames= list of variables in structure with path relative to \"TOP\" data.mdsnames= list of variables in structure with full mds path ier = error code WRITTEN BY: Jim Leuer ON 3/1/05 (original name get_mds_tree) taken from get_mds_tree.m uses sub-structure to store USES: eq_mod To see MDS structure on HYDRA run traverser tested on DIII-D and NSTX data and should work for JET data but not tested CHANGE LOG: SMF 20140923 - Changed getnci call to use nid_numbers due to fullpath not accepting wildcards. ==========================================================================","title":"Basic Information"},{"location":"function-guide/mdsplus/getmdata_m/","text":"getmdata.m \u00b6 Basic Information \u00b6 SYNTAX OPTIONS: [data_vals,time_vals,ier,units] = getmdata(shotnum, ptname, treename, connOrTokamak, getxdata) PURPOSE: Get mdsplus or ptdata data with reusable connections through mdsPlus library. INPUT: shotnum = shot number ptname = name of data - must be in single quotes treename = which tree to use for mdsplus data, or 'ptdata' (optional) Default Options depend on the server: Server: Default treename: 'D3D' -> 'ptdata' 'JET' -> 'PPF' 'NSTX' -> 'wf' 'KSTAR' -> 'pcs_kstar' 'EAST' -> 'pcs_east' 'EAST@GA' -> 'pcs_east' connOrTokamak = tokamak name, server, or reusable mdsplus library connection object. (optional, default = 'd3d') -mdsplus library objects can be made with getmdsconn -Server address can be input as a string -Tokamak name will lookup default server addresses: Options: (default = 'd3d') 'D3D' -> 'atlas.gat.com' 'JET' -> 'mdsplus.jet.efda.org' 'NSTX' -> 'birch.pppl.gov:8501' 'KSTAR' -> '203.230.126.212:8005' 'EAST' -> '202.127.204.12:8000' 'EAST@GA' -> 'eastdata.gat.com' OUTPUT: data_vals = Data for ptname defined by input (complete data record) time_vals = Time values ier = error code = 0 if OK, else > 0 units = Units string for ptname if defined in the MDSplus DB. EXAMPLES getmdata(176991, 'ip', 'ptdata', 'd3d') getmdata(57035, 'MAGN/IPLA', 'PPF', 'jet') getmdata(57035,'MAGN/IPLA','PPF','JET') getmdata(109070,'ip','wf','NSTX') getmdata(999991,'PCIP','PCS_KSTAR','kstar') getmdata(73502,'pcrl01','pcs_east','east') getmdata(73502,'pcrl01','pcs_east','east') EXAMPLE re-using MDSplus connection: [connObj, ier] = getmdsconn('d3d'); [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ip', 'ptdata', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ipmeas', 'efit01', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'li', 'efitrt1', connObj) or: [ data_vals, time_vals, ier, units, connObj ] = getmdata(176991, 'ip', 'ptdata', 'd3d') [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ipmeas', 'efit01', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'li', 'efitrt1', connObj) RESTRICTIONS: (1) Only works for 1-D and 2-D data right now WRITTEN BY: Jayson Barr ON 8/16/18","title":"getmdata.m"},{"location":"function-guide/mdsplus/getmdata_m/#getmdatam","text":"","title":"getmdata.m"},{"location":"function-guide/mdsplus/getmdata_m/#basic-information","text":"SYNTAX OPTIONS: [data_vals,time_vals,ier,units] = getmdata(shotnum, ptname, treename, connOrTokamak, getxdata) PURPOSE: Get mdsplus or ptdata data with reusable connections through mdsPlus library. INPUT: shotnum = shot number ptname = name of data - must be in single quotes treename = which tree to use for mdsplus data, or 'ptdata' (optional) Default Options depend on the server: Server: Default treename: 'D3D' -> 'ptdata' 'JET' -> 'PPF' 'NSTX' -> 'wf' 'KSTAR' -> 'pcs_kstar' 'EAST' -> 'pcs_east' 'EAST@GA' -> 'pcs_east' connOrTokamak = tokamak name, server, or reusable mdsplus library connection object. (optional, default = 'd3d') -mdsplus library objects can be made with getmdsconn -Server address can be input as a string -Tokamak name will lookup default server addresses: Options: (default = 'd3d') 'D3D' -> 'atlas.gat.com' 'JET' -> 'mdsplus.jet.efda.org' 'NSTX' -> 'birch.pppl.gov:8501' 'KSTAR' -> '203.230.126.212:8005' 'EAST' -> '202.127.204.12:8000' 'EAST@GA' -> 'eastdata.gat.com' OUTPUT: data_vals = Data for ptname defined by input (complete data record) time_vals = Time values ier = error code = 0 if OK, else > 0 units = Units string for ptname if defined in the MDSplus DB. EXAMPLES getmdata(176991, 'ip', 'ptdata', 'd3d') getmdata(57035, 'MAGN/IPLA', 'PPF', 'jet') getmdata(57035,'MAGN/IPLA','PPF','JET') getmdata(109070,'ip','wf','NSTX') getmdata(999991,'PCIP','PCS_KSTAR','kstar') getmdata(73502,'pcrl01','pcs_east','east') getmdata(73502,'pcrl01','pcs_east','east') EXAMPLE re-using MDSplus connection: [connObj, ier] = getmdsconn('d3d'); [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ip', 'ptdata', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ipmeas', 'efit01', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'li', 'efitrt1', connObj) or: [ data_vals, time_vals, ier, units, connObj ] = getmdata(176991, 'ip', 'ptdata', 'd3d') [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ipmeas', 'efit01', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'li', 'efitrt1', connObj) RESTRICTIONS: (1) Only works for 1-D and 2-D data right now WRITTEN BY: Jayson Barr ON 8/16/18","title":"Basic Information"},{"location":"function-guide/mdsplus/getmds_m/","text":"getmds.m \u00b6 Basic Information \u00b6 SYNTAX OPTIONS: [data,tvec,ier] = getmds(shot,name,range_min,range_max,tree,server,ical) [data,xvec,tvec,ier] = getmds(shot,name,range_min,range_max,tree,server,ical) PURPOSE: Get mdsplus data from the MDS database. INPUT: shot = shot number name = name of data - must be in single quotes range_min = minimum value of independent variable(s) - use NaN to specify no limit: if scalar, this is min time (s) if vector, last entry is min time (s), other entries are minima for other independent variables range_max = maximum value of independent variable(s) - use NaN to specify no limit: if scalar, this is max time (s) if vector, last entry is max time (s), other entries are maxima for other independent variables tree = which tree to use (optional, default = 'EFIT01') server = which server to use (optional). Options: 'DIII-D'(default), 'JET', 'NSTX', 'THOR' ical = return data in units of digitizer counts (ical=0), volts into digitizer (ical=2), or physics units (ical=1). Only used for data from 'THOR', 'data-server3' (EAST), and 'pcs_kstar' (KSTAR) OUTPUT: data = data for name defined by input (dimensions correspond to dimensions specified in range_min) (xvec..tvec) = variable number of arguments containing vectors of independent variables specified in range_min and range_max ier = error code = 0 if OK, else > 0 EXAMPLES getmds(106649,'rmaxis',1.5,5,'EFIT01','DIII-D') getmds(57035,'MAGN/IPLA',1.0,3.0,'PPF','JET') getmds(109070,'ip',1.0,3.0,'wf','NSTX') getmds(999991,'PCIP',0.0,8.0,'PCS_KSTAR','THOR'); NEED 3D examples RESTRICTIONS: (1) Only works for range_min/max up to length 2 at the moment (make a request for more). (2) Use the lower level routines starting with \"mds\" to manipulate the MDS data directly.","title":"getmds.m"},{"location":"function-guide/mdsplus/getmds_m/#getmdsm","text":"","title":"getmds.m"},{"location":"function-guide/mdsplus/getmds_m/#basic-information","text":"SYNTAX OPTIONS: [data,tvec,ier] = getmds(shot,name,range_min,range_max,tree,server,ical) [data,xvec,tvec,ier] = getmds(shot,name,range_min,range_max,tree,server,ical) PURPOSE: Get mdsplus data from the MDS database. INPUT: shot = shot number name = name of data - must be in single quotes range_min = minimum value of independent variable(s) - use NaN to specify no limit: if scalar, this is min time (s) if vector, last entry is min time (s), other entries are minima for other independent variables range_max = maximum value of independent variable(s) - use NaN to specify no limit: if scalar, this is max time (s) if vector, last entry is max time (s), other entries are maxima for other independent variables tree = which tree to use (optional, default = 'EFIT01') server = which server to use (optional). Options: 'DIII-D'(default), 'JET', 'NSTX', 'THOR' ical = return data in units of digitizer counts (ical=0), volts into digitizer (ical=2), or physics units (ical=1). Only used for data from 'THOR', 'data-server3' (EAST), and 'pcs_kstar' (KSTAR) OUTPUT: data = data for name defined by input (dimensions correspond to dimensions specified in range_min) (xvec..tvec) = variable number of arguments containing vectors of independent variables specified in range_min and range_max ier = error code = 0 if OK, else > 0 EXAMPLES getmds(106649,'rmaxis',1.5,5,'EFIT01','DIII-D') getmds(57035,'MAGN/IPLA',1.0,3.0,'PPF','JET') getmds(109070,'ip',1.0,3.0,'wf','NSTX') getmds(999991,'PCIP',0.0,8.0,'PCS_KSTAR','THOR'); NEED 3D examples RESTRICTIONS: (1) Only works for range_min/max up to length 2 at the moment (make a request for more). (2) Use the lower level routines starting with \"mds\" to manipulate the MDS data directly.","title":"Basic Information"},{"location":"function-guide/mdsplus/getmdsconn_m/","text":"getmdsconn.m \u00b6 Basic Information \u00b6 SYNTAX OPTIONS: [connObj, ier] = getmdsconn(serverTok) PURPOSE: Establish a connection to an MDSplus server, return a connection object. INPUT: serverTok = Either a hostname or a tokamak shortname: 'DIII-D', 'D3D' -> 'atlas.gat.com' 'JET' -> 'mdsplus.jet.efda.org' 'NSTX' -> 'birch.pppl.gov:8501' 'KSTAR'-> '203.230.126.212:8005' 'EAST' -> '202.127.204.12:8000' 'EAST@GA' -> 'eastdata.gat.com' OUTPUT: connObj = connection object used for getting data ier = error code = 0 if OK, else > 0 EXAMPLES: [connObj, ier] = getmdsconn('d3d') [connObj, ier] = getmdsconn('NSTX') [connObj, ier] = getmdsconn('east@ga') RESTRICTIONS: (1) METHOD: WRITTEN BY: Jayson Barr ON 2/14/18","title":"getmdsconn.m"},{"location":"function-guide/mdsplus/getmdsconn_m/#getmdsconnm","text":"","title":"getmdsconn.m"},{"location":"function-guide/mdsplus/getmdsconn_m/#basic-information","text":"SYNTAX OPTIONS: [connObj, ier] = getmdsconn(serverTok) PURPOSE: Establish a connection to an MDSplus server, return a connection object. INPUT: serverTok = Either a hostname or a tokamak shortname: 'DIII-D', 'D3D' -> 'atlas.gat.com' 'JET' -> 'mdsplus.jet.efda.org' 'NSTX' -> 'birch.pppl.gov:8501' 'KSTAR'-> '203.230.126.212:8005' 'EAST' -> '202.127.204.12:8000' 'EAST@GA' -> 'eastdata.gat.com' OUTPUT: connObj = connection object used for getting data ier = error code = 0 if OK, else > 0 EXAMPLES: [connObj, ier] = getmdsconn('d3d') [connObj, ier] = getmdsconn('NSTX') [connObj, ier] = getmdsconn('east@ga') RESTRICTIONS: (1) METHOD: WRITTEN BY: Jayson Barr ON 2/14/18","title":"Basic Information"},{"location":"function-guide/mdsplus/make_mdsipmex_east_m/","text":"make_mdsipmex_east.m \u00b6 Basic Information \u00b6 make_mdsipmex.m make sure ../mdsplus points to current version of mdsplus distribution to make the debug version, debug=1;make_mdsipmex; to make the shared version, shared=1;make_mdsipmex; Note; if shared, install MdsIpShr library or point $LD_LIBRARY_PATH to shareables Basil P. DUVAL, May 2000","title":"make_mdsipmex_east.m"},{"location":"function-guide/mdsplus/make_mdsipmex_east_m/#make_mdsipmex_eastm","text":"","title":"make_mdsipmex_east.m"},{"location":"function-guide/mdsplus/make_mdsipmex_east_m/#basic-information","text":"make_mdsipmex.m make sure ../mdsplus points to current version of mdsplus distribution to make the debug version, debug=1;make_mdsipmex; to make the shared version, shared=1;make_mdsipmex; Note; if shared, install MdsIpShr library or point $LD_LIBRARY_PATH to shareables Basil P. DUVAL, May 2000","title":"Basic Information"},{"location":"function-guide/mdsplus/make_mdsipmex_m/","text":"make_mdsipmex.m \u00b6 Basic Information \u00b6 make_mdsipmex.m make sure ../mdsplus points to current version of mdsplus distribution to make the debug version, debug=1;make_mdsipmex; to make the shared version, shared=1;make_mdsipmex; Note; if shared, install MdsIpShr library or point $LD_LIBRARY_PATH to shareables Basil P. DUVAL, May 2000","title":"make_mdsipmex.m"},{"location":"function-guide/mdsplus/make_mdsipmex_m/#make_mdsipmexm","text":"","title":"make_mdsipmex.m"},{"location":"function-guide/mdsplus/make_mdsipmex_m/#basic-information","text":"make_mdsipmex.m make sure ../mdsplus points to current version of mdsplus distribution to make the debug version, debug=1;make_mdsipmex; to make the shared version, shared=1;make_mdsipmex; Note; if shared, install MdsIpShr library or point $LD_LIBRARY_PATH to shareables Basil P. DUVAL, May 2000","title":"Basic Information"},{"location":"function-guide/mdsplus/mds_eq_m/","text":"mds_eq.m \u00b6 Basic Information \u00b6 SYNTAX: eq= mds_eq(shot, tree, gam, mk_var); defaults to DIII-D server mds_eq(shot, 'EFIT01, 'gam', 1, 'NSTX'); makes vars in workspace PURPOSE: Get EFIT equilibrium (GEQDSK AEQDSK MEQDSK) from mdsplus database. INPUT: <default> shot = shot number tree = which efit tree to use <'EFIT01'> gam = ['g']; get only g file, a= only a file, m= mfile, <gam> mk_var = [1]; Will make efit variables in calling workspace, <0> makes none 2 will make lower case, 3 will make upper case variable note default variables in MDS are upper case NOTE: see eq_to_env for way to make tstart<=t<tend arrays server = which data base to use: defaults to [DIII-D] also NSTX OUTPUT: eq = structure containing EFIT eqdsk variables See: eq.gnames .anames .mnames for g,a,m file names All EFIT variables are as in MDSPLUS => Upper Case Ex: eq.BCENTR, eq.BDRY, eq.PSIRZ, Use: plot(eq.GTIME, eq.CPASMA), contour(eq.R, eq.Z, eq.PSIRZ(:,:,round(length(eq.GTIME)/2))') Extra items added to structure (all lower case) eq.id = sting array of important data identifyer enf eq.gnames= sting array of all gfile names collected (eq to see all) eq.anames= sting array of all afile names collected (eq to see all) eq.mnames= sting array of all mfile names collected (eq to see all) eq.shot = shot number eq.tree = mds tree used to get data (ex. EFIT01 EFIT02 (=MSD)); if mk_var>0 it makes variables in base workspace BCENTR, BDRY, CPASMA, PSIRZ, ... NOTE: 1)Function returns all TIME data for shot in large arrays. Example: eq.BCENTER(255,1) eq.GTIME(255,1); Time data vector for all .GNAME arrays 255 times eq.ATIME(251,1); Time data vector for all .ANAME arrays 251 times eq.MTIME or eq.TIME Note old \"m\" uses TIME new \"m\" uses MTIME eq.PPRIME(65,255),PSIRZ(65,65,225) Similar arrays (without eq. strucutre) are generated in workspace if mk_var>=1 : BCENTER(255,1), GTIME(255,1) or LC if mk_var==2 2) Time is in vector eq.GTIME and is in ms. All other units are as they come from EFIT. psi(Vs/r) I(A) R(m) ... CAUTION: All time vectors are last index of vector of array. CAUTION: GTIME ATIME & (MTIME or TIME) are not necesaarly the same. CAUTION: Current Bad Variable in d3dMDSPLUS ARE: CASE, HEADER, ZGRID (use Z) CAUTION: THIS ROUTINE GETS ALL MDS EQDSK DATA FOR SHOT AND EQ CAN BE HUGE CAUTION: Afile read 1st then Gfile: variables in common: BCENTR, CPASMA, ... SEE ALSO: eq_time_lim eq_ga_env","title":"mds_eq.m"},{"location":"function-guide/mdsplus/mds_eq_m/#mds_eqm","text":"","title":"mds_eq.m"},{"location":"function-guide/mdsplus/mds_eq_m/#basic-information","text":"SYNTAX: eq= mds_eq(shot, tree, gam, mk_var); defaults to DIII-D server mds_eq(shot, 'EFIT01, 'gam', 1, 'NSTX'); makes vars in workspace PURPOSE: Get EFIT equilibrium (GEQDSK AEQDSK MEQDSK) from mdsplus database. INPUT: <default> shot = shot number tree = which efit tree to use <'EFIT01'> gam = ['g']; get only g file, a= only a file, m= mfile, <gam> mk_var = [1]; Will make efit variables in calling workspace, <0> makes none 2 will make lower case, 3 will make upper case variable note default variables in MDS are upper case NOTE: see eq_to_env for way to make tstart<=t<tend arrays server = which data base to use: defaults to [DIII-D] also NSTX OUTPUT: eq = structure containing EFIT eqdsk variables See: eq.gnames .anames .mnames for g,a,m file names All EFIT variables are as in MDSPLUS => Upper Case Ex: eq.BCENTR, eq.BDRY, eq.PSIRZ, Use: plot(eq.GTIME, eq.CPASMA), contour(eq.R, eq.Z, eq.PSIRZ(:,:,round(length(eq.GTIME)/2))') Extra items added to structure (all lower case) eq.id = sting array of important data identifyer enf eq.gnames= sting array of all gfile names collected (eq to see all) eq.anames= sting array of all afile names collected (eq to see all) eq.mnames= sting array of all mfile names collected (eq to see all) eq.shot = shot number eq.tree = mds tree used to get data (ex. EFIT01 EFIT02 (=MSD)); if mk_var>0 it makes variables in base workspace BCENTR, BDRY, CPASMA, PSIRZ, ... NOTE: 1)Function returns all TIME data for shot in large arrays. Example: eq.BCENTER(255,1) eq.GTIME(255,1); Time data vector for all .GNAME arrays 255 times eq.ATIME(251,1); Time data vector for all .ANAME arrays 251 times eq.MTIME or eq.TIME Note old \"m\" uses TIME new \"m\" uses MTIME eq.PPRIME(65,255),PSIRZ(65,65,225) Similar arrays (without eq. strucutre) are generated in workspace if mk_var>=1 : BCENTER(255,1), GTIME(255,1) or LC if mk_var==2 2) Time is in vector eq.GTIME and is in ms. All other units are as they come from EFIT. psi(Vs/r) I(A) R(m) ... CAUTION: All time vectors are last index of vector of array. CAUTION: GTIME ATIME & (MTIME or TIME) are not necesaarly the same. CAUTION: Current Bad Variable in d3dMDSPLUS ARE: CASE, HEADER, ZGRID (use Z) CAUTION: THIS ROUTINE GETS ALL MDS EQDSK DATA FOR SHOT AND EQ CAN BE HUGE CAUTION: Afile read 1st then Gfile: variables in common: BCENTR, CPASMA, ... SEE ALSO: eq_time_lim eq_ga_env","title":"Basic Information"},{"location":"function-guide/mdsplus/mds_sub_tree_m/","text":"mds_sub_tree.m \u00b6 Basic Information \u00b6 SYNTAX: mds_ot= mds_sub_tree(mds_in) PURPOSE:gets mds subtrees for next level down. INPUT: <default> mds_in = Input mds tree OUTPUT: mds_ot = Output mds subtree names WRITTEN BY: Jim Leuer ON 3/3/05 CHANGE LOG: SMF 20140923 - Changed getnci call to use nid_numbers due to fullpath not accepting wildcards. ========================================================================== @(#)mds_sub_tree.m 1.3 07/09/09","title":"mds_sub_tree.m"},{"location":"function-guide/mdsplus/mds_sub_tree_m/#mds_sub_treem","text":"","title":"mds_sub_tree.m"},{"location":"function-guide/mdsplus/mds_sub_tree_m/#basic-information","text":"SYNTAX: mds_ot= mds_sub_tree(mds_in) PURPOSE:gets mds subtrees for next level down. INPUT: <default> mds_in = Input mds tree OUTPUT: mds_ot = Output mds subtree names WRITTEN BY: Jim Leuer ON 3/3/05 CHANGE LOG: SMF 20140923 - Changed getnci call to use nid_numbers due to fullpath not accepting wildcards. ========================================================================== @(#)mds_sub_tree.m 1.3 07/09/09","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsclose_m/","text":"mdsclose.m \u00b6 Basic Information \u00b6 SYNTAX: status = mdsclose(para) PURPOSE: function to mdsclose on remote server INPUT: para = ?? (optional) (if para ~= 0, perform a disconnect of remote server) OUTPUT: status","title":"mdsclose.m"},{"location":"function-guide/mdsplus/mdsclose_m/#mdsclosem","text":"","title":"mdsclose.m"},{"location":"function-guide/mdsplus/mdsclose_m/#basic-information","text":"SYNTAX: status = mdsclose(para) PURPOSE: function to mdsclose on remote server INPUT: para = ?? (optional) (if para ~= 0, perform a disconnect of remote server) OUTPUT: status","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsconnect_m/","text":"mdsconnect.m \u00b6 Basic Information \u00b6 function to mdsconnect to a server eg : mdsconnect(para); Basil P. DUVAL, Aug 2000","title":"mdsconnect.m"},{"location":"function-guide/mdsplus/mdsconnect_m/#mdsconnectm","text":"","title":"mdsconnect.m"},{"location":"function-guide/mdsplus/mdsconnect_m/#basic-information","text":"function to mdsconnect to a server eg : mdsconnect(para); Basil P. DUVAL, Aug 2000","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsdisconnect_m/","text":"mdsdisconnect.m \u00b6 Basic Information \u00b6 SYNTAX: status = mdsdisconnect PURPOSE: function to close communication with remote mds server INPUT: none OUTPUT: status","title":"mdsdisconnect.m"},{"location":"function-guide/mdsplus/mdsdisconnect_m/#mdsdisconnectm","text":"","title":"mdsdisconnect.m"},{"location":"function-guide/mdsplus/mdsdisconnect_m/#basic-information","text":"SYNTAX: status = mdsdisconnect PURPOSE: function to close communication with remote mds server INPUT: none OUTPUT: status","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsopen_m/","text":"mdsopen.m \u00b6 Basic Information \u00b6 SYNTAX: [shoto,status] = mdsopen(server, shot) PURPOSE: function to open remote server server INPUT: server = string defining server and tree to access Example: 'atlas.gat.com::EFIT01' (server is optional, defaults to atlas.gat.com; If first parameter is not a string, will open 'EFIT01' tree.) shot = shot number OUTPUT: shoto = the shot number which was opened, if successful status = return status, odd=good, even=bad","title":"mdsopen.m"},{"location":"function-guide/mdsplus/mdsopen_m/#mdsopenm","text":"","title":"mdsopen.m"},{"location":"function-guide/mdsplus/mdsopen_m/#basic-information","text":"SYNTAX: [shoto,status] = mdsopen(server, shot) PURPOSE: function to open remote server server INPUT: server = string defining server and tree to access Example: 'atlas.gat.com::EFIT01' (server is optional, defaults to atlas.gat.com; If first parameter is not a string, will open 'EFIT01' tree.) shot = shot number OUTPUT: shoto = the shot number which was opened, if successful status = return status, odd=good, even=bad","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsput_m/","text":"mdsput.m \u00b6 Basic Information \u00b6 SYNTAX: status = mdsput(node,expr,varargin) PURPOSE: puts data in MDS data base INPUT: node expr varargin OUTPUT: status","title":"mdsput.m"},{"location":"function-guide/mdsplus/mdsput_m/#mdsputm","text":"","title":"mdsput.m"},{"location":"function-guide/mdsplus/mdsput_m/#basic-information","text":"SYNTAX: status = mdsput(node,expr,varargin) PURPOSE: puts data in MDS data base INPUT: node expr varargin OUTPUT: status","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsremotelist_m/","text":"mdsremotelist.m \u00b6 Basic Information \u00b6 To list current connections to remote server Returns the total number of connections Basil P. DUVAL, August 2000","title":"mdsremotelist.m"},{"location":"function-guide/mdsplus/mdsremotelist_m/#mdsremotelistm","text":"","title":"mdsremotelist.m"},{"location":"function-guide/mdsplus/mdsremotelist_m/#basic-information","text":"To list current connections to remote server Returns the total number of connections Basil P. DUVAL, August 2000","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsvalue_m/","text":"mdsvalue.m \u00b6 Basic Information \u00b6 SYNTAX: [reply,status] = mdsvalue(str,varargin) PURPOSE: function to open server remotely eg : mdsvalue('2+3'); INPUT: str = string defining data to get (e.g. '\\betap') varargin= ?? OUTPUT: reply = requested information status = return status, odd=good, even=bad","title":"mdsvalue.m"},{"location":"function-guide/mdsplus/mdsvalue_m/#mdsvaluem","text":"","title":"mdsvalue.m"},{"location":"function-guide/mdsplus/mdsvalue_m/#basic-information","text":"SYNTAX: [reply,status] = mdsvalue(str,varargin) PURPOSE: function to open server remotely eg : mdsvalue('2+3'); INPUT: str = string defining data to get (e.g. '\\betap') varargin= ?? OUTPUT: reply = requested information status = return status, odd=good, even=bad","title":"Basic Information"},{"location":"function-guide/mdsplus/recurse_mds_tree_m/","text":"recurse_mds_tree.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: The code in get_mds_tree defines the tree structure down to the first node that is delimited by a colon (i.e., all paths up to *:node). This function recurses down from there (when needed to actually populate the metadata in the tree. INPUT: mds_nam = node name to recurse from (or evaluate if it is a leaf node) metadata = full metadata that will be returned to user, with content filled up to this call mds_nam0 = Top tree name toupper = user selection (see get_mds_tree.m) verbose = user selection (see get_mds_tree.m) top_num = length of mds_nam0 string OUTPUT: metadata = updated full metadata object","title":"recurse_mds_tree.m"},{"location":"function-guide/mdsplus/recurse_mds_tree_m/#recurse_mds_treem","text":"","title":"recurse_mds_tree.m"},{"location":"function-guide/mdsplus/recurse_mds_tree_m/#basic-information","text":"SYNTAX: PURPOSE: The code in get_mds_tree defines the tree structure down to the first node that is delimited by a colon (i.e., all paths up to *:node). This function recurses down from there (when needed to actually populate the metadata in the tree. INPUT: mds_nam = node name to recurse from (or evaluate if it is a leaf node) metadata = full metadata that will be returned to user, with content filled up to this call mds_nam0 = Top tree name toupper = user selection (see get_mds_tree.m) verbose = user selection (see get_mds_tree.m) top_num = length of mds_nam0 string OUTPUT: metadata = updated full metadata object","title":"Basic Information"},{"location":"function-guide/ntm/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Matlab functions for NTM control find_misalignment - Find distance between a flux surface and a deposition location get_NTM_signal_parameters - Return timetraces of various NTM relevant parameters get_phase - Return phase of a fairly periodic oscillation get_Rqin - Return inboard major radii of q surfaces using efit data from mds get_Rqout - Return outboard major radii of q surfaces using efit data from mds ntmdiag - Return width (w), phase (O), phase velocity (Odot) of the 3/2 and 2/1 modes qcontour - Return coordinates of contour with specific safety factor, q K1fun - calculate bootstrap current replacement efficiency, K1 (used by MREfun) test_K1fun - A template for using K1fun MREfun - predict speed of NTM growth using the Modified Rutherford Equation test_MREfun - A template for using MREfun","title":"Contents.m"},{"location":"function-guide/ntm/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/ntm/Contents_m/#basic-information","text":"Matlab functions for NTM control find_misalignment - Find distance between a flux surface and a deposition location get_NTM_signal_parameters - Return timetraces of various NTM relevant parameters get_phase - Return phase of a fairly periodic oscillation get_Rqin - Return inboard major radii of q surfaces using efit data from mds get_Rqout - Return outboard major radii of q surfaces using efit data from mds ntmdiag - Return width (w), phase (O), phase velocity (Odot) of the 3/2 and 2/1 modes qcontour - Return coordinates of contour with specific safety factor, q K1fun - calculate bootstrap current replacement efficiency, K1 (used by MREfun) test_K1fun - A template for using K1fun MREfun - predict speed of NTM growth using the Modified Rutherford Equation test_MREfun - A template for using MREfun","title":"Basic Information"},{"location":"function-guide/ntm/K1fun_m/","text":"K1fun.m \u00b6 Basic Information \u00b6 USAGE: K1 = K1fun(w,fwhm_eccd,misalignment,toroidal_angle) PURPOSE: Calculate effectiveness parameter for replacing bootstrap current in NTM INPUTS: w, width of the NTM fwhm_eccd, Full Width at Half Maximum of ECCD misalignment, offset between current drive and resonant surface (default 0) (All of the above measured at same poloidal angle with same units) toroidal_angle, toroidal angle where CD is deposited from 0=O to 180=X, if omitted an average is calculated corresponding to continuous ECCD if == 'O' calculation is for O-point modulation with 50 duty cycle if == 'X' calculation is for X-point modulation with 50 duty cycle OUTPUTS: K1, effectiveness parameter for replacing missing bootstrap current in NTM METHOD: Based on equations derived by Francis Perkins. Expanded by Anders Welander to work for arbitrary toroidal angles and include effect of radial misalignment. See epmasw060404b-mrePhase.doc which also includes Perkins' work as an appendix.","title":"K1fun.m"},{"location":"function-guide/ntm/K1fun_m/#k1funm","text":"","title":"K1fun.m"},{"location":"function-guide/ntm/K1fun_m/#basic-information","text":"USAGE: K1 = K1fun(w,fwhm_eccd,misalignment,toroidal_angle) PURPOSE: Calculate effectiveness parameter for replacing bootstrap current in NTM INPUTS: w, width of the NTM fwhm_eccd, Full Width at Half Maximum of ECCD misalignment, offset between current drive and resonant surface (default 0) (All of the above measured at same poloidal angle with same units) toroidal_angle, toroidal angle where CD is deposited from 0=O to 180=X, if omitted an average is calculated corresponding to continuous ECCD if == 'O' calculation is for O-point modulation with 50 duty cycle if == 'X' calculation is for X-point modulation with 50 duty cycle OUTPUTS: K1, effectiveness parameter for replacing missing bootstrap current in NTM METHOD: Based on equations derived by Francis Perkins. Expanded by Anders Welander to work for arbitrary toroidal angles and include effect of radial misalignment. See epmasw060404b-mrePhase.doc which also includes Perkins' work as an appendix.","title":"Basic Information"},{"location":"function-guide/ntm/MREfun_m/","text":"MREfun.m \u00b6 Basic Information \u00b6 USAGE: dwdt = MREfun(eq2d,w,j_eccd,fwhm_eccd,misalignment,toroidal_angle) PURPOSE: Calculate dw/dt from Modified Rutherford Equation INPUTS: eq2d, structure with 2-D equilibrium inputs: q, safety factor at NTM-resonant surface (e.g. 2/1 or 3/2) dqdR, dq/dR at q-surface delta_prime0, delta_prime at q-surface before ECCD is applied tau_R, resistive time at q-surface [sec] j_tot, total current density at q-surface j_boot, bootstrap current density at q-surface wmarg, marginal island size (2*ion banana width) Rqmin, minimum major radius of q-surface Rqmax, maximum major radius of q-surface w, full width of NTM j_eccd, peak ECCD density (Gaussian profile) fwhm_eccd, Full Width at Half Maximum of ECCD misalignment, offset between ECCD peak and q-surface (default 0) toroidal_angle, toroidal angle where ECCD is deposited from 0=O to 180=X, if omitted an average dw/dt is calculated for continuous ECCD on rotating NTM if == 'O' then O-point modulation with 50 duty cycle is used if == 'X' then X-point modulation with 50 duty cycle is used j_tot, j_boot, j_eccd must all be same units (j_tot=1 is an example) All lengths including 1/delta_prime0 and 1/dqdR in same units [m] Inputs can be any mix of *one* size [n1,n2] and size [1,1] eq2d must be size [1,1] but its fields can be size [n1,n2] or [1,1] OUTPUTS: dw/dt, rate of change of island width [m/s] METHOD: MRE from Nucl Fusion 49, (2009) 045005, Prospects for..","title":"MREfun.m"},{"location":"function-guide/ntm/MREfun_m/#mrefunm","text":"","title":"MREfun.m"},{"location":"function-guide/ntm/MREfun_m/#basic-information","text":"USAGE: dwdt = MREfun(eq2d,w,j_eccd,fwhm_eccd,misalignment,toroidal_angle) PURPOSE: Calculate dw/dt from Modified Rutherford Equation INPUTS: eq2d, structure with 2-D equilibrium inputs: q, safety factor at NTM-resonant surface (e.g. 2/1 or 3/2) dqdR, dq/dR at q-surface delta_prime0, delta_prime at q-surface before ECCD is applied tau_R, resistive time at q-surface [sec] j_tot, total current density at q-surface j_boot, bootstrap current density at q-surface wmarg, marginal island size (2*ion banana width) Rqmin, minimum major radius of q-surface Rqmax, maximum major radius of q-surface w, full width of NTM j_eccd, peak ECCD density (Gaussian profile) fwhm_eccd, Full Width at Half Maximum of ECCD misalignment, offset between ECCD peak and q-surface (default 0) toroidal_angle, toroidal angle where ECCD is deposited from 0=O to 180=X, if omitted an average dw/dt is calculated for continuous ECCD on rotating NTM if == 'O' then O-point modulation with 50 duty cycle is used if == 'X' then X-point modulation with 50 duty cycle is used j_tot, j_boot, j_eccd must all be same units (j_tot=1 is an example) All lengths including 1/delta_prime0 and 1/dqdR in same units [m] Inputs can be any mix of *one* size [n1,n2] and size [1,1] eq2d must be size [1,1] but its fields can be size [n1,n2] or [1,1] OUTPUTS: dw/dt, rate of change of island width [m/s] METHOD: MRE from Nucl Fusion 49, (2009) 045005, Prospects for..","title":"Basic Information"},{"location":"function-guide/ntm/calc_K1axe_m/","text":"calc_K1axe.m \u00b6 Basic Information \u00b6 PURPOSE: Compute effectiveness parameter for replacing bootstrap current in NTM (K1) for a full range of a, x, e, where: a = toroidal angle of the ECCD with respect to the O-point, x = sqrt(log(2))*size of island / FWHM of ECCD e = 2*sqrt(log(2))*misalignment of ECCD / FWHM of ECCD INPUTS: OUTPUTS: K1axe.mat (used by K1fun.m) RESTRICTIONS: METHOD: epmasw040604mrePhase.doc WRITTEN BY: Anders Welander ON 8/23/13 MODIFICATION HISTORY:","title":"calc_K1axe.m"},{"location":"function-guide/ntm/calc_K1axe_m/#calc_k1axem","text":"","title":"calc_K1axe.m"},{"location":"function-guide/ntm/calc_K1axe_m/#basic-information","text":"PURPOSE: Compute effectiveness parameter for replacing bootstrap current in NTM (K1) for a full range of a, x, e, where: a = toroidal angle of the ECCD with respect to the O-point, x = sqrt(log(2))*size of island / FWHM of ECCD e = 2*sqrt(log(2))*misalignment of ECCD / FWHM of ECCD INPUTS: OUTPUTS: K1axe.mat (used by K1fun.m) RESTRICTIONS: METHOD: epmasw040604mrePhase.doc WRITTEN BY: Anders Welander ON 8/23/13 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/ntm/ntm_field_m/","text":"ntm_field.m \u00b6 Basic Information \u00b6 SYNTAX: [g, dgdphi, phi, rq, zq] = ntm_field(equ, q, tok, dphid, iplot) PURPOSE: Calculate fields from NTM measured by magnetic probes For examples of use cases type >> ntm_field INPUTS: equ, structure with TokSys equilibrium q, safety factor of surface (should be rational value!) tok, TokSys description of tokamak or just bpdata(1:5,1:nbp) dphid, toroidal degrees between contour points On first call default = 5, then previously used value iplot, plot geometry of filament and probes (default = 0) OUTPUTS: g(i,j) = field at probe i, when rq(j), zq(j) is at phi = 0 dgdphi = derivative of g w.r.t. phi rq, zq, phi-phi(j) = toroidal coordinates for current path #j RESTRICTIONS: The effect of the NTM is modeled as a 1-A current filament running along a field line on the rational surface. If I_deficit [A] is current missing because of NTM then magnetic probe signals = -sign(jphi)*g*I_deficit [T]","title":"ntm_field.m"},{"location":"function-guide/ntm/ntm_field_m/#ntm_fieldm","text":"","title":"ntm_field.m"},{"location":"function-guide/ntm/ntm_field_m/#basic-information","text":"SYNTAX: [g, dgdphi, phi, rq, zq] = ntm_field(equ, q, tok, dphid, iplot) PURPOSE: Calculate fields from NTM measured by magnetic probes For examples of use cases type >> ntm_field INPUTS: equ, structure with TokSys equilibrium q, safety factor of surface (should be rational value!) tok, TokSys description of tokamak or just bpdata(1:5,1:nbp) dphid, toroidal degrees between contour points On first call default = 5, then previously used value iplot, plot geometry of filament and probes (default = 0) OUTPUTS: g(i,j) = field at probe i, when rq(j), zq(j) is at phi = 0 dgdphi = derivative of g w.r.t. phi rq, zq, phi-phi(j) = toroidal coordinates for current path #j RESTRICTIONS: The effect of the NTM is modeled as a 1-A current filament running along a field line on the rational surface. If I_deficit [A] is current missing because of NTM then magnetic probe signals = -sign(jphi)*g*I_deficit [T]","title":"Basic Information"},{"location":"function-guide/ntm/qcontour_m/","text":"qcontour.m \u00b6 Basic Information \u00b6 SYNTAX: [rq, zq, psiq, rq2, zq2, psiq2] = qcontour(equ, q) h = qcontour(equ, q) for plot PURPOSE: Return contour where the safety factor equals q If nargout < 2, the contour is plotted INPUTS: equ, structure with TokSys equilibrium required fields are rg, zg, psizr, psibry, psimag, jphi q, safety factor OUTPUTS: rq, zq, coordinates for the q-surface [m] psiq, poloidal flux at the q-surface [Wb] rq2, zq2, psiq2, ditto for any extra q-surface inside first h, handles to plots of limiter, boundary, and q-surface EXAMPLE: equ = read_mds_eqdsk(149713,3,'EFIT02','D3D'); qcontour(equ, 3/2) plot q=3/2-surface (and boundary and limiter)","title":"qcontour.m"},{"location":"function-guide/ntm/qcontour_m/#qcontourm","text":"","title":"qcontour.m"},{"location":"function-guide/ntm/qcontour_m/#basic-information","text":"SYNTAX: [rq, zq, psiq, rq2, zq2, psiq2] = qcontour(equ, q) h = qcontour(equ, q) for plot PURPOSE: Return contour where the safety factor equals q If nargout < 2, the contour is plotted INPUTS: equ, structure with TokSys equilibrium required fields are rg, zg, psizr, psibry, psimag, jphi q, safety factor OUTPUTS: rq, zq, coordinates for the q-surface [m] psiq, poloidal flux at the q-surface [Wb] rq2, zq2, psiq2, ditto for any extra q-surface inside first h, handles to plots of limiter, boundary, and q-surface EXAMPLE: equ = read_mds_eqdsk(149713,3,'EFIT02','D3D'); qcontour(equ, 3/2) plot q=3/2-surface (and boundary and limiter)","title":"Basic Information"},{"location":"function-guide/ntm/test_K1fun_m/","text":"test_K1fun.m \u00b6 Basic Information \u00b6 USAGE: test_K1fun PURPOSE: Template for testing and getting started with K1fun INPUTS: OUTPUTS: Graphs identical to figures 4 and 5 in report by Francis Perkins Also found in epmasw060404b-mrePhase.doc","title":"test_K1fun.m"},{"location":"function-guide/ntm/test_K1fun_m/#test_k1funm","text":"","title":"test_K1fun.m"},{"location":"function-guide/ntm/test_K1fun_m/#basic-information","text":"USAGE: test_K1fun PURPOSE: Template for testing and getting started with K1fun INPUTS: OUTPUTS: Graphs identical to figures 4 and 5 in report by Francis Perkins Also found in epmasw060404b-mrePhase.doc","title":"Basic Information"},{"location":"function-guide/ntm/test_MREfun_m/","text":"test_MREfun.m \u00b6 Basic Information \u00b6 USAGE: test_MREfun PURPOSE: Calculate dw/dt versus w & misalignment for many cases using MREfun INPUTS: ITER equilibrium is from 2010, corsica/v3.3/sob User selects (WITHIN THIS SCRIPT): delta_prime0, delta_prime if no ECCD tau_R, resistive diffusion time at q-surface delta_eccd, FWHM in meters j_boot_frac = j_boot/j_tot j_eccd_frac = j_eccd/j_boot wmarg, marginal island size in meters wmin, minimum island size for dwdt calculation wmax, maximum island size for dwdt calculation q, q at surface of interest (typically 2/1 or 3/2) OUTPUTS: Figures identical to published material by LaHaye RESTRICTIONS: METHOD:","title":"test_MREfun.m"},{"location":"function-guide/ntm/test_MREfun_m/#test_mrefunm","text":"","title":"test_MREfun.m"},{"location":"function-guide/ntm/test_MREfun_m/#basic-information","text":"USAGE: test_MREfun PURPOSE: Calculate dw/dt versus w & misalignment for many cases using MREfun INPUTS: ITER equilibrium is from 2010, corsica/v3.3/sob User selects (WITHIN THIS SCRIPT): delta_prime0, delta_prime if no ECCD tau_R, resistive diffusion time at q-surface delta_eccd, FWHM in meters j_boot_frac = j_boot/j_tot j_eccd_frac = j_eccd/j_boot wmarg, marginal island size in meters wmin, minimum island size for dwdt calculation wmax, maximum island size for dwdt calculation q, q at surface of interest (typically 2/1 or 3/2) OUTPUTS: Figures identical to published material by LaHaye RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/plasma_models/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 plasma_models bgrd_comparison bld_isoflux_response compare_currents compare_isobgd_data get_plasma_greens load_output_objs make_out_objs plasma_output - make plasma objects for output eqn - control points plasma_output2 - make plasma objects for output eqn - flux loops/probes setup_disturbances - set up betap, li disturbance signals for simulation test_plasma_output2 test_plasma_output validate_output_model write_summary_file UNIX scripts: make_model","title":"Contents.m"},{"location":"function-guide/plasma_models/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/plasma_models/Contents_m/#basic-information","text":"plasma_models bgrd_comparison bld_isoflux_response compare_currents compare_isobgd_data get_plasma_greens load_output_objs make_out_objs plasma_output - make plasma objects for output eqn - control points plasma_output2 - make plasma objects for output eqn - flux loops/probes setup_disturbances - set up betap, li disturbance signals for simulation test_plasma_output2 test_plasma_output validate_output_model write_summary_file UNIX scripts: make_model","title":"Basic Information"},{"location":"function-guide/plasma_models/bootstrap_m/","text":"bootstrap.m \u00b6 Basic Information \u00b6 USAGE: cb = bootstrap(p, Te, ne, Zeff, Zi, Ti) PURPOSE: Calculate bootstrap current and related quantities INPUTS: p, profile information (see gsprofiles), must contain fields: psip, poloidal flux on flux surfaces [Wb] rsurf, radial center of flux surfaces [m] aminor, minor radius of flux surfaces [m] fpol, fpol = 2e-7*enclosed poloidal current [Wb] pres, pressure [Pa] q, safety factor ft, fraction trapped particles in collisionless limit Babs, Surface-averaged B field magnitude Te, electron temperature [eV] (default 1e3) ne, electron density [m-3] (default 1e19) Zeff, Effective ion charge (default 1) Zi, main ion charge (default 1) Ti, ion temperature (default Ti=Te) [eV] For all inputs size(*,2) must equal number of flux surfaces or 1 OUTPUTS: cb contains fields: sigma: 'Conductivity = cneo.*sigma_Sptz' cneo: 'Neoclassical correction' sigma_Sptz: 'Spitzer conductivity' nuestar: 'Electron collisionality' nuistar: 'Main ion collisionality' jB: 'Flux-surface average <jbs*B>' jboot: '<jbs*B>/<B>' Calculations are done with formulas found in: Neoclassical conductivity and bootstrap current formulas for general axisymmetric equilibria and arbitrary collisionality regime, Sauter et al, Physics of Plasmas 6, 2834 (1999) & erratum 9, 5140 (2002) Recreate figures in the paper by running bootstrap without arguments RESTRICTIONS: Potato orbits near axis are not considered Approximate treatment for multiple ion species","title":"bootstrap.m"},{"location":"function-guide/plasma_models/bootstrap_m/#bootstrapm","text":"","title":"bootstrap.m"},{"location":"function-guide/plasma_models/bootstrap_m/#basic-information","text":"USAGE: cb = bootstrap(p, Te, ne, Zeff, Zi, Ti) PURPOSE: Calculate bootstrap current and related quantities INPUTS: p, profile information (see gsprofiles), must contain fields: psip, poloidal flux on flux surfaces [Wb] rsurf, radial center of flux surfaces [m] aminor, minor radius of flux surfaces [m] fpol, fpol = 2e-7*enclosed poloidal current [Wb] pres, pressure [Pa] q, safety factor ft, fraction trapped particles in collisionless limit Babs, Surface-averaged B field magnitude Te, electron temperature [eV] (default 1e3) ne, electron density [m-3] (default 1e19) Zeff, Effective ion charge (default 1) Zi, main ion charge (default 1) Ti, ion temperature (default Ti=Te) [eV] For all inputs size(*,2) must equal number of flux surfaces or 1 OUTPUTS: cb contains fields: sigma: 'Conductivity = cneo.*sigma_Sptz' cneo: 'Neoclassical correction' sigma_Sptz: 'Spitzer conductivity' nuestar: 'Electron collisionality' nuistar: 'Main ion collisionality' jB: 'Flux-surface average <jbs*B>' jboot: '<jbs*B>/<B>' Calculations are done with formulas found in: Neoclassical conductivity and bootstrap current formulas for general axisymmetric equilibria and arbitrary collisionality regime, Sauter et al, Physics of Plasmas 6, 2834 (1999) & erratum 9, 5140 (2002) Recreate figures in the paper by running bootstrap without arguments RESTRICTIONS: Potato orbits near axis are not considered Approximate treatment for multiple ion species","title":"Basic Information"},{"location":"function-guide/plasma_models/calc_centroid_m/","text":"calc_centroid.m \u00b6 Basic Information \u00b6 SYNTAX: [centroid_r,centroid_z] = calc_centroid(shot_or_eq,time) PURPOSE: Compute current centroid from equilibrium data for shot. INPUT: shot_or_eq = one of the following: - shot number to fetch geqdsk data from 'EFIT01' - mdsplus data structure containing g-eqdsk info for multiple times - standard toksys equilibrium data structure time = time (s) to find centroid (required if g-eqdsk is from mdsplus or is mds data structure) - can be scalar or vector OUTPUT: centroid_r,centroid_z = centroid location (m) RESTRICTIONS: This was built for D3D, but should be extendable to other devices (might work now, but not tested.)","title":"calc_centroid.m"},{"location":"function-guide/plasma_models/calc_centroid_m/#calc_centroidm","text":"","title":"calc_centroid.m"},{"location":"function-guide/plasma_models/calc_centroid_m/#basic-information","text":"SYNTAX: [centroid_r,centroid_z] = calc_centroid(shot_or_eq,time) PURPOSE: Compute current centroid from equilibrium data for shot. INPUT: shot_or_eq = one of the following: - shot number to fetch geqdsk data from 'EFIT01' - mdsplus data structure containing g-eqdsk info for multiple times - standard toksys equilibrium data structure time = time (s) to find centroid (required if g-eqdsk is from mdsplus or is mds data structure) - can be scalar or vector OUTPUT: centroid_r,centroid_z = centroid location (m) RESTRICTIONS: This was built for D3D, but should be extendable to other devices (might work now, but not tested.)","title":"Basic Information"},{"location":"function-guide/plasma_models/setup_disturbances_m/","text":"setup_disturbances.m \u00b6 Basic Information \u00b6 SYNTAX: output_struct = setup_disturbances(disturbance_struct) PURPOSE: Set up the disturbance inputs to system model. INPUT: disturbance_struct = structure containing inputs defining disturbances, or string: enter 'help' to display available default disturbances, then enter string specifying one of these default disturbances to produce disturbance model in output structure - can use this self-documented structure as a starting point to customize input OUTPUT: output_struct = structure containing: - disturbance model if input is disturbance structure - disturbance structure corresponding to default disturbance if one of those specified as input (a field=NaN => value is not specified by disturbance model); RESTRICTIONS: METHOD: Default disturbances described in: [1] Leuer, et al, ELM Disturbances in DIII-D ITER Scenario 2 Demo Discharges, EPMjal100805iter_d3d_elm_dist Date: 5 Aug. 2010 [2] Leuer, et al, Interpretation of EFDA ITER Plasma Disturbances, EPMjal100830iter_ dist_efda, 24 Sept. 2010","title":"setup_disturbances.m"},{"location":"function-guide/plasma_models/setup_disturbances_m/#setup_disturbancesm","text":"","title":"setup_disturbances.m"},{"location":"function-guide/plasma_models/setup_disturbances_m/#basic-information","text":"SYNTAX: output_struct = setup_disturbances(disturbance_struct) PURPOSE: Set up the disturbance inputs to system model. INPUT: disturbance_struct = structure containing inputs defining disturbances, or string: enter 'help' to display available default disturbances, then enter string specifying one of these default disturbances to produce disturbance model in output structure - can use this self-documented structure as a starting point to customize input OUTPUT: output_struct = structure containing: - disturbance model if input is disturbance structure - disturbance structure corresponding to default disturbance if one of those specified as input (a field=NaN => value is not specified by disturbance model); RESTRICTIONS: METHOD: Default disturbances described in: [1] Leuer, et al, ELM Disturbances in DIII-D ITER Scenario 2 Demo Discharges, EPMjal100805iter_d3d_elm_dist Date: 5 Aug. 2010 [2] Leuer, et al, Interpretation of EFDA ITER Plasma Disturbances, EPMjal100830iter_ dist_efda, 24 Sept. 2010","title":"Basic Information"},{"location":"function-guide/plresp/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 DIII-D Plasma Response Functions and Data (/users/humphrys/matlab/plresp) rrigd3d - Make OLD format rz plasma response model and calc eigenvalues calc_rzresp - Make NEW format rz plasma response model and save set (drzdi.mat) compare_isobgd_rig - Compare EFIT isoflux/Bgrid responses to model-derived => best general comparison code: does radial/vertical comparison too! compare_efit_rig - Compare EFIT radial/vertical responses to model-derived calc_rzresp - Calculates zr response model (replaces rrigd3d) 8/98 plasma_dynamics - Calculates dynamic plasma response model objects Doc file: /users/humphrys/matlab/plresp/plresp.info Other plasma response model codes connecting to the scripts in plresp can be found in directory: /users/walker/matlab/plasma_models/*.m Unix scripts usedwith these Matlab scripts and functions: make_modelDAH - DAH version of Mike's make_model. Does entire build of model objects and files needed for doing MIMO design. Starts up Matlab as needed and generates everything.","title":"Contents.m"},{"location":"function-guide/plresp/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/plresp/Contents_m/#basic-information","text":"DIII-D Plasma Response Functions and Data (/users/humphrys/matlab/plresp) rrigd3d - Make OLD format rz plasma response model and calc eigenvalues calc_rzresp - Make NEW format rz plasma response model and save set (drzdi.mat) compare_isobgd_rig - Compare EFIT isoflux/Bgrid responses to model-derived => best general comparison code: does radial/vertical comparison too! compare_efit_rig - Compare EFIT radial/vertical responses to model-derived calc_rzresp - Calculates zr response model (replaces rrigd3d) 8/98 plasma_dynamics - Calculates dynamic plasma response model objects Doc file: /users/humphrys/matlab/plresp/plresp.info Other plasma response model codes connecting to the scripts in plresp can be found in directory: /users/walker/matlab/plasma_models/*.m Unix scripts usedwith these Matlab scripts and functions: make_modelDAH - DAH version of Mike's make_model. Does entire build of model objects and files needed for doing MIMO design. Starts up Matlab as needed and generates everything.","title":"Basic Information"},{"location":"function-guide/plresp/calc_LR_m/","text":"calc_LR.m \u00b6 Basic Information \u00b6 SYNTAX: [tau,Lp,Res,eta,Lp0] = calc_LR(R0,a,kappa,li,Te,Zeff,lnlam,ne) PURPOSE: Calculate decay time for plasma INPUTS: R0 = major radius [m] a = minor radius [m] kappa = elongation li = (optional) internal inductance (default = 0.85) Te = electron temperature [eV] Zeff = (optional) effective charge state (default=1) lnlam = (optional) Coulomb logarithm ln(Lambda) (default=15) ne = (optional) electron density [m^-3] (if present, calculates lnlam from lnlam = 31 - ln(sqrt(ne)/Te) and ignores input lnlam) OUTPUTS: tau = resistive decay L/R time constant [s] Lp = plasma self inductance (calculated with sind.m) [H] Res = plasma resistance [Ohm] eta = resistivity [Ohm-m] Lp0 = Shafranov expression with kappa correction RESTRICTIONS: All quantities scalars now. METHOD: From Chen, p. 183: eta = 5.2e-5*Zeff*lnlam/(Te^1.5); Pl.restvty ohm-m Spitzer From Hutchinson, p. 19: lnlam = 31 - log(sqrt(ne)/Te); valid for Te>10 eV","title":"calc_LR.m"},{"location":"function-guide/plresp/calc_LR_m/#calc_lrm","text":"","title":"calc_LR.m"},{"location":"function-guide/plresp/calc_LR_m/#basic-information","text":"SYNTAX: [tau,Lp,Res,eta,Lp0] = calc_LR(R0,a,kappa,li,Te,Zeff,lnlam,ne) PURPOSE: Calculate decay time for plasma INPUTS: R0 = major radius [m] a = minor radius [m] kappa = elongation li = (optional) internal inductance (default = 0.85) Te = electron temperature [eV] Zeff = (optional) effective charge state (default=1) lnlam = (optional) Coulomb logarithm ln(Lambda) (default=15) ne = (optional) electron density [m^-3] (if present, calculates lnlam from lnlam = 31 - ln(sqrt(ne)/Te) and ignores input lnlam) OUTPUTS: tau = resistive decay L/R time constant [s] Lp = plasma self inductance (calculated with sind.m) [H] Res = plasma resistance [Ohm] eta = resistivity [Ohm-m] Lp0 = Shafranov expression with kappa correction RESTRICTIONS: All quantities scalars now. METHOD: From Chen, p. 183: eta = 5.2e-5*Zeff*lnlam/(Te^1.5); Pl.restvty ohm-m Spitzer From Hutchinson, p. 19: lnlam = 31 - log(sqrt(ne)/Te); valid for Te>10 eV","title":"Basic Information"},{"location":"function-guide/pubgraphics/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 public domain graphics utilities approxi3 approximate a surface z = z(x, y) with reduced number of points arrow draw a line with an arrowhead arrow2 draw a line with an arrowhead arrow3 draw a 3-D arrow bglegend displays a legend at the location selected with the mouse chartshow ANSI-chart like display of characters MATLAB can produce contoura contour plot of matrix Z crsshair gui interface for reading (x,y) values from a plot curvefit Curve fitting and plotting routine curvefitnl Nonlinear curve fitting and plotting routine errorbarxy Plot with error bars in x or y direction ezlegend GUI input for legends and linetypes fillbar Creates a filled bar plot frontpts Move points toward (or away from) the viewer inplot plots a \"picture-in-a-picture\" loadbmp loads a .BMP format file lv_lscan used by LEGEND to determine a \"good\" place for the legend orthplot 3D plot with orthogonal projections plot3in2 plots 3-dimensional lines as in 2-dimensions plotyy Plot graphs with Y tick labels on left and right side printui Print figure with uicontrols savebmp Save Microsoft Windows 3.x .BMP format image files signature produces \"signature\" with author's name and creation time sirds Generate Single Image Random Dot Stereogram slegend puts a legend on the current plot smith Draws a Smith chart spanplot plots an HP type waterfall plot stereo View current figure as 3-D cross-fusable stereo pair subzoom Allows a zoomed in subplot in main plot suptitle Puts a title above all subplots torus Generate a torus waitbar2 Display wait bar worm3 Plot a 3D curved cylinder (a worm) zoom3d Zooms MESH and SURF plots zoomrb Graphical 2D Axis Zoom with history (rubberband version)","title":"Contents.m"},{"location":"function-guide/pubgraphics/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/pubgraphics/Contents_m/#basic-information","text":"public domain graphics utilities approxi3 approximate a surface z = z(x, y) with reduced number of points arrow draw a line with an arrowhead arrow2 draw a line with an arrowhead arrow3 draw a 3-D arrow bglegend displays a legend at the location selected with the mouse chartshow ANSI-chart like display of characters MATLAB can produce contoura contour plot of matrix Z crsshair gui interface for reading (x,y) values from a plot curvefit Curve fitting and plotting routine curvefitnl Nonlinear curve fitting and plotting routine errorbarxy Plot with error bars in x or y direction ezlegend GUI input for legends and linetypes fillbar Creates a filled bar plot frontpts Move points toward (or away from) the viewer inplot plots a \"picture-in-a-picture\" loadbmp loads a .BMP format file lv_lscan used by LEGEND to determine a \"good\" place for the legend orthplot 3D plot with orthogonal projections plot3in2 plots 3-dimensional lines as in 2-dimensions plotyy Plot graphs with Y tick labels on left and right side printui Print figure with uicontrols savebmp Save Microsoft Windows 3.x .BMP format image files signature produces \"signature\" with author's name and creation time sirds Generate Single Image Random Dot Stereogram slegend puts a legend on the current plot smith Draws a Smith chart spanplot plots an HP type waterfall plot stereo View current figure as 3-D cross-fusable stereo pair subzoom Allows a zoomed in subplot in main plot suptitle Puts a title above all subplots torus Generate a torus waitbar2 Display wait bar worm3 Plot a 3D curved cylinder (a worm) zoom3d Zooms MESH and SURF plots zoomrb Graphical 2D Axis Zoom with history (rubberband version)","title":"Basic Information"},{"location":"function-guide/regression/TsCompare_m/","text":"TsCompare.m \u00b6 Basic Information \u00b6 Synchronized time series","title":"TsCompare.m"},{"location":"function-guide/regression/TsCompare_m/#tscomparem","text":"","title":"TsCompare.m"},{"location":"function-guide/regression/TsCompare_m/#basic-information","text":"Synchronized time series","title":"Basic Information"},{"location":"function-guide/simserver/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 simserver utility functions. close_z_loop - close the z control feedback loop differ_trajectory - differentiate a trajectory signal interp_poly - produced sampled function given in poly form make_breakdown_inputs - Read eddopt file and write currents into \"PCS files\" make_initial_currents - make_PCS_V_trajectory - build voltage trajectories from current trajectories make_pf_trajectory - build open loop PF current trajectories make_scenario - Make the input files for PCS and simserver to run a particular scenario closed loop simulation. make_simserver_dat - build simserver input data file postprocess_breakdown - plot vacuum flux, field from breakdown simulation setup_plasma_sim - setup params needed for simulink sims with plasma NOTE: See common_simserver_problems.doc for things to watch out for when setting up and running a simserver run with the PCS.","title":"Contents.m"},{"location":"function-guide/simserver/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/simserver/Contents_m/#basic-information","text":"simserver utility functions. close_z_loop - close the z control feedback loop differ_trajectory - differentiate a trajectory signal interp_poly - produced sampled function given in poly form make_breakdown_inputs - Read eddopt file and write currents into \"PCS files\" make_initial_currents - make_PCS_V_trajectory - build voltage trajectories from current trajectories make_pf_trajectory - build open loop PF current trajectories make_scenario - Make the input files for PCS and simserver to run a particular scenario closed loop simulation. make_simserver_dat - build simserver input data file postprocess_breakdown - plot vacuum flux, field from breakdown simulation setup_plasma_sim - setup params needed for simulink sims with plasma NOTE: See common_simserver_problems.doc for things to watch out for when setting up and running a simserver run with the PCS.","title":"Basic Information"},{"location":"function-guide/simserver/build_shape_simserver_m/","text":"build_shape_simserver.m \u00b6 Basic Information \u00b6 USAGE: build_shape_simserver.m PURPOSE: Validate Simulink simserver simulation and generate executable version. INPUTS: Set on the command line: tokamak = string defining name of tokamak extension = string defining input script to execute (defining the input file input_bld_<tokamak>_sim_<extension>.m that will be executed. All other variables are set in that script.) Define in the input file: mdl = Simulink model name eg.'d3d_sim' shot = Shotnumber for equilibrium eg. 146970 read_shot_data = equil_time = Equilibrium time in sec. eg. 2.4 tval = interval [tmin,tmax] in which to do validation of constructed simserver efit_source = EFIT source eg. 'EFIT01' mds_server = noise_option = See help for setup_bld_d3d_sim disturbance_option = See help for setup_bld_d3d_sim ivalidate = See help for setup_bld_d3d_sim ichannelmap = See help for setup_bld_d3d_sim iconvergeq = See help for setup_bld_d3d_sim iverbose = See help for setup_bld_d3d_sim rtwcompile = set to 1 (default) to compile the executable simserver, else 0 (if the RTW license is available) master_cpu_cycle_time = PCS master cpu cycle time in us eg. 50 dt_simulink = Simulink cycle time in sec. 5.0e-6 avoids discontinuous derivatives; s state_shot = state_time = init_sim_time = patch_source = If 'shot' use the F-coil patch panel used in experiment, otherwise use this file. Rp_ext = Plasma resistance (ohms). If set, overrides Rp value that will make predicted flux induction agree with resistive flux consumption. Otherwise, do not define default_init_filename = name of file that will contain designeq currents can be generated using get_sim_initial_currents.m objdir = obj_file = pcs_dir = Directory containing infra and INTEL_DIR directories intel_dir = ncpus = master_cpu_num = cpu_order = cycle_times = (us) calc_delay_times= (us) cmd_delay_times = (us) use_fpcom = OUTPUTS: all variables needed to set up the simserver plant model and, if rtwcompile=1, an executable version of the simserver RESTRICTIONS: Requires executing the PCS in closed loop with the plant simulation as part of the build process.","title":"build_shape_simserver.m"},{"location":"function-guide/simserver/build_shape_simserver_m/#build_shape_simserverm","text":"","title":"build_shape_simserver.m"},{"location":"function-guide/simserver/build_shape_simserver_m/#basic-information","text":"USAGE: build_shape_simserver.m PURPOSE: Validate Simulink simserver simulation and generate executable version. INPUTS: Set on the command line: tokamak = string defining name of tokamak extension = string defining input script to execute (defining the input file input_bld_<tokamak>_sim_<extension>.m that will be executed. All other variables are set in that script.) Define in the input file: mdl = Simulink model name eg.'d3d_sim' shot = Shotnumber for equilibrium eg. 146970 read_shot_data = equil_time = Equilibrium time in sec. eg. 2.4 tval = interval [tmin,tmax] in which to do validation of constructed simserver efit_source = EFIT source eg. 'EFIT01' mds_server = noise_option = See help for setup_bld_d3d_sim disturbance_option = See help for setup_bld_d3d_sim ivalidate = See help for setup_bld_d3d_sim ichannelmap = See help for setup_bld_d3d_sim iconvergeq = See help for setup_bld_d3d_sim iverbose = See help for setup_bld_d3d_sim rtwcompile = set to 1 (default) to compile the executable simserver, else 0 (if the RTW license is available) master_cpu_cycle_time = PCS master cpu cycle time in us eg. 50 dt_simulink = Simulink cycle time in sec. 5.0e-6 avoids discontinuous derivatives; s state_shot = state_time = init_sim_time = patch_source = If 'shot' use the F-coil patch panel used in experiment, otherwise use this file. Rp_ext = Plasma resistance (ohms). If set, overrides Rp value that will make predicted flux induction agree with resistive flux consumption. Otherwise, do not define default_init_filename = name of file that will contain designeq currents can be generated using get_sim_initial_currents.m objdir = obj_file = pcs_dir = Directory containing infra and INTEL_DIR directories intel_dir = ncpus = master_cpu_num = cpu_order = cycle_times = (us) calc_delay_times= (us) cmd_delay_times = (us) use_fpcom = OUTPUTS: all variables needed to set up the simserver plant model and, if rtwcompile=1, an executable version of the simserver RESTRICTIONS: Requires executing the PCS in closed loop with the plant simulation as part of the build process.","title":"Basic Information"},{"location":"function-guide/simserver/calc_Ip_gains_m/","text":"calc_Ip_gains.m \u00b6 Basic Information \u00b6 SYNTAX: Ip_gains = calc_Ip_gains(tok_system,vacuum_objs,cccirc, ... pfcoils,IPCS_to_Istates,figure_num) PURPOSE: Calculate \"ohmic distribution\" of coil currents to use as gains to drive Ip in PCS control. INPUT: tok_system = model of tokamak system produced by build_tokamak_system.m vacuum_objs= vacuum model objects for this tokamak cccirc = connection vector pfcoils = subset of PF coils to use in ohmic calculation IPCS_to_Istates = mapping from coil indices in PCS to corresp. states in models contained in tok_system (examples: for KSTAR it's [1:7], for EAST it's [1 7 2 8 3 9 4 10 5 11 6 12]) figure_num = figure number to start plotting from (default = no plots) OUTPUT: Ip_gains = gains to enter into M-matrix in PCS RESTRICTIONS:","title":"calc_Ip_gains.m"},{"location":"function-guide/simserver/calc_Ip_gains_m/#calc_ip_gainsm","text":"","title":"calc_Ip_gains.m"},{"location":"function-guide/simserver/calc_Ip_gains_m/#basic-information","text":"SYNTAX: Ip_gains = calc_Ip_gains(tok_system,vacuum_objs,cccirc, ... pfcoils,IPCS_to_Istates,figure_num) PURPOSE: Calculate \"ohmic distribution\" of coil currents to use as gains to drive Ip in PCS control. INPUT: tok_system = model of tokamak system produced by build_tokamak_system.m vacuum_objs= vacuum model objects for this tokamak cccirc = connection vector pfcoils = subset of PF coils to use in ohmic calculation IPCS_to_Istates = mapping from coil indices in PCS to corresp. states in models contained in tok_system (examples: for KSTAR it's [1:7], for EAST it's [1 7 2 8 3 9 4 10 5 11 6 12]) figure_num = figure number to start plotting from (default = no plots) OUTPUT: Ip_gains = gains to enter into M-matrix in PCS RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/simserver/calc_equil_diags_m/","text":"calc_equil_diags.m \u00b6 Basic Information \u00b6 SYNTAX:[coils,psi_loops,B_probes,rogloops,Ip] = ... calc_equil_diags(tok_system,vacuum_objs) PURPOSE: Compute magnetic diagnostics associated with a plasma equilibrium. INPUT: tok_system = structure containing system model vacuum_objs = structure containing green functions to magnetic diagnostics (mpl, gpb, mlc, gbc) OUTPUT: coils = current in coils (A; in order of internal states, uncollapsed) psi_loops = flux at flux loops (Wb) B_probes = field at magnetic probes (T) rogloops = current measured by Rogowski loops (Amps) Ip = plasma current (Amps) RESTRICTIONS: Note that this function doesn't produce equilibrium values for loop voltages or for \"nonstandard\" outputs.","title":"calc_equil_diags.m"},{"location":"function-guide/simserver/calc_equil_diags_m/#calc_equil_diagsm","text":"","title":"calc_equil_diags.m"},{"location":"function-guide/simserver/calc_equil_diags_m/#basic-information","text":"SYNTAX:[coils,psi_loops,B_probes,rogloops,Ip] = ... calc_equil_diags(tok_system,vacuum_objs) PURPOSE: Compute magnetic diagnostics associated with a plasma equilibrium. INPUT: tok_system = structure containing system model vacuum_objs = structure containing green functions to magnetic diagnostics (mpl, gpb, mlc, gbc) OUTPUT: coils = current in coils (A; in order of internal states, uncollapsed) psi_loops = flux at flux loops (Wb) B_probes = field at magnetic probes (T) rogloops = current measured by Rogowski loops (Amps) Ip = plasma current (Amps) RESTRICTIONS: Note that this function doesn't produce equilibrium values for loop voltages or for \"nonstandard\" outputs.","title":"Basic Information"},{"location":"function-guide/simserver/get_sim_initial_currents_m/","text":"get_sim_initial_currents.m \u00b6 Basic Information \u00b6 USAGE: [nc, i_init, i_ip] = get_sim_initial_currents(tokamak,shot,time,source,servers) PURPOSE: Retrieve initial currents and write simserver initialization file INPUTS: tokamak: tokamak string shot: shotnumber integer time: array of times esource: efit tree server: mdsplus server fsource: F-coil data source 'efit' or 'exp' OUTPUTS: RESTRICTIONS: Only setup for D3D tokamak (will generalize as necessary)","title":"get_sim_initial_currents.m"},{"location":"function-guide/simserver/get_sim_initial_currents_m/#get_sim_initial_currentsm","text":"","title":"get_sim_initial_currents.m"},{"location":"function-guide/simserver/get_sim_initial_currents_m/#basic-information","text":"USAGE: [nc, i_init, i_ip] = get_sim_initial_currents(tokamak,shot,time,source,servers) PURPOSE: Retrieve initial currents and write simserver initialization file INPUTS: tokamak: tokamak string shot: shotnumber integer time: array of times esource: efit tree server: mdsplus server fsource: F-coil data source 'efit' or 'exp' OUTPUTS: RESTRICTIONS: Only setup for D3D tokamak (will generalize as necessary)","title":"Basic Information"},{"location":"function-guide/simserver/initial_currents_c/","text":"initial_currents.c \u00b6 Basic Information \u00b6 PURPOSE: S-Function for setting initial coil and plasma currents. INPUT(u): NONE ARGUMENTS: I_init = initial condition currents [coils(ncoils),vessel(nvessel),Ip(1)] - [Amps] where Ip is initial plasma current ncoils = number of coils nvessel = number of vessel (passive) conductors nIp = 1 if Ip included in model, else 0 (In simserver mode, this is overwritten by data coming from sim_inits.) OUTPUT(y): initial condition currents (I_init)","title":"initial_currents.c"},{"location":"function-guide/simserver/initial_currents_c/#initial_currentsc","text":"","title":"initial_currents.c"},{"location":"function-guide/simserver/initial_currents_c/#basic-information","text":"PURPOSE: S-Function for setting initial coil and plasma currents. INPUT(u): NONE ARGUMENTS: I_init = initial condition currents [coils(ncoils),vessel(nvessel),Ip(1)] - [Amps] where Ip is initial plasma current ncoils = number of coils nvessel = number of vessel (passive) conductors nIp = 1 if Ip included in model, else 0 (In simserver mode, this is overwritten by data coming from sim_inits.) OUTPUT(y): initial condition currents (I_init)","title":"Basic Information"},{"location":"function-guide/simserver/initial_currents_m/","text":"initial_currents.m \u00b6 Basic Information \u00b6 PURPOSE: S-Function for setting initial coil and plasma currents. INPUT: NONE ARGUMENTS: I_init = initial condition currents [coils(ncoils),vessel(nvessel),Ip(1)] - [Amps] where Ip is initial plasma current ncoils = number of coils nvessel = number of vessel (passive) conductors nIp = 1 if Ip included in model, else 0 (In simserver mode, I_init is overwritten by data from sim_inits.) OUTPUT: initial condition currents (I_init)","title":"initial_currents.m"},{"location":"function-guide/simserver/initial_currents_m/#initial_currentsm","text":"","title":"initial_currents.m"},{"location":"function-guide/simserver/initial_currents_m/#basic-information","text":"PURPOSE: S-Function for setting initial coil and plasma currents. INPUT: NONE ARGUMENTS: I_init = initial condition currents [coils(ncoils),vessel(nvessel),Ip(1)] - [Amps] where Ip is initial plasma current ncoils = number of coils nvessel = number of vessel (passive) conductors nIp = 1 if Ip included in model, else 0 (In simserver mode, I_init is overwritten by data from sim_inits.) OUTPUT: initial condition currents (I_init)","title":"Basic Information"},{"location":"function-guide/simserver/make_PCS_V_trajectory_m/","text":"make_PCS_V_trajectory.m \u00b6 Basic Information \u00b6 SYNTAX: Vtraj= ... make_PCS_V_trajectory(Ictraj,Iptraj,xtraj,Vlimits,diag_objects) PURPOSE: Make voltage trajectory from user-defined current trajectories for SC coils - prototype for implementation in PCS. This version uses polynomials to represent sections between vertices in PCS waveforms. INPUT: Ictraj = current trajectories specified by user, each column represents a different coil - PF [1,2,3,4,5,6,7,8,11,12,13,14] Iptraj = plasma current trajectory xtraj = x values of waveform vertices for coil trajectories Vlimits = nx2 matrix = [Vmin, Vmax], voltage limits for coil circuits diag_objects = structure, contains mutual inductances Mcc,Mcp,Mcv,Mvp with rows/cols corresponding to Ictraj,Ivtraj currents OUTPUT: Vtraj = voltage trajectories in same (PCS) order RESTRICTIONS: Assumes coils are superconducting, so coil resistance is not accounted for in voltage trajectory calculation.","title":"make_PCS_V_trajectory.m"},{"location":"function-guide/simserver/make_PCS_V_trajectory_m/#make_pcs_v_trajectorym","text":"","title":"make_PCS_V_trajectory.m"},{"location":"function-guide/simserver/make_PCS_V_trajectory_m/#basic-information","text":"SYNTAX: Vtraj= ... make_PCS_V_trajectory(Ictraj,Iptraj,xtraj,Vlimits,diag_objects) PURPOSE: Make voltage trajectory from user-defined current trajectories for SC coils - prototype for implementation in PCS. This version uses polynomials to represent sections between vertices in PCS waveforms. INPUT: Ictraj = current trajectories specified by user, each column represents a different coil - PF [1,2,3,4,5,6,7,8,11,12,13,14] Iptraj = plasma current trajectory xtraj = x values of waveform vertices for coil trajectories Vlimits = nx2 matrix = [Vmin, Vmax], voltage limits for coil circuits diag_objects = structure, contains mutual inductances Mcc,Mcp,Mcv,Mvp with rows/cols corresponding to Ictraj,Ivtraj currents OUTPUT: Vtraj = voltage trajectories in same (PCS) order RESTRICTIONS: Assumes coils are superconducting, so coil resistance is not accounted for in voltage trajectory calculation.","title":"Basic Information"},{"location":"function-guide/simserver/make_pf_trajectory_m/","text":"make_pf_trajectory.m \u00b6 Basic Information \u00b6 SYNTAX: [Ictraj,Vtraj,tItraj]=make_pf_trajectory(tok_system,vacuum_objs,... pfcoils_oh,PFmax,Ipref,PF_init,figure_num) PURPOSE: Construct PF coil current and voltage trajectories. INPUT: tok_system = model of tokamak system produced by build_tokamak_system.m vacuum_objs= vacuum model objects for this tokamak pfcoils_oh = indices from PF coils [1:ncc] to use for Ip (\"ohmic\") drive PFmax = maximum current allowed in PF coils, must correspond to order of currents represented by tok_system.cc0 Ipref = 2 column matrix, 1st col=time(s), 2nd = Ip reference (amps) PF_init = approximate PF coil initial conditions (length ncc) figure_num = figure number to start plotting from (default = no plots) OUTPUT: Ictraj = trajectory of all coil currents Vtraj = trajectory of voltages to produce those currents tItraj = time values corresponding to data in Ictraj, Vtraj RESTRICTIONS: Code computes initial condition closest to PF_init and compatible with trajectory. METHOD: See M.L.Walker, Calculation of Feedforward Current and Voltage Trajectories for Shape and Plasma Current Control, Engineering Physics Memo, EPM???","title":"make_pf_trajectory.m"},{"location":"function-guide/simserver/make_pf_trajectory_m/#make_pf_trajectorym","text":"","title":"make_pf_trajectory.m"},{"location":"function-guide/simserver/make_pf_trajectory_m/#basic-information","text":"SYNTAX: [Ictraj,Vtraj,tItraj]=make_pf_trajectory(tok_system,vacuum_objs,... pfcoils_oh,PFmax,Ipref,PF_init,figure_num) PURPOSE: Construct PF coil current and voltage trajectories. INPUT: tok_system = model of tokamak system produced by build_tokamak_system.m vacuum_objs= vacuum model objects for this tokamak pfcoils_oh = indices from PF coils [1:ncc] to use for Ip (\"ohmic\") drive PFmax = maximum current allowed in PF coils, must correspond to order of currents represented by tok_system.cc0 Ipref = 2 column matrix, 1st col=time(s), 2nd = Ip reference (amps) PF_init = approximate PF coil initial conditions (length ncc) figure_num = figure number to start plotting from (default = no plots) OUTPUT: Ictraj = trajectory of all coil currents Vtraj = trajectory of voltages to produce those currents tItraj = time values corresponding to data in Ictraj, Vtraj RESTRICTIONS: Code computes initial condition closest to PF_init and compatible with trajectory. METHOD: See M.L.Walker, Calculation of Feedforward Current and Voltage Trajectories for Shape and Plasma Current Control, Engineering Physics Memo, EPM???","title":"Basic Information"},{"location":"function-guide/simserver/make_scenario_m/","text":"make_scenario.m \u00b6 Basic Information \u00b6 SYNTAX: [Ictraj_PCS,Vtraj_PCS] = make_scenario(scenario_data,debug) PURPOSE: Make the input files needed by PCS and simserver to run a particular plasma scenario simulation. (Only works for EAST and KSTAR right now.) INPUT: in scenario_data structure: scenario_name = name(string) of scenario to build setup files for tok_system = tokamak (and plasma) model structure vacuum_objs = tokamak basic geometry objects structure IPCS_to_Istates = index vector mapping coils in PCS order to states of the linearized model, IPCS_to_Istates(i) = k, where i is the number of the PF coil, and k is the corresponding state index (include only coils intended to have nonzero equil. current) Istates_to_IPCS = index vector mapping coil current states to coils in PCS, Istates_to_IPCS(i) = k, where i is the index of the state, and k is the number of the PF coil Ipref = trajectory for plasma current (1st column=time, 2nd=Ip) Icref = trajectory for coil currents, 1st col.=time, remaining columns are PF currents in PCS order (required for vacuum, else not used) PF_state_names_PCS = names of PF current states, in PCS order PFmax = vector maximum currents allowed in PF coils iplcirc = set equal to 1 to include plasma circuit eqn in model cccirc = coil connection definitions pfcoils = subset of PF coils to compute trajectories for = either indices into vacuum_objs.fcnames or names in vacuum_objs.fcnames vacuum_model = flag, 0=vacuum model in tok_system, 1=plasma model ip_init = initial value for Ip dt_rz = time step for R and Z feedback control Gp_z,Gd_z,Gi_z = gains for Z control taup_z,taud_z,taui_z = time constants for Z control full_system = set to 1 to get full set of outputs, else 0 Vlimits = upper and lower bounds on coil voltages idx_vcntl_ckts = indices of vert. cntrl coils, after circuits connected debug = set to 1 to get debug plots of trajectories OUTPUT: Ictraj_PCS Vctraj_PCS FILES (all with scenario_name in place of #): #.log = log showing what is produced and how to use #_PF*_Itraj.dat = PF and Ip trajectories (consistent with Ip trajectory) #_Ip_traj.dat = Ip trajectory #_Vtraj.dat = voltage trajectories #_PCS_mutuals.dat = matrices needed by PCS to compute V trajs #_I_init.dat = file to use to initialize simserver currents at other than default (equilibrium) values RESTRICTIONS: (1) Assumes that first 3 sets of diagnostics are: coils, flux loops, probes (2) Works only when ohmic distribution currents all the same sign right now.","title":"make_scenario.m"},{"location":"function-guide/simserver/make_scenario_m/#make_scenariom","text":"","title":"make_scenario.m"},{"location":"function-guide/simserver/make_scenario_m/#basic-information","text":"SYNTAX: [Ictraj_PCS,Vtraj_PCS] = make_scenario(scenario_data,debug) PURPOSE: Make the input files needed by PCS and simserver to run a particular plasma scenario simulation. (Only works for EAST and KSTAR right now.) INPUT: in scenario_data structure: scenario_name = name(string) of scenario to build setup files for tok_system = tokamak (and plasma) model structure vacuum_objs = tokamak basic geometry objects structure IPCS_to_Istates = index vector mapping coils in PCS order to states of the linearized model, IPCS_to_Istates(i) = k, where i is the number of the PF coil, and k is the corresponding state index (include only coils intended to have nonzero equil. current) Istates_to_IPCS = index vector mapping coil current states to coils in PCS, Istates_to_IPCS(i) = k, where i is the index of the state, and k is the number of the PF coil Ipref = trajectory for plasma current (1st column=time, 2nd=Ip) Icref = trajectory for coil currents, 1st col.=time, remaining columns are PF currents in PCS order (required for vacuum, else not used) PF_state_names_PCS = names of PF current states, in PCS order PFmax = vector maximum currents allowed in PF coils iplcirc = set equal to 1 to include plasma circuit eqn in model cccirc = coil connection definitions pfcoils = subset of PF coils to compute trajectories for = either indices into vacuum_objs.fcnames or names in vacuum_objs.fcnames vacuum_model = flag, 0=vacuum model in tok_system, 1=plasma model ip_init = initial value for Ip dt_rz = time step for R and Z feedback control Gp_z,Gd_z,Gi_z = gains for Z control taup_z,taud_z,taui_z = time constants for Z control full_system = set to 1 to get full set of outputs, else 0 Vlimits = upper and lower bounds on coil voltages idx_vcntl_ckts = indices of vert. cntrl coils, after circuits connected debug = set to 1 to get debug plots of trajectories OUTPUT: Ictraj_PCS Vctraj_PCS FILES (all with scenario_name in place of #): #.log = log showing what is produced and how to use #_PF*_Itraj.dat = PF and Ip trajectories (consistent with Ip trajectory) #_Ip_traj.dat = Ip trajectory #_Vtraj.dat = voltage trajectories #_PCS_mutuals.dat = matrices needed by PCS to compute V trajs #_I_init.dat = file to use to initialize simserver currents at other than default (equilibrium) values RESTRICTIONS: (1) Assumes that first 3 sets of diagnostics are: coils, flux loops, probes (2) Works only when ohmic distribution currents all the same sign right now.","title":"Basic Information"},{"location":"function-guide/simserver/make_simserver_dat_m/","text":"make_simserver_dat.m \u00b6 Basic Information \u00b6 SYNTAX: make_simserver_dat(init_file,Icoil0,Ip0) PURPOSE: Build input file to simserver to specify initial coil currents. This function is for generic simserver. To generate a patch panel file for input to d3d simserver, use make_d3d_simserver_dat. INPUT: init_file = name of file to create Icoil0 = initial coil currents (Amps) Ip0 = initial plasma current (Amps) OUTPUT: writes out data into file \"init_file\"","title":"make_simserver_dat.m"},{"location":"function-guide/simserver/make_simserver_dat_m/#make_simserver_datm","text":"","title":"make_simserver_dat.m"},{"location":"function-guide/simserver/make_simserver_dat_m/#basic-information","text":"SYNTAX: make_simserver_dat(init_file,Icoil0,Ip0) PURPOSE: Build input file to simserver to specify initial coil currents. This function is for generic simserver. To generate a patch panel file for input to d3d simserver, use make_d3d_simserver_dat. INPUT: init_file = name of file to create Icoil0 = initial coil currents (Amps) Ip0 = initial plasma current (Amps) OUTPUT: writes out data into file \"init_file\"","title":"Basic Information"},{"location":"function-guide/simserver/ohmic_dist1_m/","text":"ohmic_dist1.m \u00b6 Basic Information \u00b6 USAGE: [ohmic_dist_data] = ohmic_dist1(ohmic_calc_inputs) PURPOSE: Calculates the Best Ohmic current distribution for F coils INPUTS: [default] ohmic_calc_inputs = structure, containing one or more of following: cccirc = coil connection vector Pcc = mapping from coil states to all PF coils (only one of cccirc or Pcc should be provided) pfcoils_oh = indices of PF coil to use in ohmic distribution flux0 = target flux at center, scaler (Vs) [1] bz_targ = target vertical field scaler or (npt,1) (T) [0] ic_min = minimum coil currents (A), either full set or current states ic_max = maximum coil currents (A), either full set or current states vacuum_objs = vacuum model objects for the device npt = Number of points on boundary for optimization [101] r_plasma = Major radius of breakdown circle (m) z_plasma = Z Location of center of breakdown circle (m) [0] rpt, zpt = R,Z Plasma boundary Points (m) (alternatively, use a,k,d below) a_plasma = Minor radius of breakdown circle (only needed if no rpt,zpt) k_plasma = Elongation of breakdown circle (only needed if no rpt,zpt) [1] d_plasma = Triangularity of breakdown circle(only needed if no rpt,zpt)[0] minimize_i = 0.1; Includes currents in opts. to reduce +-I [0] minimize_i weights how much I smooting to perform Value of 0 to 0.1 are reasonable pause_it= 1; => pause between figures [0]; figure_num = optional, if not provided then no plotting OUTPUTS: ohmic_dist_data = structure, containing: ic_ohmic = Optimum Ohmic Terminal Current vector (A) ict_ohmic= Optimum Ohmic Amp-Turn Current vector (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) figure_num = updated figure number (if figure_num is input) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m now very similar to CUROPT by including Bz and constraints on currents now calculates based on terminal currents rather than (amp-turns)","title":"ohmic_dist1.m"},{"location":"function-guide/simserver/ohmic_dist1_m/#ohmic_dist1m","text":"","title":"ohmic_dist1.m"},{"location":"function-guide/simserver/ohmic_dist1_m/#basic-information","text":"USAGE: [ohmic_dist_data] = ohmic_dist1(ohmic_calc_inputs) PURPOSE: Calculates the Best Ohmic current distribution for F coils INPUTS: [default] ohmic_calc_inputs = structure, containing one or more of following: cccirc = coil connection vector Pcc = mapping from coil states to all PF coils (only one of cccirc or Pcc should be provided) pfcoils_oh = indices of PF coil to use in ohmic distribution flux0 = target flux at center, scaler (Vs) [1] bz_targ = target vertical field scaler or (npt,1) (T) [0] ic_min = minimum coil currents (A), either full set or current states ic_max = maximum coil currents (A), either full set or current states vacuum_objs = vacuum model objects for the device npt = Number of points on boundary for optimization [101] r_plasma = Major radius of breakdown circle (m) z_plasma = Z Location of center of breakdown circle (m) [0] rpt, zpt = R,Z Plasma boundary Points (m) (alternatively, use a,k,d below) a_plasma = Minor radius of breakdown circle (only needed if no rpt,zpt) k_plasma = Elongation of breakdown circle (only needed if no rpt,zpt) [1] d_plasma = Triangularity of breakdown circle(only needed if no rpt,zpt)[0] minimize_i = 0.1; Includes currents in opts. to reduce +-I [0] minimize_i weights how much I smooting to perform Value of 0 to 0.1 are reasonable pause_it= 1; => pause between figures [0]; figure_num = optional, if not provided then no plotting OUTPUTS: ohmic_dist_data = structure, containing: ic_ohmic = Optimum Ohmic Terminal Current vector (A) ict_ohmic= Optimum Ohmic Amp-Turn Current vector (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) figure_num = updated figure number (if figure_num is input) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m now very similar to CUROPT by including Bz and constraints on currents now calculates based on terminal currents rather than (amp-turns)","title":"Basic Information"},{"location":"function-guide/simserver/pack_io_PCS_data_m/","text":"pack_io_PCS_data.m \u00b6 Basic Information \u00b6 SYNTAX: io_PCS_data = pack_io_PCS_data(pcs_connect_data) PURPOSE: Utility function to pack the data from connection data structure into one long vector for input to io_PCS S-function. INPUT: pcs_connect_data = data structure with separate fields defined by variables listed in comment header of io_PCS.c OUTPUT: io_PCS_data = single vector containing the same information","title":"pack_io_PCS_data.m"},{"location":"function-guide/simserver/pack_io_PCS_data_m/#pack_io_pcs_datam","text":"","title":"pack_io_PCS_data.m"},{"location":"function-guide/simserver/pack_io_PCS_data_m/#basic-information","text":"SYNTAX: io_PCS_data = pack_io_PCS_data(pcs_connect_data) PURPOSE: Utility function to pack the data from connection data structure into one long vector for input to io_PCS S-function. INPUT: pcs_connect_data = data structure with separate fields defined by variables listed in comment header of io_PCS.c OUTPUT: io_PCS_data = single vector containing the same information","title":"Basic Information"},{"location":"function-guide/simserver/read_simserver_init_file_m/","text":"read_simserver_init_file.m \u00b6 Basic Information \u00b6 USAGE: [i_init, nc, i_ip ] = read_simserver_init_file(sim_init_filename,inc_plasma,system); PURPOSE: Read simserver current initialization file. Replaces code in sim_device_init INPUTS: sim_init_filename: name of initialization file inc_plasma: set=1 to include an initial condition for the Ip equation system: toksys system model OUTPUTS: i_init: initial values of conductor currents [PF_coils, vessel, Ip] nc: number of total PF-coil currents i_ip: initial value of Ip RESTRICTIONS: Returns zeros for vessel currents right now. Could be extended in the future to also read and return vessel currents from the initial conditions file.","title":"read_simserver_init_file.m"},{"location":"function-guide/simserver/read_simserver_init_file_m/#read_simserver_init_filem","text":"","title":"read_simserver_init_file.m"},{"location":"function-guide/simserver/read_simserver_init_file_m/#basic-information","text":"USAGE: [i_init, nc, i_ip ] = read_simserver_init_file(sim_init_filename,inc_plasma,system); PURPOSE: Read simserver current initialization file. Replaces code in sim_device_init INPUTS: sim_init_filename: name of initialization file inc_plasma: set=1 to include an initial condition for the Ip equation system: toksys system model OUTPUTS: i_init: initial values of conductor currents [PF_coils, vessel, Ip] nc: number of total PF-coil currents i_ip: initial value of Ip RESTRICTIONS: Returns zeros for vessel currents right now. Could be extended in the future to also read and return vessel currents from the initial conditions file.","title":"Basic Information"},{"location":"function-guide/simserver/setup_io_PCS_Sfn_m/","text":"setup_io_PCS_Sfn.m \u00b6 Basic Information \u00b6 USAGE: setup_io_PCS_Sfn.m PURPOSE: set inputs for io_PCS S-function INPUTS: tokamak = name of device, e.g., 'd3d', 'east', 'kstar', etc. shot(OR shotnum) = number of shot start_time = starting time for simulation of what you care about init_sim_time = initial simulation time (seconds) = any time before baseline calc in PCS ncpus = number of realtime cpus executing (or being simulated) in the PCS master_cpu_num = number of cpu whos cycle time defines the multiplier for all cpus cpu_order = order to feed data to cpus (master cpu first) cycle_times = cycle times of real-time cpus, in order 1...ncpus calc_delay_times = computational delay for each cpu, entry i corresponds to cpu i cmd_delay_times = delay in sending commands from each cpu, entry i corresponds to cpu i NUM_SIM_OUTPUTS = number of PCS channels (width of diags signal fed to the PCS interface block) pcs_channels2 = indices of PCS channels corresponding to simulated signals fed to the PCS interface block's input, indexed from 1 (see input_data2.m in INTEL_DIR or INTEL64_DIR or run get_input_channels.m) pcs_channels2_names = signal names corresponding to indices in pcs_channels (optional, used only for human understanding) simulation_includes.m = file containing definitions of command signal indices in PCS and conversion factors from counts into DAC to command voltages OUTPUTS: pcs_connect_data = a structure with fields: ncpus integer = number of cpus that PCS is compiled for master_cpu_num integer = master cpu number in PCS start_time float = time in seconds to jump to in beginning simulation (optional, default 0) init_sim_time floag = time in seconds at which to start the process for baseline calculation shotnum integer = shot number to get PCS initial condition data from DA_GAIN = multiplier that converts digitizer volts to counts Note: PCS sends out digitizer counts (not volts) Further, PCS and matlab simulation maintain the VME ranges: 4096 counts = -10 to 10 V But, sysmain_master.h multiplies commands by 16 to get DAC* commands in 16-bit count range So count-to-volt conversion is (20/4096)*(1/16)=10.0/32767.0=3.0518e-04, which is the inherent number (IN) for DAC* commands, DA_GAIN = 1/IN. IN values are documented in simulation_includes.h. use_fpcom = flag, if 1 use fpcom (unclipped) data for commands instead of intcom (optional, default=0) cycle_times float(ncpu) = cycle times of real-time cpus, in order 1...ncpus calc_delay_times float(ncpu) = computational delay for each cpu, entry i corresponds to cpu i cmd_delay_times = delay in sending commands, entry i corresponds to cpu i num_pcs_inputs integer = number of PCS channels (defines input port size) pcs_channels integer(num_pcs_inputs) = indices of PCS channels input to io_PCS; these are <device>_sim outputs, indexed from 1 (see input_data.h) pcs_channel_names = names of signals corresponding to pcs_channels (for human readability) num_commands = number of intcommand channels (defines output port size) intcom_channels = indices of intcommand channels defining PCS Sfn output, indexed from 1 intcom_cpus = cpu numbers where intcom values are coming from, indexed from 1 cpu_order = order to feed data to cpus (master cpu first) OTHER VARIABLES pcs_channels_ids integer(num_pcs_inputs) = used in <device>_simX_model Selector block to id PCS variables for Diag. Physics Out port RESTRICTIONS: METHOD Script initializes variables needed by io_PCS S-function. Inputs are needed from both <device>_sim and the PCS compiled to use in the simulation. <device>_sim code is found in this directory. PCS header files are found in the user's PCS directory by default The intention is to allow for changes in the PCS to be made without bothering this workflow. Inputs to <device>_sim.mdl are PCS commands. Outputs are signals sent to the pcs. Conversely, inputs to io_PCS are <device>_sim signals and outputs are PCS commands. The signals generated by <device>_sim are defined in SIMULATION_TO_PCS.h. The commands generated by io_PCS are defined in input_data2.h <device>_sim_struct.output_signals contains PCS pointnames for the signals in the simulink model, <device>_sim_struct.output_signals begins with <device>_system.output_signals(:,1) and continues with signals added in <device>_sim2.mdl <device>_sim_struct.input_signals: These are commands from the PCS used to identify the intcom_channels, which are indices of the Sfn output DAC are actual commands that go out. FSF is the command calculated, FSC is the clipped value and should agree with DAC IPFEPS is the command calculated and IPCEPS is the clipped value pcsinputs2 are the macros extracted from input_data2.h pcs_channels2 are the indices of the macros for the pcs therefore, pcsinputs2(pcs_channels2) are the macros for the pcs To extract the indices of <device>_sim_struct.output_signals we need for the pcs from the simulation data, we match pcsinputs2(pcs_channels2) with <device>_sim_struct.output_signals","title":"setup_io_PCS_Sfn.m"},{"location":"function-guide/simserver/setup_io_PCS_Sfn_m/#setup_io_pcs_sfnm","text":"","title":"setup_io_PCS_Sfn.m"},{"location":"function-guide/simserver/setup_io_PCS_Sfn_m/#basic-information","text":"USAGE: setup_io_PCS_Sfn.m PURPOSE: set inputs for io_PCS S-function INPUTS: tokamak = name of device, e.g., 'd3d', 'east', 'kstar', etc. shot(OR shotnum) = number of shot start_time = starting time for simulation of what you care about init_sim_time = initial simulation time (seconds) = any time before baseline calc in PCS ncpus = number of realtime cpus executing (or being simulated) in the PCS master_cpu_num = number of cpu whos cycle time defines the multiplier for all cpus cpu_order = order to feed data to cpus (master cpu first) cycle_times = cycle times of real-time cpus, in order 1...ncpus calc_delay_times = computational delay for each cpu, entry i corresponds to cpu i cmd_delay_times = delay in sending commands from each cpu, entry i corresponds to cpu i NUM_SIM_OUTPUTS = number of PCS channels (width of diags signal fed to the PCS interface block) pcs_channels2 = indices of PCS channels corresponding to simulated signals fed to the PCS interface block's input, indexed from 1 (see input_data2.m in INTEL_DIR or INTEL64_DIR or run get_input_channels.m) pcs_channels2_names = signal names corresponding to indices in pcs_channels (optional, used only for human understanding) simulation_includes.m = file containing definitions of command signal indices in PCS and conversion factors from counts into DAC to command voltages OUTPUTS: pcs_connect_data = a structure with fields: ncpus integer = number of cpus that PCS is compiled for master_cpu_num integer = master cpu number in PCS start_time float = time in seconds to jump to in beginning simulation (optional, default 0) init_sim_time floag = time in seconds at which to start the process for baseline calculation shotnum integer = shot number to get PCS initial condition data from DA_GAIN = multiplier that converts digitizer volts to counts Note: PCS sends out digitizer counts (not volts) Further, PCS and matlab simulation maintain the VME ranges: 4096 counts = -10 to 10 V But, sysmain_master.h multiplies commands by 16 to get DAC* commands in 16-bit count range So count-to-volt conversion is (20/4096)*(1/16)=10.0/32767.0=3.0518e-04, which is the inherent number (IN) for DAC* commands, DA_GAIN = 1/IN. IN values are documented in simulation_includes.h. use_fpcom = flag, if 1 use fpcom (unclipped) data for commands instead of intcom (optional, default=0) cycle_times float(ncpu) = cycle times of real-time cpus, in order 1...ncpus calc_delay_times float(ncpu) = computational delay for each cpu, entry i corresponds to cpu i cmd_delay_times = delay in sending commands, entry i corresponds to cpu i num_pcs_inputs integer = number of PCS channels (defines input port size) pcs_channels integer(num_pcs_inputs) = indices of PCS channels input to io_PCS; these are <device>_sim outputs, indexed from 1 (see input_data.h) pcs_channel_names = names of signals corresponding to pcs_channels (for human readability) num_commands = number of intcommand channels (defines output port size) intcom_channels = indices of intcommand channels defining PCS Sfn output, indexed from 1 intcom_cpus = cpu numbers where intcom values are coming from, indexed from 1 cpu_order = order to feed data to cpus (master cpu first) OTHER VARIABLES pcs_channels_ids integer(num_pcs_inputs) = used in <device>_simX_model Selector block to id PCS variables for Diag. Physics Out port RESTRICTIONS: METHOD Script initializes variables needed by io_PCS S-function. Inputs are needed from both <device>_sim and the PCS compiled to use in the simulation. <device>_sim code is found in this directory. PCS header files are found in the user's PCS directory by default The intention is to allow for changes in the PCS to be made without bothering this workflow. Inputs to <device>_sim.mdl are PCS commands. Outputs are signals sent to the pcs. Conversely, inputs to io_PCS are <device>_sim signals and outputs are PCS commands. The signals generated by <device>_sim are defined in SIMULATION_TO_PCS.h. The commands generated by io_PCS are defined in input_data2.h <device>_sim_struct.output_signals contains PCS pointnames for the signals in the simulink model, <device>_sim_struct.output_signals begins with <device>_system.output_signals(:,1) and continues with signals added in <device>_sim2.mdl <device>_sim_struct.input_signals: These are commands from the PCS used to identify the intcom_channels, which are indices of the Sfn output DAC are actual commands that go out. FSF is the command calculated, FSC is the clipped value and should agree with DAC IPFEPS is the command calculated and IPCEPS is the clipped value pcsinputs2 are the macros extracted from input_data2.h pcs_channels2 are the indices of the macros for the pcs therefore, pcsinputs2(pcs_channels2) are the macros for the pcs To extract the indices of <device>_sim_struct.output_signals we need for the pcs from the simulation data, we match pcsinputs2(pcs_channels2) with <device>_sim_struct.output_signals","title":"Basic Information"},{"location":"function-guide/simserver/setup_plasma_sim_m/","text":"setup_plasma_sim.m \u00b6 Basic Information \u00b6 SYNTAX: setup_plasma_sim PURPOSE: Define variables needed for simulink models that include plasma. Also defines some data that can be used to program the PCS when running in closed loop versus a simserver constructed from simulink model. (Only works for EAST and KSTAR right now.) INPUT: vacuum_objs = vacuum model data structure iplcirc = set equal to 1 to include plasma circuit eqn in model ichooseq = choose type of equilibrium data to use: 0 = vacuum model (no plasma equilibrium required) 1 = efit gfile 2 = Corsica equilibrium files 3 = saved corsica equilibrium 4 = TokSys equilibrium data structure efit_gfile = EFIT equilibrium file (g-file), only needed if ichooseq=1 corsica_inputs = name of ??? (required only if ichooseq=2) corsica_savefile = name of saved corsica equilibrium (required only if ichooseq=3) equil_data = name of TokSys format equilibrium data structure (required only if ichooseq=4) ip_init = initial value for Ip dt_rz = time step for R and Z feedback control Gp_z,Gd_z,Gi_z = gains for Z control taup_z,taud_z,taui_z = time constants for Z control Gp_r,Gd_r,Gi_r = gains for R control taup_r,taud_r,taui_r = time constants for R control Vlimits_PF = upper and lower bounds on PF coil voltages idx_vcntl_ckts = indices of vertical control circuits in system model OUTPUT: many variables needed to initialize simulink (*.mdl) models Ip_gains = gain vector that can be used for Ip control in PCS FILES: <tokamak>_PCS_mutuals.dat = matrices needed by PCS to compute V trajs init_currents.dat = initial currents file (set = equilibrium values) RESTRICTIONS: (1) Assumes that first 3 sets of diagnostics are: coils, flux loops, probes (2) Works only when ohmic distribution currents all the same sign right now. (3) Does not work (incorrect diags_0) with nonzero equilibrium vessel currents.","title":"setup_plasma_sim.m"},{"location":"function-guide/simserver/setup_plasma_sim_m/#setup_plasma_simm","text":"","title":"setup_plasma_sim.m"},{"location":"function-guide/simserver/setup_plasma_sim_m/#basic-information","text":"SYNTAX: setup_plasma_sim PURPOSE: Define variables needed for simulink models that include plasma. Also defines some data that can be used to program the PCS when running in closed loop versus a simserver constructed from simulink model. (Only works for EAST and KSTAR right now.) INPUT: vacuum_objs = vacuum model data structure iplcirc = set equal to 1 to include plasma circuit eqn in model ichooseq = choose type of equilibrium data to use: 0 = vacuum model (no plasma equilibrium required) 1 = efit gfile 2 = Corsica equilibrium files 3 = saved corsica equilibrium 4 = TokSys equilibrium data structure efit_gfile = EFIT equilibrium file (g-file), only needed if ichooseq=1 corsica_inputs = name of ??? (required only if ichooseq=2) corsica_savefile = name of saved corsica equilibrium (required only if ichooseq=3) equil_data = name of TokSys format equilibrium data structure (required only if ichooseq=4) ip_init = initial value for Ip dt_rz = time step for R and Z feedback control Gp_z,Gd_z,Gi_z = gains for Z control taup_z,taud_z,taui_z = time constants for Z control Gp_r,Gd_r,Gi_r = gains for R control taup_r,taud_r,taui_r = time constants for R control Vlimits_PF = upper and lower bounds on PF coil voltages idx_vcntl_ckts = indices of vertical control circuits in system model OUTPUT: many variables needed to initialize simulink (*.mdl) models Ip_gains = gain vector that can be used for Ip control in PCS FILES: <tokamak>_PCS_mutuals.dat = matrices needed by PCS to compute V trajs init_currents.dat = initial currents file (set = equilibrium values) RESTRICTIONS: (1) Assumes that first 3 sets of diagnostics are: coils, flux loops, probes (2) Works only when ohmic distribution currents all the same sign right now. (3) Does not work (incorrect diags_0) with nonzero equilibrium vessel currents.","title":"Basic Information"},{"location":"function-guide/simserver/simserver_setup_MSE_m/","text":"simserver_setup_MSE.m \u00b6 Basic Information \u00b6 SYNTAX: setup_MSE PURPOSE: Define configuration data for MSE module. INPUT: OUTPUT:","title":"simserver_setup_MSE.m"},{"location":"function-guide/simserver/simserver_setup_MSE_m/#simserver_setup_msem","text":"","title":"simserver_setup_MSE.m"},{"location":"function-guide/simserver/simserver_setup_MSE_m/#basic-information","text":"SYNTAX: setup_MSE PURPOSE: Define configuration data for MSE module. INPUT: OUTPUT:","title":"Basic Information"},{"location":"function-guide/simserver/simserver_setup_limited_system_m/","text":"simserver_setup_limited_system.m \u00b6 Basic Information \u00b6 SYNTAX: setup_limited_system PURPOSE: Define configuration data for limited_system module. INPUT: ichooseq = model equilibrium selection flag (see build_tokamak_systea.m) tok_system = system model for the tokamak min_currents = max_currents = num_Ecoils = number of E-coils (for most devices, this is 0) nv = inc_plasma = set to 1 to include plasma ODE in the system model adiagfilter,bdiagfilter,cdiagfilter,ddiagfilter = A,B,C,D matrices for diagnostics filter (optional, use only if your model includes diagnostics filter block) OUTPUT: limited_system = struct containing config info needed for the limited_system block in toksim_generic library","title":"simserver_setup_limited_system.m"},{"location":"function-guide/simserver/simserver_setup_limited_system_m/#simserver_setup_limited_systemm","text":"","title":"simserver_setup_limited_system.m"},{"location":"function-guide/simserver/simserver_setup_limited_system_m/#basic-information","text":"SYNTAX: setup_limited_system PURPOSE: Define configuration data for limited_system module. INPUT: ichooseq = model equilibrium selection flag (see build_tokamak_systea.m) tok_system = system model for the tokamak min_currents = max_currents = num_Ecoils = number of E-coils (for most devices, this is 0) nv = inc_plasma = set to 1 to include plasma ODE in the system model adiagfilter,bdiagfilter,cdiagfilter,ddiagfilter = A,B,C,D matrices for diagnostics filter (optional, use only if your model includes diagnostics filter block) OUTPUT: limited_system = struct containing config info needed for the limited_system block in toksim_generic library","title":"Basic Information"},{"location":"function-guide/simserver/simserver_setup_lin_plasma_sim_m/","text":"simserver_setup_lin_plasma_sim.m \u00b6 Basic Information \u00b6 SYNTAX: simserver_setup_lin_plasma_sim PURPOSE: Define configuration data for lin_plasma_sim module. INPUT: Same inputs as function simserver_setup_limited_system, and in addition: d0 nc nv inc_plasma select_coils = indices of coil current initial values that constitute initial conditions for the current states in system model i_init = initial coil current values (all coils) OUTPUT:","title":"simserver_setup_lin_plasma_sim.m"},{"location":"function-guide/simserver/simserver_setup_lin_plasma_sim_m/#simserver_setup_lin_plasma_simm","text":"","title":"simserver_setup_lin_plasma_sim.m"},{"location":"function-guide/simserver/simserver_setup_lin_plasma_sim_m/#basic-information","text":"SYNTAX: simserver_setup_lin_plasma_sim PURPOSE: Define configuration data for lin_plasma_sim module. INPUT: Same inputs as function simserver_setup_limited_system, and in addition: d0 nc nv inc_plasma select_coils = indices of coil current initial values that constitute initial conditions for the current states in system model i_init = initial coil current values (all coils) OUTPUT:","title":"Basic Information"},{"location":"function-guide/simserver/write_simserver_init_file_m/","text":"write_simserver_init_file.m \u00b6 Basic Information \u00b6 USAGE: write_simserver_init_file PURPOSE: Write simserver current initialization file. (duplicates existing function in make_simserver_dat.m) Eg. ncoils: nc initial_coil_currents: i_coils initial_plasma_current: i_ip INPUTS: sim_init_filename: name of simserver initialization file nc: number of PF coils i_coils: coil currents (A) ## These are E-coil followed by F-coil currents (MA/turn, i.e. terminal currents). ## i_ip: Plasma current (A) OUTPUTS: ier: error flag","title":"write_simserver_init_file.m"},{"location":"function-guide/simserver/write_simserver_init_file_m/#write_simserver_init_filem","text":"","title":"write_simserver_init_file.m"},{"location":"function-guide/simserver/write_simserver_init_file_m/#basic-information","text":"USAGE: write_simserver_init_file PURPOSE: Write simserver current initialization file. (duplicates existing function in make_simserver_dat.m) Eg. ncoils: nc initial_coil_currents: i_coils initial_plasma_current: i_ip INPUTS: sim_init_filename: name of simserver initialization file nc: number of PF coils i_coils: coil currents (A) ## These are E-coil followed by F-coil currents (MA/turn, i.e. terminal currents). ## i_ip: Plasma current (A) OUTPUTS: ier: error flag","title":"Basic Information"},{"location":"function-guide/teq/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 TEQ-Related Matlab Functions and Scripts (matlab/teq) build_corsica_peq96 - Build Corsica/TEQ state space for control analysis sim_corsica_peq96 - Simulate linear evolution of OL/CL Corsica SS create_corsica_flat_files - Create flat files from corsica savefile read_corsica_data - read flat files into toksys equilibrium struct","title":"Contents.m"},{"location":"function-guide/teq/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/teq/Contents_m/#basic-information","text":"TEQ-Related Matlab Functions and Scripts (matlab/teq) build_corsica_peq96 - Build Corsica/TEQ state space for control analysis sim_corsica_peq96 - Simulate linear evolution of OL/CL Corsica SS create_corsica_flat_files - Create flat files from corsica savefile read_corsica_data - read flat files into toksys equilibrium struct","title":"Basic Information"},{"location":"function-guide/teq/create_corsica_flat_files_m/","text":"create_corsica_flat_files.m \u00b6 Basic Information \u00b6 USAGE: create_corsica_flat_files PURPOSE: Invoke caltrans and create flat files INPUTS: corsica_save_file, name of corsica save file OUTPUTS: RESTRICTIONS: METHOD: corsica is invoked with the name of the *.sav file as first argument and basis script [gatools_root '/matlab/teq/create_corsica_flat_files.bas'] as second.","title":"create_corsica_flat_files.m"},{"location":"function-guide/teq/create_corsica_flat_files_m/#create_corsica_flat_filesm","text":"","title":"create_corsica_flat_files.m"},{"location":"function-guide/teq/create_corsica_flat_files_m/#basic-information","text":"USAGE: create_corsica_flat_files PURPOSE: Invoke caltrans and create flat files INPUTS: corsica_save_file, name of corsica save file OUTPUTS: RESTRICTIONS: METHOD: corsica is invoked with the name of the *.sav file as first argument and basis script [gatools_root '/matlab/teq/create_corsica_flat_files.bas'] as second.","title":"Basic Information"},{"location":"function-guide/teq/read_corsica_data_m/","text":"read_corsica_data.m \u00b6 Basic Information \u00b6 USAGE: equil_data = read_corsica_data(dirname,tok_data_struct) PURPOSE: Read flat files made with create_corsica_flat_files.m (or .bas) INPUTS: dirname, the directory with all the flat files, such as: sys_dims.flat psi.flat cc.flat crj.flat, and many more... OR (for backwards compatibility) dirname can be a struct containing paths to sysdims.flat, psi.flat, cc.flat, crj.flat In this latter case only a subset of the outputs are returned tok_data_struct, standard toksys description of the tokamak tok_data_struct is used to make fcturn, turnfc, fcid, ecid Everything else comes from the corsica flat files in dirname. OUTPUTS: equil_data, a standard toksys equilibrium structure: cpasma: 'Plasma current [A]' jphi: 'Current density on grid [MA/m^2]' pcurrt: 'Current within rectangular grid elements [A]' psizr: 'Total flux on grid [Wb]' pres: 'Pressure at flux values [Pa]' pprime: 'pprime at flux values [Pa/(Wb/rad)]' fpol: 'fpol at flux values' fprime: 'fprime at flux values' ffprim: 'ffprim at flux values' qpsi: 'q at flux values' bzero: 'Vacuum toroidal field at rzero [T]' rzero: 'Reference point for bzero [m]' rmaxis: 'R of magnetic axis [m]' zmaxis: 'Z of magnetic axis [m]' psimag: 'Flux at magnetic axis [Wb]' psibry: 'Flux at boundary [Wb]' rcur: 'R of current centroid [m]' zcur: 'Z of current centroid [m]' nbbbs: 'Number of boundary points = length(rbbbs)' rbbbs: 'R of boundary points [m]' zbbbs: 'Z of boundary points [m]' xlim: 'R of limiter [m]' ylim: 'Z of limiter [m]' rxps: 'R of X points [m]' zxps: 'Z of X points [m]' psixps: 'Flux at X points [Wb]' cc: 'PF coil currents in MA-turns' cc2: 'PF coil currents in MA-turns' dr: 'Radial distance between grid points [m]' dz: 'Vertical distance between grid points [m]' rg: 'Radial coordinates of grid points [m]' zg: 'Vertical coordinates of grid points [m]' nw: 'Number of radial grid points [m]' nh: 'Number of vertical grid points [m]' fcturn: 'Number of turns in PF coils = tok_data_struct.fcnturn' turnfc: 'ones(nff,1) (nff derived from tok_data_struct)' fcid: '1:nff (nff derived from tok_data_struct)' ecid: 'tok_data_struct.ecdata(5,:)' RESTRICTIONS: METHOD: Reads flat files generated by create_corsica_flat_files.m This function converts units and saves to efit variable names tok_data_struct is needed to create fcturn, turnfc, ecid, fcid If only 4 flat files are available then the grid and limdata from tok_data_struct are used in findlcfs which derives psibry, psibnd.","title":"read_corsica_data.m"},{"location":"function-guide/teq/read_corsica_data_m/#read_corsica_datam","text":"","title":"read_corsica_data.m"},{"location":"function-guide/teq/read_corsica_data_m/#basic-information","text":"USAGE: equil_data = read_corsica_data(dirname,tok_data_struct) PURPOSE: Read flat files made with create_corsica_flat_files.m (or .bas) INPUTS: dirname, the directory with all the flat files, such as: sys_dims.flat psi.flat cc.flat crj.flat, and many more... OR (for backwards compatibility) dirname can be a struct containing paths to sysdims.flat, psi.flat, cc.flat, crj.flat In this latter case only a subset of the outputs are returned tok_data_struct, standard toksys description of the tokamak tok_data_struct is used to make fcturn, turnfc, fcid, ecid Everything else comes from the corsica flat files in dirname. OUTPUTS: equil_data, a standard toksys equilibrium structure: cpasma: 'Plasma current [A]' jphi: 'Current density on grid [MA/m^2]' pcurrt: 'Current within rectangular grid elements [A]' psizr: 'Total flux on grid [Wb]' pres: 'Pressure at flux values [Pa]' pprime: 'pprime at flux values [Pa/(Wb/rad)]' fpol: 'fpol at flux values' fprime: 'fprime at flux values' ffprim: 'ffprim at flux values' qpsi: 'q at flux values' bzero: 'Vacuum toroidal field at rzero [T]' rzero: 'Reference point for bzero [m]' rmaxis: 'R of magnetic axis [m]' zmaxis: 'Z of magnetic axis [m]' psimag: 'Flux at magnetic axis [Wb]' psibry: 'Flux at boundary [Wb]' rcur: 'R of current centroid [m]' zcur: 'Z of current centroid [m]' nbbbs: 'Number of boundary points = length(rbbbs)' rbbbs: 'R of boundary points [m]' zbbbs: 'Z of boundary points [m]' xlim: 'R of limiter [m]' ylim: 'Z of limiter [m]' rxps: 'R of X points [m]' zxps: 'Z of X points [m]' psixps: 'Flux at X points [Wb]' cc: 'PF coil currents in MA-turns' cc2: 'PF coil currents in MA-turns' dr: 'Radial distance between grid points [m]' dz: 'Vertical distance between grid points [m]' rg: 'Radial coordinates of grid points [m]' zg: 'Vertical coordinates of grid points [m]' nw: 'Number of radial grid points [m]' nh: 'Number of vertical grid points [m]' fcturn: 'Number of turns in PF coils = tok_data_struct.fcnturn' turnfc: 'ones(nff,1) (nff derived from tok_data_struct)' fcid: '1:nff (nff derived from tok_data_struct)' ecid: 'tok_data_struct.ecdata(5,:)' RESTRICTIONS: METHOD: Reads flat files generated by create_corsica_flat_files.m This function converts units and saves to efit variable names tok_data_struct is needed to create fcturn, turnfc, ecid, fcid If only 4 flat files are available then the grid and limdata from tok_data_struct are used in findlcfs which derives psibry, psibnd.","title":"Basic Information"},{"location":"function-guide/teq/read_corsica_flat_files_m/","text":"read_corsica_flat_files.m \u00b6 Basic Information \u00b6 USAGE: equil_data = read_corsica_flat_files(dirname) PURPOSE: Read flat files made with create_corsica_flat_files.m (or .bas) INPUTS: dirname, the directory with all the flat files, such as: sys_dims.flat psi.flat cc.flat crj.flat, etc... OUTPUTS: Standard toksys equilibrium structure: cpasma: 'Plasma current [A]' jphi: 'Current density on grid [MA/m^2]' psizr: 'Total flux on grid [Wb]' pres: 'Pressure at flux values [Pa]' pprime: 'pprime at flux values [Pa/(Wb/rad)]' fpol: 'fpol at flux values' fprime: 'fprime at flux values' ffprim: 'ffprim at flux values' qpsi: 'q at flux values' bzero: 'Vacuum toroidal field at rzero [T]' rzero: 'Reference point for bzero [m]' rmaxis: 'R of magnetic axis [m]' zmaxis: 'Z of magnetic axis [m]' psimag: 'Flux at magnetic axis [Wb]' psibry: 'Flux at boundary [Wb]' rcur: 'R of current centroid [m]' zcur: 'Z of current centroid [m]' nbbbs: 'Number of boundary points = length(rbbbs)' rbbbs: 'R of boundary points [m]' zbbbs: 'Z of boundary points [m]' xlim: 'R of limiter [m]' ylim: 'Z of limiter [m]' rxps: 'R of X points [m]' zxps: 'Z of X points [m]' psixps: 'Flux at X points [Wb]' cc: 'PF coil currents in MA-turns' dr: 'Radial distance between grid points [m]' dz: 'Vertical distance between grid points [m]' rg: 'Radial coordinates of grid points [m]' zg: 'Vertical coordinates of grid points [m]' RESTRICTIONS: METHOD: Reads flat files generated by create_corsica_flat_files.m This function converts units and saves to efit variable names","title":"read_corsica_flat_files.m"},{"location":"function-guide/teq/read_corsica_flat_files_m/#read_corsica_flat_filesm","text":"","title":"read_corsica_flat_files.m"},{"location":"function-guide/teq/read_corsica_flat_files_m/#basic-information","text":"USAGE: equil_data = read_corsica_flat_files(dirname) PURPOSE: Read flat files made with create_corsica_flat_files.m (or .bas) INPUTS: dirname, the directory with all the flat files, such as: sys_dims.flat psi.flat cc.flat crj.flat, etc... OUTPUTS: Standard toksys equilibrium structure: cpasma: 'Plasma current [A]' jphi: 'Current density on grid [MA/m^2]' psizr: 'Total flux on grid [Wb]' pres: 'Pressure at flux values [Pa]' pprime: 'pprime at flux values [Pa/(Wb/rad)]' fpol: 'fpol at flux values' fprime: 'fprime at flux values' ffprim: 'ffprim at flux values' qpsi: 'q at flux values' bzero: 'Vacuum toroidal field at rzero [T]' rzero: 'Reference point for bzero [m]' rmaxis: 'R of magnetic axis [m]' zmaxis: 'Z of magnetic axis [m]' psimag: 'Flux at magnetic axis [Wb]' psibry: 'Flux at boundary [Wb]' rcur: 'R of current centroid [m]' zcur: 'Z of current centroid [m]' nbbbs: 'Number of boundary points = length(rbbbs)' rbbbs: 'R of boundary points [m]' zbbbs: 'Z of boundary points [m]' xlim: 'R of limiter [m]' ylim: 'Z of limiter [m]' rxps: 'R of X points [m]' zxps: 'Z of X points [m]' psixps: 'Flux at X points [Wb]' cc: 'PF coil currents in MA-turns' dr: 'Radial distance between grid points [m]' dz: 'Vertical distance between grid points [m]' rg: 'Radial coordinates of grid points [m]' zg: 'Vertical coordinates of grid points [m]' RESTRICTIONS: METHOD: Reads flat files generated by create_corsica_flat_files.m This function converts units and saves to efit variable names","title":"Basic Information"},{"location":"function-guide/tok_models/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Tokamak System Modeling Tools (Humphreys) build_model - build_tokamak_system - Function to build state space for control design and analysis. Calculates vertical growth rates along the way. Note that build_tok_sys is intended to be called by a machine-specific script like build_east_sys.m calc_ssop_from_I - Compute steady-state operating point (ynom,Inom,Vnom) cc_efit_to_tok - convert EFIT conductor currents to toksys change_tokobj_units - modify units of vacuum data objects in tok_data_struct gbr2p_x_vec - multiply compressed object gbr2p by a vector get_signals - Fetch signals in \"output_signals\" field of system model struct lim2vv - Construct a vacuum vessel model from limiter surface specification makelpcur - make elliptical cross-section, flat to parabolic plasma current distr. defined on standard EPGenv grid. make_out_objs - make_tok_objects - Function to calculate all Green functions and other data objects needed for build_tokamak_system.m. Note that make_tok_objects is intended to be called by a machine-specific script like make_east_objects.m mpp_x_vec - multiply compressed object mpp or gbz2p by a vector plasma_output - plasma_output2 - plasma_out_common - common code for both plasma_output, plasma_output2 proj_turn - Make proj. vector/matrix for coil connections and turn specs. rzrig - creates plasma rigid model response objects scale_equil_response- scale plasma response model with equilibrium Ip load_tok_objects - Load vacuum data objects for selected device configuration plot_tok_geo_config - call plot_tok_geo for multiple vacuum data objects gspert - return linear plasma response gseq - return an equilibrium, given the conductor currents and pprime, ffprim gsevolve - like gseq but also returns time derivatives","title":"Contents.m"},{"location":"function-guide/tok_models/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/tok_models/Contents_m/#basic-information","text":"Tokamak System Modeling Tools (Humphreys) build_model - build_tokamak_system - Function to build state space for control design and analysis. Calculates vertical growth rates along the way. Note that build_tok_sys is intended to be called by a machine-specific script like build_east_sys.m calc_ssop_from_I - Compute steady-state operating point (ynom,Inom,Vnom) cc_efit_to_tok - convert EFIT conductor currents to toksys change_tokobj_units - modify units of vacuum data objects in tok_data_struct gbr2p_x_vec - multiply compressed object gbr2p by a vector get_signals - Fetch signals in \"output_signals\" field of system model struct lim2vv - Construct a vacuum vessel model from limiter surface specification makelpcur - make elliptical cross-section, flat to parabolic plasma current distr. defined on standard EPGenv grid. make_out_objs - make_tok_objects - Function to calculate all Green functions and other data objects needed for build_tokamak_system.m. Note that make_tok_objects is intended to be called by a machine-specific script like make_east_objects.m mpp_x_vec - multiply compressed object mpp or gbz2p by a vector plasma_output - plasma_output2 - plasma_out_common - common code for both plasma_output, plasma_output2 proj_turn - Make proj. vector/matrix for coil connections and turn specs. rzrig - creates plasma rigid model response objects scale_equil_response- scale plasma response model with equilibrium Ip load_tok_objects - Load vacuum data objects for selected device configuration plot_tok_geo_config - call plot_tok_geo for multiple vacuum data objects gspert - return linear plasma response gseq - return an equilibrium, given the conductor currents and pprime, ffprim gsevolve - like gseq but also returns time derivatives","title":"Basic Information"},{"location":"function-guide/tok_models/build_model_m/","text":"build_model.m \u00b6 Basic Information \u00b6 SYNTAX: build_model PURPOSE: Generate data objects which can be used to construct complete system model, based on linearized plasma response. INPUT: shot = shot number tmodel = time to derive model from (in ms) tokamak = name of device to build model for tok_data_struct = vacuum data objects for this device output_irzresp = irzresp for output equation object generation eqdir = directory where efit equilibrium files are located efit_source = tree in mdsplus to get equilibrium from (only one of either eqdir or efit_source should be specified) outflag = flag to determine what output files to produce 0 = none 1 = run plasma_output, save results 2 = run plasma_output2, save results 3 = run both plasma_output, plasma_output2 - save (default) Rp = plasma resistance (only needed if outflag>0) OUTPUT: files = drzdi_<shot>_<tmodel>.mat out_objs_<shot>_<tmodel>.mat out2_objs_<shot>_<tmodel>.mat","title":"build_model.m"},{"location":"function-guide/tok_models/build_model_m/#build_modelm","text":"","title":"build_model.m"},{"location":"function-guide/tok_models/build_model_m/#basic-information","text":"SYNTAX: build_model PURPOSE: Generate data objects which can be used to construct complete system model, based on linearized plasma response. INPUT: shot = shot number tmodel = time to derive model from (in ms) tokamak = name of device to build model for tok_data_struct = vacuum data objects for this device output_irzresp = irzresp for output equation object generation eqdir = directory where efit equilibrium files are located efit_source = tree in mdsplus to get equilibrium from (only one of either eqdir or efit_source should be specified) outflag = flag to determine what output files to produce 0 = none 1 = run plasma_output, save results 2 = run plasma_output2, save results 3 = run both plasma_output, plasma_output2 - save (default) Rp = plasma resistance (only needed if outflag>0) OUTPUT: files = drzdi_<shot>_<tmodel>.mat out_objs_<shot>_<tmodel>.mat out2_objs_<shot>_<tmodel>.mat","title":"Basic Information"},{"location":"function-guide/tok_models/build_tokamak_system_m/","text":"build_tokamak_system.m \u00b6 Basic Information \u00b6 USAGE: tok_system= build_tokamak_system(build_inputs) PURPOSE: Generic script to build tokamak axisymmetric system from pre-calculated objects. Includes R,Z,Ip response in system. INPUTS: (in build_inputs structure) tokamak = name of tokamak system to construct (required) vacuum_objs = structure containing device model objects (required) cccirc = connection vector for CC's netlist = network connection description (Only one of cccirc or netlist can be input. If neither is input, default connections are used.) efit_gfile = equilibrium gfile to read (not required if ichooseq=0) ichooseq= equilibrium file type: 0 = vacuum model (no equilibrium data required) 1 = efit_gfile 2 = corsica generated flat files 3 = saved corsica equilibrium 4 = TokSys equilibrium data structure corsica_inputs = name of directory containing corsica input (flat) files (required only if ichooseq=2) corsica_savefile = name of saved corsica equilibrium (required only if ichooseq=3) equil_data = name of TokSys format equilibrium data structure (required only if ichooseq=4) irzresp_dynamic, irzresp_output = flags determining plasma contribution to dynamic (state) and output equations (default = 3 for both): 0 = motionless plasma 1 = rigid R motion 2 = rigid Z 3 = both R and Z rigid motions 4 = nonrigid plasma response based on vst in corsica 5 = gspert, (perturbed grad-shafronv equation plasma response) OPTIONAL INPUTS: vvgroup = vacuum vessel grouping vector: length = all vessel elements set element value = k to belong to group k, 0 to not include (default= [1:total # elements]) vvcirc = circuit connection vector for vac. vessel(default=all independent) iplcirc = flag to select inclusion of plasma circuit in state space(1) or not(0) (optional, default = 1 if ichooseq>0) Rp = (optional) user override of computed plasma resistance Rext = extra circuit resistance to add to each coil and vessel element can be either length=#coils or #coils + #vessel (default=0) Lext = extra circuit inductance to add to each coil/vessel can be either length=#coils or #coils + #vessel (default=0) replace_Rext= if 1, instead of adding Rext, replace the computed coil/vessel resistance with Rext (default=0) cc_file = file containing coil currents (optional, usually given by efit) idx_efit_to_tok = optional map of efit indices to toksys indices, s.t. if I=currents in efit order, then I(idx_efit_to_tok)=currents in toksys order scldzdis = To increase gamma when irzresp_dynamic=irzresp_output=4, make scldzdis<1.0. (optional, default=1) tok_geo_plot_fn = one of 'generic', 'plot_east_geo', 'plot_kstar_geo', etc. (optional, default = '' or 'none' => no plots) Te_res = plasma electron temp for plasma resistance calc [eV] (optional, default = 4000eV) li_res = plasma internal inductance for resistance calculation (optional,default = 0.5) Zeff_res = Zeff for resistance calc (optional, default = 1.5) scale_R_scpf = scale factor to multiply resistance of superconducting PF coils, scalar or vector of length = number of coils (optional, default = 1 applied to ALL coils) netlist_currents = array of strings defining branches for which to output currents (optional, default = no current outputs, not used if cccirc used for circuit connectivity) netlist_voltages = n x 2 matrix, each row containing node numbers [N1 N2], with voltage output defined as V(N1)-V(N2) (optional, default = no voltage outputs, not used if cccirc used for circuit connectivity) gspert_options = options for gspert calculation (only used if irzresp values=5) iwait = (optional) flag: 1=wait when error messages, 0(default)=no wait verbose = level of screen output. Allowed values are: 0 = no messages or uncritical warnings (default) 1 = display warnings 2 = display warnings and other messages OUTPUTS: tok_system = structure containing model of tokamak system RESTRICTIONS: Must have specified objects files in specified path. Dimensions of equilibrium objects much match electromagnetic system dimensions (eg grid rg,zg must match crj dimensions). METHOD: Loads and defines objects needed for control analysis/design. cccirc uses Corsica connection vector convention: vector of indices identifying which circuit each coil belongs to (\"index\" is negative to denote antiseries...). So eg [1 2 3 1 -2 -3] means coil 1 is series'd with coil 4, coil 2 is antiseries'd with coil 5, coil 3 is antiseriesd with coil 6, and there are 3 total circuits in the final connected system.","title":"build_tokamak_system.m"},{"location":"function-guide/tok_models/build_tokamak_system_m/#build_tokamak_systemm","text":"","title":"build_tokamak_system.m"},{"location":"function-guide/tok_models/build_tokamak_system_m/#basic-information","text":"USAGE: tok_system= build_tokamak_system(build_inputs) PURPOSE: Generic script to build tokamak axisymmetric system from pre-calculated objects. Includes R,Z,Ip response in system. INPUTS: (in build_inputs structure) tokamak = name of tokamak system to construct (required) vacuum_objs = structure containing device model objects (required) cccirc = connection vector for CC's netlist = network connection description (Only one of cccirc or netlist can be input. If neither is input, default connections are used.) efit_gfile = equilibrium gfile to read (not required if ichooseq=0) ichooseq= equilibrium file type: 0 = vacuum model (no equilibrium data required) 1 = efit_gfile 2 = corsica generated flat files 3 = saved corsica equilibrium 4 = TokSys equilibrium data structure corsica_inputs = name of directory containing corsica input (flat) files (required only if ichooseq=2) corsica_savefile = name of saved corsica equilibrium (required only if ichooseq=3) equil_data = name of TokSys format equilibrium data structure (required only if ichooseq=4) irzresp_dynamic, irzresp_output = flags determining plasma contribution to dynamic (state) and output equations (default = 3 for both): 0 = motionless plasma 1 = rigid R motion 2 = rigid Z 3 = both R and Z rigid motions 4 = nonrigid plasma response based on vst in corsica 5 = gspert, (perturbed grad-shafronv equation plasma response) OPTIONAL INPUTS: vvgroup = vacuum vessel grouping vector: length = all vessel elements set element value = k to belong to group k, 0 to not include (default= [1:total # elements]) vvcirc = circuit connection vector for vac. vessel(default=all independent) iplcirc = flag to select inclusion of plasma circuit in state space(1) or not(0) (optional, default = 1 if ichooseq>0) Rp = (optional) user override of computed plasma resistance Rext = extra circuit resistance to add to each coil and vessel element can be either length=#coils or #coils + #vessel (default=0) Lext = extra circuit inductance to add to each coil/vessel can be either length=#coils or #coils + #vessel (default=0) replace_Rext= if 1, instead of adding Rext, replace the computed coil/vessel resistance with Rext (default=0) cc_file = file containing coil currents (optional, usually given by efit) idx_efit_to_tok = optional map of efit indices to toksys indices, s.t. if I=currents in efit order, then I(idx_efit_to_tok)=currents in toksys order scldzdis = To increase gamma when irzresp_dynamic=irzresp_output=4, make scldzdis<1.0. (optional, default=1) tok_geo_plot_fn = one of 'generic', 'plot_east_geo', 'plot_kstar_geo', etc. (optional, default = '' or 'none' => no plots) Te_res = plasma electron temp for plasma resistance calc [eV] (optional, default = 4000eV) li_res = plasma internal inductance for resistance calculation (optional,default = 0.5) Zeff_res = Zeff for resistance calc (optional, default = 1.5) scale_R_scpf = scale factor to multiply resistance of superconducting PF coils, scalar or vector of length = number of coils (optional, default = 1 applied to ALL coils) netlist_currents = array of strings defining branches for which to output currents (optional, default = no current outputs, not used if cccirc used for circuit connectivity) netlist_voltages = n x 2 matrix, each row containing node numbers [N1 N2], with voltage output defined as V(N1)-V(N2) (optional, default = no voltage outputs, not used if cccirc used for circuit connectivity) gspert_options = options for gspert calculation (only used if irzresp values=5) iwait = (optional) flag: 1=wait when error messages, 0(default)=no wait verbose = level of screen output. Allowed values are: 0 = no messages or uncritical warnings (default) 1 = display warnings 2 = display warnings and other messages OUTPUTS: tok_system = structure containing model of tokamak system RESTRICTIONS: Must have specified objects files in specified path. Dimensions of equilibrium objects much match electromagnetic system dimensions (eg grid rg,zg must match crj dimensions). METHOD: Loads and defines objects needed for control analysis/design. cccirc uses Corsica connection vector convention: vector of indices identifying which circuit each coil belongs to (\"index\" is negative to denote antiseries...). So eg [1 2 3 1 -2 -3] means coil 1 is series'd with coil 4, coil 2 is antiseries'd with coil 5, coil 3 is antiseriesd with coil 6, and there are 3 total circuits in the final connected system.","title":"Basic Information"},{"location":"function-guide/tok_models/calc_Iq_m/","text":"calc_Iq.m \u00b6 Basic Information \u00b6 USAGE: [Iqresp,Iq,eqx] = calc_Iq(q,tok_data_struct,eq,options) PURPOSE: Calculate amount of current within q-surfaces and responses thereof INPUTS: q: q-values for surfaces tok_data_struct: toksys description of tokamak eq: equilibrium structure options (optional), do help gspert for description OUTPUTS: Iqresp: response structure with fields: dIqdis: response of current inside q to conductor currents dIqdip,*dli,*dbphi, etc: exogenous responses Iq: current within q-contours eqx: extra equilibrium information, help gspert for description","title":"calc_Iq.m"},{"location":"function-guide/tok_models/calc_Iq_m/#calc_iqm","text":"","title":"calc_Iq.m"},{"location":"function-guide/tok_models/calc_Iq_m/#basic-information","text":"USAGE: [Iqresp,Iq,eqx] = calc_Iq(q,tok_data_struct,eq,options) PURPOSE: Calculate amount of current within q-surfaces and responses thereof INPUTS: q: q-values for surfaces tok_data_struct: toksys description of tokamak eq: equilibrium structure options (optional), do help gspert for description OUTPUTS: Iqresp: response structure with fields: dIqdis: response of current inside q to conductor currents dIqdip,*dli,*dbphi, etc: exogenous responses Iq: current within q-contours eqx: extra equilibrium information, help gspert for description","title":"Basic Information"},{"location":"function-guide/tok_models/calc_fluxexp_m/","text":"calc_fluxexp.m \u00b6 Basic Information \u00b6 USAGE: fluxexp = calc_fluxexp(eq, r, z) [fluxexp, r2, d2] = calc_fluxexp(eq, r, z, d) PURPOSE: Calculate flux expansion at points r,z for equilibrium eq INPUTS: eq, TokSys description of an equilibrium containing fields: rg, zg = grid coordinates psizr = flux at points rg, zg rbbbs, zbbbs, nbbbs = nbbbs plasma boundary coordinates psibry = boundary flux r,z, coordinates of points where flux expansion is calculated d, distance in outboard midplane to outside boundary (default 0) OUTPUTS: fluxexp, if d==0,flux expansion = abs(pr)./sqrt(yr.^2+yz.^2) where pr = d(psi)/dR at maximum major radius for the boundary and sqrt(yr.^2+yz.^2) is magnitude of flux gradient at points r,z if d > 0, fluxexp = D/d, where D is perpendicular distance from r,z to point r2, z2 with same flux difference as distance d in midplane","title":"calc_fluxexp.m"},{"location":"function-guide/tok_models/calc_fluxexp_m/#calc_fluxexpm","text":"","title":"calc_fluxexp.m"},{"location":"function-guide/tok_models/calc_fluxexp_m/#basic-information","text":"USAGE: fluxexp = calc_fluxexp(eq, r, z) [fluxexp, r2, d2] = calc_fluxexp(eq, r, z, d) PURPOSE: Calculate flux expansion at points r,z for equilibrium eq INPUTS: eq, TokSys description of an equilibrium containing fields: rg, zg = grid coordinates psizr = flux at points rg, zg rbbbs, zbbbs, nbbbs = nbbbs plasma boundary coordinates psibry = boundary flux r,z, coordinates of points where flux expansion is calculated d, distance in outboard midplane to outside boundary (default 0) OUTPUTS: fluxexp, if d==0,flux expansion = abs(pr)./sqrt(yr.^2+yz.^2) where pr = d(psi)/dR at maximum major radius for the boundary and sqrt(yr.^2+yz.^2) is magnitude of flux gradient at points r,z if d > 0, fluxexp = D/d, where D is perpendicular distance from r,z to point r2, z2 with same flux difference as distance d in midplane","title":"Basic Information"},{"location":"function-guide/tok_models/calc_gaps_m/","text":"calc_gaps.m \u00b6 Basic Information \u00b6 USAGE: [gapresp,gaps,gapspec] = calc_gaps(gapspec,tok_data_struct,resp,eq,idoplot) PURPOSE: Calculate gaps and responses thereof at specified locations A gap is defined as the distance between the plasma boundary and the wall along a line through a specified \"gap location\", with direction of measurement defined by gradient of flux for a nominal equilibrium at that prescribed \"gap location\". (This nominal equilibrium is also used to generate the linearized plasma response model.) INPUTS: gapspec: gap specification on the form [r z gr gz] r,z is gap location and gr,gz nominal gradient If nominal gradient is 0,0 then it is taken from eq This creates a gapspec with eq as nominal equilibrium If gapspec is empty, a default inner, upper, outer, lower gap are set tok_data_struct: toksys description of tokamak resp: (optional) the output from a response model (gspert or rzrig) eq: equilibrium structure idoplot: flag to plot limiter, boundary, gap location, and gap vector OUTPUTS: gapresp: response structure with fields: dgapdis: gap response to conductors [m/A] dgapdip,*dli,*dbetap, etc: exogenous responses gaps: distances from boundary to wall through r,z along gr,gz [m] gapspec: Complete gap specification on form [r z gr gz].","title":"calc_gaps.m"},{"location":"function-guide/tok_models/calc_gaps_m/#calc_gapsm","text":"","title":"calc_gaps.m"},{"location":"function-guide/tok_models/calc_gaps_m/#basic-information","text":"USAGE: [gapresp,gaps,gapspec] = calc_gaps(gapspec,tok_data_struct,resp,eq,idoplot) PURPOSE: Calculate gaps and responses thereof at specified locations A gap is defined as the distance between the plasma boundary and the wall along a line through a specified \"gap location\", with direction of measurement defined by gradient of flux for a nominal equilibrium at that prescribed \"gap location\". (This nominal equilibrium is also used to generate the linearized plasma response model.) INPUTS: gapspec: gap specification on the form [r z gr gz] r,z is gap location and gr,gz nominal gradient If nominal gradient is 0,0 then it is taken from eq This creates a gapspec with eq as nominal equilibrium If gapspec is empty, a default inner, upper, outer, lower gap are set tok_data_struct: toksys description of tokamak resp: (optional) the output from a response model (gspert or rzrig) eq: equilibrium structure idoplot: flag to plot limiter, boundary, gap location, and gap vector OUTPUTS: gapresp: response structure with fields: dgapdis: gap response to conductors [m/A] dgapdip,*dli,*dbetap, etc: exogenous responses gaps: distances from boundary to wall through r,z along gr,gz [m] gapspec: Complete gap specification on form [r z gr gz].","title":"Basic Information"},{"location":"function-guide/tok_models/calc_iso_m/","text":"calc_iso.m \u00b6 Basic Information \u00b6 USAGE: [isoresp,iso] = calc_iso(rziso,tok_data_struct,resp,eq) PURPOSE: Calculate flux, field and responses thereof at isoflux points INPUTS: rziso: R, Z of isoflux points arranged as [R(:) Z(:)] (unit: meters) tok_data_struct: toksys description of tokamak resp (optional): the output from a response model (gspert or rzrig) eq (optional): either equilibrium with field psizr or psizr itself OUTPUTS: isoresp: response structure with fields: dpsidis: flux response to conductors [Wb/A] dpsidip,*dli,*dbetap, etc: exogenous responses dbrdis, dbzdis: Br, Bz responses to conductors [T/A] dbrdip,dbzdip, etc: exogenous Br, Bz responses iso: equilibrium structure with fields: psi: flux at rziso points br, bz: Br, Bz at rziso points RESTRICTIONS: rziso must be within the grid","title":"calc_iso.m"},{"location":"function-guide/tok_models/calc_iso_m/#calc_isom","text":"","title":"calc_iso.m"},{"location":"function-guide/tok_models/calc_iso_m/#basic-information","text":"USAGE: [isoresp,iso] = calc_iso(rziso,tok_data_struct,resp,eq) PURPOSE: Calculate flux, field and responses thereof at isoflux points INPUTS: rziso: R, Z of isoflux points arranged as [R(:) Z(:)] (unit: meters) tok_data_struct: toksys description of tokamak resp (optional): the output from a response model (gspert or rzrig) eq (optional): either equilibrium with field psizr or psizr itself OUTPUTS: isoresp: response structure with fields: dpsidis: flux response to conductors [Wb/A] dpsidip,*dli,*dbetap, etc: exogenous responses dbrdis, dbzdis: Br, Bz responses to conductors [T/A] dbrdip,dbzdip, etc: exogenous Br, Bz responses iso: equilibrium structure with fields: psi: flux at rziso points br, bz: Br, Bz at rziso points RESTRICTIONS: rziso must be within the grid","title":"Basic Information"},{"location":"function-guide/tok_models/calc_ndecay_m/","text":"calc_ndecay.m \u00b6 Basic Information \u00b6 SYNTAX: ndecay = calc_ndecay(psivac,rg,zg,r0,z0,rdec,zdec); PURPOSE: Calculate decay index at point (or vector of points) from vacuum flux on grid. INPUTS: psivac = flux on grid (either vector or nz x nr array) (Wb) rg = grid radial position vector [m] zg = grid vertical position vector [m] r0 = radial position of reference point for Bz0 (scalar) [m] z0 = vertical position of reference point for Bz0 (scalar) [m] rdec = radial position(s) to calc decay index at (scalar/vector) [m] zdec = vertical position(s) to calc decay index at (scalar/vector) [m] OUTPUTS: ndecay = decay index (indices if rdec, zdec are vectors) RESTRICTIONS: r0,z0 must be scalar. rdec,zdec can be vectors. If only r0,z0 are given (no rdec,zdec), will use that point as both Bz0 reference and location to calculate ndecay. But if rdec,zdec are given as well, r0,z0 will be location of Bz0 reference, and rdec,zdec will be location(s) at which to calc ndecay. METHOD: see rzrig.m, calc_decind_victor.m","title":"calc_ndecay.m"},{"location":"function-guide/tok_models/calc_ndecay_m/#calc_ndecaym","text":"","title":"calc_ndecay.m"},{"location":"function-guide/tok_models/calc_ndecay_m/#basic-information","text":"SYNTAX: ndecay = calc_ndecay(psivac,rg,zg,r0,z0,rdec,zdec); PURPOSE: Calculate decay index at point (or vector of points) from vacuum flux on grid. INPUTS: psivac = flux on grid (either vector or nz x nr array) (Wb) rg = grid radial position vector [m] zg = grid vertical position vector [m] r0 = radial position of reference point for Bz0 (scalar) [m] z0 = vertical position of reference point for Bz0 (scalar) [m] rdec = radial position(s) to calc decay index at (scalar/vector) [m] zdec = vertical position(s) to calc decay index at (scalar/vector) [m] OUTPUTS: ndecay = decay index (indices if rdec, zdec are vectors) RESTRICTIONS: r0,z0 must be scalar. rdec,zdec can be vectors. If only r0,z0 are given (no rdec,zdec), will use that point as both Bz0 reference and location to calculate ndecay. But if rdec,zdec are given as well, r0,z0 will be location of Bz0 reference, and rdec,zdec will be location(s) at which to calc ndecay. METHOD: see rzrig.m, calc_decind_victor.m","title":"Basic Information"},{"location":"function-guide/tok_models/calc_ssop_from_I_m/","text":"calc_ssop_from_I.m \u00b6 Basic Information \u00b6 SYNTAX: ssop = calc_ssop_from_I(tok_system,ssop_inputs) PURPOSE: Compute steady-state operating point (ynom,Inom,Vnom), where Inom contains closest approximation to Icnom consistent with being a valid steady- state operating point. Values of ynom are always nonzero when default values of zero nominal currents are used. INPUT: tok_system = tokamak system model, as constructed by build_tokamak_system ssop_inputs = structure containing all optional inputs: Icnom = vector of PF coil currents defining center of coordinates for model. To use plasma equilibrium currents, let Icnom = Pcc*Ieq(1:ncx) (optional, default = all 0) Ipnom = value of plasma current defining center of coordinates for model (optional, default = 0). Nonzero value should be used only if non-ohmic drive is available to hold plasma current = Ipnom in steady-state. OUTPUT: ssop = steady state operating point, containing: ynom = nominal values for outputs y Inom = vector of nominal coil, vessel, and plasma currents (coil currents in Inom are best match to Icnom that is consistent with steady-state gain) Vnom = vector of voltages that produce coil currents in Inom vector Inomstates = vector of nominal coil, vessel, and plasma current states RESTRICTIONS: Only works right now for outputs that are modeled as linear relative to a plasma equilibrium. METHOD: See Prop. 3 of Walker & Humphreys, Valid Coordinate Systems for Linearized Plasma Shape Response Models in Tokamaks (where it is shown that the only valid choice for nominal vessel currents is 0). The Icnom vector is projected onto the range of the steady-state gain to compute Inom; the pseudo-inverse of steady-state gain is applied to compute Vnom (this is true inverse for vectors in range of steady-state gain).","title":"calc_ssop_from_I.m"},{"location":"function-guide/tok_models/calc_ssop_from_I_m/#calc_ssop_from_im","text":"","title":"calc_ssop_from_I.m"},{"location":"function-guide/tok_models/calc_ssop_from_I_m/#basic-information","text":"SYNTAX: ssop = calc_ssop_from_I(tok_system,ssop_inputs) PURPOSE: Compute steady-state operating point (ynom,Inom,Vnom), where Inom contains closest approximation to Icnom consistent with being a valid steady- state operating point. Values of ynom are always nonzero when default values of zero nominal currents are used. INPUT: tok_system = tokamak system model, as constructed by build_tokamak_system ssop_inputs = structure containing all optional inputs: Icnom = vector of PF coil currents defining center of coordinates for model. To use plasma equilibrium currents, let Icnom = Pcc*Ieq(1:ncx) (optional, default = all 0) Ipnom = value of plasma current defining center of coordinates for model (optional, default = 0). Nonzero value should be used only if non-ohmic drive is available to hold plasma current = Ipnom in steady-state. OUTPUT: ssop = steady state operating point, containing: ynom = nominal values for outputs y Inom = vector of nominal coil, vessel, and plasma currents (coil currents in Inom are best match to Icnom that is consistent with steady-state gain) Vnom = vector of voltages that produce coil currents in Inom vector Inomstates = vector of nominal coil, vessel, and plasma current states RESTRICTIONS: Only works right now for outputs that are modeled as linear relative to a plasma equilibrium. METHOD: See Prop. 3 of Walker & Humphreys, Valid Coordinate Systems for Linearized Plasma Shape Response Models in Tokamaks (where it is shown that the only valid choice for nominal vessel currents is 0). The Icnom vector is projected onto the range of the steady-state gain to compute Inom; the pseudo-inverse of steady-state gain is applied to compute Vnom (this is true inverse for vectors in range of steady-state gain).","title":"Basic Information"},{"location":"function-guide/tok_models/calc_taupen_m/","text":"calc_taupen.m \u00b6 Basic Information \u00b6 USAGE: >> taupen = calc_taupen(tok_data_struct,ipf,Rmeas,Zmeas,options); PURPOSE: Function to calculate pentration time for generic tokamak by driving PF coils with step CURRENT to produce VV currents and calculate field at meas point INPUTS: tok_data_struct = standard TokSys vacuum objects structure ipf = index of PF coil to drive and calculate measurement time Rmeas,Zmeas = R,Z values at which to measure penetration [m] options.iplot = (optional) flag to enable plotting of time history for estimation of penetration time for PF ipf at (Rmeas,Zmeas). Default = 1 options.Gpc = (optional) Green function object desired for penetration time estimation. Must be a PF-coil-to-grid object. Default = mpc options.Gpv = (optional) Green function object desired for penetration time estimation. Must be a VV-element-to-grid object. Default = mpv options.taupf = (optional) time constant for PF current rise [s] Default = 1e-3. options.tmax = (optional) max time for evolution [s]. Default = 50e-3 options.nt = (optional) # of time points in evolution. Default = calculated on basis of taupf and tmax: nt = 10*(tmax/taupf) options.resv_fix = (optional) modified resv vector to use for calculation. Default = resv from tok_data_struct. OUTPUTS: taupen = estimated penetration time for ipf and Rmeas,Zmeas outputs = structure with other useful quantities (Plots showing fit, if iplot=1) RESTRICTIONS: METHOD: Run lsim for step CURRENT applied to PF coil ipf, generate field history at (Rmeas,Zmeas) measurement point with field type specified by options.Gpc, Gpv, fit result to exponential rise to extract approx single time constant taupen. Fit only to early time corre. to one e-folding (if were pure single-tau exponential) to extract effective single time constant for dominant rise time... Remove all other PF coils from problem, so they're not doing any shielding. USE EXAMPLE: >> tok_data_struct = load_tok_objects('kstar','2010','6565'); >> resv_fix = tok_data_struct.resv; >> resv_fix(71:end) = resv_fix(71:end)*1000; kill all but VV walls >> options.resv_fix = resv_fix; >> taupfs = zeros(14,1); just SC PF's >> for ii=1:14 >> [taupen,ymeas,t] = calc_taupen(tok_data_struct,ii,1.8,0,options); >> taupfs(ii)=taupen; >> end","title":"calc_taupen.m"},{"location":"function-guide/tok_models/calc_taupen_m/#calc_taupenm","text":"","title":"calc_taupen.m"},{"location":"function-guide/tok_models/calc_taupen_m/#basic-information","text":"USAGE: >> taupen = calc_taupen(tok_data_struct,ipf,Rmeas,Zmeas,options); PURPOSE: Function to calculate pentration time for generic tokamak by driving PF coils with step CURRENT to produce VV currents and calculate field at meas point INPUTS: tok_data_struct = standard TokSys vacuum objects structure ipf = index of PF coil to drive and calculate measurement time Rmeas,Zmeas = R,Z values at which to measure penetration [m] options.iplot = (optional) flag to enable plotting of time history for estimation of penetration time for PF ipf at (Rmeas,Zmeas). Default = 1 options.Gpc = (optional) Green function object desired for penetration time estimation. Must be a PF-coil-to-grid object. Default = mpc options.Gpv = (optional) Green function object desired for penetration time estimation. Must be a VV-element-to-grid object. Default = mpv options.taupf = (optional) time constant for PF current rise [s] Default = 1e-3. options.tmax = (optional) max time for evolution [s]. Default = 50e-3 options.nt = (optional) # of time points in evolution. Default = calculated on basis of taupf and tmax: nt = 10*(tmax/taupf) options.resv_fix = (optional) modified resv vector to use for calculation. Default = resv from tok_data_struct. OUTPUTS: taupen = estimated penetration time for ipf and Rmeas,Zmeas outputs = structure with other useful quantities (Plots showing fit, if iplot=1) RESTRICTIONS: METHOD: Run lsim for step CURRENT applied to PF coil ipf, generate field history at (Rmeas,Zmeas) measurement point with field type specified by options.Gpc, Gpv, fit result to exponential rise to extract approx single time constant taupen. Fit only to early time corre. to one e-folding (if were pure single-tau exponential) to extract effective single time constant for dominant rise time... Remove all other PF coils from problem, so they're not doing any shielding. USE EXAMPLE: >> tok_data_struct = load_tok_objects('kstar','2010','6565'); >> resv_fix = tok_data_struct.resv; >> resv_fix(71:end) = resv_fix(71:end)*1000; kill all but VV walls >> options.resv_fix = resv_fix; >> taupfs = zeros(14,1); just SC PF's >> for ii=1:14 >> [taupen,ymeas,t] = calc_taupen(tok_data_struct,ii,1.8,0,options); >> taupfs(ii)=taupen; >> end","title":"Basic Information"},{"location":"function-guide/tok_models/calc_vv_resvals_m/","text":"calc_vv_resvals.m \u00b6 Basic Information \u00b6 SYNTAX: [resvv,vals,vecs] = calc_vv_resvals(tok_data_struct) PURPOSE: Calculate one-turn resistance of vacuum vessel from tok_data_struct objects, and also calculate eigenvalues/ vectors from the vessel-only passive system. Prints various values to standard output and passes to output variables. INPUTS: tok_data_struct = standard TokSys passive system data structure which must include mvv, resv OUTPUTS: resvv = one-turn resistance of VV [Ohms] vals = eigenvalues of vessel system amatvv=-inv(mvv)*diag(resv); vecs = eigenvectors of vessel system amatvv=-inv(mvv)*diag(resv); RESTRICTIONS: METHOD:","title":"calc_vv_resvals.m"},{"location":"function-guide/tok_models/calc_vv_resvals_m/#calc_vv_resvalsm","text":"","title":"calc_vv_resvals.m"},{"location":"function-guide/tok_models/calc_vv_resvals_m/#basic-information","text":"SYNTAX: [resvv,vals,vecs] = calc_vv_resvals(tok_data_struct) PURPOSE: Calculate one-turn resistance of vacuum vessel from tok_data_struct objects, and also calculate eigenvalues/ vectors from the vessel-only passive system. Prints various values to standard output and passes to output variables. INPUTS: tok_data_struct = standard TokSys passive system data structure which must include mvv, resv OUTPUTS: resvv = one-turn resistance of VV [Ohms] vals = eigenvalues of vessel system amatvv=-inv(mvv)*diag(resv); vecs = eigenvectors of vessel system amatvv=-inv(mvv)*diag(resv); RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/calc_x_m/","text":"calc_x.m \u00b6 Basic Information \u00b6 USAGE: [xresp,x,bresp,b,xtarget] = calc_x(xtarget,tok_data_struct,resp,eq,idoplot) PURPOSE: Find x-points and responses thereof *in vicinity of* specified target points and also return Br, Bz and their responses *at* specified target points. INPUTS: xtarget: specification on the form [r z] where r and z are column vectors of approximate or target x-point locations. If xtarget is empty, the default is bottom and top of boundary. tok_data_struct: toksys description of tokamak resp: (optional) the output from a response model (gspert or rzrig) eq: equilibrium structure idoplot: flag to plot limiter, boundary, xtarget points and x-points OUTPUTS: xresp: response structure with fields: drxdis: rx response to conductors [m/A] dzxdis: zx response to conductors [m/A] drxdip,*dli,*dbetap, etc: exogenous responses x: the x-points on form [rx zx] found near xtarget points bresp: response structure with fields: dbrdis: br response at points xtarget to conductors [T/A] dbzdis: bz response at points xtarget to conductors [T/A] dbrdip,*dli,*dbetap, etc: exogenous responses b: The fields at xtarget points on the form [br bz] xtarget: Target location for x-points (same as input if input is not empty)","title":"calc_x.m"},{"location":"function-guide/tok_models/calc_x_m/#calc_xm","text":"","title":"calc_x.m"},{"location":"function-guide/tok_models/calc_x_m/#basic-information","text":"USAGE: [xresp,x,bresp,b,xtarget] = calc_x(xtarget,tok_data_struct,resp,eq,idoplot) PURPOSE: Find x-points and responses thereof *in vicinity of* specified target points and also return Br, Bz and their responses *at* specified target points. INPUTS: xtarget: specification on the form [r z] where r and z are column vectors of approximate or target x-point locations. If xtarget is empty, the default is bottom and top of boundary. tok_data_struct: toksys description of tokamak resp: (optional) the output from a response model (gspert or rzrig) eq: equilibrium structure idoplot: flag to plot limiter, boundary, xtarget points and x-points OUTPUTS: xresp: response structure with fields: drxdis: rx response to conductors [m/A] dzxdis: zx response to conductors [m/A] drxdip,*dli,*dbetap, etc: exogenous responses x: the x-points on form [rx zx] found near xtarget points bresp: response structure with fields: dbrdis: br response at points xtarget to conductors [T/A] dbzdis: bz response at points xtarget to conductors [T/A] dbrdip,*dli,*dbetap, etc: exogenous responses b: The fields at xtarget points on the form [br bz] xtarget: Target location for x-points (same as input if input is not empty)","title":"Basic Information"},{"location":"function-guide/tok_models/cccirc_to_Pcc_m/","text":"cccirc_to_Pcc.m \u00b6 Basic Information \u00b6 USAGE: Pcc = cccirc_to_Pcc(cccirc) DESCRIPTION: Calculate circuit connection matrix from connection vector INPUTS: cccirc = Connection vector for CC's (see build_tokamak_system) OUTPUTS Pcc = [nc ncx] matrix for converting unconnected coils to circuits","title":"cccirc_to_Pcc.m"},{"location":"function-guide/tok_models/cccirc_to_Pcc_m/#cccirc_to_pccm","text":"","title":"cccirc_to_Pcc.m"},{"location":"function-guide/tok_models/cccirc_to_Pcc_m/#basic-information","text":"USAGE: Pcc = cccirc_to_Pcc(cccirc) DESCRIPTION: Calculate circuit connection matrix from connection vector INPUTS: cccirc = Connection vector for CC's (see build_tokamak_system) OUTPUTS Pcc = [nc ncx] matrix for converting unconnected coils to circuits","title":"Basic Information"},{"location":"function-guide/tok_models/change_tokobj_units_m/","text":"change_tokobj_units.m \u00b6 Basic Information \u00b6 USAGE: mod_data_struct=change_tokobj_units(tok_data_struct,imks,iterminal) PURPOSE: Create a copy of the tokamak vacuum data objects data structure with specified units and turns convention. INPUTS: tok_data_struct = data structure, contents defined by creation in make_tok_objects.m imks = if 1, create data objects in MKS units, 0 means currents in MA iterminal = if 1, all multi-turn coils are interpreted to be in \"terminal mode\", e.g. currents are as measured at input or output terminals, 0 means \"lumped mode\", e.g. current is total cross-sectional current in multi-turn coil. OUTPUTS: mod_data_struct = same data structure, but with modified data objects","title":"change_tokobj_units.m"},{"location":"function-guide/tok_models/change_tokobj_units_m/#change_tokobj_unitsm","text":"","title":"change_tokobj_units.m"},{"location":"function-guide/tok_models/change_tokobj_units_m/#basic-information","text":"USAGE: mod_data_struct=change_tokobj_units(tok_data_struct,imks,iterminal) PURPOSE: Create a copy of the tokamak vacuum data objects data structure with specified units and turns convention. INPUTS: tok_data_struct = data structure, contents defined by creation in make_tok_objects.m imks = if 1, create data objects in MKS units, 0 means currents in MA iterminal = if 1, all multi-turn coils are interpreted to be in \"terminal mode\", e.g. currents are as measured at input or output terminals, 0 means \"lumped mode\", e.g. current is total cross-sectional current in multi-turn coil. OUTPUTS: mod_data_struct = same data structure, but with modified data objects","title":"Basic Information"},{"location":"function-guide/tok_models/changeq_m/","text":"changeq.m \u00b6 Basic Information \u00b6 USAGE: [eq, eqx] = changeq(eq0,eq_target,tok_data_struct,options,idoplot) PURPOSE: Change an equilibrium from eq0 to eq_target Targeted variables are: (rbbbs,zbbbs), cc, cpasma, betap, li Bus constraint such as the VFI on DIII-D can be imposed on cc INPUTS: eq0: Original equilibrium structure on toksys format eq_target: Equilibrium structure containing target quantities Specify NaN for variables to adjust in order to achieve target example: if cc can be adjusted then set eq_target.cc(:) = NaN; tok_data_struct: standard toksys object for tokamak description options.converrmax = upper limit on flux error in resulting eq options.maxiter: maximum convergence iterations, default = 25; options.cccirc: standard toksys assignment of circuit numbers to coils, options.bus_code: indices are 1 for coils on bus, 0 for others For DIII-D do: PP_objs = get_PP_objs(shot) options.bus_code = [0 0 PP_objs.bus_code] idoplot: plot each iteration for idoplot seconds, default 0 = no plot OUTPUTS: eq: structure containing new converged equilibrium on tok_data_struct grid eqx: structure containing extra information (see eqx.descriptions) RESTRICTIONS: MAXIMUM grid size is 65x65 Only these quantities are updated for the new equilibrium: rbbbs, zbbbs, jphi, psizr, pprime, ffprim, pres, fpol cc, psimag, psibry, cpasma, rmaxis, zmaxis, rg, zg, dr, dz nw, nh, psirz, ssibry, ssimag, qpsi METHOD: Linear solution is found by gspert and converged with convergeq","title":"changeq.m"},{"location":"function-guide/tok_models/changeq_m/#changeqm","text":"","title":"changeq.m"},{"location":"function-guide/tok_models/changeq_m/#basic-information","text":"USAGE: [eq, eqx] = changeq(eq0,eq_target,tok_data_struct,options,idoplot) PURPOSE: Change an equilibrium from eq0 to eq_target Targeted variables are: (rbbbs,zbbbs), cc, cpasma, betap, li Bus constraint such as the VFI on DIII-D can be imposed on cc INPUTS: eq0: Original equilibrium structure on toksys format eq_target: Equilibrium structure containing target quantities Specify NaN for variables to adjust in order to achieve target example: if cc can be adjusted then set eq_target.cc(:) = NaN; tok_data_struct: standard toksys object for tokamak description options.converrmax = upper limit on flux error in resulting eq options.maxiter: maximum convergence iterations, default = 25; options.cccirc: standard toksys assignment of circuit numbers to coils, options.bus_code: indices are 1 for coils on bus, 0 for others For DIII-D do: PP_objs = get_PP_objs(shot) options.bus_code = [0 0 PP_objs.bus_code] idoplot: plot each iteration for idoplot seconds, default 0 = no plot OUTPUTS: eq: structure containing new converged equilibrium on tok_data_struct grid eqx: structure containing extra information (see eqx.descriptions) RESTRICTIONS: MAXIMUM grid size is 65x65 Only these quantities are updated for the new equilibrium: rbbbs, zbbbs, jphi, psizr, pprime, ffprim, pres, fpol cc, psimag, psibry, cpasma, rmaxis, zmaxis, rg, zg, dr, dz nw, nh, psirz, ssibry, ssimag, qpsi METHOD: Linear solution is found by gspert and converged with convergeq","title":"Basic Information"},{"location":"function-guide/tok_models/check_tok_objects_m/","text":"check_tok_objects.m \u00b6 Basic Information \u00b6 USAGE: >> check_tok_objects(tok_data_struct,plot_geo_fun, ... efit_gfile,read_gfile_fun); PURPOSE: Function to do checks of mutuals, Green functions for tokamak system analogous to D3D Electromagnetic Environment. INPUTS: tok_data_struct = standard structure containing vacuum objects plot_geo_fun = name of geometry plotting script to use (e.g. 'plot_east_geo') efit_gfile = (opt) name of EFIT gfile for equilibrium plotting read_gfile_fun = (opt) name of gfile reader to use (if efit_gfile) OUTPUTS: Checks of various objects, plots to confirm... valsv = VV eigenvalues (rad/sec) RESTRICTIONS: METHOD: cmpares some object values with grid-to-s.t., does some eigenvalue calculations, displays results to check...","title":"check_tok_objects.m"},{"location":"function-guide/tok_models/check_tok_objects_m/#check_tok_objectsm","text":"","title":"check_tok_objects.m"},{"location":"function-guide/tok_models/check_tok_objects_m/#basic-information","text":"USAGE: >> check_tok_objects(tok_data_struct,plot_geo_fun, ... efit_gfile,read_gfile_fun); PURPOSE: Function to do checks of mutuals, Green functions for tokamak system analogous to D3D Electromagnetic Environment. INPUTS: tok_data_struct = standard structure containing vacuum objects plot_geo_fun = name of geometry plotting script to use (e.g. 'plot_east_geo') efit_gfile = (opt) name of EFIT gfile for equilibrium plotting read_gfile_fun = (opt) name of gfile reader to use (if efit_gfile) OUTPUTS: Checks of various objects, plots to confirm... valsv = VV eigenvalues (rad/sec) RESTRICTIONS: METHOD: cmpares some object values with grid-to-s.t., does some eigenvalue calculations, displays results to check...","title":"Basic Information"},{"location":"function-guide/tok_models/convergeq_m/","text":"convergeq.m \u00b6 Basic Information \u00b6 USAGE: [ceq, eqx] = convergeq(eq,tok_data_struct,options,idoplot) PURPOSE: Converge equilibrium, i.e. minimize psizr_app+psizr_pla - psizr where psizr_app is calculated from mpc, cc and psizr_pla from mpp, jphi and jphi in turn is calculated using psizr, pprime, ffprim \u0006 The converged equilibrium is on the grid in tok_data_struct which can be different from the grid in the original efit. Bus constraint such as the VFI on DIII-D can be imposed on cc INPUTS: eq: An equilibrium containing at least psizr, pprime, ffprim, cc tok_data_struct: standard toksys object for tokamak description options.converrmax = upper limit on resulting flux error max(abs(psizr_app(:)+psizr_pla(:)-psizr(:))), default 1e-12 options.iconstraints: (default is 3) 0. conserve pres and fpol as functions of normalized flux 1: conserve pres and total plasma current 2: conserve thermal energy and fpol 3: conserve thermal energy and total plasma current options.maxiter: maximum number of iterations, default = 25; options.icx: Specify a subset of cc that can change, default icx=1:nc options.cccirc: standard toksys assignment of circuit numbers to coils, options.bus_code: indices are 1 for coils on bus, 0 for others bus_code*cc = 0 (bus_code is row vector and cc is column vector) cc will be adjusted to meet the constraint: bus_code*cc = 0 For DIII-D: PP_objs = get_PP_objs(shot) options.bus_code = [0 0 PP_objs.bus_code] idoplot: plot each iteration for idoplot seconds, default 0 = no plot OUTPUTS: ceq: structure containing converged equilibrium on tok_data_struct grid eqx: structure containing extra information (see eqx.descriptions) RESTRICTIONS: The following quantities are updated for converged equilibrium: rbbbs, zbbbs, jphi, psizr, pprime, ffprim, pres, fpol cc, psimag, psibry, cpasma, rmaxis, zmaxis, rg, zg, dr, dz nw, nh, psirz, ssibry, ssimag, qpsi METHOD: The Newton-Rhapson method is used to converge to the solution.","title":"convergeq.m"},{"location":"function-guide/tok_models/convergeq_m/#convergeqm","text":"","title":"convergeq.m"},{"location":"function-guide/tok_models/convergeq_m/#basic-information","text":"USAGE: [ceq, eqx] = convergeq(eq,tok_data_struct,options,idoplot) PURPOSE: Converge equilibrium, i.e. minimize psizr_app+psizr_pla - psizr where psizr_app is calculated from mpc, cc and psizr_pla from mpp, jphi and jphi in turn is calculated using psizr, pprime, ffprim \u0006 The converged equilibrium is on the grid in tok_data_struct which can be different from the grid in the original efit. Bus constraint such as the VFI on DIII-D can be imposed on cc INPUTS: eq: An equilibrium containing at least psizr, pprime, ffprim, cc tok_data_struct: standard toksys object for tokamak description options.converrmax = upper limit on resulting flux error max(abs(psizr_app(:)+psizr_pla(:)-psizr(:))), default 1e-12 options.iconstraints: (default is 3) 0. conserve pres and fpol as functions of normalized flux 1: conserve pres and total plasma current 2: conserve thermal energy and fpol 3: conserve thermal energy and total plasma current options.maxiter: maximum number of iterations, default = 25; options.icx: Specify a subset of cc that can change, default icx=1:nc options.cccirc: standard toksys assignment of circuit numbers to coils, options.bus_code: indices are 1 for coils on bus, 0 for others bus_code*cc = 0 (bus_code is row vector and cc is column vector) cc will be adjusted to meet the constraint: bus_code*cc = 0 For DIII-D: PP_objs = get_PP_objs(shot) options.bus_code = [0 0 PP_objs.bus_code] idoplot: plot each iteration for idoplot seconds, default 0 = no plot OUTPUTS: ceq: structure containing converged equilibrium on tok_data_struct grid eqx: structure containing extra information (see eqx.descriptions) RESTRICTIONS: The following quantities are updated for converged equilibrium: rbbbs, zbbbs, jphi, psizr, pprime, ffprim, pres, fpol cc, psimag, psibry, cpasma, rmaxis, zmaxis, rg, zg, dr, dz nw, nh, psirz, ssibry, ssimag, qpsi METHOD: The Newton-Rhapson method is used to converge to the solution.","title":"Basic Information"},{"location":"function-guide/tok_models/create_noise_link_m/","text":"create_noise_link.m \u00b6 Basic Information \u00b6 SYNTAX: create_noise_link(filename) PURPOSE: Creates a soft link in the working directory called \"noise.mat\" to an existing file named by filename. The file specified by filename must exist or the fucntion will error out. INPUTS: filename = the full path to the existing file that is to be linked to \"noise.mat\" OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise_file, make_noise","title":"create_noise_link.m"},{"location":"function-guide/tok_models/create_noise_link_m/#create_noise_linkm","text":"","title":"create_noise_link.m"},{"location":"function-guide/tok_models/create_noise_link_m/#basic-information","text":"SYNTAX: create_noise_link(filename) PURPOSE: Creates a soft link in the working directory called \"noise.mat\" to an existing file named by filename. The file specified by filename must exist or the fucntion will error out. INPUTS: filename = the full path to the existing file that is to be linked to \"noise.mat\" OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise_file, make_noise","title":"Basic Information"},{"location":"function-guide/tok_models/divertor_model_m/","text":"divertor_model.m \u00b6 Basic Information \u00b6 SYNTAX: [nec,Wth,Qtard,nec2,nrc2,nrd2,output_data]= divertor_model(Gamec,Gamrc,Gamrd,nec1,nrc1,nrd1,dt); PURPOSE: Model evolution of divertor (and core) plasma states in response to changing gas flow rates. Outputs quantities useful to measure for active feedback control of divertor (and core) properties. Evolves single time step on call INPUTS: Gamec = core fueling gas flow rate (hydrogenic, so same as electron) [atoms/m^3/sec = electrons/m^3/sec] Gamrc = core radiating impurity (RI) flow rate [atoms/m^3/sec] Gamrd = divertor radiating impurity flow rate [atoms/m^3/sec] nec1 = initial core electron density [electrons/m^3] nrc1 = initial core RI density [ions/m^3] nrd1 = initial divertor RI density [ions/m^3] dt = time step [sec] OUTPUTS: nec = present core electron density output (same as nec2) [electrons/m^3] Wth = core thermal stored energy output [J] Qtard = heat flux to divertor target output [W/s] nec2 = core electron density after time step dt [electrons/m^3] nrc2 = core RI density after time step dt [ions/m^3] nrd2 = divertor RI density after time step dt [ions/m^3] output_data = structure with useful data to provide to analyze output: Pradc, Pradd RESTRICTIONS: METHOD: State equations are the three continuity equations for nec, nrc, nrd. Output equations describe Wth Qtard as function of input heating power Pheat and radiated core power Pradc. nec is the third output variable. Pradc represented by Bremsstrahlung-like expression including both core electron-electron and electron-impurity collisions. Pradd (radiation from divertor) represented by empirical function to capture observed behavior of ionization/density front up and along divertor legs, with corresponding maximum in radiation as function of upstream density (nec). Scale factor of 150 makes function produce ~ 1 MW total rad pwr for 2 keV, 2e19 plasma w/ no impurity... Pradd coeff Crd is chosen so 2e19 core density makes ~1.5 MW rad in div State equations evolved by implicit scheme (exponential solution over time step)","title":"divertor_model.m"},{"location":"function-guide/tok_models/divertor_model_m/#divertor_modelm","text":"","title":"divertor_model.m"},{"location":"function-guide/tok_models/divertor_model_m/#basic-information","text":"SYNTAX: [nec,Wth,Qtard,nec2,nrc2,nrd2,output_data]= divertor_model(Gamec,Gamrc,Gamrd,nec1,nrc1,nrd1,dt); PURPOSE: Model evolution of divertor (and core) plasma states in response to changing gas flow rates. Outputs quantities useful to measure for active feedback control of divertor (and core) properties. Evolves single time step on call INPUTS: Gamec = core fueling gas flow rate (hydrogenic, so same as electron) [atoms/m^3/sec = electrons/m^3/sec] Gamrc = core radiating impurity (RI) flow rate [atoms/m^3/sec] Gamrd = divertor radiating impurity flow rate [atoms/m^3/sec] nec1 = initial core electron density [electrons/m^3] nrc1 = initial core RI density [ions/m^3] nrd1 = initial divertor RI density [ions/m^3] dt = time step [sec] OUTPUTS: nec = present core electron density output (same as nec2) [electrons/m^3] Wth = core thermal stored energy output [J] Qtard = heat flux to divertor target output [W/s] nec2 = core electron density after time step dt [electrons/m^3] nrc2 = core RI density after time step dt [ions/m^3] nrd2 = divertor RI density after time step dt [ions/m^3] output_data = structure with useful data to provide to analyze output: Pradc, Pradd RESTRICTIONS: METHOD: State equations are the three continuity equations for nec, nrc, nrd. Output equations describe Wth Qtard as function of input heating power Pheat and radiated core power Pradc. nec is the third output variable. Pradc represented by Bremsstrahlung-like expression including both core electron-electron and electron-impurity collisions. Pradd (radiation from divertor) represented by empirical function to capture observed behavior of ionization/density front up and along divertor legs, with corresponding maximum in radiation as function of upstream density (nec). Scale factor of 150 makes function produce ~ 1 MW total rad pwr for 2 keV, 2e19 plasma w/ no impurity... Pradd coeff Crd is chosen so 2e19 core density makes ~1.5 MW rad in div State equations evolved by implicit scheme (exponential solution over time step)","title":"Basic Information"},{"location":"function-guide/tok_models/evolveq_m/","text":"evolveq.m \u00b6 Basic Information \u00b6 USAGE: [y, e, eq, eqx] = evolveq(u,C,tok,eq0) PURPOSE: Evolve an equilibrium. Initialize by calling with all arguments: y = evolveq(u,C,tok,eq0) Evolve by calling with new inputs in u: y = evolveq(u) INPUTS: u, structure with inputs that affect the equilibrium: cc0t: coil currents such that psizr_app = mpc*cc0t vc0t: vessel currents such that psizr_app = mpv*vc0t ip: plasma current li: normalized inductance betap: poloidal beta If an input is missing then no change of the quantity is made. C, output matrix such that y = C*[cc0t; vc0t; pcurrt], where pcurrt is plasma currents within grid elements [A] Example: C = [[mcc mcv mpc']; [mcv' mvv mpv']] outputs flux at conductors tok, Toksys description of the tokamak eq0, initial equilibrium OUTPUTS: y, outputs defined by C e, structure with all persistent variables eq, equilibrium (returning eq increases execution time) eqx. last analyzed equilibrium and some simulation parameters METHOD: The equilibrium and its response matrix are persistent variables. When the routine is called, the equilibrium is updated by the linear response to the changes that have occurred in u, and a new output, y is calculated. Large changes can be made in one step, evolveq estimates magnitude of nonlinear response and divides large changes into several smaller internally. When uncertainties in the linear response have accrued, a correction is made. When the response matrix becomes inaccurate a new is calculated.","title":"evolveq.m"},{"location":"function-guide/tok_models/evolveq_m/#evolveqm","text":"","title":"evolveq.m"},{"location":"function-guide/tok_models/evolveq_m/#basic-information","text":"USAGE: [y, e, eq, eqx] = evolveq(u,C,tok,eq0) PURPOSE: Evolve an equilibrium. Initialize by calling with all arguments: y = evolveq(u,C,tok,eq0) Evolve by calling with new inputs in u: y = evolveq(u) INPUTS: u, structure with inputs that affect the equilibrium: cc0t: coil currents such that psizr_app = mpc*cc0t vc0t: vessel currents such that psizr_app = mpv*vc0t ip: plasma current li: normalized inductance betap: poloidal beta If an input is missing then no change of the quantity is made. C, output matrix such that y = C*[cc0t; vc0t; pcurrt], where pcurrt is plasma currents within grid elements [A] Example: C = [[mcc mcv mpc']; [mcv' mvv mpv']] outputs flux at conductors tok, Toksys description of the tokamak eq0, initial equilibrium OUTPUTS: y, outputs defined by C e, structure with all persistent variables eq, equilibrium (returning eq increases execution time) eqx. last analyzed equilibrium and some simulation parameters METHOD: The equilibrium and its response matrix are persistent variables. When the routine is called, the equilibrium is updated by the linear response to the changes that have occurred in u, and a new output, y is calculated. Large changes can be made in one step, evolveq estimates magnitude of nonlinear response and divides large changes into several smaller internally. When uncertainties in the linear response have accrued, a correction is made. When the response matrix becomes inaccurate a new is calculated.","title":"Basic Information"},{"location":"function-guide/tok_models/gbr2p_x_vec_m/","text":"gbr2p_x_vec.m \u00b6 Basic Information \u00b6 SYNTAX: product = gbr2p_x_vec(gbr2p,vec) PURPOSE: Compute product of matrix gbr2p and vector vec, where gbr2p is stored in compressed format. Use mpp_x_vec for multiplication with either mpp or gbz2p. INPUT: gbr2p = plasma grid to plasma grid mutuals in compressed format OUTPUT: product = product of matrix multiplication SEE ALSO: get_plasma_greens, mpp_x_vec","title":"gbr2p_x_vec.m"},{"location":"function-guide/tok_models/gbr2p_x_vec_m/#gbr2p_x_vecm","text":"","title":"gbr2p_x_vec.m"},{"location":"function-guide/tok_models/gbr2p_x_vec_m/#basic-information","text":"SYNTAX: product = gbr2p_x_vec(gbr2p,vec) PURPOSE: Compute product of matrix gbr2p and vector vec, where gbr2p is stored in compressed format. Use mpp_x_vec for multiplication with either mpp or gbz2p. INPUT: gbr2p = plasma grid to plasma grid mutuals in compressed format OUTPUT: product = product of matrix multiplication SEE ALSO: get_plasma_greens, mpp_x_vec","title":"Basic Information"},{"location":"function-guide/tok_models/getIq_m/","text":"getIq.m \u00b6 Basic Information \u00b6 USAGE: [Iq, t, Iqn] = getIq(shot,q,t1,t2,efit_source,tokamak) PURPOSE: get current within q-surface INPUTS: shot: shot number q: q-values for surfaces (default 2) t1, t2: Specification of the time samples (t) t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: (default efit02) tokamak: (default d3d) OUTPUTS: Iq: current within q-contours t: times [sec] Iqn: Iq/cpasma, i.e. fraction of current within q-surfaces","title":"getIq.m"},{"location":"function-guide/tok_models/getIq_m/#getiqm","text":"","title":"getIq.m"},{"location":"function-guide/tok_models/getIq_m/#basic-information","text":"USAGE: [Iq, t, Iqn] = getIq(shot,q,t1,t2,efit_source,tokamak) PURPOSE: get current within q-surface INPUTS: shot: shot number q: q-values for surfaces (default 2) t1, t2: Specification of the time samples (t) t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: (default efit02) tokamak: (default d3d) OUTPUTS: Iq: current within q-contours t: times [sec] Iqn: Iq/cpasma, i.e. fraction of current within q-surfaces","title":"Basic Information"},{"location":"function-guide/tok_models/get_plasma_greens_m/","text":"get_plasma_greens.m \u00b6 Basic Information \u00b6 SYNTAX: [mp,gbr,gbz]=... get_plasma_greens(mpp,gbr2p,gbz2p,src_r_idx,src_z_idx,nz) PURPOSE: Get mutual inductance, Br, and Bz green's function responses (plasma green's functions) to a given grid point current source. INPUT: mpp = plasma grid to plasma grid mutuals in compressed format gbr2p = Br green's functions from plasma grid to plasma grid in compressed format gbz2p = Bz green's functions from plasma grid to plasma grid in compressed format src_r_idx = index of r coordinate of current source in overall grid (0 < src_r_idx <= nr) src_z_idx = index of z coordinate of current source in overall grid (0 < src_z_idx <= nz) nz = number of grids in z dimension OUTPUT: mp = mutuals from selected grid current source to all other grids gbr = Br greens fns from selected grid current source to all other grids gbz = Bz greens fns from selected grid current source to all other grids (Output units are same as input objects mpp, gbr2p, gbz2p.) SEE ALSO: mpp_x_vec","title":"get_plasma_greens.m"},{"location":"function-guide/tok_models/get_plasma_greens_m/#get_plasma_greensm","text":"","title":"get_plasma_greens.m"},{"location":"function-guide/tok_models/get_plasma_greens_m/#basic-information","text":"SYNTAX: [mp,gbr,gbz]=... get_plasma_greens(mpp,gbr2p,gbz2p,src_r_idx,src_z_idx,nz) PURPOSE: Get mutual inductance, Br, and Bz green's function responses (plasma green's functions) to a given grid point current source. INPUT: mpp = plasma grid to plasma grid mutuals in compressed format gbr2p = Br green's functions from plasma grid to plasma grid in compressed format gbz2p = Bz green's functions from plasma grid to plasma grid in compressed format src_r_idx = index of r coordinate of current source in overall grid (0 < src_r_idx <= nr) src_z_idx = index of z coordinate of current source in overall grid (0 < src_z_idx <= nz) nz = number of grids in z dimension OUTPUT: mp = mutuals from selected grid current source to all other grids gbr = Br greens fns from selected grid current source to all other grids gbz = Bz greens fns from selected grid current source to all other grids (Output units are same as input objects mpp, gbr2p, gbz2p.) SEE ALSO: mpp_x_vec","title":"Basic Information"},{"location":"function-guide/tok_models/getgaps_m/","text":"getgaps.m \u00b6 Basic Information \u00b6 USAGE: [gaps,t, gapspec] = getgaps(shot,gapspec,t1,t2,efit_source,tokamak,idoplot) PURPOSE: Get gaps defined by gapspec A gap is defined as the distance between the plasma boundary and the wall along a line through a specified \"gap location\", with direction of measurement defined by gradient of flux for a nominal equilibrium at that prescribed \"gap location\". INPUTS: shot: shot number gapspec: gap specification on the form [r z gr gz] r,z is gap location and gr,gz nominal gradient default gaps are: inner, upper, outer, lower see also calc_gaps t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: string with name of efit-tree OR equil_data default efit01 for shot<900000, efitrt1 for shot>=900000 tokamak: default d3d idoplot: flag to plot limiter, gap locations, and gap vectors OUTPUTS: gaps: distances from boundary to wall through r,z along gr,gz [m] t: time [sec] gapspec: gapspec that was used (supplied in call or default)","title":"getgaps.m"},{"location":"function-guide/tok_models/getgaps_m/#getgapsm","text":"","title":"getgaps.m"},{"location":"function-guide/tok_models/getgaps_m/#basic-information","text":"USAGE: [gaps,t, gapspec] = getgaps(shot,gapspec,t1,t2,efit_source,tokamak,idoplot) PURPOSE: Get gaps defined by gapspec A gap is defined as the distance between the plasma boundary and the wall along a line through a specified \"gap location\", with direction of measurement defined by gradient of flux for a nominal equilibrium at that prescribed \"gap location\". INPUTS: shot: shot number gapspec: gap specification on the form [r z gr gz] r,z is gap location and gr,gz nominal gradient default gaps are: inner, upper, outer, lower see also calc_gaps t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: string with name of efit-tree OR equil_data default efit01 for shot<900000, efitrt1 for shot>=900000 tokamak: default d3d idoplot: flag to plot limiter, gap locations, and gap vectors OUTPUTS: gaps: distances from boundary to wall through r,z along gr,gz [m] t: time [sec] gapspec: gapspec that was used (supplied in call or default)","title":"Basic Information"},{"location":"function-guide/tok_models/getiso_m/","text":"getiso.m \u00b6 Basic Information \u00b6 USAGE: [iso,t] = getiso(shot,rziso,t1,t2,efit_source,tokamak,idoplot) PURPOSE: Get iso fluxes and fields at rziso points INPUTS: shot: shot number rziso: R, Z of isoflux points arranged as [R(:) Z(:)] (unit: meters) t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: string with name of efit-tree OR equil_data default efit01 for shot<900000, efitrt1 for shot>=900000 tokamak: default d3d idoplot: flag to plot limiter and rziso points OUTPUTS: iso: structure with fields: psi: flux at rziso points br, bz: Br, Bz at rziso points t: time [sec]","title":"getiso.m"},{"location":"function-guide/tok_models/getiso_m/#getisom","text":"","title":"getiso.m"},{"location":"function-guide/tok_models/getiso_m/#basic-information","text":"USAGE: [iso,t] = getiso(shot,rziso,t1,t2,efit_source,tokamak,idoplot) PURPOSE: Get iso fluxes and fields at rziso points INPUTS: shot: shot number rziso: R, Z of isoflux points arranged as [R(:) Z(:)] (unit: meters) t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: string with name of efit-tree OR equil_data default efit01 for shot<900000, efitrt1 for shot>=900000 tokamak: default d3d idoplot: flag to plot limiter and rziso points OUTPUTS: iso: structure with fields: psi: flux at rziso points br, bz: Br, Bz at rziso points t: time [sec]","title":"Basic Information"},{"location":"function-guide/tok_models/getxpt_m/","text":"getxpt.m \u00b6 Basic Information \u00b6 USAGE: [rx,zx,psix,t,br,bz,eqs] = getxpt(shot,t1,t2,efit_source,tokamak,xtarget,idoplot) PURPOSE: Get coordinates for 1 x-point below and 1 above the magnetic axis. The points where flux is closest to the boundary flux are chosen. Also return the flux at these x-points and at the boundary. In addition return Br, Bz at xtarget points (if specified) INPUTS: shot: shot number t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: Structure with equilibria or name of MDS tree or directory with gfiles or corsica flat files (see help read_eq), default EFIT01 for shot<900000, EFITRT1 for shot>=900000 tokamak: default D3D xtarget: specification on the form [r z] where r and z are column vectors of target x-point locations, for calculation of Br, Bz. idoplot: flag to plot x-point trajectories and limiter, bit 0 plots x's, bit 1 plots limiter, bit 2 adds text, bit 3 adds color coding of times, bit 4 adds colorbar, idoplot=31 plots it all, default is 0. OUTPUTS: rx: radial position of x-points [lower; upper] [m] zx: vertical position of x-points [lower; upper] [m] psix: fluxes at [lower x; upper x; boundary] [Wb] t: time [sec] br: radial magnetic field at xtarget points bz: vertical magnetic field at xtarget points eqs: The structure with equilibria from efit_source","title":"getxpt.m"},{"location":"function-guide/tok_models/getxpt_m/#getxptm","text":"","title":"getxpt.m"},{"location":"function-guide/tok_models/getxpt_m/#basic-information","text":"USAGE: [rx,zx,psix,t,br,bz,eqs] = getxpt(shot,t1,t2,efit_source,tokamak,xtarget,idoplot) PURPOSE: Get coordinates for 1 x-point below and 1 above the magnetic axis. The points where flux is closest to the boundary flux are chosen. Also return the flux at these x-points and at the boundary. In addition return Br, Bz at xtarget points (if specified) INPUTS: shot: shot number t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: Structure with equilibria or name of MDS tree or directory with gfiles or corsica flat files (see help read_eq), default EFIT01 for shot<900000, EFITRT1 for shot>=900000 tokamak: default D3D xtarget: specification on the form [r z] where r and z are column vectors of target x-point locations, for calculation of Br, Bz. idoplot: flag to plot x-point trajectories and limiter, bit 0 plots x's, bit 1 plots limiter, bit 2 adds text, bit 3 adds color coding of times, bit 4 adds colorbar, idoplot=31 plots it all, default is 0. OUTPUTS: rx: radial position of x-points [lower; upper] [m] zx: vertical position of x-points [lower; upper] [m] psix: fluxes at [lower x; upper x; boundary] [Wb] t: time [sec] br: radial magnetic field at xtarget points bz: vertical magnetic field at xtarget points eqs: The structure with equilibria from efit_source","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DN_m/","text":"gsdesign_demo_d3d_DN.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_d3d_DN PURPOSE: DEMO of gsdesign showing design of EAST-like double-x-point for DIII-D INPUTS: none OUTPUTS: eq, a double snowflake equilibrium","title":"gsdesign_demo_d3d_DN.m"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DN_m/#gsdesign_demo_d3d_dnm","text":"","title":"gsdesign_demo_d3d_DN.m"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DN_m/#basic-information","text":"USAGE: gsdesign_demo_d3d_DN PURPOSE: DEMO of gsdesign showing design of EAST-like double-x-point for DIII-D INPUTS: none OUTPUTS: eq, a double snowflake equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DSNF_m/","text":"gsdesign_demo_d3d_DSNF.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_d3d_DSNF PURPOSE: DEMO of gsdesign showing design of double-snowflake for DIII-D INPUTS: none OUTPUTS: eq, a double snowflake equilibrium","title":"gsdesign_demo_d3d_DSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DSNF_m/#gsdesign_demo_d3d_dsnfm","text":"","title":"gsdesign_demo_d3d_DSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DSNF_m/#basic-information","text":"USAGE: gsdesign_demo_d3d_DSNF PURPOSE: DEMO of gsdesign showing design of double-snowflake for DIII-D INPUTS: none OUTPUTS: eq, a double snowflake equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_east_DSNF_m/","text":"gsdesign_demo_east_DSNF.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_east_DSNF PURPOSE: DEMO of gsdesign showing design of double-snowflake for EAST INPUTS: none OUTPUTS: eq, a double snowflake equilibrium","title":"gsdesign_demo_east_DSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_east_DSNF_m/#gsdesign_demo_east_dsnfm","text":"","title":"gsdesign_demo_east_DSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_east_DSNF_m/#basic-information","text":"USAGE: gsdesign_demo_east_DSNF PURPOSE: DEMO of gsdesign showing design of double-snowflake for EAST INPUTS: none OUTPUTS: eq, a double snowflake equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_east_LSNF_m/","text":"gsdesign_demo_east_LSNF.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_east_LSNF PURPOSE: DEMO of gsdesign showing design of lower-snowflake for EAST INPUTS: none OUTPUTS: eq, a lower-snowflake equilibrium","title":"gsdesign_demo_east_LSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_east_LSNF_m/#gsdesign_demo_east_lsnfm","text":"","title":"gsdesign_demo_east_LSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_east_LSNF_m/#basic-information","text":"USAGE: gsdesign_demo_east_LSNF PURPOSE: DEMO of gsdesign showing design of lower-snowflake for EAST INPUTS: none OUTPUTS: eq, a lower-snowflake equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_iter_m/","text":"gsdesign_demo_iter.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_iter PURPOSE: Design equilibrium for ITER INPUTS: None (just run the code) OUTPUTS: Plots and designed equilibrium METHOD:","title":"gsdesign_demo_iter.m"},{"location":"function-guide/tok_models/gsdesign_demo_iter_m/#gsdesign_demo_iterm","text":"","title":"gsdesign_demo_iter.m"},{"location":"function-guide/tok_models/gsdesign_demo_iter_m/#basic-information","text":"USAGE: gsdesign_demo_iter PURPOSE: Design equilibrium for ITER INPUTS: None (just run the code) OUTPUTS: Plots and designed equilibrium METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_kstar_ISS_m/","text":"gsdesign_demo_kstar_ISS.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_kstar_ISS PURPOSE: Design ITER-similar shape for KSTAR INPUTS: None (just run the code) OUTPUTS: Plots of and tables of feedforward currents METHOD:","title":"gsdesign_demo_kstar_ISS.m"},{"location":"function-guide/tok_models/gsdesign_demo_kstar_ISS_m/#gsdesign_demo_kstar_issm","text":"","title":"gsdesign_demo_kstar_ISS.m"},{"location":"function-guide/tok_models/gsdesign_demo_kstar_ISS_m/#basic-information","text":"USAGE: gsdesign_demo_kstar_ISS PURPOSE: Design ITER-similar shape for KSTAR INPUTS: None (just run the code) OUTPUTS: Plots of and tables of feedforward currents METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/lim2vv_m/","text":"lim2vv.m \u00b6 Basic Information \u00b6 SYNTAX: [vvdata,dirnu,iacnu,fracnu]=lim2vv(limdata,dperp,dw,idir,frac,iac); PURPOSE: Calculate vessel elements from limiter specification given by limdata = set of vertices in limiter, between which will be located vessel elements. INPUTS: limdata = set of vertices in limiter, between which will be located vessel elements. limdata has format [[r1 z1];[r2 z2]...] dperp = amount vessel elements are displaced from limiter dw = width of vessel elements idir = (optional) direction indices corr to each vessel element (nvv = nlim - 1). Default corresponds to +1; reverses direction of wall displacement if set element of idir to -1. frac = (optional) fraction by which to scale each VVelement iac = (optional) indices telling if AC or AC2 type element. Default = all AC (index 1) elements. Note that automatically sets vertical or horizontal elements to type 0... OUTPUTS: vvdata = vvdata array with standard format idirnu = new idir vector (actually used) iacnu = new iac vector (which was used in specifying actual vvdata) fracnu = new frac vector (actually used) plots of corresponding geometry RESTRICTIONS: METHOD:","title":"lim2vv.m"},{"location":"function-guide/tok_models/lim2vv_m/#lim2vvm","text":"","title":"lim2vv.m"},{"location":"function-guide/tok_models/lim2vv_m/#basic-information","text":"SYNTAX: [vvdata,dirnu,iacnu,fracnu]=lim2vv(limdata,dperp,dw,idir,frac,iac); PURPOSE: Calculate vessel elements from limiter specification given by limdata = set of vertices in limiter, between which will be located vessel elements. INPUTS: limdata = set of vertices in limiter, between which will be located vessel elements. limdata has format [[r1 z1];[r2 z2]...] dperp = amount vessel elements are displaced from limiter dw = width of vessel elements idir = (optional) direction indices corr to each vessel element (nvv = nlim - 1). Default corresponds to +1; reverses direction of wall displacement if set element of idir to -1. frac = (optional) fraction by which to scale each VVelement iac = (optional) indices telling if AC or AC2 type element. Default = all AC (index 1) elements. Note that automatically sets vertical or horizontal elements to type 0... OUTPUTS: vvdata = vvdata array with standard format idirnu = new idir vector (actually used) iacnu = new iac vector (which was used in specifying actual vvdata) fracnu = new frac vector (actually used) plots of corresponding geometry RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/linsim_tok_zctrl_m/","text":"linsim_tok_zctrl.m \u00b6 Basic Information \u00b6 USAGE: [out_data] = linsim_tok_zctrl(tok_system,tau_ps,T_ps,Vvec, ... Vlims,Kpvec,Kdvec,taupd,iplot,zdisp0,tmax,zmax, ... Gpsweep,Gdsweep,idxacsw) PURPOSE: Function to simulate linear vertical control with standard tau_ps, T_ps power supply definition. Called by script sim_iter_zctrl.m. Simulates response to zdisp0 initial condition INPUTS: tok_system = structure gen. by build_* script containing system data tau_ps = power supply time constant [s] T_ps = power supply delay time (in addition to one-pole tau_ps) [s] Vvec = vector specifying active coils (entries: 0=not active, +/-1 = active positive(negative) voltage/current Vlims = vector giving voltage saturation levels [V] Kpvec = vector giving proportional gain [V/m] Kdvec = vector giving derivative gain [V/m/s] taupd = time constant for 1-pole filter on PD operation [s] iplot = (opt) flag to select plotting (1=plot, 0=don't(default)) zdisp0 = (opt) specific value to calculate displacement trajectory for and plot (if selected) tmax = (opt) max time for simulation (def=1.0 sec) zmax = (opt) max z for plotting (def = 0.9 m) Gpsweep = vector with Gpmin, Gpmax, ngp Gdsweep = vector with Gdmin, Gdmax, ngd idxacsw = idx scalar for selected active coil to plot contours (this must be idx of coil whose peak I, V are negative, since code finds min of time history for contouring) OUTPUTS: out_data = structure that includes histories + plots (if selected) RESTRICTIONS: METHOD:","title":"linsim_tok_zctrl.m"},{"location":"function-guide/tok_models/linsim_tok_zctrl_m/#linsim_tok_zctrlm","text":"","title":"linsim_tok_zctrl.m"},{"location":"function-guide/tok_models/linsim_tok_zctrl_m/#basic-information","text":"USAGE: [out_data] = linsim_tok_zctrl(tok_system,tau_ps,T_ps,Vvec, ... Vlims,Kpvec,Kdvec,taupd,iplot,zdisp0,tmax,zmax, ... Gpsweep,Gdsweep,idxacsw) PURPOSE: Function to simulate linear vertical control with standard tau_ps, T_ps power supply definition. Called by script sim_iter_zctrl.m. Simulates response to zdisp0 initial condition INPUTS: tok_system = structure gen. by build_* script containing system data tau_ps = power supply time constant [s] T_ps = power supply delay time (in addition to one-pole tau_ps) [s] Vvec = vector specifying active coils (entries: 0=not active, +/-1 = active positive(negative) voltage/current Vlims = vector giving voltage saturation levels [V] Kpvec = vector giving proportional gain [V/m] Kdvec = vector giving derivative gain [V/m/s] taupd = time constant for 1-pole filter on PD operation [s] iplot = (opt) flag to select plotting (1=plot, 0=don't(default)) zdisp0 = (opt) specific value to calculate displacement trajectory for and plot (if selected) tmax = (opt) max time for simulation (def=1.0 sec) zmax = (opt) max z for plotting (def = 0.9 m) Gpsweep = vector with Gpmin, Gpmax, ngp Gdsweep = vector with Gdmin, Gdmax, ngd idxacsw = idx scalar for selected active coil to plot contours (this must be idx of coil whose peak I, V are negative, since code finds min of time history for contouring) OUTPUTS: out_data = structure that includes histories + plots (if selected) RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/load_tok_objects_m/","text":"load_tok_objects.m \u00b6 Basic Information \u00b6 SYNTAX: tok_data_struct = load_tok_objects(tok,config_name, grid) PURPOSE: Load vacuum data objects for selected device configuration. Provides general access to load_<device>_object.m scripts INPUT: tok = string defining tokamak device or requests for help, eg help or help d3d config_name = string defining configuration name efit_grid = string identifying the EFIT grid resolution OUTPUT: tok_data_struct = vacuum objects data structure CALLING SEQUENCE: tok_data_struct = load_tok_objects('help') tok_data_struct = load_tok_objects('help d3d') Most Current TokSys Models as of 20121005 (need to confirm these...) tok_data_struct = load_tok_objects('d3d','current') RESTRICTIONS: METHOD: WRITTEN BY: Matthew J. Lanctot MODIFICATIONS: MJL 2012/10/05 Created.Provide access to all load_<device>_object.m scripts DAH 2014/7/11 Updated EAST current to 2014","title":"load_tok_objects.m"},{"location":"function-guide/tok_models/load_tok_objects_m/#load_tok_objectsm","text":"","title":"load_tok_objects.m"},{"location":"function-guide/tok_models/load_tok_objects_m/#basic-information","text":"SYNTAX: tok_data_struct = load_tok_objects(tok,config_name, grid) PURPOSE: Load vacuum data objects for selected device configuration. Provides general access to load_<device>_object.m scripts INPUT: tok = string defining tokamak device or requests for help, eg help or help d3d config_name = string defining configuration name efit_grid = string identifying the EFIT grid resolution OUTPUT: tok_data_struct = vacuum objects data structure CALLING SEQUENCE: tok_data_struct = load_tok_objects('help') tok_data_struct = load_tok_objects('help d3d') Most Current TokSys Models as of 20121005 (need to confirm these...) tok_data_struct = load_tok_objects('d3d','current') RESTRICTIONS: METHOD: WRITTEN BY: Matthew J. Lanctot MODIFICATIONS: MJL 2012/10/05 Created.Provide access to all load_<device>_object.m scripts DAH 2014/7/11 Updated EAST current to 2014","title":"Basic Information"},{"location":"function-guide/tok_models/make_ctrlvecs_m/","text":"make_ctrlvecs.m \u00b6 Basic Information \u00b6 USAGE: >> make_ctrlvecs PURPOSE: Script to construct control vectors for M-matrix in PCS. Called from scripts such as make_east_ctrlvecs or make_kstar_ctrlvecs. INPUTS: (Defined in workspace prior to calling make_predictors) Required: objdir = directory containing objects file objfile = objects file name (eg kstar_obj_struct.mat) tokamak = machine name, eg 'KSTAR', 'EAST', (needed for read_gfile_tok) idxcr = PF coil index vector for Rctrlvec idxcz = PF coil index vector for Zctrlvec idxcip = PF coil index vector for Ipctrlvec rrange1 = maj radius range of sub-grid for fields (m) eg [1.5 2] zrange1 = vert range of sub-grid for fields (m) eg [-.5 .5] iusejphi = 1 = use jphi (all current) region for fields, else ??? efit_gfile_grid = gfile to use to define grid from jphi if iusejphi=1 gfile_data = gfile data to use to define grid from jphi (Only one of efit_gfile_grid or gfile_data should be specified.) rrefk zrefk Optional: separate_figures = set to 1 to get 1 figure per plot, otherwise multiple (default) sign_ip = either +1/-1, assuming standard convention for all Ip, PF coils (default 1) iconstraint = set to 1 to constrain Ip ctrl vector elements all one sign, else 0 (default) ipltbp = 1 to plot Bprobes in plot_geo call (0 to not) ipltfl = 1 to plot flux loops in plot_geo call (0 to not) USED??? nprtst = # of princ comp of grid to mag set to use in test nsvdz1,2 = # of sing vals to keep in R pred inverse (for P*pred1,2) nsvdr1,2 = # of sing vals to keep in R pred inverse nsvdi1,2 = # of sing vals to keep in Ip pred inverse nsvdk1,2 = # of sing vals to keep in Kappa pred inverse OUTPUTS: Zctrlvec = Z-ctrl vector (Vpf_Z = Zctrlvec*PID*Zerror) Rctrlvec = R-ctrl vector (Vpf_R = Rctrlvec*PID*Zerror) Ipctrlvec = Ip-ctrl vector (Vpf_R = Rctrlvec*PID*Zerror) (Sign is such that multiplying ctrlvec by positive value => positive change in controlled parameter, except kappa which has indeterminate sign.) + many plots evaluating quality of control vectors in producing specified field RESTRICTIONS: If iusejphi==1, must have efit_gfile_grid defined (which is source of jphi on which grid is based if iusejphi=1) METHOD: Variety of inversions of grid-to-mag objects, linear fits to selected data from subgrids, subset of magnetics...","title":"make_ctrlvecs.m"},{"location":"function-guide/tok_models/make_ctrlvecs_m/#make_ctrlvecsm","text":"","title":"make_ctrlvecs.m"},{"location":"function-guide/tok_models/make_ctrlvecs_m/#basic-information","text":"USAGE: >> make_ctrlvecs PURPOSE: Script to construct control vectors for M-matrix in PCS. Called from scripts such as make_east_ctrlvecs or make_kstar_ctrlvecs. INPUTS: (Defined in workspace prior to calling make_predictors) Required: objdir = directory containing objects file objfile = objects file name (eg kstar_obj_struct.mat) tokamak = machine name, eg 'KSTAR', 'EAST', (needed for read_gfile_tok) idxcr = PF coil index vector for Rctrlvec idxcz = PF coil index vector for Zctrlvec idxcip = PF coil index vector for Ipctrlvec rrange1 = maj radius range of sub-grid for fields (m) eg [1.5 2] zrange1 = vert range of sub-grid for fields (m) eg [-.5 .5] iusejphi = 1 = use jphi (all current) region for fields, else ??? efit_gfile_grid = gfile to use to define grid from jphi if iusejphi=1 gfile_data = gfile data to use to define grid from jphi (Only one of efit_gfile_grid or gfile_data should be specified.) rrefk zrefk Optional: separate_figures = set to 1 to get 1 figure per plot, otherwise multiple (default) sign_ip = either +1/-1, assuming standard convention for all Ip, PF coils (default 1) iconstraint = set to 1 to constrain Ip ctrl vector elements all one sign, else 0 (default) ipltbp = 1 to plot Bprobes in plot_geo call (0 to not) ipltfl = 1 to plot flux loops in plot_geo call (0 to not) USED??? nprtst = # of princ comp of grid to mag set to use in test nsvdz1,2 = # of sing vals to keep in R pred inverse (for P*pred1,2) nsvdr1,2 = # of sing vals to keep in R pred inverse nsvdi1,2 = # of sing vals to keep in Ip pred inverse nsvdk1,2 = # of sing vals to keep in Kappa pred inverse OUTPUTS: Zctrlvec = Z-ctrl vector (Vpf_Z = Zctrlvec*PID*Zerror) Rctrlvec = R-ctrl vector (Vpf_R = Rctrlvec*PID*Zerror) Ipctrlvec = Ip-ctrl vector (Vpf_R = Rctrlvec*PID*Zerror) (Sign is such that multiplying ctrlvec by positive value => positive change in controlled parameter, except kappa which has indeterminate sign.) + many plots evaluating quality of control vectors in producing specified field RESTRICTIONS: If iusejphi==1, must have efit_gfile_grid defined (which is source of jphi on which grid is based if iusejphi=1) METHOD: Variety of inversions of grid-to-mag objects, linear fits to selected data from subgrids, subset of magnetics...","title":"Basic Information"},{"location":"function-guide/tok_models/make_model_script_m/","text":"make_model_script.m \u00b6 Basic Information \u00b6 SYNTAX: make_model_script PURPOSE: Script to build output objects needed to build isoflux models. INPUT: shotnum = shot number time = equilibrium time (ms) tokamak = name of device to build model for tok_data_struct = vacuum data objects for this device out_irzresp = output irzresp value (1, 2, or 3) eqdir = directory where efit equilibrium files are located efit_source = tree in mdsplus to get equilibrium, e.g. EFIT01, EFITRT (only one of either eqdir or efit_source should be specified) OUTPUT: out_objs_<shotnum>_<time>.mat - mat file containing isoflux objects out2_objs_<shotnum>_<time>.mat - mat file containing magnetics objects RESTRICTIONS: Requires existence of script mdl_parms_<shotnum>_<time>.m in your matlab path.","title":"make_model_script.m"},{"location":"function-guide/tok_models/make_model_script_m/#make_model_scriptm","text":"","title":"make_model_script.m"},{"location":"function-guide/tok_models/make_model_script_m/#basic-information","text":"SYNTAX: make_model_script PURPOSE: Script to build output objects needed to build isoflux models. INPUT: shotnum = shot number time = equilibrium time (ms) tokamak = name of device to build model for tok_data_struct = vacuum data objects for this device out_irzresp = output irzresp value (1, 2, or 3) eqdir = directory where efit equilibrium files are located efit_source = tree in mdsplus to get equilibrium, e.g. EFIT01, EFITRT (only one of either eqdir or efit_source should be specified) OUTPUT: out_objs_<shotnum>_<time>.mat - mat file containing isoflux objects out2_objs_<shotnum>_<time>.mat - mat file containing magnetics objects RESTRICTIONS: Requires existence of script mdl_parms_<shotnum>_<time>.m in your matlab path.","title":"Basic Information"},{"location":"function-guide/tok_models/make_noise_file_m/","text":"make_noise_file.m \u00b6 Basic Information \u00b6 SYNTAX: make_noise_file(filename, tstart, tend, dt, num_diags) make_noise_file(filename, tstart, tend, dt, num_diags, vars) make_noise_file(filename, tstart, tend, dt, num_diags, vars, noise_type) PURPOSE: Generate a file containing a noise matrix that can be read into a \"from file\" simulink block and create a soft link to that file called \"noise.mat\". The matrix is formatted such that the first row is a vector of times. Each subsequent row is a time series of noise that can be added to a diagnostic output signal. Row i of the matrix maps to the i-1 diagnostic. INPUTS: filename = the full path to the .mat file that will be created tstart = the starting time of the time vector tend = the end time of the time vector dt = the time step of the time vector num_diags = the number of diagnostic outputs vars = (optional) a vector of variances (sigma^2). Must be of length num_diags. noise_type = (optional) the type of noise to be generated. If vars is specified, defaults to 'gaussian'. Otherwise defaults to 'zeros' (ie no noise). Allowed Values: - 'gaussian' - Noise will be gaussian - 'zeros' - No noise OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise, create_noise_link","title":"make_noise_file.m"},{"location":"function-guide/tok_models/make_noise_file_m/#make_noise_filem","text":"","title":"make_noise_file.m"},{"location":"function-guide/tok_models/make_noise_file_m/#basic-information","text":"SYNTAX: make_noise_file(filename, tstart, tend, dt, num_diags) make_noise_file(filename, tstart, tend, dt, num_diags, vars) make_noise_file(filename, tstart, tend, dt, num_diags, vars, noise_type) PURPOSE: Generate a file containing a noise matrix that can be read into a \"from file\" simulink block and create a soft link to that file called \"noise.mat\". The matrix is formatted such that the first row is a vector of times. Each subsequent row is a time series of noise that can be added to a diagnostic output signal. Row i of the matrix maps to the i-1 diagnostic. INPUTS: filename = the full path to the .mat file that will be created tstart = the starting time of the time vector tend = the end time of the time vector dt = the time step of the time vector num_diags = the number of diagnostic outputs vars = (optional) a vector of variances (sigma^2). Must be of length num_diags. noise_type = (optional) the type of noise to be generated. If vars is specified, defaults to 'gaussian'. Otherwise defaults to 'zeros' (ie no noise). Allowed Values: - 'gaussian' - Noise will be gaussian - 'zeros' - No noise OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise, create_noise_link","title":"Basic Information"},{"location":"function-guide/tok_models/make_noise_m/","text":"make_noise.m \u00b6 Basic Information \u00b6 SYNTAX: make_noise(filename, tstart, tend, dt, num_diags) make_noise(filename, tstart, tend, dt, num_diags, vars) PURPOSE: Generate a file containing a noise matrix that can be read into a \"from file\" simulink block and create a soft link to that file called \"noise.mat\" in the working directory. The matrix is formatted such that the first row is a vector of times. Each subsequent row is a time series of noise that can be added to a diagnostic output signal. Row i of the matrix maps to the i-1 diagnostic. INPUTS: filename = the full path to the .mat file that will be created tstart = the starting time of the time vector tend = the end time of the time vector dt = the time step of the time vector num_diags = the number of diagnostic outputs vars = (optional) a vector of variances (sigma^2). Must be of length num_diags. If vars is not used, then a zero-noise matrix is generated. OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise_file, create_noise_link","title":"make_noise.m"},{"location":"function-guide/tok_models/make_noise_m/#make_noisem","text":"","title":"make_noise.m"},{"location":"function-guide/tok_models/make_noise_m/#basic-information","text":"SYNTAX: make_noise(filename, tstart, tend, dt, num_diags) make_noise(filename, tstart, tend, dt, num_diags, vars) PURPOSE: Generate a file containing a noise matrix that can be read into a \"from file\" simulink block and create a soft link to that file called \"noise.mat\" in the working directory. The matrix is formatted such that the first row is a vector of times. Each subsequent row is a time series of noise that can be added to a diagnostic output signal. Row i of the matrix maps to the i-1 diagnostic. INPUTS: filename = the full path to the .mat file that will be created tstart = the starting time of the time vector tend = the end time of the time vector dt = the time step of the time vector num_diags = the number of diagnostic outputs vars = (optional) a vector of variances (sigma^2). Must be of length num_diags. If vars is not used, then a zero-noise matrix is generated. OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise_file, create_noise_link","title":"Basic Information"},{"location":"function-guide/tok_models/make_out_objs_m/","text":"make_out_objs.m \u00b6 Basic Information \u00b6 SYNTAX: make_out_objs PURPOSE: make output object files using both plasma_output.m and plasma_output2.m INPUT: tokamak ichooseq shotnum = shot number to generate model from tmodel = time of equilibrium to generate model from (ms) outflag = flag to determine which set(s) of output objects to generate 0 = none 1 = run plasma_output, save results 2 = run plasma_output2, save results 3 = run both plasma_output, plasma_output2 - save (default) output_irzresp = set to one of: 0 = use no rigid response 1 = use only rigid r response 2 = use both rigid r and z response vacuum_model', 0, ... iplcirc', 1, ... num_Ecoils = number of E-coils (2 or 5) eqdir = directory where nominal EFIT equilibrium files are located Te_res = li_res = Rp = plasma resistance Zeff_res = isonms = names of isoflux segments bgdnms = names of grids used to compute magnetic field near X points scale_cc_resp = scaling vector for coil currents in response objects scale_vv_resp = scaling vector for vessel currents in response objects OUTPUT files: out_eqn_objects.mat = objects from plasma_output.m out2_eqn_objects.mat = objects from plasma_output2.m RESTRICTIONS: Assumes that drzdi files is of form drzdi_<shotnum>_<tmodel>.mat","title":"make_out_objs.m"},{"location":"function-guide/tok_models/make_out_objs_m/#make_out_objsm","text":"","title":"make_out_objs.m"},{"location":"function-guide/tok_models/make_out_objs_m/#basic-information","text":"SYNTAX: make_out_objs PURPOSE: make output object files using both plasma_output.m and plasma_output2.m INPUT: tokamak ichooseq shotnum = shot number to generate model from tmodel = time of equilibrium to generate model from (ms) outflag = flag to determine which set(s) of output objects to generate 0 = none 1 = run plasma_output, save results 2 = run plasma_output2, save results 3 = run both plasma_output, plasma_output2 - save (default) output_irzresp = set to one of: 0 = use no rigid response 1 = use only rigid r response 2 = use both rigid r and z response vacuum_model', 0, ... iplcirc', 1, ... num_Ecoils = number of E-coils (2 or 5) eqdir = directory where nominal EFIT equilibrium files are located Te_res = li_res = Rp = plasma resistance Zeff_res = isonms = names of isoflux segments bgdnms = names of grids used to compute magnetic field near X points scale_cc_resp = scaling vector for coil currents in response objects scale_vv_resp = scaling vector for vessel currents in response objects OUTPUT files: out_eqn_objects.mat = objects from plasma_output.m out2_eqn_objects.mat = objects from plasma_output2.m RESTRICTIONS: Assumes that drzdi files is of form drzdi_<shotnum>_<tmodel>.mat","title":"Basic Information"},{"location":"function-guide/tok_models/make_predictors_m/","text":"make_predictors.m \u00b6 Basic Information \u00b6 USAGE: predictors = make_predictors(predictor_inputs) PURPOSE: Script to construct plasma geometry predictors from standard environment inputs. Intended to be generic to any standard tokamak system environment.Called from scripts such as make_east_predictors or make_kstar_predictors. INPUTS: (in structure \"predictor_inputs\") tok_data_struct = vacuum geometry objects structure for the device efit_gfile_test = gfile to use (for testing of predictors only) tokamak = machine name, eg 'KSTAR', 'EAST', (needed for read_gfile_tok) idxbpr = index vector to select desired probes for R-predictors idxbpz = index vector to select desired probes for Z-predictors idxbpip = index vector to select desired probes for Ip-predictors idxbpk = index vector to select desired probes for kappa-predictors idxflr = index vector to select desired flux loops for R-predictors idxflz = index vector to select desired flux loops for Z-predictors idxflip = index vector to select desired flux loops for Ip-predictors idxflk = index vector to select desired flux loops for kappa-predictors idxc = PF coil index vector for fitting/testing with EFIT idxv = VV index vector for testing with VV currents rrange1 = maj radius range of sub-grid for predictor 1 (m) eg [1.5 2] zrange1 = vert range of sub-grid for predictor 1 (m) eg [-.5 .5] iusejphi = flag to use jphi (all current) region for fits efit_gfile_grid = gfile to use to define grid from jphi if iusejphi=1 nprtst = # of princ comp of grid to mag set to use in test nsvdz2 = # of sing vals to keep in R pred inverse (for P*pred1,2) nsvdr2 = # of sing vals to keep in R pred inverse nsvdi2 = # of sing vals to keep in Ip pred inverse nsvdk1 = # of sing vals to keep in Kappa pred inverse nrs nzs nkaps nls Rmin,Rmax Zmin,Zmax kapmin,kapmax limin,limax amax Z1,Z2 R1,R2 cctest icomppfr icomppfz icomppfip icomppfk OUTPUTS: (in structure \"predictors\") Pzpred = Z-predictor (Pzpred*[mag]/Ip0 = predicted Z) Prpred = R-predictor (Prpred*[mag]/Ip0 + Rrel = predicted R) Pipred = Ip-predictor (Pipred*[Bprobes] = predicted Ip) Pkpred = kappa-predictor (Pkpred*[mag]/Ip0??? = predicted kappa) Rpred Zpred Ippred Kpred + many plots evaluating quality of predictors RESTRICTIONS: Specified objects file must provide units desired in predictor (eg if want predictor based on mks, must use mks object file). Comments in code assume MA-based objects (eg east_objects.mat), but should be consistent with mks/terminal choice if use those object files). If iusejphi==1, must have efit_gfile_grid defined (which is source of jphi on which grid is based if iusejphi=1) METHOD: Variety of inversions of grid-to-mag objects, linear fits to selected data from subgrids, subset of magnetics...","title":"make_predictors.m"},{"location":"function-guide/tok_models/make_predictors_m/#make_predictorsm","text":"","title":"make_predictors.m"},{"location":"function-guide/tok_models/make_predictors_m/#basic-information","text":"USAGE: predictors = make_predictors(predictor_inputs) PURPOSE: Script to construct plasma geometry predictors from standard environment inputs. Intended to be generic to any standard tokamak system environment.Called from scripts such as make_east_predictors or make_kstar_predictors. INPUTS: (in structure \"predictor_inputs\") tok_data_struct = vacuum geometry objects structure for the device efit_gfile_test = gfile to use (for testing of predictors only) tokamak = machine name, eg 'KSTAR', 'EAST', (needed for read_gfile_tok) idxbpr = index vector to select desired probes for R-predictors idxbpz = index vector to select desired probes for Z-predictors idxbpip = index vector to select desired probes for Ip-predictors idxbpk = index vector to select desired probes for kappa-predictors idxflr = index vector to select desired flux loops for R-predictors idxflz = index vector to select desired flux loops for Z-predictors idxflip = index vector to select desired flux loops for Ip-predictors idxflk = index vector to select desired flux loops for kappa-predictors idxc = PF coil index vector for fitting/testing with EFIT idxv = VV index vector for testing with VV currents rrange1 = maj radius range of sub-grid for predictor 1 (m) eg [1.5 2] zrange1 = vert range of sub-grid for predictor 1 (m) eg [-.5 .5] iusejphi = flag to use jphi (all current) region for fits efit_gfile_grid = gfile to use to define grid from jphi if iusejphi=1 nprtst = # of princ comp of grid to mag set to use in test nsvdz2 = # of sing vals to keep in R pred inverse (for P*pred1,2) nsvdr2 = # of sing vals to keep in R pred inverse nsvdi2 = # of sing vals to keep in Ip pred inverse nsvdk1 = # of sing vals to keep in Kappa pred inverse nrs nzs nkaps nls Rmin,Rmax Zmin,Zmax kapmin,kapmax limin,limax amax Z1,Z2 R1,R2 cctest icomppfr icomppfz icomppfip icomppfk OUTPUTS: (in structure \"predictors\") Pzpred = Z-predictor (Pzpred*[mag]/Ip0 = predicted Z) Prpred = R-predictor (Prpred*[mag]/Ip0 + Rrel = predicted R) Pipred = Ip-predictor (Pipred*[Bprobes] = predicted Ip) Pkpred = kappa-predictor (Pkpred*[mag]/Ip0??? = predicted kappa) Rpred Zpred Ippred Kpred + many plots evaluating quality of predictors RESTRICTIONS: Specified objects file must provide units desired in predictor (eg if want predictor based on mks, must use mks object file). Comments in code assume MA-based objects (eg east_objects.mat), but should be consistent with mks/terminal choice if use those object files). If iusejphi==1, must have efit_gfile_grid defined (which is source of jphi on which grid is based if iusejphi=1) METHOD: Variety of inversions of grid-to-mag objects, linear fits to selected data from subgrids, subset of magnetics...","title":"Basic Information"},{"location":"function-guide/tok_models/make_tok_data_struct_m/","text":"make_tok_data_struct.m \u00b6 Basic Information \u00b6 SYNTAX: tok_data = make_tok_data_struct(datafiles,imks,iterminal) PURPOSE: Convert data contained in \"environment\" files into a standard format tokamak data structure. INPUT: datafiles = string array (size nfiles by max name length) of *.mat files containing tokamak environment data imks = if 1, input objects in datafiles are mks, else 0 (default=MA,uH) iterminal = if 1, input objects are terminal units, else 0 (default) OUTPUT: tok_data = data structure constructed from this data. Contains: - data objects - units = units of data objects - description = descriptions of data objects","title":"make_tok_data_struct.m"},{"location":"function-guide/tok_models/make_tok_data_struct_m/#make_tok_data_structm","text":"","title":"make_tok_data_struct.m"},{"location":"function-guide/tok_models/make_tok_data_struct_m/#basic-information","text":"SYNTAX: tok_data = make_tok_data_struct(datafiles,imks,iterminal) PURPOSE: Convert data contained in \"environment\" files into a standard format tokamak data structure. INPUT: datafiles = string array (size nfiles by max name length) of *.mat files containing tokamak environment data imks = if 1, input objects in datafiles are mks, else 0 (default=MA,uH) iterminal = if 1, input objects are terminal units, else 0 (default) OUTPUT: tok_data = data structure constructed from this data. Contains: - data objects - units = units of data objects - description = descriptions of data objects","title":"Basic Information"},{"location":"function-guide/tok_models/make_tok_objects_m/","text":"make_tok_objects.m \u00b6 Basic Information \u00b6 USAGE: make_tok_objects(make_tok_inputs,procedures) PURPOSE: Script to calculate vacuum data objects (e.g. mutuals, Green fns) for a tokamak system model. The \"minimal\" set of objects which must be defined is VV, FC. INPUTS (see TokSys_Users_Guide.pdf): make_tok_inputs = data structure defining how to make data objects. This structure must contain: tokamak = string defining tokamak being constructed, used in file names config_name = string label identifying machine configuration (Warning: non-alphanumeric chars in config_name may cause problems) datadir = directory where files defining tokamak are located vvdata_file = Filename for vvdata data (must be of form *.data) (actually just has to have 4 characters after \".\", and must have a name distinct from all the other *.data) fcdata_file = Fcoil data file (name must be of same form as vvdata) fcnturn_file = file with PF turns nminvv = # of conductors in *min* dimension of vacuum vessel elts (can be scalar or vector with length=#vessel elts) nminfc = # of conductors in *min* dimension of fcoils (can be scalar or vector with length=#fcoils) Vessel resistance data, either: etav = VV resistivity vector, uOhm-m OR vvres_file = file with vessel element (terminal) resistances (Ohms) PF coil resistance data, either: etaf = Fcoil resistivity vector, uOhm-m (NOTE: for SC coils, set etaf=1e-3*eta(Cu)) OR fcres_file = file with coil element (terminal) resistances (Ohms) TD coil resistance data, either: etat = TD coil resistivity vector, uOhm-m OR tdres_file = file with coil element (terminal) resistances (Ohms) Optionally, it may contain: ecdata_file = Ecoil data file (name must be of same form as vvdata) ecturn_file = ecoil turn groupings vvfrac_file = file with vacuum vessel fractions of currents fldata_file = Flux loop data file bpdata_file = Bprobe data file msedata_file = MSE loci file rldata_file = Rogowski loop data file lvdata_file = Loop voltage data file limdata_file = file containing limiter definition data (npts x 2) nr,nz = # of grid elem. in r,z dir. (if~=0, must also enter values for rgmin,rgmax,zgmin,zgmax - see below) rgmin,rgmax = Min,max in major radial dimension on plasma grid [m] zgmin,zgmax = Min,max in vertical dimension on plasma grid [m] E-coil resistance data (required if ecdata_file used), either: etae = Ecoil resistivity vector, uOhm-m OR ecres_file = file with coil element (terminal) resistances (Ohms) fcnames_file = file containing fcoil names vvnames_file = file containing vessel element names flnames_file = file containing flux loop names bpnames_file = file containing Bprobe names msenames_file = file containing names of MSE channels that view points in msedata rlnames_file = file containing Rogowski loop names lvnames_file = file containing loop voltage names nminec = # of conductors in *min* dimension of ecoils. Required if ecdata_file is used. (scalar or vector of length=#ecoils) nmingg = scalar # of conductors in *min* dimension of plasma grid Required if plasma grid inputs used. plot_tok_geo_fn = string defining script to execute to plot the geometry of the device (e.g. 'plot_kstar_geo', 'plot_east_geo'... set to 'generic' (default) to use default to plot X-section ecsignals_file = E coil signal names file fcsignals_file = F coil signal names file flsignals_file = flux loop signal names file bpsignals_file = B probe signal names file rlsignals_file = Rogowski loop signal names file lvsignals_file = loop voltage signal names file procedures = array of strings defining procedures to operate on the data after generation (optional, default = []) OUTPUTS: save files <tokamak>_obj_<config_name> = contains structure tok_data_struct, units= terminal, MKS (in file name, '/' replaced by '-', ' ' by '_', '\\' by '')","title":"make_tok_objects.m"},{"location":"function-guide/tok_models/make_tok_objects_m/#make_tok_objectsm","text":"","title":"make_tok_objects.m"},{"location":"function-guide/tok_models/make_tok_objects_m/#basic-information","text":"USAGE: make_tok_objects(make_tok_inputs,procedures) PURPOSE: Script to calculate vacuum data objects (e.g. mutuals, Green fns) for a tokamak system model. The \"minimal\" set of objects which must be defined is VV, FC. INPUTS (see TokSys_Users_Guide.pdf): make_tok_inputs = data structure defining how to make data objects. This structure must contain: tokamak = string defining tokamak being constructed, used in file names config_name = string label identifying machine configuration (Warning: non-alphanumeric chars in config_name may cause problems) datadir = directory where files defining tokamak are located vvdata_file = Filename for vvdata data (must be of form *.data) (actually just has to have 4 characters after \".\", and must have a name distinct from all the other *.data) fcdata_file = Fcoil data file (name must be of same form as vvdata) fcnturn_file = file with PF turns nminvv = # of conductors in *min* dimension of vacuum vessel elts (can be scalar or vector with length=#vessel elts) nminfc = # of conductors in *min* dimension of fcoils (can be scalar or vector with length=#fcoils) Vessel resistance data, either: etav = VV resistivity vector, uOhm-m OR vvres_file = file with vessel element (terminal) resistances (Ohms) PF coil resistance data, either: etaf = Fcoil resistivity vector, uOhm-m (NOTE: for SC coils, set etaf=1e-3*eta(Cu)) OR fcres_file = file with coil element (terminal) resistances (Ohms) TD coil resistance data, either: etat = TD coil resistivity vector, uOhm-m OR tdres_file = file with coil element (terminal) resistances (Ohms) Optionally, it may contain: ecdata_file = Ecoil data file (name must be of same form as vvdata) ecturn_file = ecoil turn groupings vvfrac_file = file with vacuum vessel fractions of currents fldata_file = Flux loop data file bpdata_file = Bprobe data file msedata_file = MSE loci file rldata_file = Rogowski loop data file lvdata_file = Loop voltage data file limdata_file = file containing limiter definition data (npts x 2) nr,nz = # of grid elem. in r,z dir. (if~=0, must also enter values for rgmin,rgmax,zgmin,zgmax - see below) rgmin,rgmax = Min,max in major radial dimension on plasma grid [m] zgmin,zgmax = Min,max in vertical dimension on plasma grid [m] E-coil resistance data (required if ecdata_file used), either: etae = Ecoil resistivity vector, uOhm-m OR ecres_file = file with coil element (terminal) resistances (Ohms) fcnames_file = file containing fcoil names vvnames_file = file containing vessel element names flnames_file = file containing flux loop names bpnames_file = file containing Bprobe names msenames_file = file containing names of MSE channels that view points in msedata rlnames_file = file containing Rogowski loop names lvnames_file = file containing loop voltage names nminec = # of conductors in *min* dimension of ecoils. Required if ecdata_file is used. (scalar or vector of length=#ecoils) nmingg = scalar # of conductors in *min* dimension of plasma grid Required if plasma grid inputs used. plot_tok_geo_fn = string defining script to execute to plot the geometry of the device (e.g. 'plot_kstar_geo', 'plot_east_geo'... set to 'generic' (default) to use default to plot X-section ecsignals_file = E coil signal names file fcsignals_file = F coil signal names file flsignals_file = flux loop signal names file bpsignals_file = B probe signal names file rlsignals_file = Rogowski loop signal names file lvsignals_file = loop voltage signal names file procedures = array of strings defining procedures to operate on the data after generation (optional, default = []) OUTPUTS: save files <tokamak>_obj_<config_name> = contains structure tok_data_struct, units= terminal, MKS (in file name, '/' replaced by '-', ' ' by '_', '\\' by '')","title":"Basic Information"},{"location":"function-guide/tok_models/makelpcur_m/","text":"makelpcur.m \u00b6 Basic Information \u00b6 SYNTAX: (function) [cphi,ipfil,izg,irg]=makelpcur(zgg,rgg,ip,zp,rp,ap,kap,limod,nfil,iaddctr) PURPOSE: Function to make elliptical cross-section, flat to parabolic plasma current distr. defined on standard EPGenv grid. INPUTS: zgg = array of vertical position of grid points on nzxnr grid [m] rgg = array of maj. radial position of grid points on nzxnr grid [m] ip = total plasma current = sum(sum(cphi)) [conventionally MA, but can be any units] zp = current centroid vertical position [m] rp = current centroid major radial position [m] ap = minor radius at plasma midplane [m] kap = elongation of elliptical current distribution limod = (optional) specifies the distribution type & peakedness of profile: if limod>0 (continuous distribution): limod=0.5 -> flat profile, limod>=1.0 -> parabolic profile. Default = 1.0 (parabolic distribution) if limod<=0 (discrete filamentary distribution, MFIT-like): limod=0 -> filament at nearest grid point to rp,zp limod=-0.5 -> filaments at 0.5ap, kap ellipse. limod=-1 -> filaments at edge of ap,kap ellipse. nfil = (optional; required if limod<=0) number of filaments. Should be even number >= 4 to have 2 filaments on midplane, equal number above and below midplane. However, algorithm will work with any number. iaddctr = (optional; use only if limod<0) if =1, adds filament at grid point nearest (zp,rp) location. OUTPUTS: cphi = plasma current distribution on nzxnr grid [MA, but see ip above] Note that cphi consists of current filaments, NOT CURRENT DENSITY!! Thus ip = total(cphi); ipfil = vector of currents in each filament irg = vector of radial indices corresponding to locations of current fils in order of ipfil (indices are indices of nrx1 rg vector) izg = vector of vertical indices corresponding to locations of current fils in order of ipfil (indices are indices of nzx1 zg vector) RESTRICTIONS: Must have loaded DIII-D geometry environment (>> load_d3denv) or otherwise defined rgg, zgg. nfil should be even number >=4 to have up-down symmetric distribution with 2 filaments on plasma midplane. However, algorithm will work with any number. Note that the final number of filaments may not equal nfil if the original distribution of nfil filaments is too dense for the grid. Note also that limod=0 will produce a one-filament distribution regardless of nfil (since the nfil points will all be located at rp,zp, resulting in a single grid point being used for the filament. METHOD: Taken from IDL makelpcur.pro. Filament ring algorithm (limod<=0) developed after Matlab version. For this case, the filaments are placed in the grid points nearest to the originally calculated locations on the ellipse. The current in each filament is simply ip/nfil, so that the resulting current centroid is not necessarily at (rp,zp). Should fix this at some point... DAH Another option is to make limod (when negative) tell it what fraction of current goes in the central filamnet relative to the edge ones. DAH","title":"makelpcur.m"},{"location":"function-guide/tok_models/makelpcur_m/#makelpcurm","text":"","title":"makelpcur.m"},{"location":"function-guide/tok_models/makelpcur_m/#basic-information","text":"SYNTAX: (function) [cphi,ipfil,izg,irg]=makelpcur(zgg,rgg,ip,zp,rp,ap,kap,limod,nfil,iaddctr) PURPOSE: Function to make elliptical cross-section, flat to parabolic plasma current distr. defined on standard EPGenv grid. INPUTS: zgg = array of vertical position of grid points on nzxnr grid [m] rgg = array of maj. radial position of grid points on nzxnr grid [m] ip = total plasma current = sum(sum(cphi)) [conventionally MA, but can be any units] zp = current centroid vertical position [m] rp = current centroid major radial position [m] ap = minor radius at plasma midplane [m] kap = elongation of elliptical current distribution limod = (optional) specifies the distribution type & peakedness of profile: if limod>0 (continuous distribution): limod=0.5 -> flat profile, limod>=1.0 -> parabolic profile. Default = 1.0 (parabolic distribution) if limod<=0 (discrete filamentary distribution, MFIT-like): limod=0 -> filament at nearest grid point to rp,zp limod=-0.5 -> filaments at 0.5ap, kap ellipse. limod=-1 -> filaments at edge of ap,kap ellipse. nfil = (optional; required if limod<=0) number of filaments. Should be even number >= 4 to have 2 filaments on midplane, equal number above and below midplane. However, algorithm will work with any number. iaddctr = (optional; use only if limod<0) if =1, adds filament at grid point nearest (zp,rp) location. OUTPUTS: cphi = plasma current distribution on nzxnr grid [MA, but see ip above] Note that cphi consists of current filaments, NOT CURRENT DENSITY!! Thus ip = total(cphi); ipfil = vector of currents in each filament irg = vector of radial indices corresponding to locations of current fils in order of ipfil (indices are indices of nrx1 rg vector) izg = vector of vertical indices corresponding to locations of current fils in order of ipfil (indices are indices of nzx1 zg vector) RESTRICTIONS: Must have loaded DIII-D geometry environment (>> load_d3denv) or otherwise defined rgg, zgg. nfil should be even number >=4 to have up-down symmetric distribution with 2 filaments on plasma midplane. However, algorithm will work with any number. Note that the final number of filaments may not equal nfil if the original distribution of nfil filaments is too dense for the grid. Note also that limod=0 will produce a one-filament distribution regardless of nfil (since the nfil points will all be located at rp,zp, resulting in a single grid point being used for the filament. METHOD: Taken from IDL makelpcur.pro. Filament ring algorithm (limod<=0) developed after Matlab version. For this case, the filaments are placed in the grid points nearest to the originally calculated locations on the ellipse. The current in each filament is simply ip/nfil, so that the resulting current centroid is not necessarily at (rp,zp). Should fix this at some point... DAH Another option is to make limod (when negative) tell it what fraction of current goes in the central filamnet relative to the edge ones. DAH","title":"Basic Information"},{"location":"function-guide/tok_models/mpp_x_vec_m/","text":"mpp_x_vec.m \u00b6 Basic Information \u00b6 SYNTAX: product = mpp_x_vec(mpp,vec) PURPOSE: Compute product of matrix mpp and vector vec, where mpp is stored in compressed format with dimension nz*nr x nr. Can be used also for gbz2p in place of mpp. Use gbr2p_x_vec for multiplication with gbr2p. INPUT: mpp = grid to grid mutuals in compressed format vec = vector or matrix with size = nz x nr x n OR nz*nr x n, where final dimension n is arbitrary. (E.g., n=1 usually represents a single current distribution on plasma grid, while n>1 can represent current distributions at multiple times.) OUTPUT: product = product of matrix multiplication, same size as vec SEE ALSO: get_plasma_greens, gbr2p_x_vec","title":"mpp_x_vec.m"},{"location":"function-guide/tok_models/mpp_x_vec_m/#mpp_x_vecm","text":"","title":"mpp_x_vec.m"},{"location":"function-guide/tok_models/mpp_x_vec_m/#basic-information","text":"SYNTAX: product = mpp_x_vec(mpp,vec) PURPOSE: Compute product of matrix mpp and vector vec, where mpp is stored in compressed format with dimension nz*nr x nr. Can be used also for gbz2p in place of mpp. Use gbr2p_x_vec for multiplication with gbr2p. INPUT: mpp = grid to grid mutuals in compressed format vec = vector or matrix with size = nz x nr x n OR nz*nr x n, where final dimension n is arbitrary. (E.g., n=1 usually represents a single current distribution on plasma grid, while n>1 can represent current distributions at multiple times.) OUTPUT: product = product of matrix multiplication, same size as vec SEE ALSO: get_plasma_greens, gbr2p_x_vec","title":"Basic Information"},{"location":"function-guide/tok_models/plasma_out_common_m/","text":"plasma_out_common.m \u00b6 Basic Information \u00b6 SYNTAX: plasma_out_common PURPOSE: common code for all \"plasma_output\" routines INPUT: equil_data = rzrig_data = irzresp = set to: 0 = use no rigid response 1 = use only rigid r response 2 = use both rigid r and z response num_Ecoils rgg zg rg mvv jphi0 fcnturn cc0 = coil currents from EFIT (MA-turns) include_Ip EB_out (optional, default=1 if num_Ecoils=5) plasma_obj_file = name of plasma_objects.mat file (if include_Ip=1) OUTPUT: (units depend on input objects - need to correct comments) cvnturn drdi (m/MA) dzdi (m/MA) CRZmat (m/A) dcrzdi (A/A) dcrzdip (A/A) dcrzdbetap (A/?) dcrzdli (A/?) ir iz idxpf cphi0 = EFIT equilibrium plasma current distribution (MA) cc0 = cc0 converted to MA from MA-turns mu0 = 0.4*pi; twopi = 2*pi; twopir = twopi*rgg(:) dz = (m) dr = (m) nvv = size(mvv,1) ncurrents irscl izscl ccnturn","title":"plasma_out_common.m"},{"location":"function-guide/tok_models/plasma_out_common_m/#plasma_out_commonm","text":"","title":"plasma_out_common.m"},{"location":"function-guide/tok_models/plasma_out_common_m/#basic-information","text":"SYNTAX: plasma_out_common PURPOSE: common code for all \"plasma_output\" routines INPUT: equil_data = rzrig_data = irzresp = set to: 0 = use no rigid response 1 = use only rigid r response 2 = use both rigid r and z response num_Ecoils rgg zg rg mvv jphi0 fcnturn cc0 = coil currents from EFIT (MA-turns) include_Ip EB_out (optional, default=1 if num_Ecoils=5) plasma_obj_file = name of plasma_objects.mat file (if include_Ip=1) OUTPUT: (units depend on input objects - need to correct comments) cvnturn drdi (m/MA) dzdi (m/MA) CRZmat (m/A) dcrzdi (A/A) dcrzdip (A/A) dcrzdbetap (A/?) dcrzdli (A/?) ir iz idxpf cphi0 = EFIT equilibrium plasma current distribution (MA) cc0 = cc0 converted to MA from MA-turns mu0 = 0.4*pi; twopi = 2*pi; twopir = twopi*rgg(:) dz = (m) dr = (m) nvv = size(mvv,1) ncurrents irscl izscl ccnturn","title":"Basic Information"},{"location":"function-guide/tok_models/plasma_output2_m/","text":"plasma_output2.m \u00b6 Basic Information \u00b6 ARE UNITS ON MPL AND GPB CORRECT?? SYNTAX: output2_objs= ... plasma_output2(equil_data,rzrig_data,vacuum_objs,build_inputs) PURPOSE: Calculate DIII-D plasma response output equation objects for rigid plasma. Diagnostics are some or all of normal DIII-D diagnostics. Run plasma_dynamics.m first to create the file plasma_objects.mat. INPUT: equil_data = equilibrium data structure rzrig_data = data structure generated by rzrig vacuum_objs = data structure containing standard tokamak geometry objects build_inputs = (see plasma_dynamics) OUTPUTS: output2_objs: CXd = diagnostics flux, Br, Bz response due to plasma motion from I_cond (=d[Psi, B ]pl/dIcond), Wb/A and T/A CXp = diagnostics flux, Br, Bz response due to plasma current change from I_cond (=d[Psi, B ]pl/dIcond), Wb/A and T/A Gp = diagnostics flux, Br, Bz response due to plasma current (Ip) change CRZmat = Plasma R, Z response to I_cond (m/A) plasma_row = row vector to multiply by conductor currents to get Ip in the case that Rp=0 dcrzdi', dcrzdi, ... dcrzdip', dcrzdip, ... dcrzdbetap', dcrzdbetap, ... dcrzdli', dcrzdli, ... CXbetap = diagnostics flux, Br, Bz response due to changes in betap (=d[Psi, B ]pl/dbetap), Wb/? and T/? CXli = diagnostics flux, Br, Bz response due to changes in li (=d[Psi, B ]pl/dli), Wb/? and T/? RESTRICTIONS: (1) Ip model only works for single filament (2) Assumes all objects are in mks/terminal units. METHOD:","title":"plasma_output2.m"},{"location":"function-guide/tok_models/plasma_output2_m/#plasma_output2m","text":"","title":"plasma_output2.m"},{"location":"function-guide/tok_models/plasma_output2_m/#basic-information","text":"ARE UNITS ON MPL AND GPB CORRECT?? SYNTAX: output2_objs= ... plasma_output2(equil_data,rzrig_data,vacuum_objs,build_inputs) PURPOSE: Calculate DIII-D plasma response output equation objects for rigid plasma. Diagnostics are some or all of normal DIII-D diagnostics. Run plasma_dynamics.m first to create the file plasma_objects.mat. INPUT: equil_data = equilibrium data structure rzrig_data = data structure generated by rzrig vacuum_objs = data structure containing standard tokamak geometry objects build_inputs = (see plasma_dynamics) OUTPUTS: output2_objs: CXd = diagnostics flux, Br, Bz response due to plasma motion from I_cond (=d[Psi, B ]pl/dIcond), Wb/A and T/A CXp = diagnostics flux, Br, Bz response due to plasma current change from I_cond (=d[Psi, B ]pl/dIcond), Wb/A and T/A Gp = diagnostics flux, Br, Bz response due to plasma current (Ip) change CRZmat = Plasma R, Z response to I_cond (m/A) plasma_row = row vector to multiply by conductor currents to get Ip in the case that Rp=0 dcrzdi', dcrzdi, ... dcrzdip', dcrzdip, ... dcrzdbetap', dcrzdbetap, ... dcrzdli', dcrzdli, ... CXbetap = diagnostics flux, Br, Bz response due to changes in betap (=d[Psi, B ]pl/dbetap), Wb/? and T/? CXli = diagnostics flux, Br, Bz response due to changes in li (=d[Psi, B ]pl/dli), Wb/? and T/? RESTRICTIONS: (1) Ip model only works for single filament (2) Assumes all objects are in mks/terminal units. METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/plasma_output_m/","text":"plasma_output.m \u00b6 Basic Information \u00b6 SYNTAX: plasma_output PURPOSE: Calculate DIII-D plasma response output equation objects for rigid plasma. Outputs are control point fluxes and field at X-point. Run plasma_dynamics.m first to create the file plasma_objects.mat. INPUTS: build_inputs = structure containing: tokamak: name of the device (e.g. 'd3d', 'nstx', 'east', etc) ichooseq: output_irzresp: 0 = use no rigid response 1 = use only rigid r response 2 = use only rigid z response 3 = use both rigid r and z response vacuum_model: iplcirc: set=1 to include Ip variation model (optional, default 0) Te_res: li_res: Rp: Zeff_res: ccnturn: efit_gfile OR efit_source fcid: vvid: vvfrac: calc_resp: make_resp_dir: efit_source: shotnum: time: num_Ecoils: for D3D, set to 2 or 6; all other devices, 0 (default) vacuum_objs = isoflux_defns = structure containing isonms, ref_num, bgrdnms rzrig_data = scale_cc_resp = (optional) scale_vv_resp = (optional) ARE THESE USED?? From plasma_objects.mat (only needed if iplcirc=1 and Rp=0): Mpd = mutuals from plasma filament to conductors (H) Lp = plasma self-inductance(H) Rp = plasma resistance(Ohms) Xpp = (H) Xpd = (H) plasma_obj_file = name of plasma_objects.mat file (if needed, see above) plasma_obj_log = Text file containing parameter settings which created plasma_objects file. Must have same prefix as plasma_objects file and suffix = \".log\" (file name will be constructed if needed) efit_gfile = EFIT g0-file name OR efit_source OUTPUTS: output_objs = structure (saved in out_objs_<shot>_<time>.mat) containing: nptiso = array of number of points in each isoflux segment (isonms) nptbgd = array of number of points in each bgrid segment (bgrdnms) (define here totiso=sum(nptiso), totbgd=sum(nptbgd), ncond = necoils + nfcoils + nvv) nptbgd2 = array of number of points in each bgrid segment (bgrdnms2) CXmatI = Ctrl. pt. and gridpt flux response due to plasma motion from I_cond (=d[Psi_isflux, Psi_grid]pl/dIcond), Wb/A (size = (totiso+totbgd) x ncond) CXmatBR, CXmatBZ = gridpt. Br, Bz response due to plasma motion from I_cond (=d[Br_grid, Bz_grid,...]pl/dIcond), T/A (size = totbgd x ncond) CmatI = Ctrl. pt. and gridpt flux, response due to plasma+cond from I_cond (=d[Psi_segments,Psi_grid(s)]tot/dIcond), Wb/A (size = (totiso+totbgd) x ncond). For indices representing grid, first index represents indexing through the grid by rows first. CmatBR, CmatBZ = Grid pt. Br, Bz response due to plasma+cond from I_cond (=d[Br, Bz,...]tot/dIcond), T/A (size = totbgd x ncond) First index represents indexing through the grid by rows first. CRZmat = Plasma R, Z response to I_cond (m/A) Psi0 = equilibrium values of flux (Wb) on all control pts (size = totiso+totbgd x 1) BR0, BZ0 = equilibrium values of field (T) on control grid (size = totbgd x 1) CYmatI = Ctrl. pt. and gridpt flux response due to plasma current change (=d[Psi_isflux,Psi_grid]/dIpl) Wb/A (size = totiso+totbgd x 1) CYmatBR, CYmatBZ = grid pt. Br, Bz response due to plasma current change (=d[Brgrid, Bzgrid]pl/dIpl) T/A (size = totbgd x ncond) CmatIbetap = ctrl pt and gridpt flux response due to changes in betap (=d[Psi_iso, Psi_grid]pl/dbetap), Wb/unit-beta (size = totiso+totbgd x 1) CmatBRbetap, CmatBZbetap = gridpt Br, Bz response due to changes in betap (=d[Bgrid]pl/dbetap), T/unit-beta (size = totbgd x 1) CmatIli = ctrl pt and gridpt flux response due to changes in li (=d[Psi_iso,Psi_grid ]pl/dli), Wb/unit-li (size = totiso+totbgd x 1) CmatBRli, CmatBZli = gridpt Br, Bz response due to changes in li (=d[Bgrid ]pl/dli), T/unit-li (size = totbgd x 1) rbgd = r coordinates of grid pts zbgd = z coordinates of grid pts rbgd2 = r coordinates of grid pts, grid 2 zbgd2 = z coordinates of grid pts, grid 2 Log file out_objs_<shot>_<time>.log RESTRICTIONS: (1) Works only for D3D and NSTX (so far). (2) Ip model only works for single filament (idxfil) (3) Data file data_file must exist and contain Green function data for control point response to current in conductors and on grid. (4) NOTE that sizes of output objects are defined by the data in the \"sizedata\" array - may not match size in tok_data_struct OR size in tok_system. METHOD: (1) Green's functions from coils, vessel, and plasma grid points to the isoflux control points are stored in files and read in by read_response.m - \"help read_response\" for Green function conventions. (2) plasma current variation objects only have 1 d.o.f. but a distributed current; a current wtd average is used.","title":"plasma_output.m"},{"location":"function-guide/tok_models/plasma_output_m/#plasma_outputm","text":"","title":"plasma_output.m"},{"location":"function-guide/tok_models/plasma_output_m/#basic-information","text":"SYNTAX: plasma_output PURPOSE: Calculate DIII-D plasma response output equation objects for rigid plasma. Outputs are control point fluxes and field at X-point. Run plasma_dynamics.m first to create the file plasma_objects.mat. INPUTS: build_inputs = structure containing: tokamak: name of the device (e.g. 'd3d', 'nstx', 'east', etc) ichooseq: output_irzresp: 0 = use no rigid response 1 = use only rigid r response 2 = use only rigid z response 3 = use both rigid r and z response vacuum_model: iplcirc: set=1 to include Ip variation model (optional, default 0) Te_res: li_res: Rp: Zeff_res: ccnturn: efit_gfile OR efit_source fcid: vvid: vvfrac: calc_resp: make_resp_dir: efit_source: shotnum: time: num_Ecoils: for D3D, set to 2 or 6; all other devices, 0 (default) vacuum_objs = isoflux_defns = structure containing isonms, ref_num, bgrdnms rzrig_data = scale_cc_resp = (optional) scale_vv_resp = (optional) ARE THESE USED?? From plasma_objects.mat (only needed if iplcirc=1 and Rp=0): Mpd = mutuals from plasma filament to conductors (H) Lp = plasma self-inductance(H) Rp = plasma resistance(Ohms) Xpp = (H) Xpd = (H) plasma_obj_file = name of plasma_objects.mat file (if needed, see above) plasma_obj_log = Text file containing parameter settings which created plasma_objects file. Must have same prefix as plasma_objects file and suffix = \".log\" (file name will be constructed if needed) efit_gfile = EFIT g0-file name OR efit_source OUTPUTS: output_objs = structure (saved in out_objs_<shot>_<time>.mat) containing: nptiso = array of number of points in each isoflux segment (isonms) nptbgd = array of number of points in each bgrid segment (bgrdnms) (define here totiso=sum(nptiso), totbgd=sum(nptbgd), ncond = necoils + nfcoils + nvv) nptbgd2 = array of number of points in each bgrid segment (bgrdnms2) CXmatI = Ctrl. pt. and gridpt flux response due to plasma motion from I_cond (=d[Psi_isflux, Psi_grid]pl/dIcond), Wb/A (size = (totiso+totbgd) x ncond) CXmatBR, CXmatBZ = gridpt. Br, Bz response due to plasma motion from I_cond (=d[Br_grid, Bz_grid,...]pl/dIcond), T/A (size = totbgd x ncond) CmatI = Ctrl. pt. and gridpt flux, response due to plasma+cond from I_cond (=d[Psi_segments,Psi_grid(s)]tot/dIcond), Wb/A (size = (totiso+totbgd) x ncond). For indices representing grid, first index represents indexing through the grid by rows first. CmatBR, CmatBZ = Grid pt. Br, Bz response due to plasma+cond from I_cond (=d[Br, Bz,...]tot/dIcond), T/A (size = totbgd x ncond) First index represents indexing through the grid by rows first. CRZmat = Plasma R, Z response to I_cond (m/A) Psi0 = equilibrium values of flux (Wb) on all control pts (size = totiso+totbgd x 1) BR0, BZ0 = equilibrium values of field (T) on control grid (size = totbgd x 1) CYmatI = Ctrl. pt. and gridpt flux response due to plasma current change (=d[Psi_isflux,Psi_grid]/dIpl) Wb/A (size = totiso+totbgd x 1) CYmatBR, CYmatBZ = grid pt. Br, Bz response due to plasma current change (=d[Brgrid, Bzgrid]pl/dIpl) T/A (size = totbgd x ncond) CmatIbetap = ctrl pt and gridpt flux response due to changes in betap (=d[Psi_iso, Psi_grid]pl/dbetap), Wb/unit-beta (size = totiso+totbgd x 1) CmatBRbetap, CmatBZbetap = gridpt Br, Bz response due to changes in betap (=d[Bgrid]pl/dbetap), T/unit-beta (size = totbgd x 1) CmatIli = ctrl pt and gridpt flux response due to changes in li (=d[Psi_iso,Psi_grid ]pl/dli), Wb/unit-li (size = totiso+totbgd x 1) CmatBRli, CmatBZli = gridpt Br, Bz response due to changes in li (=d[Bgrid ]pl/dli), T/unit-li (size = totbgd x 1) rbgd = r coordinates of grid pts zbgd = z coordinates of grid pts rbgd2 = r coordinates of grid pts, grid 2 zbgd2 = z coordinates of grid pts, grid 2 Log file out_objs_<shot>_<time>.log RESTRICTIONS: (1) Works only for D3D and NSTX (so far). (2) Ip model only works for single filament (idxfil) (3) Data file data_file must exist and contain Green function data for control point response to current in conductors and on grid. (4) NOTE that sizes of output objects are defined by the data in the \"sizedata\" array - may not match size in tok_data_struct OR size in tok_system. METHOD: (1) Green's functions from coils, vessel, and plasma grid points to the isoflux control points are stored in files and read in by read_response.m - \"help read_response\" for Green function conventions. (2) plasma current variation objects only have 1 d.o.f. but a distributed current; a current wtd average is used.","title":"Basic Information"},{"location":"function-guide/tok_models/plasma_response_vst_m/","text":"plasma_response_vst.m \u00b6 Basic Information \u00b6 USAGE: vst_data = plasma_response_vst(equil_data,iefit,tokamak,tok_data_struct,ichooseq) PURPOSE: Calculate plasma response objects using vst in corsica INPUTS: eq_file = name of an efit gfile or a saved corsica equilibrium tokamak = device to construct model objects for (e.g. 'NSTX','KSTAR',etc) vac_objs = structure containing: mcc, mvv, mcv, mpc, mpv, resc, resv, zg, rg, ecdata (Note that imks and iterminal in this structure define the units of the data objects to be produced. imks=1 gives MKS units, otherwise units are MA,uH,uOhms. iterminal=1 gives terminal mode, 0 gives lumped.) ichooseq= equilibrium file type: 1 = efit_gfile 2 = corsica generated flat files 3 = saved corsica equilibrium OUTPUTS: vst = structure containing: METHOD: The matlab script generates a basis script file and invokes corsica with this file to generate plasma response objects with vst. After that execution returns to matlab. VERSION: @(#)plasma_response_vst.m 1.2 06/25/09","title":"plasma_response_vst.m"},{"location":"function-guide/tok_models/plasma_response_vst_m/#plasma_response_vstm","text":"","title":"plasma_response_vst.m"},{"location":"function-guide/tok_models/plasma_response_vst_m/#basic-information","text":"USAGE: vst_data = plasma_response_vst(equil_data,iefit,tokamak,tok_data_struct,ichooseq) PURPOSE: Calculate plasma response objects using vst in corsica INPUTS: eq_file = name of an efit gfile or a saved corsica equilibrium tokamak = device to construct model objects for (e.g. 'NSTX','KSTAR',etc) vac_objs = structure containing: mcc, mvv, mcv, mpc, mpv, resc, resv, zg, rg, ecdata (Note that imks and iterminal in this structure define the units of the data objects to be produced. imks=1 gives MKS units, otherwise units are MA,uH,uOhms. iterminal=1 gives terminal mode, 0 gives lumped.) ichooseq= equilibrium file type: 1 = efit_gfile 2 = corsica generated flat files 3 = saved corsica equilibrium OUTPUTS: vst = structure containing: METHOD: The matlab script generates a basis script file and invokes corsica with this file to generate plasma response objects with vst. After that execution returns to matlab. VERSION: @(#)plasma_response_vst.m 1.2 06/25/09","title":"Basic Information"},{"location":"function-guide/tok_models/plot_tok_geo_config_m/","text":"plot_tok_geo_config.m \u00b6 Basic Information \u00b6 SYNTAX: plot_tok_geo_config(tok) PURPOSE: call plot_tok_geo for multiple vacuum data objects INPUT: tok: name of the device OUTPUT: Figure plotted to screen and .ps file RESTRICTIONS: METHOD: WRITTEN BY: MJL 20121002 MODIFICATIONS: So far only ITER and D3D cases are implemented","title":"plot_tok_geo_config.m"},{"location":"function-guide/tok_models/plot_tok_geo_config_m/#plot_tok_geo_configm","text":"","title":"plot_tok_geo_config.m"},{"location":"function-guide/tok_models/plot_tok_geo_config_m/#basic-information","text":"SYNTAX: plot_tok_geo_config(tok) PURPOSE: call plot_tok_geo for multiple vacuum data objects INPUT: tok: name of the device OUTPUT: Figure plotted to screen and .ps file RESTRICTIONS: METHOD: WRITTEN BY: MJL 20121002 MODIFICATIONS: So far only ITER and D3D cases are implemented","title":"Basic Information"},{"location":"function-guide/tok_models/plot_tok_geo_m/","text":"plot_tok_geo.m \u00b6 Basic Information \u00b6 USAGE: plot_tok_geo(tok_data_struct,options,equil_data) Examples: plot_tok_geo(tok_data_struct,options,east_system.equil_data) plot_tok_geo(tok_data_struct,options,psizr) PURPOSE: Plot the basic tokamak geometry. INPUTS: [default] tok_data_struct = structure containing tokamak geometry data options = structure containing any of the following options: iblackbg = flag: 0= white figure background, [1]=black figure background ipltpsi = flag: 1= contour equilibrium psizr, >1= #contours to plot (default = 1 if psizr exists, else 0) ipltrho = flag 1= contour equilibrium normalized rho surfaces, >1= #contours to plot ipltB = flag: 1= contour equilibrium |B|, >1= #contours to plot [0] ipltJ = flag: 1= contour equilibrium jphi, >1= #contours to plot [0] (Only one of ipltpsi, iltrho, ipltB, ipltJ may be specified; all need equil_data.) ipltfc = flag; 1= plot the f-coils [1] ipltvv = flag; 1= plot the vacuum vessel elements [1] ipltlim = flag: 1= plot limiter switch [1] ipltfl = flag: 1= plot Flux Loops [0] ipltbp = flag: 1= plot B-Probe indices [0] ipltgap = flag: 1= plot gap locations [0] ilabeleq = flag: 1= contour label flux values [0] ilabelfc = flag: 1= label PF's with indices, >1 => use name labels, with fontsize=ilabelfc [0] ilabelcc = flag: 1= label PF coil STATES with indices (cannot also set ilabelfc) Pcc = matrix that computes PF currents from states (required if ilabelcc=1) ilabelvv = flag: 1= label VV elements with indices [0] ilabelfl = flag: 1= label FL's with indices [0] >1 => use name labels, with fontsize=ilabelfl [0] ilabelbp = flag: 1= label BP's with indices, >1 => use name labels, with fontsize=ilabelbp [0] ilabelgap= flag: 1= label gaps with indices [0] idxvv = indices of vacuum vessel to plot (default = all) idxfl = indices of flux loops to plot (default all, used only if ipltfl) idxbp = indices of Bprobes to plot (default all, used only if ipltbp) vvgroup = grouping vector for vacuum vessel elements, used only if ilabelvv=1 to define vessel element labels ileftright: bit 1 = plot left side, bit 0 = plot right side (default) equil_data = equilibrium psizr from EFIT OR structure containing psizr and psibnd (e.g. equil_data in *_system struct produced by build_*_sys.m script. OUTPUTS: Plot of tokamak geometry","title":"plot_tok_geo.m"},{"location":"function-guide/tok_models/plot_tok_geo_m/#plot_tok_geom","text":"","title":"plot_tok_geo.m"},{"location":"function-guide/tok_models/plot_tok_geo_m/#basic-information","text":"USAGE: plot_tok_geo(tok_data_struct,options,equil_data) Examples: plot_tok_geo(tok_data_struct,options,east_system.equil_data) plot_tok_geo(tok_data_struct,options,psizr) PURPOSE: Plot the basic tokamak geometry. INPUTS: [default] tok_data_struct = structure containing tokamak geometry data options = structure containing any of the following options: iblackbg = flag: 0= white figure background, [1]=black figure background ipltpsi = flag: 1= contour equilibrium psizr, >1= #contours to plot (default = 1 if psizr exists, else 0) ipltrho = flag 1= contour equilibrium normalized rho surfaces, >1= #contours to plot ipltB = flag: 1= contour equilibrium |B|, >1= #contours to plot [0] ipltJ = flag: 1= contour equilibrium jphi, >1= #contours to plot [0] (Only one of ipltpsi, iltrho, ipltB, ipltJ may be specified; all need equil_data.) ipltfc = flag; 1= plot the f-coils [1] ipltvv = flag; 1= plot the vacuum vessel elements [1] ipltlim = flag: 1= plot limiter switch [1] ipltfl = flag: 1= plot Flux Loops [0] ipltbp = flag: 1= plot B-Probe indices [0] ipltgap = flag: 1= plot gap locations [0] ilabeleq = flag: 1= contour label flux values [0] ilabelfc = flag: 1= label PF's with indices, >1 => use name labels, with fontsize=ilabelfc [0] ilabelcc = flag: 1= label PF coil STATES with indices (cannot also set ilabelfc) Pcc = matrix that computes PF currents from states (required if ilabelcc=1) ilabelvv = flag: 1= label VV elements with indices [0] ilabelfl = flag: 1= label FL's with indices [0] >1 => use name labels, with fontsize=ilabelfl [0] ilabelbp = flag: 1= label BP's with indices, >1 => use name labels, with fontsize=ilabelbp [0] ilabelgap= flag: 1= label gaps with indices [0] idxvv = indices of vacuum vessel to plot (default = all) idxfl = indices of flux loops to plot (default all, used only if ipltfl) idxbp = indices of Bprobes to plot (default all, used only if ipltbp) vvgroup = grouping vector for vacuum vessel elements, used only if ilabelvv=1 to define vessel element labels ileftright: bit 1 = plot left side, bit 0 = plot right side (default) equil_data = equilibrium psizr from EFIT OR structure containing psizr and psibnd (e.g. equil_data in *_system struct produced by build_*_sys.m script. OUTPUTS: Plot of tokamak geometry","title":"Basic Information"},{"location":"function-guide/tok_models/proj_turn_m/","text":"proj_turn.m \u00b6 Basic Information \u00b6 proj_turn Generates projection matrix to combine series and anti-series coils. optionally includes turns in output SYNTAX: proj= proj_turn(conect,turns) INPUT: conect= connection vector containing id of coils to connect same index coils are in series, negative are in anti-series, 0 excludes ex: [1,2,2,3,2,0,5,-5] 6th coil is not used, 7th & 8th are anti-series turns= turns in each coil element (or fraction of turns) can be used to make a one turn system (same size as conect) ex: [9,1/3,1/3,10,1/3,-3,8,8] coil 2 is a 1 turn system (1/3+1/3+1/3=1) If not present assumes 1-turn in each coil Examples: Standard NSTX (no PF4, PF5u,l series:) conect= [1,2,3,4,0,5,5,0,6,7,8,9]; NSTX (PF4u,l, PF5u,l series:) conect= [1,2,3,4,5,6,6,5,7,8,9,10]; Convert to Neumeyer order: oh, 1au, 1al, ib 2u 2l 3u 3l 4 5: conect= [1 2 5 7 9 10 10 9 8 6 3 4]; OUTPUT: proj= Projection matrix USE: mccc= proj*mcc*proj'; mcvv= proj*mcv; rescc= proj*resc; names: namess=char([]); for ii=1:size(proj,1) nam= char([]); id= find(abs(proj(ii,:))); for jj=1:length(id); if proj(ii,id(jj)) < 0 nam=[nam remove_space(names(id(jj),:)) '_']; '_' = anti-series else nam=[nam remove_space(names(id(jj),:))]; end end namess= strvcat(namess,nam); end","title":"proj_turn.m"},{"location":"function-guide/tok_models/proj_turn_m/#proj_turnm","text":"","title":"proj_turn.m"},{"location":"function-guide/tok_models/proj_turn_m/#basic-information","text":"proj_turn Generates projection matrix to combine series and anti-series coils. optionally includes turns in output SYNTAX: proj= proj_turn(conect,turns) INPUT: conect= connection vector containing id of coils to connect same index coils are in series, negative are in anti-series, 0 excludes ex: [1,2,2,3,2,0,5,-5] 6th coil is not used, 7th & 8th are anti-series turns= turns in each coil element (or fraction of turns) can be used to make a one turn system (same size as conect) ex: [9,1/3,1/3,10,1/3,-3,8,8] coil 2 is a 1 turn system (1/3+1/3+1/3=1) If not present assumes 1-turn in each coil Examples: Standard NSTX (no PF4, PF5u,l series:) conect= [1,2,3,4,0,5,5,0,6,7,8,9]; NSTX (PF4u,l, PF5u,l series:) conect= [1,2,3,4,5,6,6,5,7,8,9,10]; Convert to Neumeyer order: oh, 1au, 1al, ib 2u 2l 3u 3l 4 5: conect= [1 2 5 7 9 10 10 9 8 6 3 4]; OUTPUT: proj= Projection matrix USE: mccc= proj*mcc*proj'; mcvv= proj*mcv; rescc= proj*resc; names: namess=char([]); for ii=1:size(proj,1) nam= char([]); id= find(abs(proj(ii,:))); for jj=1:length(id); if proj(ii,id(jj)) < 0 nam=[nam remove_space(names(id(jj),:)) '_']; '_' = anti-series else nam=[nam remove_space(names(id(jj),:))]; end end namess= strvcat(namess,nam); end","title":"Basic Information"},{"location":"function-guide/tok_models/regrid_m/","text":"regrid.m \u00b6 Basic Information \u00b6 USAGE: config = regrid(rg, zg, config0) config = regrid(nr, nz, config0) PURPOSE: Replace the grid in config0 with the grid rg, zg If first input is scalar (= nr) then: rg = linspace(config0.rg(1),config0.rg(end),nr)' If second input is scalar (= nz) then: zg = linspace(config0.zg(1),config0.zg(end),nz)' INPUTS: rg, radii of grid points [m] zg, height of grid points [m] config0, a.k.a. tok_data_struct or vac_objs a structure containing (TokSys) tokamak information OUTPUTS: config, like config0 but all grid quantities are for rg, zg","title":"regrid.m"},{"location":"function-guide/tok_models/regrid_m/#regridm","text":"","title":"regrid.m"},{"location":"function-guide/tok_models/regrid_m/#basic-information","text":"USAGE: config = regrid(rg, zg, config0) config = regrid(nr, nz, config0) PURPOSE: Replace the grid in config0 with the grid rg, zg If first input is scalar (= nr) then: rg = linspace(config0.rg(1),config0.rg(end),nr)' If second input is scalar (= nz) then: zg = linspace(config0.zg(1),config0.zg(end),nz)' INPUTS: rg, radii of grid points [m] zg, height of grid points [m] config0, a.k.a. tok_data_struct or vac_objs a structure containing (TokSys) tokamak information OUTPUTS: config, like config0 but all grid quantities are for rg, zg","title":"Basic Information"},{"location":"function-guide/tok_models/run_divertor_model_m/","text":"run_divertor_model.m \u00b6 Basic Information \u00b6 USAGE: >> run_divertor_model PURPOSE: Script to run divertor_model.m to evolve divertor/core dynamics with specified inputs, intended to execute open loop OR closed loop evolution. For open loop, inputs waveforms (Gamec(t), Gamrc(t),Gamrd(t)) are defined explicitly below. For open loop, input waveforms are determined dynamic by feedback laws defined below. INPUTS: OUTPUTS: RESTRICTIONS: METHOD:","title":"run_divertor_model.m"},{"location":"function-guide/tok_models/run_divertor_model_m/#run_divertor_modelm","text":"","title":"run_divertor_model.m"},{"location":"function-guide/tok_models/run_divertor_model_m/#basic-information","text":"USAGE: >> run_divertor_model PURPOSE: Script to run divertor_model.m to evolve divertor/core dynamics with specified inputs, intended to execute open loop OR closed loop evolution. For open loop, inputs waveforms (Gamec(t), Gamrc(t),Gamrd(t)) are defined explicitly below. For open loop, input waveforms are determined dynamic by feedback laws defined below. INPUTS: OUTPUTS: RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/rzrig_m/","text":"rzrig.m \u00b6 Basic Information \u00b6 USAGE: function [model_data,cc0,vc0,dbg_objs]=rzrig( ... equil_data,tokamak,vac_objs,idoplots,idoncal,idxvv,iwait) PURPOSE: Script to calculate vertical and radial response using rigid current-conserving model of plasma for GENERAL systems. Takes basic data from EFIT g-file or external data input (cc, jphi; eg from Corsica) and needs environment objects of same names as D3D environment. cc and jphi are ASSUMED to be in MA when read from gfile or defined externally. INPUTS: equil_data = structure containing equilibrium information tokamak = device to construct model objects for (e.g. 'NSTX','KSTAR',etc) vac_objs = structure containing: mcc, mvv, mcv, mpc, mpv, resc, resv, zg, rg, ecdata (Note that imks and iterminal in this structure define the units of the data objects to be produced. imks=1 gives MKS units, otherwise units are MA,uH,uOhms. iterminal=1 gives terminal mode, 0 gives lumped.) idoplots= (optional) flag to select plotting: 1=plot, 0=don't(default) idoncal = (optional) flag to select calc of decay index: 1=calc, 0=don't(default) idxvv = (optional) indices of VV elements to use in force calculation (default=1:nvv) iwait = (optional) 1(default)=wait with error messages, 0=no wait iverbose = (optional) Flag to display messages, default is 0 OUTPUTS: model_data = quantities describing vertical/radial force balance&couplings - data objects - units = units of data objects - desc = descriptions of data objects cc0 = equilibrium coil currents (size matching objects in vac_objs, with units as specified by imks and iterminal in vac_objs) vc0 = equilibrium vessel currents (size matching objects in vac_objs, with units as specified by imks and iterminal in vac_objs) Also displays max positive eigenvalue for various conductor modifications. RESTRICTIONS: Plasma current density must be zero within 1 grid of upper & lower walls (for 2-sided calculations of gradients). Circuits defaulted to be lumped (one-turn) elements (see ccnturn def below). If magnetic mapping objects (mcc, mpc, etc...) are in terminal mode (iterminal==1), ccnturn must correspond to turns in them. cc coming from read_gfile (or wherever) assumed to be lumped mode. METHOD: Described in Walker/Humphreys, Valid Coordinate Systems for Linearized Plasma Shape Response Models in Tokamaks, FS&T,Nov.06; GA report GA-A25042","title":"rzrig.m"},{"location":"function-guide/tok_models/rzrig_m/#rzrigm","text":"","title":"rzrig.m"},{"location":"function-guide/tok_models/rzrig_m/#basic-information","text":"USAGE: function [model_data,cc0,vc0,dbg_objs]=rzrig( ... equil_data,tokamak,vac_objs,idoplots,idoncal,idxvv,iwait) PURPOSE: Script to calculate vertical and radial response using rigid current-conserving model of plasma for GENERAL systems. Takes basic data from EFIT g-file or external data input (cc, jphi; eg from Corsica) and needs environment objects of same names as D3D environment. cc and jphi are ASSUMED to be in MA when read from gfile or defined externally. INPUTS: equil_data = structure containing equilibrium information tokamak = device to construct model objects for (e.g. 'NSTX','KSTAR',etc) vac_objs = structure containing: mcc, mvv, mcv, mpc, mpv, resc, resv, zg, rg, ecdata (Note that imks and iterminal in this structure define the units of the data objects to be produced. imks=1 gives MKS units, otherwise units are MA,uH,uOhms. iterminal=1 gives terminal mode, 0 gives lumped.) idoplots= (optional) flag to select plotting: 1=plot, 0=don't(default) idoncal = (optional) flag to select calc of decay index: 1=calc, 0=don't(default) idxvv = (optional) indices of VV elements to use in force calculation (default=1:nvv) iwait = (optional) 1(default)=wait with error messages, 0=no wait iverbose = (optional) Flag to display messages, default is 0 OUTPUTS: model_data = quantities describing vertical/radial force balance&couplings - data objects - units = units of data objects - desc = descriptions of data objects cc0 = equilibrium coil currents (size matching objects in vac_objs, with units as specified by imks and iterminal in vac_objs) vc0 = equilibrium vessel currents (size matching objects in vac_objs, with units as specified by imks and iterminal in vac_objs) Also displays max positive eigenvalue for various conductor modifications. RESTRICTIONS: Plasma current density must be zero within 1 grid of upper & lower walls (for 2-sided calculations of gradients). Circuits defaulted to be lumped (one-turn) elements (see ccnturn def below). If magnetic mapping objects (mcc, mpc, etc...) are in terminal mode (iterminal==1), ccnturn must correspond to turns in them. cc coming from read_gfile (or wherever) assumed to be lumped mode. METHOD: Described in Walker/Humphreys, Valid Coordinate Systems for Linearized Plasma Shape Response Models in Tokamaks, FS&T,Nov.06; GA report GA-A25042","title":"Basic Information"},{"location":"function-guide/tok_models/scale_equil_response_m/","text":"scale_equil_response.m \u00b6 Basic Information \u00b6 SYNTAX: scaled_system = scale_equil_response(tok_system,scaleip) PURPOSE: Modify the response model contained in tok_system for an equilibrium scaled by the factor scaleip. INPUT: tok_system = system model of the type built by build_tokamak_system scale_ip = scalar to multiply by currents in equilibrium that was used when generating tok_system OUTPUT: scaled_system = system model of the same type representing an equilibrium scaled by the factor scaleip","title":"scale_equil_response.m"},{"location":"function-guide/tok_models/scale_equil_response_m/#scale_equil_responsem","text":"","title":"scale_equil_response.m"},{"location":"function-guide/tok_models/scale_equil_response_m/#basic-information","text":"SYNTAX: scaled_system = scale_equil_response(tok_system,scaleip) PURPOSE: Modify the response model contained in tok_system for an equilibrium scaled by the factor scaleip. INPUT: tok_system = system model of the type built by build_tokamak_system scale_ip = scalar to multiply by currents in equilibrium that was used when generating tok_system OUTPUT: scaled_system = system model of the same type representing an equilibrium scaled by the factor scaleip","title":"Basic Information"},{"location":"function-guide/tok_models/strikepoints_m/","text":"strikepoints.m \u00b6 Basic Information \u00b6 USAGE: sr = strikepoints(equ,resp1) sr = strikepoints(equ,resp2,tok) PURPOSE: Find strike points and related response objects Some of the returned points may not be true strike points INPUTS: equ, equilibrium description, required fields are: rg, zg = grid coordinates psizr = flux on grid psibry = boundary flux xlim, ylim OR Rlim, Zlim OR limdata = limiter coordinates resp1, plasma response, required fields are: dpsizrdx, dpsibrydx = response to a variable called x resp2, plasma response from gspert (x=[is;Ip;li;betap]) Fields dcphid* from gspert are used internally with tok.mpp to calculate dpsizrdx, dpsibrydx, for x=[is;Ip;li;betap] tok, TokSys description of tokamak (tok_data_struct) OUTPUTS: sr, strike points and responses in a structure with fields: rst, zst = *all* points on limiter where flux = psibry dpsistdx = flux change at rst, zst in response to x drstdx, dzstdx = displacement along limiter in response to x","title":"strikepoints.m"},{"location":"function-guide/tok_models/strikepoints_m/#strikepointsm","text":"","title":"strikepoints.m"},{"location":"function-guide/tok_models/strikepoints_m/#basic-information","text":"USAGE: sr = strikepoints(equ,resp1) sr = strikepoints(equ,resp2,tok) PURPOSE: Find strike points and related response objects Some of the returned points may not be true strike points INPUTS: equ, equilibrium description, required fields are: rg, zg = grid coordinates psizr = flux on grid psibry = boundary flux xlim, ylim OR Rlim, Zlim OR limdata = limiter coordinates resp1, plasma response, required fields are: dpsizrdx, dpsibrydx = response to a variable called x resp2, plasma response from gspert (x=[is;Ip;li;betap]) Fields dcphid* from gspert are used internally with tok.mpp to calculate dpsizrdx, dpsibrydx, for x=[is;Ip;li;betap] tok, TokSys description of tokamak (tok_data_struct) OUTPUTS: sr, strike points and responses in a structure with fields: rst, zst = *all* points on limiter where flux = psibry dpsistdx = flux change at rst, zst in response to x drstdx, dzstdx = displacement along limiter in response to x","title":"Basic Information"},{"location":"function-guide/tok_models/test_gseq_iter_m/","text":"test_gseq_iter.m \u00b6 Basic Information \u00b6 USAGE: test_gseq_iter PURPOSE: Examples on how to run gseq INPUTS: None (just run the code) OUTPUTS: Demonstration of gseq, including plots of evolving equilibrium","title":"test_gseq_iter.m"},{"location":"function-guide/tok_models/test_gseq_iter_m/#test_gseq_iterm","text":"","title":"test_gseq_iter.m"},{"location":"function-guide/tok_models/test_gseq_iter_m/#basic-information","text":"USAGE: test_gseq_iter PURPOSE: Examples on how to run gseq INPUTS: None (just run the code) OUTPUTS: Demonstration of gseq, including plots of evolving equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/test_output_objs_m/","text":"test_output_objs.m \u00b6 Basic Information \u00b6 SYNTAX: test_output_objs PURPOSE: Test consistency of EFIT equilibrium, output_objs data from PCS calculations, and calculations from objects in toksys vacuum data structure. Only tested for D3D and NSTX right now. INPUT: tok_system = data structure created by build_<device>_sys.m tok_data_struct = vacuum data model structure output_objs = data structure created by plasma_outputs.m wait_for_plots = set to 1 to pause after each plot [0] figure_num = figure number for incrementing figures [0] OUTPUT: plots comparing various calculation results","title":"test_output_objs.m"},{"location":"function-guide/tok_models/test_output_objs_m/#test_output_objsm","text":"","title":"test_output_objs.m"},{"location":"function-guide/tok_models/test_output_objs_m/#basic-information","text":"SYNTAX: test_output_objs PURPOSE: Test consistency of EFIT equilibrium, output_objs data from PCS calculations, and calculations from objects in toksys vacuum data structure. Only tested for D3D and NSTX right now. INPUT: tok_system = data structure created by build_<device>_sys.m tok_data_struct = vacuum data model structure output_objs = data structure created by plasma_outputs.m wait_for_plots = set to 1 to pause after each plot [0] figure_num = figure number for incrementing figures [0] OUTPUT: plots comparing various calculation results","title":"Basic Information"},{"location":"function-guide/tok_models/tokgeo_m/","text":"tokgeo.m \u00b6 Basic Information \u00b6 USAGE: tokgeo Find and show tokamaks in the workspace tokgeo(tok) Show the tokamak in tok tokgeo(tok,opt) Show tok with menu options in opt INPUTS: tok, tokamak geometry data in TokSys format opt, initial menu, type \"tokgeo options\" for a description OUTPUTS: Figure with extra menus \"View\", \"Lines', \"Surfaces\", \"Names\"","title":"tokgeo.m"},{"location":"function-guide/tok_models/tokgeo_m/#tokgeom","text":"","title":"tokgeo.m"},{"location":"function-guide/tok_models/tokgeo_m/#basic-information","text":"USAGE: tokgeo Find and show tokamaks in the workspace tokgeo(tok) Show the tokamak in tok tokgeo(tok,opt) Show tok with menu options in opt INPUTS: tok, tokamak geometry data in TokSys format opt, initial menu, type \"tokgeo options\" for a description OUTPUTS: Figure with extra menus \"View\", \"Lines', \"Surfaces\", \"Names\"","title":"Basic Information"},{"location":"function-guide/tok_models/update_maxis_m/","text":"update_maxis.m \u00b6 Basic Information \u00b6 USAGE: Initial call must include config: [rmaxis, zmaxis, maxis, iia, wa, drmaxisdpsi, dzmaxisdpsi] = ... update_maxis(rmaxis, zmaxis, psizr, config) Initial call that only configures: update_maxis([], [], [], config) Repeat calls execute faster if config is omitted: [rmaxis, zmaxis, maxis, iia, wa, drmaxisdpsi, dzmaxisdpsi] = ... update_maxis(rmaxis, zmaxis, psizr) PURPOSE: Zoom in on magnetic axis INPUTS: rmaxis, zmaxis, approximate axis position psizr, flux on the grid config, a structure with fields: rg, zg, grid coordinates limdata, limiter coordinates [Zlim; Rlim] OUTPUTS: rmaxis, zmaxis, updated position of magnetic axis maxis, boolean true if axis still inside limiter after update iia, wa, indices and weights such that psimag = wa*psizr(iia) drmaxisdpsi, weights so that drmaxis = drmaxisdpsi*dpsizr(iia) dzmaxisdpsi, weights so that dzmaxis = dzmaxisdpsi*dpsizr(iia) METHOD: interpolation with bicubic Hermite splines, Newton-Rhapson to zoom, private version of isinpoly to check that axis is inside limiter","title":"update_maxis.m"},{"location":"function-guide/tok_models/update_maxis_m/#update_maxism","text":"","title":"update_maxis.m"},{"location":"function-guide/tok_models/update_maxis_m/#basic-information","text":"USAGE: Initial call must include config: [rmaxis, zmaxis, maxis, iia, wa, drmaxisdpsi, dzmaxisdpsi] = ... update_maxis(rmaxis, zmaxis, psizr, config) Initial call that only configures: update_maxis([], [], [], config) Repeat calls execute faster if config is omitted: [rmaxis, zmaxis, maxis, iia, wa, drmaxisdpsi, dzmaxisdpsi] = ... update_maxis(rmaxis, zmaxis, psizr) PURPOSE: Zoom in on magnetic axis INPUTS: rmaxis, zmaxis, approximate axis position psizr, flux on the grid config, a structure with fields: rg, zg, grid coordinates limdata, limiter coordinates [Zlim; Rlim] OUTPUTS: rmaxis, zmaxis, updated position of magnetic axis maxis, boolean true if axis still inside limiter after update iia, wa, indices and weights such that psimag = wa*psizr(iia) drmaxisdpsi, weights so that drmaxis = drmaxisdpsi*dpsizr(iia) dzmaxisdpsi, weights so that dzmaxis = dzmaxisdpsi*dpsizr(iia) METHOD: interpolation with bicubic Hermite splines, Newton-Rhapson to zoom, private version of isinpoly to check that axis is inside limiter","title":"Basic Information"},{"location":"function-guide/toksim/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Toksim library and support functions. toksim_generic.slx - Toksim library of generic modules User functions: ------------------------ configure_EG_outputs - Customize the EGout_convertor module. def_EGoutput - Define EG output signals from active Simulink model. EGio_from_model - Build an EG signal_defns data structure from Simulink model example_EG_io - example_event_schedule - Example of an event schedule for the EG. load_event_schedule - Load an event schedule for the EG make_Vector2Bus - Create a Vector2Bus block in the currently selected block of model. pcssp_bld_setup - Create setup data structures for a simulink model. pcssp_prune_setup - Prune the setup data structures to remove unused params. var_exists - Generalization of \"exist\" and \"isfield\" functions.","title":"Contents.m"},{"location":"function-guide/toksim/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/toksim/Contents_m/#basic-information","text":"Toksim library and support functions. toksim_generic.slx - Toksim library of generic modules User functions: ------------------------ configure_EG_outputs - Customize the EGout_convertor module. def_EGoutput - Define EG output signals from active Simulink model. EGio_from_model - Build an EG signal_defns data structure from Simulink model example_EG_io - example_event_schedule - Example of an event schedule for the EG. load_event_schedule - Load an event schedule for the EG make_Vector2Bus - Create a Vector2Bus block in the currently selected block of model. pcssp_bld_setup - Create setup data structures for a simulink model. pcssp_prune_setup - Prune the setup data structures to remove unused params. var_exists - Generalization of \"exist\" and \"isfield\" functions.","title":"Basic Information"},{"location":"function-guide/toksim/GSevolve_setup_m/","text":"GSevolve_setup.m \u00b6 Basic Information \u00b6 SYNTAX: GSevolve_setup(module_path) PURPOSE: Define configuration, initial, and tsdata for GSevolve module INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data","title":"GSevolve_setup.m"},{"location":"function-guide/toksim/GSevolve_setup_m/#gsevolve_setupm","text":"","title":"GSevolve_setup.m"},{"location":"function-guide/toksim/GSevolve_setup_m/#basic-information","text":"SYNTAX: GSevolve_setup(module_path) PURPOSE: Define configuration, initial, and tsdata for GSevolve module INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data","title":"Basic Information"},{"location":"function-guide/toksim/Ip_evolution_setup_m/","text":"Ip_evolution_setup.m \u00b6 Basic Information \u00b6 SYNTAX: Ip_evolution_setup PURPOSE: Define configuration data structure for Ip_evolution module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Ip_evolution_setup.m"},{"location":"function-guide/toksim/Ip_evolution_setup_m/#ip_evolution_setupm","text":"","title":"Ip_evolution_setup.m"},{"location":"function-guide/toksim/Ip_evolution_setup_m/#basic-information","text":"SYNTAX: Ip_evolution_setup PURPOSE: Define configuration data structure for Ip_evolution module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/LH_module_setup_m/","text":"LH_module_setup.m \u00b6 Basic Information \u00b6 SYNTAX: LH_module_setup PURPOSE: Define configuration data structure for LH_module module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"LH_module_setup.m"},{"location":"function-guide/toksim/LH_module_setup_m/#lh_module_setupm","text":"","title":"LH_module_setup.m"},{"location":"function-guide/toksim/LH_module_setup_m/#basic-information","text":"SYNTAX: LH_module_setup PURPOSE: Define configuration data structure for LH_module module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/PCS_D3Dtype_setup_m/","text":"PCS_D3Dtype_setup.m \u00b6 Basic Information \u00b6 SYNTAX: setup_data = PCS_D3Dtype_setup(module_path) PURPOSE: Setup file for module PCS_D3Dtype_setup that connects the plant simulation to an executing PCS.","title":"PCS_D3Dtype_setup.m"},{"location":"function-guide/toksim/PCS_D3Dtype_setup_m/#pcs_d3dtype_setupm","text":"","title":"PCS_D3Dtype_setup.m"},{"location":"function-guide/toksim/PCS_D3Dtype_setup_m/#basic-information","text":"SYNTAX: setup_data = PCS_D3Dtype_setup(module_path) PURPOSE: Setup file for module PCS_D3Dtype_setup that connects the plant simulation to an executing PCS.","title":"Basic Information"},{"location":"function-guide/toksim/gsevolve_sfun_m/","text":"gsevolve_sfun.m \u00b6 Basic Information \u00b6 USAGE: called by gsevolve module PURPOSE: interface between simulink and gsevolve INPUTS: xs, the state of the plasma vps, voltages on coils from power supplies vcd, voltages induced by current drive time, the time in the simulation OUTPUTS: y, outputs defined by config.outputs For more detailed information, type gsevolve at the matlab prompt","title":"gsevolve_sfun.m"},{"location":"function-guide/toksim/gsevolve_sfun_m/#gsevolve_sfunm","text":"","title":"gsevolve_sfun.m"},{"location":"function-guide/toksim/gsevolve_sfun_m/#basic-information","text":"USAGE: called by gsevolve module PURPOSE: interface between simulink and gsevolve INPUTS: xs, the state of the plasma vps, voltages on coils from power supplies vcd, voltages induced by current drive time, the time in the simulation OUTPUTS: y, outputs defined by config.outputs For more detailed information, type gsevolve at the matlab prompt","title":"Basic Information"},{"location":"function-guide/toksim/gsupdates_m/","text":"gsupdates.m \u00b6 Basic Information \u00b6 USAGE: called by gsevolve module PURPOSE: interface between simulink and gsevolve INPUTS: x, state of the plasma OUTPUTS: d, dynamics objects For more detailed information, type gsevolve at the matlab prompt","title":"gsupdates.m"},{"location":"function-guide/toksim/gsupdates_m/#gsupdatesm","text":"","title":"gsupdates.m"},{"location":"function-guide/toksim/gsupdates_m/#basic-information","text":"USAGE: called by gsevolve module PURPOSE: interface between simulink and gsevolve INPUTS: x, state of the plasma OUTPUTS: d, dynamics objects For more detailed information, type gsevolve at the matlab prompt","title":"Basic Information"},{"location":"function-guide/toksim/limited_system_setup_m/","text":"limited_system_setup.m \u00b6 Basic Information \u00b6 SYNTAX: setup_data = limited_system_setup(module_path) PURPOSE: Define configuration data structure for limited_system module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"limited_system_setup.m"},{"location":"function-guide/toksim/limited_system_setup_m/#limited_system_setupm","text":"","title":"limited_system_setup.m"},{"location":"function-guide/toksim/limited_system_setup_m/#basic-information","text":"SYNTAX: setup_data = limited_system_setup(module_path) PURPOSE: Define configuration data structure for limited_system module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/lin_plasma_sim_setup_m/","text":"lin_plasma_sim_setup.m \u00b6 Basic Information \u00b6 SYNTAX: lin_plasma_sim_setup PURPOSE: Define configuration data structure for limited_system module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"lin_plasma_sim_setup.m"},{"location":"function-guide/toksim/lin_plasma_sim_setup_m/#lin_plasma_sim_setupm","text":"","title":"lin_plasma_sim_setup.m"},{"location":"function-guide/toksim/lin_plasma_sim_setup_m/#basic-information","text":"SYNTAX: lin_plasma_sim_setup PURPOSE: Define configuration data structure for limited_system module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/make_Vector2Bus_m/","text":"make_Vector2Bus.m \u00b6 Basic Information \u00b6 SYNTAX: make_Vector2Bus(block_name,output_signals) PURPOSE: Create a Vector2Bus block in the currently selected block of your simulink model. INPUT: block_name = what to call the block (string) output_signals = structure with field names defining the separate output bus fields OUTPUT: creates a Simulink block in the currently active subsystem window RESTRICTIONS: Currently allows sub-buses only 1 level down from top. All leaf nodes must be column vectors.","title":"make_Vector2Bus.m"},{"location":"function-guide/toksim/make_Vector2Bus_m/#make_vector2busm","text":"","title":"make_Vector2Bus.m"},{"location":"function-guide/toksim/make_Vector2Bus_m/#basic-information","text":"SYNTAX: make_Vector2Bus(block_name,output_signals) PURPOSE: Create a Vector2Bus block in the currently selected block of your simulink model. INPUT: block_name = what to call the block (string) output_signals = structure with field names defining the separate output bus fields OUTPUT: creates a Simulink block in the currently active subsystem window RESTRICTIONS: Currently allows sub-buses only 1 level down from top. All leaf nodes must be column vectors.","title":"Basic Information"},{"location":"function-guide/toksim/read_torbeam_eqdata_m/","text":"read_torbeam_eqdata.m \u00b6 Basic Information \u00b6 SYNTAX: eqdata = read_torbeam_eqdata(eqdata_file) PURPOSE: Read torbeam eqdata input files into matlab environment. INPUT: eqdata_file = string specifying name of file containing equil data OUTPUT: eqdata = eqdata data array as specified in torbeam documentation nw = number of radial coordinates in grid nh = number of vertical coordinates in grid","title":"read_torbeam_eqdata.m"},{"location":"function-guide/toksim/read_torbeam_eqdata_m/#read_torbeam_eqdatam","text":"","title":"read_torbeam_eqdata.m"},{"location":"function-guide/toksim/read_torbeam_eqdata_m/#basic-information","text":"SYNTAX: eqdata = read_torbeam_eqdata(eqdata_file) PURPOSE: Read torbeam eqdata input files into matlab environment. INPUT: eqdata_file = string specifying name of file containing equil data OUTPUT: eqdata = eqdata data array as specified in torbeam documentation nw = number of radial coordinates in grid nh = number of vertical coordinates in grid","title":"Basic Information"},{"location":"function-guide/toksim/read_torbeam_prdata_m/","text":"read_torbeam_prdata.m \u00b6 Basic Information \u00b6 SYNTAX: [prdata,dens_len,temp_len] = read_torbeam_prdata(ne_file,Te_file) PURPOSE: Read torbeam prdata input files into matlab environment. INPUT: ne_file = string specifying name of file containing electron density data Te_file = string specifying name of file containing electron temperature data OUTPUT: prdata = prdata data array as specified in torbeam documentation dens_len = length of valid density array data (k in torbeam documentation) temp_len = length of valid temperature array data (l in torbeam documentation)","title":"read_torbeam_prdata.m"},{"location":"function-guide/toksim/read_torbeam_prdata_m/#read_torbeam_prdatam","text":"","title":"read_torbeam_prdata.m"},{"location":"function-guide/toksim/read_torbeam_prdata_m/#basic-information","text":"SYNTAX: [prdata,dens_len,temp_len] = read_torbeam_prdata(ne_file,Te_file) PURPOSE: Read torbeam prdata input files into matlab environment. INPUT: ne_file = string specifying name of file containing electron density data Te_file = string specifying name of file containing electron temperature data OUTPUT: prdata = prdata data array as specified in torbeam documentation dens_len = length of valid density array data (k in torbeam documentation) temp_len = length of valid temperature array data (l in torbeam documentation)","title":"Basic Information"},{"location":"function-guide/toksim/rtplots_m/","text":"rtplots.m \u00b6 Basic Information \u00b6 USAGE: rtplots(block) PURPOSE: time-triggered plotting during simulations INPUTS: x, state vector persistent variables are read from gsupdate PARAMETER: c, config data for gsupdate & plot settings OUTPUTS: tp, next time to plot figure with plots","title":"rtplots.m"},{"location":"function-guide/toksim/rtplots_m/#rtplotsm","text":"","title":"rtplots.m"},{"location":"function-guide/toksim/rtplots_m/#basic-information","text":"USAGE: rtplots(block) PURPOSE: time-triggered plotting during simulations INPUTS: x, state vector persistent variables are read from gsupdate PARAMETER: c, config data for gsupdate & plot settings OUTPUTS: tp, next time to plot figure with plots","title":"Basic Information"},{"location":"function-guide/toksim/simple_HCD_actuator_setup_m/","text":"simple_HCD_actuator_setup.m \u00b6 Basic Information \u00b6 SYNTAX: simple_HCD_actuator_setup PURPOSE: Define configuration data structure for simple_HCD_actuator module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"simple_HCD_actuator_setup.m"},{"location":"function-guide/toksim/simple_HCD_actuator_setup_m/#simple_hcd_actuator_setupm","text":"","title":"simple_HCD_actuator_setup.m"},{"location":"function-guide/toksim/simple_HCD_actuator_setup_m/#basic-information","text":"SYNTAX: simple_HCD_actuator_setup PURPOSE: Define configuration data structure for simple_HCD_actuator module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/slblocks_m/","text":"slblocks.m \u00b6 Basic Information \u00b6 Specify that the Simulink models should appear in the library browser","title":"slblocks.m"},{"location":"function-guide/toksim/slblocks_m/#slblocksm","text":"","title":"slblocks.m"},{"location":"function-guide/toksim/slblocks_m/#basic-information","text":"Specify that the Simulink models should appear in the library browser","title":"Basic Information"},{"location":"function-guide/toksim/torbeam_sizes_m/","text":"torbeam_sizes.m \u00b6 Basic Information \u00b6 Define max dimensions for torbeam objects. MUST MATCH DIMENSIONS IN torbeam_Sfn.c AND IN torbeam.f90.","title":"torbeam_sizes.m"},{"location":"function-guide/toksim/torbeam_sizes_m/#torbeam_sizesm","text":"","title":"torbeam_sizes.m"},{"location":"function-guide/toksim/torbeam_sizes_m/#basic-information","text":"Define max dimensions for torbeam objects. MUST MATCH DIMENSIONS IN torbeam_Sfn.c AND IN torbeam.f90.","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/TorGA_curgap_f90/","text":"TorGA_curgap.f90 \u00b6 Basic Information \u00b6 -----------------------------------------------------------------------&","title":"TorGA_curgap.f90"},{"location":"function-guide/toksim/build_torbeam/TorGA_curgap_f90/#torga_curgapf90","text":"","title":"TorGA_curgap.f90"},{"location":"function-guide/toksim/build_torbeam/TorGA_curgap_f90/#basic-information","text":"-----------------------------------------------------------------------&","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/coef_f90/","text":"coef.f90 \u00b6 Basic Information \u00b6 *********************************************************************","title":"coef.f90"},{"location":"function-guide/toksim/build_torbeam/coef_f90/#coeff90","text":"","title":"coef.f90"},{"location":"function-guide/toksim/build_torbeam/coef_f90/#basic-information","text":"*********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/commons_f90/","text":"commons.f90 \u00b6 Basic Information \u00b6 Single byte integer","title":"commons.f90"},{"location":"function-guide/toksim/build_torbeam/commons_f90/#commonsf90","text":"","title":"commons.f90"},{"location":"function-guide/toksim/build_torbeam/commons_f90/#basic-information","text":"Single byte integer","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/config_ext_f90/","text":"config_ext.f90 \u00b6 Basic Information \u00b6 #######################################################################","title":"config_ext.f90"},{"location":"function-guide/toksim/build_torbeam/config_ext_f90/#config_extf90","text":"","title":"config_ext.f90"},{"location":"function-guide/toksim/build_torbeam/config_ext_f90/#basic-information","text":"#######################################################################","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/const_and_precisions_f90/","text":"const_and_precisions.f90 \u00b6 Basic Information \u00b6 #######################################################################","title":"const_and_precisions.f90"},{"location":"function-guide/toksim/build_torbeam/const_and_precisions_f90/#const_and_precisionsf90","text":"","title":"const_and_precisions.f90"},{"location":"function-guide/toksim/build_torbeam/const_and_precisions_f90/#basic-information","text":"#######################################################################","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/curba_f90/","text":"curba.f90 \u00b6 Basic Information \u00b6 ----------------------------------------------------------------------- This is the CURBA3 relativistic, finite aspect ratio current-drive package. See comments at beginning of subroutine CURBA for use. To compile this package as a standalone code under Basis, run COSMOS CCLCUR. Need to read from CFS, user 313, directory bcur3, the files CURBA3, VAR.CUR, CCLCUR and PACK.IN. From directory legendb, file LIBLEG. Also, need to run lib BASIS; Then type lines: x ctl; n ctl; x ctl pack.ctl ctl.o. Note in current BASIS, need to type \"package cur\" at first cur> prompt to get going; also the old \"generate noplot\" is replaced by typing \"ctlplot=no\" once; then just \"generate\".","title":"curba.f90"},{"location":"function-guide/toksim/build_torbeam/curba_f90/#curbaf90","text":"","title":"curba.f90"},{"location":"function-guide/toksim/build_torbeam/curba_f90/#basic-information","text":"----------------------------------------------------------------------- This is the CURBA3 relativistic, finite aspect ratio current-drive package. See comments at beginning of subroutine CURBA for use. To compile this package as a standalone code under Basis, run COSMOS CCLCUR. Need to read from CFS, user 313, directory bcur3, the files CURBA3, VAR.CUR, CCLCUR and PACK.IN. From directory legendb, file LIBLEG. Also, need to run lib BASIS; Then type lines: x ctl; n ctl; x ctl pack.ctl ctl.o. Note in current BASIS, need to type \"package cur\" at first cur> prompt to get going; also the old \"generate noplot\" is replaced by typing \"ctlplot=no\" once; then just \"generate\".","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/currn_f90/","text":"currn.f90 \u00b6 Basic Information \u00b6 **********************************************************************","title":"currn.f90"},{"location":"function-guide/toksim/build_torbeam/currn_f90/#currnf90","text":"","title":"currn.f90"},{"location":"function-guide/toksim/build_torbeam/currn_f90/#basic-information","text":"**********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/deriv_f90/","text":"deriv.f90 \u00b6 Basic Information \u00b6 ****************************************************************","title":"deriv.f90"},{"location":"function-guide/toksim/build_torbeam/deriv_f90/#derivf90","text":"","title":"deriv.f90"},{"location":"function-guide/toksim/build_torbeam/deriv_f90/#basic-information","text":"****************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/ecdisp_f90/","text":"ecdisp.f90 \u00b6 Basic Information \u00b6 derived from calcei for usee with int=3 only result -> y = expei(x) computes the exponential integral exp(-x)*ei(x) for real arguments x where / integral (from t=-infinity to t=x) (exp(t)/t), x > 0, ei(x) = { \\ -integral (from t=-x to t=infinity) (exp(t)/t), x < 0, and where the first integral is a principal value integral.","title":"ecdisp.f90"},{"location":"function-guide/toksim/build_torbeam/ecdisp_f90/#ecdispf90","text":"","title":"ecdisp.f90"},{"location":"function-guide/toksim/build_torbeam/ecdisp_f90/#basic-information","text":"derived from calcei for usee with int=3 only result -> y = expei(x) computes the exponential integral exp(-x)*ei(x) for real arguments x where / integral (from t=-infinity to t=x) (exp(t)/t), x > 0, ei(x) = { \\ -integral (from t=-x to t=infinity) (exp(t)/t), x < 0, and where the first integral is a principal value integral.","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/eqs_beam_f90/","text":"eqs_beam.f90 \u00b6 Basic Information \u00b6 *********************************************************************","title":"eqs_beam.f90"},{"location":"function-guide/toksim/build_torbeam/eqs_beam_f90/#eqs_beamf90","text":"","title":"eqs_beam.f90"},{"location":"function-guide/toksim/build_torbeam/eqs_beam_f90/#basic-information","text":"*********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/equila_f90/","text":"equila.f90 \u00b6 Basic Information \u00b6 *********************************************************************","title":"equila.f90"},{"location":"function-guide/toksim/build_torbeam/equila_f90/#equilaf90","text":"","title":"equila.f90"},{"location":"function-guide/toksim/build_torbeam/equila_f90/#basic-information","text":"*********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/green_func_ext_f90/","text":"green_func_ext.f90 \u00b6 Basic Information \u00b6 #######################################################################","title":"green_func_ext.f90"},{"location":"function-guide/toksim/build_torbeam/green_func_ext_f90/#green_func_extf90","text":"","title":"green_func_ext.f90"},{"location":"function-guide/toksim/build_torbeam/green_func_ext_f90/#basic-information","text":"#######################################################################","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/grid6_f90/","text":"grid6.f90 \u00b6 Basic Information \u00b6 grid6.f90: like ~frv/TORBEAM/v1.3/grid/grid5.f90 except: - DER1 and DER2 operate on ni,nj subarrays","title":"grid6.f90"},{"location":"function-guide/toksim/build_torbeam/grid6_f90/#grid6f90","text":"","title":"grid6.f90"},{"location":"function-guide/toksim/build_torbeam/grid6_f90/#basic-information","text":"grid6.f90: like ~frv/TORBEAM/v1.3/grid/grid5.f90 except: - DER1 and DER2 operate on ni,nj subarrays","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/in_f90/","text":"in.f90 \u00b6 Basic Information \u00b6 *********************************************************************","title":"in.f90"},{"location":"function-guide/toksim/build_torbeam/in_f90/#inf90","text":"","title":"in.f90"},{"location":"function-guide/toksim/build_torbeam/in_f90/#basic-information","text":"*********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/interf_f90/","text":"interf.f90 \u00b6 Basic Information \u00b6 *********************************************************************","title":"interf.f90"},{"location":"function-guide/toksim/build_torbeam/interf_f90/#interff90","text":"","title":"interf.f90"},{"location":"function-guide/toksim/build_torbeam/interf_f90/#basic-information","text":"*********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/interpolB_f90/","text":"interpolB.f90 \u00b6 Basic Information \u00b6 ****************************************************************","title":"interpolB.f90"},{"location":"function-guide/toksim/build_torbeam/interpolB_f90/#interpolbf90","text":"","title":"interpolB.f90"},{"location":"function-guide/toksim/build_torbeam/interpolB_f90/#basic-information","text":"****************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/link_torbeam_m/","text":"link_torbeam.m \u00b6 Basic Information \u00b6 mex -g -v torbeam_Sfn.c commons.F90 ecdisp.f90 in.F90 t4_mod_tprof.f90 ocop.F90 rot.f90 deriv.F90 ... interpolB.F90 refr.f90 equila.F90 westerino_nonag.f90 grid6.F90 nr_fixcon3.F90 eqs_beam.F90 ... interf.f90 coef.F90 lsodeAnc.f90 lsode.f90 read_routines.f90 torbeam.F90","title":"link_torbeam.m"},{"location":"function-guide/toksim/build_torbeam/link_torbeam_m/#link_torbeamm","text":"","title":"link_torbeam.m"},{"location":"function-guide/toksim/build_torbeam/link_torbeam_m/#basic-information","text":"mex -g -v torbeam_Sfn.c commons.F90 ecdisp.f90 in.F90 t4_mod_tprof.f90 ocop.F90 rot.f90 deriv.F90 ... interpolB.F90 refr.f90 equila.F90 westerino_nonag.f90 grid6.F90 nr_fixcon3.F90 eqs_beam.F90 ... interf.f90 coef.F90 lsodeAnc.f90 lsode.f90 read_routines.f90 torbeam.F90","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/lsodeAnc_f90/","text":"lsodeAnc.f90 \u00b6 Basic Information \u00b6 Ancillary subroutines for subroutine lsode.f90/lsode ******************************************************************* ++++++++++++++++++++++++++ New stuff +++++++++++++++++++++++++++++++++","title":"lsodeAnc.f90"},{"location":"function-guide/toksim/build_torbeam/lsodeAnc_f90/#lsodeancf90","text":"","title":"lsodeAnc.f90"},{"location":"function-guide/toksim/build_torbeam/lsodeAnc_f90/#basic-information","text":"Ancillary subroutines for subroutine lsode.f90/lsode ******************************************************************* ++++++++++++++++++++++++++ New stuff +++++++++++++++++++++++++++++++++","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/lsode_f90/","text":"lsode.f90 \u00b6 Basic Information \u00b6 *******************************************************************","title":"lsode.f90"},{"location":"function-guide/toksim/build_torbeam/lsode_f90/#lsodef90","text":"","title":"lsode.f90"},{"location":"function-guide/toksim/build_torbeam/lsode_f90/#basic-information","text":"*******************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/nr_fixcon3_f90/","text":"nr_fixcon3.f90 \u00b6 Basic Information \u00b6 f90 version of Num.Recipes f77 routines from torbeam.f Obtained by f77-f90 converter fixcon","title":"nr_fixcon3.f90"},{"location":"function-guide/toksim/build_torbeam/nr_fixcon3_f90/#nr_fixcon3f90","text":"","title":"nr_fixcon3.f90"},{"location":"function-guide/toksim/build_torbeam/nr_fixcon3_f90/#basic-information","text":"f90 version of Num.Recipes f77 routines from torbeam.f Obtained by f77-f90 converter fixcon","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/ocop_f90/","text":"ocop.f90 \u00b6 Basic Information \u00b6 *********************************************************************","title":"ocop.f90"},{"location":"function-guide/toksim/build_torbeam/ocop_f90/#ocopf90","text":"","title":"ocop.f90"},{"location":"function-guide/toksim/build_torbeam/ocop_f90/#basic-information","text":"*********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/out_f90/","text":"out.f90 \u00b6 Basic Information \u00b6 *********************************************************************","title":"out.f90"},{"location":"function-guide/toksim/build_torbeam/out_f90/#outf90","text":"","title":"out.f90"},{"location":"function-guide/toksim/build_torbeam/out_f90/#basic-information","text":"*********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/precision_mod_f90/","text":"precision_mod.f90 \u00b6 Basic Information \u00b6 Precision can be adjusted below:","title":"precision_mod.f90"},{"location":"function-guide/toksim/build_torbeam/precision_mod_f90/#precision_modf90","text":"","title":"precision_mod.f90"},{"location":"function-guide/toksim/build_torbeam/precision_mod_f90/#basic-information","text":"Precision can be adjusted below:","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/quanc8_f90/","text":"quanc8.f90 \u00b6 Basic Information \u00b6 double precision fun, a, b, abserr, relerr, result, errest, flag","title":"quanc8.f90"},{"location":"function-guide/toksim/build_torbeam/quanc8_f90/#quanc8f90","text":"","title":"quanc8.f90"},{"location":"function-guide/toksim/build_torbeam/quanc8_f90/#basic-information","text":"double precision fun, a, b, abserr, relerr, result, errest, flag","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_eqdata_m/","text":"read_torbeam_eqdata.m \u00b6 Basic Information \u00b6 SYNTAX: eqdata = read_torbeam_eqdata(eqdata_file) PURPOSE: Read torbeam eqdata input files into matlab environment. INPUT: eqdata_file = string specifying name of file containing equil data OUTPUT: eqdata = eqdata data array as specified in torbeam documentation nw = number of radial coordinates in grid nh = number of vertical coordinates in grid","title":"read_torbeam_eqdata.m"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_eqdata_m/#read_torbeam_eqdatam","text":"","title":"read_torbeam_eqdata.m"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_eqdata_m/#basic-information","text":"SYNTAX: eqdata = read_torbeam_eqdata(eqdata_file) PURPOSE: Read torbeam eqdata input files into matlab environment. INPUT: eqdata_file = string specifying name of file containing equil data OUTPUT: eqdata = eqdata data array as specified in torbeam documentation nw = number of radial coordinates in grid nh = number of vertical coordinates in grid","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_prdata_m/","text":"read_torbeam_prdata.m \u00b6 Basic Information \u00b6 SYNTAX: [prdata,dens_len,temp_len] = read_torbeam_prdata(ne_file,Te_file) PURPOSE: Read torbeam prdata input files into matlab environment. INPUT: ne_file = string specifying name of file containing electron density data Te_file = string specifying name of file containing electron temperature data OUTPUT: prdata = prdata data array as specified in torbeam documentation dens_len = length of valid density array data (k in torbeam documentation) temp_len = length of valid temperature array data (l in torbeam documentation)","title":"read_torbeam_prdata.m"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_prdata_m/#read_torbeam_prdatam","text":"","title":"read_torbeam_prdata.m"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_prdata_m/#basic-information","text":"SYNTAX: [prdata,dens_len,temp_len] = read_torbeam_prdata(ne_file,Te_file) PURPOSE: Read torbeam prdata input files into matlab environment. INPUT: ne_file = string specifying name of file containing electron density data Te_file = string specifying name of file containing electron temperature data OUTPUT: prdata = prdata data array as specified in torbeam documentation dens_len = length of valid density array data (k in torbeam documentation) temp_len = length of valid temperature array data (l in torbeam documentation)","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/real_mod_f90/","text":"real_mod.f90 \u00b6 Basic Information \u00b6 return real(x, real_8_)","title":"real_mod.f90"},{"location":"function-guide/toksim/build_torbeam/real_mod_f90/#real_modf90","text":"","title":"real_mod.f90"},{"location":"function-guide/toksim/build_torbeam/real_mod_f90/#basic-information","text":"return real(x, real_8_)","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/refr_f90/","text":"refr.f90 \u00b6 Basic Information \u00b6 *********************************************************************","title":"refr.f90"},{"location":"function-guide/toksim/build_torbeam/refr_f90/#refrf90","text":"","title":"refr.f90"},{"location":"function-guide/toksim/build_torbeam/refr_f90/#basic-information","text":"*********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/rot_f90/","text":"rot.f90 \u00b6 Basic Information \u00b6 *********************************************************************","title":"rot.f90"},{"location":"function-guide/toksim/build_torbeam/rot_f90/#rotf90","text":"","title":"rot.f90"},{"location":"function-guide/toksim/build_torbeam/rot_f90/#basic-information","text":"*********************************************************************","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/t4_mod_tprof_f90/","text":"t4_mod_tprof.f90 \u00b6 Basic Information \u00b6 matt>>","title":"t4_mod_tprof.f90"},{"location":"function-guide/toksim/build_torbeam/t4_mod_tprof_f90/#t4_mod_tproff90","text":"","title":"t4_mod_tprof.f90"},{"location":"function-guide/toksim/build_torbeam/t4_mod_tprof_f90/#basic-information","text":"matt>>","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/test_data_torbeam_m/","text":"test_data_torbeam.m \u00b6 Basic Information \u00b6 Convert input files designed for standard torbeam input into data to drive the torbeam S-function.","title":"test_data_torbeam.m"},{"location":"function-guide/toksim/build_torbeam/test_data_torbeam_m/#test_data_torbeamm","text":"","title":"test_data_torbeam.m"},{"location":"function-guide/toksim/build_torbeam/test_data_torbeam_m/#basic-information","text":"Convert input files designed for standard torbeam input into data to drive the torbeam S-function.","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/torbeam_f90/","text":"torbeam.f90 \u00b6 Basic Information \u00b6 matt>>","title":"torbeam.f90"},{"location":"function-guide/toksim/build_torbeam/torbeam_f90/#torbeamf90","text":"","title":"torbeam.f90"},{"location":"function-guide/toksim/build_torbeam/torbeam_f90/#basic-information","text":"matt>>","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/torbeam_sizes_m/","text":"torbeam_sizes.m \u00b6 Basic Information \u00b6 Define max dimensions for torbeam objects. MUST MATCH DIMENSIONS IN torbeam_Sfn.c AND IN torbeam.f90.","title":"torbeam_sizes.m"},{"location":"function-guide/toksim/build_torbeam/torbeam_sizes_m/#torbeam_sizesm","text":"","title":"torbeam_sizes.m"},{"location":"function-guide/toksim/build_torbeam/torbeam_sizes_m/#basic-information","text":"Define max dimensions for torbeam objects. MUST MATCH DIMENSIONS IN torbeam_Sfn.c AND IN torbeam.f90.","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/westerino_nonag_f90/","text":"westerino_nonag.f90 \u00b6 Basic Information \u00b6 ABSORPTION ROUTINE IMPLICIT NONE REAL*8 THETA,NR,NI,ALFA,BETA,VTE,MODE,PI,ME,NI,TE, + NIA,VF INTEGER I C PI AND THE ELECTRON MASS (MKS) PI = 4.*ATAN(1.) ME = 9.1E-31 c LOEPJE DO 1 I = 1, 200 c THETA IS THE ANGEL BETWEEN THE WAVE VECTOR AND THE c THE MAGNETIC FIELD. FOR PERPENDICULAR PROPAGATION THETA = PI / 2. C ALFA IS RELATED TO THE DENSITY IT IS THE PLASMA C FREQUENCY SQUARED OVER THE WAVE FREQUENCY SQUARED. ALFA = 0.3 C BETA IS RELATED TO THE MAGNETIC FIELD STRENGTH, IT C IS THE CYCLOTRON FREQUENCY SQUARED OVER THE WAVE C FREQUENCY SQUARED. BETA = 1. + I / 1E4 (first harmonic) C NR IS THE REAL PART OF THE REFRACTIVE INDEX (INPUT) C IS TO BE CALCULATED FROM THE DISPERSION RELATION. NR = SQRT(1.-ALFA) C MODE SELECTS THE MODE. MODE = -1 SELECTS THE X-MODE C MODE = +1 SELECTS THE O-MODE. MODE = +1 C VTE IS THE THERMAL VELOCITY OF THE ELECTRONS NORMALIZED C TO THE SPEED OF LIGHT AND THEREFORE C RELATED TO THE ELECTRON TEMPERATURE TE. BELOW TE IS GIVEN C IN KEV, VTE IS THEN CALCULATED TE = 1 VTE = SQRT(3.2E-16*TE/ME)/3.0e8 C CALL THE ROUTINE CALL DAMPBQ(THETA,NR,NI,ALFA,BETA,VTE,MODE) C CALCULATE ALFA FOR THE PERPENDICULAR PROPAGATING O-MODE C FROM ANALYTIC FORMULA (approx) VF = 511.*(SQRT(BETA)-1)/ TE NIA = 2*SQRT(PI)*ALFA*SQRT(1-ALFA)*VF**2.5*EXP(-VF)/15. C THE OUTPUT IS THE ABSORPTION COEFFICIENT STORED IN NI WRITE(*,*)NI,NIA This is the absolute value of the imagnary part of the refractive index. To obtain the imaginary part of the wave vector one has to multiply with omega/c. This imaginary wave vector lies along the real part. The power is given by P = 1. - exp [ - 2 \\int k_i \\cdot {\\rm d}{\\bf s} ] where k_i = ni * \\omega / c. The {\\rm d} {\\bf s} is in the direction of the wave propagation and therefore in the direction of the group velocity. (the direction of wave propagation is of course directly calculated in the code) The wave vector is not necessarily in this direction. Therefore, an additional cos(ph) appears where ph is the angle between the wave vector and the direction of propagation. The differential equation is then dP / d s = 2 NI * \\omega / c * cos(ph) * (1 - P ) This can be integrated with the ODE routine. 1 CONTINUE END *********************************************************************","title":"westerino_nonag.f90"},{"location":"function-guide/toksim/build_torbeam/westerino_nonag_f90/#westerino_nonagf90","text":"","title":"westerino_nonag.f90"},{"location":"function-guide/toksim/build_torbeam/westerino_nonag_f90/#basic-information","text":"ABSORPTION ROUTINE IMPLICIT NONE REAL*8 THETA,NR,NI,ALFA,BETA,VTE,MODE,PI,ME,NI,TE, + NIA,VF INTEGER I C PI AND THE ELECTRON MASS (MKS) PI = 4.*ATAN(1.) ME = 9.1E-31 c LOEPJE DO 1 I = 1, 200 c THETA IS THE ANGEL BETWEEN THE WAVE VECTOR AND THE c THE MAGNETIC FIELD. FOR PERPENDICULAR PROPAGATION THETA = PI / 2. C ALFA IS RELATED TO THE DENSITY IT IS THE PLASMA C FREQUENCY SQUARED OVER THE WAVE FREQUENCY SQUARED. ALFA = 0.3 C BETA IS RELATED TO THE MAGNETIC FIELD STRENGTH, IT C IS THE CYCLOTRON FREQUENCY SQUARED OVER THE WAVE C FREQUENCY SQUARED. BETA = 1. + I / 1E4 (first harmonic) C NR IS THE REAL PART OF THE REFRACTIVE INDEX (INPUT) C IS TO BE CALCULATED FROM THE DISPERSION RELATION. NR = SQRT(1.-ALFA) C MODE SELECTS THE MODE. MODE = -1 SELECTS THE X-MODE C MODE = +1 SELECTS THE O-MODE. MODE = +1 C VTE IS THE THERMAL VELOCITY OF THE ELECTRONS NORMALIZED C TO THE SPEED OF LIGHT AND THEREFORE C RELATED TO THE ELECTRON TEMPERATURE TE. BELOW TE IS GIVEN C IN KEV, VTE IS THEN CALCULATED TE = 1 VTE = SQRT(3.2E-16*TE/ME)/3.0e8 C CALL THE ROUTINE CALL DAMPBQ(THETA,NR,NI,ALFA,BETA,VTE,MODE) C CALCULATE ALFA FOR THE PERPENDICULAR PROPAGATING O-MODE C FROM ANALYTIC FORMULA (approx) VF = 511.*(SQRT(BETA)-1)/ TE NIA = 2*SQRT(PI)*ALFA*SQRT(1-ALFA)*VF**2.5*EXP(-VF)/15. C THE OUTPUT IS THE ABSORPTION COEFFICIENT STORED IN NI WRITE(*,*)NI,NIA This is the absolute value of the imagnary part of the refractive index. To obtain the imaginary part of the wave vector one has to multiply with omega/c. This imaginary wave vector lies along the real part. The power is given by P = 1. - exp [ - 2 \\int k_i \\cdot {\\rm d}{\\bf s} ] where k_i = ni * \\omega / c. The {\\rm d} {\\bf s} is in the direction of the wave propagation and therefore in the direction of the group velocity. (the direction of wave propagation is of course directly calculated in the code) The wave vector is not necessarily in this direction. Therefore, an additional cos(ph) appears where ph is the angle between the wave vector and the direction of propagation. The differential equation is then dP / d s = 2 NI * \\omega / c * cos(ph) * (1 - P ) This can be integrated with the ODE routine. 1 CONTINUE END *********************************************************************","title":"Basic Information"},{"location":"function-guide/utilities/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Utility functions Input/Output functions: hdcopy - get a hard copy of plot(s) on screen hdcopysys - get a hard copy of SIMULINK block diagram in_script - reads variable from call/base area - use for script/fun ot_script - writes variables to call area - use for script/fun print_figs - print all figures (or list of figs) to .eps files read_namelist - read FORTRAN namelist file read_point - reads a file (.ptn) which contains list of point names set_save_v6 - makes \"save\" produce Version 6 compatable .mat files space - print a blank line to screen wait - pause with message to terminal write_ascii_table - Write out table to ascii file for easy import into MSWord write_namelist - Script to write namelist see also read_namelist netcdf_R14 - reads (some) netcdf written files (only Matlab_R14) dlmcell - writes a cell array to a file File/variable management clash - prints strings that collide with M, Mex, or MAT file name diff_mat - Compares two .mat files for differences disp_list - displays a row number in front of input string array dispp - similar to disp but print to multiple files,and/or screen exist_f_pwd - does file exist in present working directory? find_conflicts - find potential conflicts variable name conflicts keep - keeps specified variables and clears the rest mk_var - makes a variable with value only if it does not exist parse_filename - Returns [dir,name,ext] of input string filename save_mat - save list of variables into a .mat file struct_names - list of all variables & structure names in a structure struct_to_ws - puts 1st fields of structure into variables in workspace struct_to_ws_all - Puts ALL Variables of structure into workspace whoss - extension of whos that shows variable values String manipulation: fix_undscr - exchanges \"_\" with \"\\_\" to eliminate subscripting in text insert_string - insert a substring into another string at given indices intvec2str - convert vector of integers to string isblank - determine if string(s) is (are) blank remove_space - remove space from different locations in string (deblank) strlen - find length of string strsfind - like strfind except operates on multiple rows of patterns strcompare - single string from 1st identical charcters of string array strsmatch - find matching strings in two arrays of strings strsmatchs - like strsmatch but outputs matches in different columns strmatch_anywhr - finds rows of \"strs\" which have string \"str\" anywhere strmatch_end - like strmatch but looks from end of each row cell2str - convert a cell array to a string array Other: det_poly dijkstra - Calculates shortest path between 2 vertices in graph find_near - find index of vector element with value nearest to input gfile_shot_time - return shot and time from gfile or afile name intersect_bdry - find intersection of line with curve search_path - string search of functions in matlabpath submatrix_poly tok_from_pwd - determines tokamak string based on \"pwd\" and runs startup whatfunction - find function whose name contains partial string zero_crossing - estimate value(s) of x where data-defined fn. crosses y=0","title":"Contents.m"},{"location":"function-guide/utilities/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/utilities/Contents_m/#basic-information","text":"Utility functions Input/Output functions: hdcopy - get a hard copy of plot(s) on screen hdcopysys - get a hard copy of SIMULINK block diagram in_script - reads variable from call/base area - use for script/fun ot_script - writes variables to call area - use for script/fun print_figs - print all figures (or list of figs) to .eps files read_namelist - read FORTRAN namelist file read_point - reads a file (.ptn) which contains list of point names set_save_v6 - makes \"save\" produce Version 6 compatable .mat files space - print a blank line to screen wait - pause with message to terminal write_ascii_table - Write out table to ascii file for easy import into MSWord write_namelist - Script to write namelist see also read_namelist netcdf_R14 - reads (some) netcdf written files (only Matlab_R14) dlmcell - writes a cell array to a file File/variable management clash - prints strings that collide with M, Mex, or MAT file name diff_mat - Compares two .mat files for differences disp_list - displays a row number in front of input string array dispp - similar to disp but print to multiple files,and/or screen exist_f_pwd - does file exist in present working directory? find_conflicts - find potential conflicts variable name conflicts keep - keeps specified variables and clears the rest mk_var - makes a variable with value only if it does not exist parse_filename - Returns [dir,name,ext] of input string filename save_mat - save list of variables into a .mat file struct_names - list of all variables & structure names in a structure struct_to_ws - puts 1st fields of structure into variables in workspace struct_to_ws_all - Puts ALL Variables of structure into workspace whoss - extension of whos that shows variable values String manipulation: fix_undscr - exchanges \"_\" with \"\\_\" to eliminate subscripting in text insert_string - insert a substring into another string at given indices intvec2str - convert vector of integers to string isblank - determine if string(s) is (are) blank remove_space - remove space from different locations in string (deblank) strlen - find length of string strsfind - like strfind except operates on multiple rows of patterns strcompare - single string from 1st identical charcters of string array strsmatch - find matching strings in two arrays of strings strsmatchs - like strsmatch but outputs matches in different columns strmatch_anywhr - finds rows of \"strs\" which have string \"str\" anywhere strmatch_end - like strmatch but looks from end of each row cell2str - convert a cell array to a string array Other: det_poly dijkstra - Calculates shortest path between 2 vertices in graph find_near - find index of vector element with value nearest to input gfile_shot_time - return shot and time from gfile or afile name intersect_bdry - find intersection of line with curve search_path - string search of functions in matlabpath submatrix_poly tok_from_pwd - determines tokamak string based on \"pwd\" and runs startup whatfunction - find function whose name contains partial string zero_crossing - estimate value(s) of x where data-defined fn. crosses y=0","title":"Basic Information"},{"location":"function-guide/utilities/ETA_m/","text":"ETA.m \u00b6 Basic Information \u00b6 USAGE: [str, sec] = ETA(frac) PURPOSE: Estimate day and time that lengthy calculations will finish INPUTS: frac, fraction of calculations that have been completed OUTPUTS: str, string with date and time when calculations will finish sec, number of seconds remaining until calculations finish EXAMPLE: ETA(0) Reset timer for i = 1:n Calculation fprintf(char(8+zeros(1,45))) fprintf('Calculations will finish s',ETA(i/n)) end disp(' ')","title":"ETA.m"},{"location":"function-guide/utilities/ETA_m/#etam","text":"","title":"ETA.m"},{"location":"function-guide/utilities/ETA_m/#basic-information","text":"USAGE: [str, sec] = ETA(frac) PURPOSE: Estimate day and time that lengthy calculations will finish INPUTS: frac, fraction of calculations that have been completed OUTPUTS: str, string with date and time when calculations will finish sec, number of seconds remaining until calculations finish EXAMPLE: ETA(0) Reset timer for i = 1:n Calculation fprintf(char(8+zeros(1,45))) fprintf('Calculations will finish s',ETA(i/n)) end disp(' ')","title":"Basic Information"},{"location":"function-guide/utilities/cell2str_m/","text":"cell2str.m \u00b6 Basic Information \u00b6 CELL2STR Convert a 2-D cell array of strings to a string in MATLAB syntax. STR = CELL2STR(CELLSTR) converts the 2-D cell-string CELLSTR to a MATLAB string so that EVAL(STR) produces the original cell-string. Works as corresponding MAT2STR but for cell array of strings instead of scalar matrices. Example cellstr = {'U-234','Th-230'}; cell2str(cellstr) produces the string '{''U-234'',''Th-230'';}'. See also MAT2STR, STRREP, CELLFUN, EVAL.","title":"cell2str.m"},{"location":"function-guide/utilities/cell2str_m/#cell2strm","text":"","title":"cell2str.m"},{"location":"function-guide/utilities/cell2str_m/#basic-information","text":"CELL2STR Convert a 2-D cell array of strings to a string in MATLAB syntax. STR = CELL2STR(CELLSTR) converts the 2-D cell-string CELLSTR to a MATLAB string so that EVAL(STR) produces the original cell-string. Works as corresponding MAT2STR but for cell array of strings instead of scalar matrices. Example cellstr = {'U-234','Th-230'}; cell2str(cellstr) produces the string '{''U-234'',''Th-230'';}'. See also MAT2STR, STRREP, CELLFUN, EVAL.","title":"Basic Information"},{"location":"function-guide/utilities/clash_m/","text":"clash.m \u00b6 Basic Information \u00b6 CLASH Test for name collision CLASH(string), where string is either a single string, a string matrix, or the name of a file containing the strings to search for, prints the strings that collide with M, Mex, or MAT file names on the MATLABPATH. Files containing lists of names should have one name per line. CLASH(string,1) prints out messages for each string, CLASH(string) only reports clashes. I = CLASH(string) produces a vector of 1's and 0's. 1's for names that clash, and 0's otherwise. Ex: clash('xlabel') clash(['xlabel.m';'quadblah'],1) clash('/path/filename') I = clash(['xlabel.m';'quadblah']) ******* file ******* xlabel.m foobar andrew.mat ******************** clash('file')","title":"clash.m"},{"location":"function-guide/utilities/clash_m/#clashm","text":"","title":"clash.m"},{"location":"function-guide/utilities/clash_m/#basic-information","text":"CLASH Test for name collision CLASH(string), where string is either a single string, a string matrix, or the name of a file containing the strings to search for, prints the strings that collide with M, Mex, or MAT file names on the MATLABPATH. Files containing lists of names should have one name per line. CLASH(string,1) prints out messages for each string, CLASH(string) only reports clashes. I = CLASH(string) produces a vector of 1's and 0's. 1's for names that clash, and 0's otherwise. Ex: clash('xlabel') clash(['xlabel.m';'quadblah'],1) clash('/path/filename') I = clash(['xlabel.m';'quadblah']) ******* file ******* xlabel.m foobar andrew.mat ******************** clash('file')","title":"Basic Information"},{"location":"function-guide/utilities/det_poly_m/","text":"det_poly.m \u00b6 Basic Information \u00b6 SYNTAX: det = det_poly(matrix) PURPOSE: Compute determinant of polynomial matrix. A poly matrix is of the form matrix(P,M,M), which represents an MxM matrix of polynomials of at most degree P-1. The P elements of matrix(:,k,j) represent a poly in matlab representation. INPUT: matrix = matrix of polynomials OUTPUT: det = polynomial that is determinant of matrix","title":"det_poly.m"},{"location":"function-guide/utilities/det_poly_m/#det_polym","text":"","title":"det_poly.m"},{"location":"function-guide/utilities/det_poly_m/#basic-information","text":"SYNTAX: det = det_poly(matrix) PURPOSE: Compute determinant of polynomial matrix. A poly matrix is of the form matrix(P,M,M), which represents an MxM matrix of polynomials of at most degree P-1. The P elements of matrix(:,k,j) represent a poly in matlab representation. INPUT: matrix = matrix of polynomials OUTPUT: det = polynomial that is determinant of matrix","title":"Basic Information"},{"location":"function-guide/utilities/diff_mat_m/","text":"diff_mat.m \u00b6 Basic Information \u00b6 DIFF_MAT compares two structures or two .mat files to see if the variables are the same & have same values SYNTAX: [sam,sdiff,s1,s2] = diff_mat(mat1,mat2,del (optional),levels (optional)) Output arguments are optional. If not set the function will print an output of the comparison to the screen. Use the levels argument to set the number of levels of sub-structures to compare (see description below for more info). diff_mat(mat1,mat2); Prints output of comparison [sam,sdiff]= diff_mat(mat1,mat2,del); sam= diff_mat(mat1,mat2,0); No approximate comparison [sam,sdiff,s1,s2]= diff_mat(mat1,mat2); output variables in struct s1,s2 diff_mat(mat1,mat2,del,levels); Set the number of levels of substructures to compare INPUT: mat1,mat2= mat1 and mat2 are both .mat file names file names to read and compare (example: matlab.mat) (assumes .mat extension if file doesnt exist) The following types of data can be compared. All others will be ignored. 'double','sparse','char','int8','uint8','int16', 'uint16', 'int32', 'uint32','function_handle', and 'struct'. NOTE: Whether or not a sub-structure is compared is determined by the levels argument. del= Optional evaluation limit for approximate equal evaluation default= eps; if 0 approximate evaluation skipped levels= Optional number of levels of substructures to be recursively evaluated. <= -1 (DEFAULT) No limit to the number of sub-structures to be evaluated. 0. No substructures will be evaluated. >= 1. Specified number of substructures will be evaluated. OUTPUT: sam = 1 if mat1 and mat2 identical, 0 if not exactly identical sdiff= structure of differences: (ex. sdiff.sam, sdiff.c1, sdiff.s1and2 .sam= 1 if mat1 and mat2 identical, 0 if not exactly identical .c1= variable names in .mat1 [char array] .c2= variable names in .mat2 [char array] .s1not2= list of variables in mat1 but not in mat2 .s2not1= list of variables in mat2 but not in mat1 .s1and2= list of variable in mat1 and mat2; Below lists are subsets of .s1and2 which can be compared numerically .s1eq2 = list of variables that are identically 0 [norm()==0] .s1neq2= list of variables that are not identically 0 [norm()~=0] .n1neq2= norm of variables in list s1neq2 .s1apr2= approximate variable list: norm(mat2-mat1)/norm(mat1)<=del] .s1napr2= not approx. variable list: norm(mat2-mat1)/norm(mat1)>del] .n1napr2= fractional norm of variables in list s1napr2 .s1nev2= list of variables that cannot be evaluated (struc, cell...) s1= structure containing all mat1 variables s2= structure containing all mat2 variables NOTE: All matricies with different sizes are marked with \"inf\" norm's NOTE: use 'diff_mat' with 'struc_to_ws' to get 'neq' variables into env [sam,sdiff,s1,s2]= diff_mat_load('good.mat','bad.mat'); struct_to_ws(s1,[],[],[],sdiff.s1neq2,'_1') ?_1 struct_to_ws(s2,[],[],[],sdiff.s1neq2,'_2') ?_2 RESTRICTIONS: Fields of type logical and cell will not be compared.","title":"diff_mat.m"},{"location":"function-guide/utilities/diff_mat_m/#diff_matm","text":"","title":"diff_mat.m"},{"location":"function-guide/utilities/diff_mat_m/#basic-information","text":"DIFF_MAT compares two structures or two .mat files to see if the variables are the same & have same values SYNTAX: [sam,sdiff,s1,s2] = diff_mat(mat1,mat2,del (optional),levels (optional)) Output arguments are optional. If not set the function will print an output of the comparison to the screen. Use the levels argument to set the number of levels of sub-structures to compare (see description below for more info). diff_mat(mat1,mat2); Prints output of comparison [sam,sdiff]= diff_mat(mat1,mat2,del); sam= diff_mat(mat1,mat2,0); No approximate comparison [sam,sdiff,s1,s2]= diff_mat(mat1,mat2); output variables in struct s1,s2 diff_mat(mat1,mat2,del,levels); Set the number of levels of substructures to compare INPUT: mat1,mat2= mat1 and mat2 are both .mat file names file names to read and compare (example: matlab.mat) (assumes .mat extension if file doesnt exist) The following types of data can be compared. All others will be ignored. 'double','sparse','char','int8','uint8','int16', 'uint16', 'int32', 'uint32','function_handle', and 'struct'. NOTE: Whether or not a sub-structure is compared is determined by the levels argument. del= Optional evaluation limit for approximate equal evaluation default= eps; if 0 approximate evaluation skipped levels= Optional number of levels of substructures to be recursively evaluated. <= -1 (DEFAULT) No limit to the number of sub-structures to be evaluated. 0. No substructures will be evaluated. >= 1. Specified number of substructures will be evaluated. OUTPUT: sam = 1 if mat1 and mat2 identical, 0 if not exactly identical sdiff= structure of differences: (ex. sdiff.sam, sdiff.c1, sdiff.s1and2 .sam= 1 if mat1 and mat2 identical, 0 if not exactly identical .c1= variable names in .mat1 [char array] .c2= variable names in .mat2 [char array] .s1not2= list of variables in mat1 but not in mat2 .s2not1= list of variables in mat2 but not in mat1 .s1and2= list of variable in mat1 and mat2; Below lists are subsets of .s1and2 which can be compared numerically .s1eq2 = list of variables that are identically 0 [norm()==0] .s1neq2= list of variables that are not identically 0 [norm()~=0] .n1neq2= norm of variables in list s1neq2 .s1apr2= approximate variable list: norm(mat2-mat1)/norm(mat1)<=del] .s1napr2= not approx. variable list: norm(mat2-mat1)/norm(mat1)>del] .n1napr2= fractional norm of variables in list s1napr2 .s1nev2= list of variables that cannot be evaluated (struc, cell...) s1= structure containing all mat1 variables s2= structure containing all mat2 variables NOTE: All matricies with different sizes are marked with \"inf\" norm's NOTE: use 'diff_mat' with 'struc_to_ws' to get 'neq' variables into env [sam,sdiff,s1,s2]= diff_mat_load('good.mat','bad.mat'); struct_to_ws(s1,[],[],[],sdiff.s1neq2,'_1') ?_1 struct_to_ws(s2,[],[],[],sdiff.s1neq2,'_2') ?_2 RESTRICTIONS: Fields of type logical and cell will not be compared.","title":"Basic Information"},{"location":"function-guide/utilities/dijkstra2_m/","text":"dijkstra2.m \u00b6 Basic Information \u00b6 DIJKSTRA Calculates the shortest path between two points on a map using Dijkstra's Algorithm DIJKSTRA requires a list of nodes and a list of segments as inputs, as well as a starting node. (These are created randomly if they are not specified as inputs into the function Optionally, an ending node can also be used as an input to terminate the algorithm early (otherwise, the algorithm will find the shortest paths and distances to all of the nodes on the map from the starting node) AUTHOR: Joseph Kirk (c) 11/2006 EMAIL: jdkirk630 at gmail dot com For more information about Dijkstra's Algorithm check out: http://en.wikipedia.org/wiki/Dijkstra's_algorithm or http://mathworld.wolfram.com/DijkstrasAlgorithm.html","title":"dijkstra2.m"},{"location":"function-guide/utilities/dijkstra2_m/#dijkstra2m","text":"","title":"dijkstra2.m"},{"location":"function-guide/utilities/dijkstra2_m/#basic-information","text":"DIJKSTRA Calculates the shortest path between two points on a map using Dijkstra's Algorithm DIJKSTRA requires a list of nodes and a list of segments as inputs, as well as a starting node. (These are created randomly if they are not specified as inputs into the function Optionally, an ending node can also be used as an input to terminate the algorithm early (otherwise, the algorithm will find the shortest paths and distances to all of the nodes on the map from the starting node) AUTHOR: Joseph Kirk (c) 11/2006 EMAIL: jdkirk630 at gmail dot com For more information about Dijkstra's Algorithm check out: http://en.wikipedia.org/wiki/Dijkstra's_algorithm or http://mathworld.wolfram.com/DijkstrasAlgorithm.html","title":"Basic Information"},{"location":"function-guide/utilities/dijkstra_m/","text":"dijkstra.m \u00b6 Basic Information \u00b6 SYNTAX: [path, totalCost] = dijkstra(n, CostMatrix, s, d) PURPOSE: Find the least cost path between two nodes in a network. INPUT: n = the number of nodes in the network CostMatrix = matrix whose (i,j)th entry defines the cost of moving from node i to node j or conversely. Use Inf if impossible. s = source node index d = destination node index OUTPUT: path = the list of nodes in the path from source to destination totalCost = the total cost of the path RESTRICTIONS: Node numbers must be consecutive, starting at 1.","title":"dijkstra.m"},{"location":"function-guide/utilities/dijkstra_m/#dijkstram","text":"","title":"dijkstra.m"},{"location":"function-guide/utilities/dijkstra_m/#basic-information","text":"SYNTAX: [path, totalCost] = dijkstra(n, CostMatrix, s, d) PURPOSE: Find the least cost path between two nodes in a network. INPUT: n = the number of nodes in the network CostMatrix = matrix whose (i,j)th entry defines the cost of moving from node i to node j or conversely. Use Inf if impossible. s = source node index d = destination node index OUTPUT: path = the list of nodes in the path from source to destination totalCost = the total cost of the path RESTRICTIONS: Node numbers must be consecutive, starting at 1.","title":"Basic Information"},{"location":"function-guide/utilities/disp_list_m/","text":"disp_list.m \u00b6 Basic Information \u00b6 PURPOSE: DISP_LIST displays list of character arrays with prepended row number primarily for display of row number/string identification SYNTAX: disp_list(strin); displays strot strot = disp_list(strin); outputs array for future display","title":"disp_list.m"},{"location":"function-guide/utilities/disp_list_m/#disp_listm","text":"","title":"disp_list.m"},{"location":"function-guide/utilities/disp_list_m/#basic-information","text":"PURPOSE: DISP_LIST displays list of character arrays with prepended row number primarily for display of row number/string identification SYNTAX: disp_list(strin); displays strot strot = disp_list(strin); outputs array for future display","title":"Basic Information"},{"location":"function-guide/utilities/dispp_m/","text":"dispp.m \u00b6 Basic Information \u00b6 ============================================================================= Prints numeric or character array like disp(array) but writes to file (fid). Column heading and line spliting is not performed Useful for making \"diary\" screen data go to file instead of to screen also does multiple prints to screen and file or multiple files SYNTAX: dispp(array,fid); prints to fid (fid must be open file id) count=dispp(array,fid); returns number of characters printed dispp(array,fid,ndig); uses num2str(array,ndig) for numeric arr INPUT: [default] array= printed array (just like in disp(array)) fid= open file id (use fid= fopen(file_name,'w'); [0] = screen if fid is an array dispp writes to all files in fid list ndig= number of digits for numeric [default uses: num2str(array)] OUTPUT: prints data to file just like disp(array) does to screen count= number of array elements printed or number characters printed including \\n line feeds Limitations: At present array must be all one type: number or char array Column heading and line spliting is NOT performed like disp() =============================================================================","title":"dispp.m"},{"location":"function-guide/utilities/dispp_m/#disppm","text":"","title":"dispp.m"},{"location":"function-guide/utilities/dispp_m/#basic-information","text":"============================================================================= Prints numeric or character array like disp(array) but writes to file (fid). Column heading and line spliting is not performed Useful for making \"diary\" screen data go to file instead of to screen also does multiple prints to screen and file or multiple files SYNTAX: dispp(array,fid); prints to fid (fid must be open file id) count=dispp(array,fid); returns number of characters printed dispp(array,fid,ndig); uses num2str(array,ndig) for numeric arr INPUT: [default] array= printed array (just like in disp(array)) fid= open file id (use fid= fopen(file_name,'w'); [0] = screen if fid is an array dispp writes to all files in fid list ndig= number of digits for numeric [default uses: num2str(array)] OUTPUT: prints data to file just like disp(array) does to screen count= number of array elements printed or number characters printed including \\n line feeds Limitations: At present array must be all one type: number or char array Column heading and line spliting is NOT performed like disp() =============================================================================","title":"Basic Information"},{"location":"function-guide/utilities/dlmcell_m/","text":"dlmcell.m \u00b6 Basic Information \u00b6 <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><> <><><><><> dlmcell - Write Cell Array to Text File <><><><><> <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><> Version: 01.06.2010 (c) Roland Pfister roland_pfister@t-online.de 1. Synopsis A single cell array is written to an output file. Cells may consist of any combination of (a) numbers, (b) letters, or (c) words. The inputs are as follows: - file The output filename (string). - cell_array The cell array to be written. - delimiter Delimiter symbol, e.g. ',' (optional; default: tab ('\\t'}). - append '-a' for appending the content to the output file (optional). 2. Example mycell = {'Numbers', 'Letters', 'Words','More Words'; ... 1, 'A', 'Apple', {'Apricot'}; ... 2, 'B', 'Banana', {'Blueberry'}; ... 3, 'C', 'Cherry', {'Cranberry'}; }; dlmcell('mytext.txt',mycell); <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>","title":"dlmcell.m"},{"location":"function-guide/utilities/dlmcell_m/#dlmcellm","text":"","title":"dlmcell.m"},{"location":"function-guide/utilities/dlmcell_m/#basic-information","text":"<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><> <><><><><> dlmcell - Write Cell Array to Text File <><><><><> <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><> Version: 01.06.2010 (c) Roland Pfister roland_pfister@t-online.de 1. Synopsis A single cell array is written to an output file. Cells may consist of any combination of (a) numbers, (b) letters, or (c) words. The inputs are as follows: - file The output filename (string). - cell_array The cell array to be written. - delimiter Delimiter symbol, e.g. ',' (optional; default: tab ('\\t'}). - append '-a' for appending the content to the output file (optional). 2. Example mycell = {'Numbers', 'Letters', 'Words','More Words'; ... 1, 'A', 'Apple', {'Apricot'}; ... 2, 'B', 'Banana', {'Blueberry'}; ... 3, 'C', 'Cherry', {'Cranberry'}; }; dlmcell('mytext.txt',mycell); <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>","title":"Basic Information"},{"location":"function-guide/utilities/dlmwrite_m/","text":"dlmwrite.m \u00b6 Basic Information \u00b6 DLMWRITE Write ASCII delimited file. DLMWRITE(FILENAME,M,DLM) writes matrix M into FILENAME using the character DLM as the delimiter. Specify '\\t' to produce tab-delimited files. DLMWRITE(FILENAME, M, DLM, R, C) writes matrix M starting at offset row R, and column C in the file. R and C are zero-based, that is R=C=0 specifies first number in the file. DLMWRITE(FILENAME, M, DLM, R, C, NDIG) writes values in matrix M with NDIG digits. See also DLMREAD, CSVWRITE, CSVREAD, WK1WRITE, WK1READ.","title":"dlmwrite.m"},{"location":"function-guide/utilities/dlmwrite_m/#dlmwritem","text":"","title":"dlmwrite.m"},{"location":"function-guide/utilities/dlmwrite_m/#basic-information","text":"DLMWRITE Write ASCII delimited file. DLMWRITE(FILENAME,M,DLM) writes matrix M into FILENAME using the character DLM as the delimiter. Specify '\\t' to produce tab-delimited files. DLMWRITE(FILENAME, M, DLM, R, C) writes matrix M starting at offset row R, and column C in the file. R and C are zero-based, that is R=C=0 specifies first number in the file. DLMWRITE(FILENAME, M, DLM, R, C, NDIG) writes values in matrix M with NDIG digits. See also DLMREAD, CSVWRITE, CSVREAD, WK1WRITE, WK1READ.","title":"Basic Information"},{"location":"function-guide/utilities/error_data2_m/","text":"error_data2.m \u00b6 Basic Information \u00b6 Calculate error between x1 + x2*k and data.","title":"error_data2.m"},{"location":"function-guide/utilities/error_data2_m/#error_data2m","text":"","title":"error_data2.m"},{"location":"function-guide/utilities/error_data2_m/#basic-information","text":"Calculate error between x1 + x2*k and data.","title":"Basic Information"},{"location":"function-guide/utilities/exist_f_pwd_m/","text":"exist_f_pwd.m \u00b6 Basic Information \u00b6 performs an \"exist(name,'file')\" only on the present working directory pwd SYNTAX: [iopt]= exist_f_pwd(name); INPUT: name = string of file name to search for in the pwd OUTPUT: iopt = same output as exist for file 0 no exist 2 file","title":"exist_f_pwd.m"},{"location":"function-guide/utilities/exist_f_pwd_m/#exist_f_pwdm","text":"","title":"exist_f_pwd.m"},{"location":"function-guide/utilities/exist_f_pwd_m/#basic-information","text":"performs an \"exist(name,'file')\" only on the present working directory pwd SYNTAX: [iopt]= exist_f_pwd(name); INPUT: name = string of file name to search for in the pwd OUTPUT: iopt = same output as exist for file 0 no exist 2 file","title":"Basic Information"},{"location":"function-guide/utilities/find_conflicts_m/","text":"find_conflicts.m \u00b6 Basic Information \u00b6 SYNTAX: find_conflicts PURPOSE: Find potential conflicts between variable names in your environment and function names in your search path. INPUT: none OUTPUT: printed warnings of potential conflicts RESTRICTIONS: METHOD: Entire environment is saved at beginning of execution and restore when complete; this may take some time if large workspace is used.","title":"find_conflicts.m"},{"location":"function-guide/utilities/find_conflicts_m/#find_conflictsm","text":"","title":"find_conflicts.m"},{"location":"function-guide/utilities/find_conflicts_m/#basic-information","text":"SYNTAX: find_conflicts PURPOSE: Find potential conflicts between variable names in your environment and function names in your search path. INPUT: none OUTPUT: printed warnings of potential conflicts RESTRICTIONS: METHOD: Entire environment is saved at beginning of execution and restore when complete; this may take some time if large workspace is used.","title":"Basic Information"},{"location":"function-guide/utilities/find_latest_ver_m/","text":"find_latest_ver.m \u00b6 Basic Information \u00b6 find_latest_ver.m finds latest version of a routine assumes name is in format: xxxxxx54.m where xxxxxx is program name and 54 is version. It does a directory on xxxxxx*.m and finds largest number also will work on xxxxx.m* finding xxxxx.m45. SYNTAX: [name_latest,version_n]= find_latest_ver(name); INPUT: name = string of file name to do directory on (ex: program; program.m; program*.m) iopt = 0= return array of all matches not just latest 1= return full name [default] 2= eliminate extention .* 3= eliminate path */ 4= eliminate extention and path if ipt negative (ie. -1) then returns all file names not just latest OUTPUT: name_latest = latest version of file (ex: program106.m) version_n = version number (ex. 106) Caution: name without a number is considered version -1 name0 is considered version 0; name01 is same as name1 this doesnt care what names wild card * gets only looks for 5555. NEW Search: If it doesnt find routine in current directory it looks for file without the wild card in the path using which(). If it finds the the file then it does a directory in this \"BASE\" area","title":"find_latest_ver.m"},{"location":"function-guide/utilities/find_latest_ver_m/#find_latest_verm","text":"","title":"find_latest_ver.m"},{"location":"function-guide/utilities/find_latest_ver_m/#basic-information","text":"find_latest_ver.m finds latest version of a routine assumes name is in format: xxxxxx54.m where xxxxxx is program name and 54 is version. It does a directory on xxxxxx*.m and finds largest number also will work on xxxxx.m* finding xxxxx.m45. SYNTAX: [name_latest,version_n]= find_latest_ver(name); INPUT: name = string of file name to do directory on (ex: program; program.m; program*.m) iopt = 0= return array of all matches not just latest 1= return full name [default] 2= eliminate extention .* 3= eliminate path */ 4= eliminate extention and path if ipt negative (ie. -1) then returns all file names not just latest OUTPUT: name_latest = latest version of file (ex: program106.m) version_n = version number (ex. 106) Caution: name without a number is considered version -1 name0 is considered version 0; name01 is same as name1 this doesnt care what names wild card * gets only looks for 5555. NEW Search: If it doesnt find routine in current directory it looks for file without the wild card in the path using which(). If it finds the the file then it does a directory in this \"BASE\" area","title":"Basic Information"},{"location":"function-guide/utilities/find_near_m/","text":"find_near.m \u00b6 Basic Information \u00b6 function idx=find_near(vec,t0) Function to find vec index with vec value nearest to t0 (eg find index nearest to time t0 in a time vector vec). t0 can be a vector as well. Then returns vector of nearest value indices corr to t0 values.","title":"find_near.m"},{"location":"function-guide/utilities/find_near_m/#find_nearm","text":"","title":"find_near.m"},{"location":"function-guide/utilities/find_near_m/#basic-information","text":"function idx=find_near(vec,t0) Function to find vec index with vec value nearest to t0 (eg find index nearest to time t0 in a time vector vec). t0 can be a vector as well. Then returns vector of nearest value indices corr to t0 values.","title":"Basic Information"},{"location":"function-guide/utilities/fix_undscr_m/","text":"fix_undscr.m \u00b6 Basic Information \u00b6 PURPOSE: put \\ infront of any _ so it plots correctly when using TEX SYNTAX: [string_ot]= fix_undscr(string_in); INPUT: string_in= string containing _ which are converted to \\_ OUTPUT: string_ot= string containing \\_ which prints ok in TEX Note: Now works on string arrays","title":"fix_undscr.m"},{"location":"function-guide/utilities/fix_undscr_m/#fix_undscrm","text":"","title":"fix_undscr.m"},{"location":"function-guide/utilities/fix_undscr_m/#basic-information","text":"PURPOSE: put \\ infront of any _ so it plots correctly when using TEX SYNTAX: [string_ot]= fix_undscr(string_in); INPUT: string_in= string containing _ which are converted to \\_ OUTPUT: string_ot= string containing \\_ which prints ok in TEX Note: Now works on string arrays","title":"Basic Information"},{"location":"function-guide/utilities/gendep_m/","text":"gendep.m \u00b6 Basic Information \u00b6 Generate a list of mfile dependencies in the form: target : dep1 dep2 dep3 depN dep1 : dep2 : dep3 : depN : INPUTS: target - name of the makefile target mcommand - mfile or function used to generate the target depfilename - name of the file where the generated dependencies will be dumped. This follows the methodology outlined here: http://scottmcpeak.com/autodepend/autodepend.html In particular, here why you have the lines listing dependencies as targets with no prereqs: What is needed is a way to say that a particular prerequisite file, if missing, should be treated as changed (so the target will be rebuilt), but not cause an error. GNU make has an obscure feature that does just this: if a file (1) appears as a target in a rule with no prerequisites and no commands, and (2) that file does not exist and cannot be remade, then make will rebuild anything which depends on that file and not report an error. (See Chapter 4 of the make manual, \"Rules without Commands or Prerequisites\".)","title":"gendep.m"},{"location":"function-guide/utilities/gendep_m/#gendepm","text":"","title":"gendep.m"},{"location":"function-guide/utilities/gendep_m/#basic-information","text":"Generate a list of mfile dependencies in the form: target : dep1 dep2 dep3 depN dep1 : dep2 : dep3 : depN : INPUTS: target - name of the makefile target mcommand - mfile or function used to generate the target depfilename - name of the file where the generated dependencies will be dumped. This follows the methodology outlined here: http://scottmcpeak.com/autodepend/autodepend.html In particular, here why you have the lines listing dependencies as targets with no prereqs: What is needed is a way to say that a particular prerequisite file, if missing, should be treated as changed (so the target will be rebuilt), but not cause an error. GNU make has an obscure feature that does just this: if a file (1) appears as a target in a rule with no prerequisites and no commands, and (2) that file does not exist and cannot be remade, then make will rebuild anything which depends on that file and not report an error. (See Chapter 4 of the make manual, \"Rules without Commands or Prerequisites\".)","title":"Basic Information"},{"location":"function-guide/utilities/gfile_shot_time_m/","text":"gfile_shot_time.m \u00b6 Basic Information \u00b6 SYNTAX: [shot, time] = gfile_shot_time(filename,typeflag) PURPOSE: Return shot and time values from gfile or afile name. INPUT: filename = name of gfile or afile typeflag = 0 to return as integer values (time in ms), 1 to return as string values (default) OUTPUT: shot = shot number stripped from file name time = time (in ms) stripped from file name","title":"gfile_shot_time.m"},{"location":"function-guide/utilities/gfile_shot_time_m/#gfile_shot_timem","text":"","title":"gfile_shot_time.m"},{"location":"function-guide/utilities/gfile_shot_time_m/#basic-information","text":"SYNTAX: [shot, time] = gfile_shot_time(filename,typeflag) PURPOSE: Return shot and time values from gfile or afile name. INPUT: filename = name of gfile or afile typeflag = 0 to return as integer values (time in ms), 1 to return as string values (default) OUTPUT: shot = shot number stripped from file name time = time (in ms) stripped from file name","title":"Basic Information"},{"location":"function-guide/utilities/gridit_m/","text":"gridit.m \u00b6 Basic Information \u00b6 gridit: Script to put grid lines at selected values of x,y. Usage: xgrid=linspace(1.7,.01,1.74); ygrid=linspace(0,.5,6); gridit; Inputs: define these variables (as desired): xgrid = vector of grid lines corr. to x-axis points ygrid = vector of grid lines corr. to y-axis points","title":"gridit.m"},{"location":"function-guide/utilities/gridit_m/#griditm","text":"","title":"gridit.m"},{"location":"function-guide/utilities/gridit_m/#basic-information","text":"gridit: Script to put grid lines at selected values of x,y. Usage: xgrid=linspace(1.7,.01,1.74); ygrid=linspace(0,.5,6); gridit; Inputs: define these variables (as desired): xgrid = vector of grid lines corr. to x-axis points ygrid = vector of grid lines corr. to y-axis points","title":"Basic Information"},{"location":"function-guide/utilities/hdcopy_m/","text":"hdcopy.m \u00b6 Basic Information \u00b6 SYNTAX: hdcopy(figures,keep_ps,device) PURPOSE: Create hardcopy plots of figures on screen. (See hdcopysys.m for hardcopies of SIMULINK block diagrams.) INPUT: figures = list of figure numbers (optional: if omitted, current figure is plotted) keep_ps = set to 1 to retain postscript file (hdcopytemp.ps) in local directory, if a string, then plots are stored in file with that name, else deleted (optional, default=0) device = string defining print device (optional, default='hplj21') - note that device can be 'eps' or 'epsc', but set keep_ps=1 to keep it. - Set device=0 to prevent printing (e.g. when keep_ps=1). OUTPUT: hardcopy plots to printer hdcopytemp.ps = local postscript file (if keep_ps=1) (or hdcopytemp.eps if device='eps' or 'epsc') METHOD: Creates postscript file using matlab print command, then sends to printer using !lp.","title":"hdcopy.m"},{"location":"function-guide/utilities/hdcopy_m/#hdcopym","text":"","title":"hdcopy.m"},{"location":"function-guide/utilities/hdcopy_m/#basic-information","text":"SYNTAX: hdcopy(figures,keep_ps,device) PURPOSE: Create hardcopy plots of figures on screen. (See hdcopysys.m for hardcopies of SIMULINK block diagrams.) INPUT: figures = list of figure numbers (optional: if omitted, current figure is plotted) keep_ps = set to 1 to retain postscript file (hdcopytemp.ps) in local directory, if a string, then plots are stored in file with that name, else deleted (optional, default=0) device = string defining print device (optional, default='hplj21') - note that device can be 'eps' or 'epsc', but set keep_ps=1 to keep it. - Set device=0 to prevent printing (e.g. when keep_ps=1). OUTPUT: hardcopy plots to printer hdcopytemp.ps = local postscript file (if keep_ps=1) (or hdcopytemp.eps if device='eps' or 'epsc') METHOD: Creates postscript file using matlab print command, then sends to printer using !lp.","title":"Basic Information"},{"location":"function-guide/utilities/hdcopysys_m/","text":"hdcopysys.m \u00b6 Basic Information \u00b6 SYNTAX: hdcopysys(system,keep_ps,device) PURPOSE: Create hardcopy plots of system block diagram. (See hdcopy.m for ordinary figures.) INPUT: system = text string specifying system name keep_ps = set to 1 to retain postscript file in local directory, else deleted (optional, default=0) device = string defining print device (optional, default='hplj21') - Set = 0 to prevent printing (e.g. when keep_ps=1). - Device can be 'eps', in which case keep_ps must=1 to save the eps file. OUTPUT: hardcopy plot to printer hdcopytemp.ps = local postscript file (if keep_ps=1) RESTRICTIONS: The system to be printed must be opened by SIMULINK within your MATLAB session in order for this function to work. METHOD: Creates postscript file using matlab print command, then sends to printer using !lp. Modify printer device for your local printer.","title":"hdcopysys.m"},{"location":"function-guide/utilities/hdcopysys_m/#hdcopysysm","text":"","title":"hdcopysys.m"},{"location":"function-guide/utilities/hdcopysys_m/#basic-information","text":"SYNTAX: hdcopysys(system,keep_ps,device) PURPOSE: Create hardcopy plots of system block diagram. (See hdcopy.m for ordinary figures.) INPUT: system = text string specifying system name keep_ps = set to 1 to retain postscript file in local directory, else deleted (optional, default=0) device = string defining print device (optional, default='hplj21') - Set = 0 to prevent printing (e.g. when keep_ps=1). - Device can be 'eps', in which case keep_ps must=1 to save the eps file. OUTPUT: hardcopy plot to printer hdcopytemp.ps = local postscript file (if keep_ps=1) RESTRICTIONS: The system to be printed must be opened by SIMULINK within your MATLAB session in order for this function to work. METHOD: Creates postscript file using matlab print command, then sends to printer using !lp. Modify printer device for your local printer.","title":"Basic Information"},{"location":"function-guide/utilities/in_script_m/","text":"in_script.m \u00b6 Basic Information \u00b6 SYNTAX: in_script PURPOSE: reads variable identified by string vnam into function from calling area or from base area, in this order INPUT: vnam= name of variable to bring in from calling or base area ex: vnam='vac_objects'; vnam='time'; vnam= 'ip'; ... OUTPUT: variable identified by string vnam is set in routine from calling or base area dumm= 1 if variable set, 0 if variable not found and not set EXAMPLE USE in Function to allow call of function as script if nargin <= 0 vnam= 'rbs'; in_script; if ~dumm return; end vnam= 'minimize_i'; in_script end NOTE: This script when used inside a function allows the function to act like a script for input. If variable doesnt exist it does not set RESTRICTIONS: vnam must be a character variable Caution: overwrites variable identified in vnam in routine and variable dumm see also ot_script","title":"in_script.m"},{"location":"function-guide/utilities/in_script_m/#in_scriptm","text":"","title":"in_script.m"},{"location":"function-guide/utilities/in_script_m/#basic-information","text":"SYNTAX: in_script PURPOSE: reads variable identified by string vnam into function from calling area or from base area, in this order INPUT: vnam= name of variable to bring in from calling or base area ex: vnam='vac_objects'; vnam='time'; vnam= 'ip'; ... OUTPUT: variable identified by string vnam is set in routine from calling or base area dumm= 1 if variable set, 0 if variable not found and not set EXAMPLE USE in Function to allow call of function as script if nargin <= 0 vnam= 'rbs'; in_script; if ~dumm return; end vnam= 'minimize_i'; in_script end NOTE: This script when used inside a function allows the function to act like a script for input. If variable doesnt exist it does not set RESTRICTIONS: vnam must be a character variable Caution: overwrites variable identified in vnam in routine and variable dumm see also ot_script","title":"Basic Information"},{"location":"function-guide/utilities/ineqconstr_lsqs_m/","text":"ineqconstr_lsqs.m \u00b6 Basic Information \u00b6 SYNTAX: x = ineqconstr_lsqs(A,b,B,d) PURPOSE: Inequality constrained least squares solution. Solves min || Ax - b || subject to ||Bx - d|| <= a. **************NOT WORKING YET************** INPUT: A = mxn matrix in LHS of Ax=b least squares problem b = mx1 vector in RHS of Ax=b least squares problem B = pxn matrix in constraint equation Bx=d d = px1 vector (all elts >=0) in constraint equation Bx=d OUTPUT: x = solution vector for constrained least squares problem RESTRICTIONS: A and B must be full rank.","title":"ineqconstr_lsqs.m"},{"location":"function-guide/utilities/ineqconstr_lsqs_m/#ineqconstr_lsqsm","text":"","title":"ineqconstr_lsqs.m"},{"location":"function-guide/utilities/ineqconstr_lsqs_m/#basic-information","text":"SYNTAX: x = ineqconstr_lsqs(A,b,B,d) PURPOSE: Inequality constrained least squares solution. Solves min || Ax - b || subject to ||Bx - d|| <= a. **************NOT WORKING YET************** INPUT: A = mxn matrix in LHS of Ax=b least squares problem b = mx1 vector in RHS of Ax=b least squares problem B = pxn matrix in constraint equation Bx=d d = px1 vector (all elts >=0) in constraint equation Bx=d OUTPUT: x = solution vector for constrained least squares problem RESTRICTIONS: A and B must be full rank.","title":"Basic Information"},{"location":"function-guide/utilities/insert_string_m/","text":"insert_string.m \u00b6 Basic Information \u00b6 SYNTAX: strout = insert_string(str2insert,string,indices) PURPOSE: Insert a specified substring within a given string at one or more locations. INPUT: str2insert = string to insert string = string to insert it into indices = indices in string at which to insert (length>=1) (inserts BEFORE the character located at each index) OUTPUT: strout = string resulting from the insertions RESTRICTIONS:","title":"insert_string.m"},{"location":"function-guide/utilities/insert_string_m/#insert_stringm","text":"","title":"insert_string.m"},{"location":"function-guide/utilities/insert_string_m/#basic-information","text":"SYNTAX: strout = insert_string(str2insert,string,indices) PURPOSE: Insert a specified substring within a given string at one or more locations. INPUT: str2insert = string to insert string = string to insert it into indices = indices in string at which to insert (length>=1) (inserts BEFORE the character located at each index) OUTPUT: strout = string resulting from the insertions RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/utilities/intersect_bdry_m/","text":"intersect_bdry.m \u00b6 Basic Information \u00b6 SYNTAX: [xi,yi,found] = intersect_bdry(x,y,xstart,ystart,xend,yend,bounded) PURPOSE: Given a set of connected line segments (such as a closed boundary) and the end points of an independent line segment, find the intersection of the independent segment and the boundary. The first intersection found will be returned so for reliability the segment should intersect the boundary in at most one place. INPUT: x,y = (x,y) of boundary (vectors) xstart,ystart = (x,y) of start of independent segment xend,yend = (x,y) of end of independent segment bounded = set to 1 to require the intersection to be between endpoints. set to 0 to allow intersection anywhere along the infinite lines defined by extending the independent line segment and a segment in the boundary. (In this case, the intersection will be found for the first segment in the bdry which is not parallel to the independent segment. OUTPUT: xi,yi = (x,y) coordinate of intersection found = 0, if no intersection found. = index of second point on intersecting bdry segment, otherwise.","title":"intersect_bdry.m"},{"location":"function-guide/utilities/intersect_bdry_m/#intersect_bdrym","text":"","title":"intersect_bdry.m"},{"location":"function-guide/utilities/intersect_bdry_m/#basic-information","text":"SYNTAX: [xi,yi,found] = intersect_bdry(x,y,xstart,ystart,xend,yend,bounded) PURPOSE: Given a set of connected line segments (such as a closed boundary) and the end points of an independent line segment, find the intersection of the independent segment and the boundary. The first intersection found will be returned so for reliability the segment should intersect the boundary in at most one place. INPUT: x,y = (x,y) of boundary (vectors) xstart,ystart = (x,y) of start of independent segment xend,yend = (x,y) of end of independent segment bounded = set to 1 to require the intersection to be between endpoints. set to 0 to allow intersection anywhere along the infinite lines defined by extending the independent line segment and a segment in the boundary. (In this case, the intersection will be found for the first segment in the bdry which is not parallel to the independent segment. OUTPUT: xi,yi = (x,y) coordinate of intersection found = 0, if no intersection found. = index of second point on intersecting bdry segment, otherwise.","title":"Basic Information"},{"location":"function-guide/utilities/intvec2str_m/","text":"intvec2str.m \u00b6 Basic Information \u00b6 SYNTAX: string = intvec2str(intvec) PURPOSE: Convert vector of integers to string. Puts commas between entries. INPUT: intvec = vector of integers OUTPUT: string = vector converted into string WRITTEN BY: Mike Walker ON ??/94","title":"intvec2str.m"},{"location":"function-guide/utilities/intvec2str_m/#intvec2strm","text":"","title":"intvec2str.m"},{"location":"function-guide/utilities/intvec2str_m/#basic-information","text":"SYNTAX: string = intvec2str(intvec) PURPOSE: Convert vector of integers to string. Puts commas between entries. INPUT: intvec = vector of integers OUTPUT: string = vector converted into string WRITTEN BY: Mike Walker ON ??/94","title":"Basic Information"},{"location":"function-guide/utilities/is_inuse_m/","text":"is_inuse.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: Determine if a name is already in use as a function name INPUT: name = string defining name to be tested OUTPUT: inuse = returns: 1 if already in use as a function 0 if not in use","title":"is_inuse.m"},{"location":"function-guide/utilities/is_inuse_m/#is_inusem","text":"","title":"is_inuse.m"},{"location":"function-guide/utilities/is_inuse_m/#basic-information","text":"SYNTAX: PURPOSE: Determine if a name is already in use as a function name INPUT: name = string defining name to be tested OUTPUT: inuse = returns: 1 if already in use as a function 0 if not in use","title":"Basic Information"},{"location":"function-guide/utilities/isblank_m/","text":"isblank.m \u00b6 Basic Information \u00b6 SYNTAX: result = isblank(string) PURPOSE: Determine if input string (strings) is (are) blank. INPUT: string = string or string array OUTPUT: result = boolean (0 or 1), 1 if string is blank, else 0","title":"isblank.m"},{"location":"function-guide/utilities/isblank_m/#isblankm","text":"","title":"isblank.m"},{"location":"function-guide/utilities/isblank_m/#basic-information","text":"SYNTAX: result = isblank(string) PURPOSE: Determine if input string (strings) is (are) blank. INPUT: string = string or string array OUTPUT: result = boolean (0 or 1), 1 if string is blank, else 0","title":"Basic Information"},{"location":"function-guide/utilities/isvect_m/","text":"isvect.m \u00b6 Basic Information \u00b6 ISVECT(A,GUESS) Returns logical true if A is a vector of type GUESS. A is an array. The alternative second input, GUESS, is either: 1 or 'r' or 'row' (inquire if A is a row vector) or 2 or 'c' or 'col' or 'column' (inquire if A is a column vector). [TF, TYPE] = isvect(A,GUESS) will also return a value (TYPE) representing the type of vector given by A . If TYPE is returned as a: 0 - this means A is not a vector 1 - this means A is a row vector 2 - this means A is a column vector Examples: A=[1 2 3]; isvect(A) Returns true isvect(A,1) Returns true (A is a row vector) isvect(A,'r') Returns true (A is a row vector) isvect(A,2) Returns false (A is not a column vector) [TF TYPE] = isvect(A,1) Returns TF = 1, TYPE = 1 (row) If A is scalar, isvect(A) returns true for any GUESS and TYPE=1. See also isnumeric, islogical, ischar, isempty. Author: Matt Fig Contact: popkenai@yahoo.com Date: feb 2006","title":"isvect.m"},{"location":"function-guide/utilities/isvect_m/#isvectm","text":"","title":"isvect.m"},{"location":"function-guide/utilities/isvect_m/#basic-information","text":"ISVECT(A,GUESS) Returns logical true if A is a vector of type GUESS. A is an array. The alternative second input, GUESS, is either: 1 or 'r' or 'row' (inquire if A is a row vector) or 2 or 'c' or 'col' or 'column' (inquire if A is a column vector). [TF, TYPE] = isvect(A,GUESS) will also return a value (TYPE) representing the type of vector given by A . If TYPE is returned as a: 0 - this means A is not a vector 1 - this means A is a row vector 2 - this means A is a column vector Examples: A=[1 2 3]; isvect(A) Returns true isvect(A,1) Returns true (A is a row vector) isvect(A,'r') Returns true (A is a row vector) isvect(A,2) Returns false (A is not a column vector) [TF TYPE] = isvect(A,1) Returns TF = 1, TYPE = 1 (row) If A is scalar, isvect(A) returns true for any GUESS and TYPE=1. See also isnumeric, islogical, ischar, isempty. Author: Matt Fig Contact: popkenai@yahoo.com Date: feb 2006","title":"Basic Information"},{"location":"function-guide/utilities/keep_m/","text":"keep.m \u00b6 Basic Information \u00b6 KEEP keeps the caller workspace variables of your choice and clear the rest. Its usage is just like \"clear\" but only for variables. Xiaoning (David) Yang xyang@lanl.gov 1998 Revision based on comments from Michael McPartland, michael@gaitalf.mgh.harvard.edu, 1999","title":"keep.m"},{"location":"function-guide/utilities/keep_m/#keepm","text":"","title":"keep.m"},{"location":"function-guide/utilities/keep_m/#basic-information","text":"KEEP keeps the caller workspace variables of your choice and clear the rest. Its usage is just like \"clear\" but only for variables. Xiaoning (David) Yang xyang@lanl.gov 1998 Revision based on comments from Michael McPartland, michael@gaitalf.mgh.harvard.edu, 1999","title":"Basic Information"},{"location":"function-guide/utilities/keep_v5_m/","text":"keep_v5.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: INPUT: keepstr = string containing names of variables to keep OUTPUT: RESTRICTIONS:","title":"keep_v5.m"},{"location":"function-guide/utilities/keep_v5_m/#keep_v5m","text":"","title":"keep_v5.m"},{"location":"function-guide/utilities/keep_v5_m/#basic-information","text":"SYNTAX: PURPOSE: INPUT: keepstr = string containing names of variables to keep OUTPUT: RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/utilities/make_HP_m/","text":"make_HP.m \u00b6 Basic Information \u00b6 SYNTAX: make_HP PURPOSE: Customizes the specified template makefile. Customized makefile can be used to build an executable from the generated model code. Used only by SIMULINK realtime code generation. Modified from make_rtw.m provided with Matlab. INPUT: varargin OUTPUT: RESTRICTIONS: METHOD: MAKE_RTW first invokes the Target Language Compiler to generate the code and then invokes the language specific make procedure. WRITTEN BY: Mike Walker ON 11/14/97 ------------------------------------ Get model name and build arguments ------------------------------------","title":"make_HP.m"},{"location":"function-guide/utilities/make_HP_m/#make_hpm","text":"","title":"make_HP.m"},{"location":"function-guide/utilities/make_HP_m/#basic-information","text":"SYNTAX: make_HP PURPOSE: Customizes the specified template makefile. Customized makefile can be used to build an executable from the generated model code. Used only by SIMULINK realtime code generation. Modified from make_rtw.m provided with Matlab. INPUT: varargin OUTPUT: RESTRICTIONS: METHOD: MAKE_RTW first invokes the Target Language Compiler to generate the code and then invokes the language specific make procedure. WRITTEN BY: Mike Walker ON 11/14/97 ------------------------------------ Get model name and build arguments ------------------------------------","title":"Basic Information"},{"location":"function-guide/utilities/make_function_m/","text":"make_function.m \u00b6 Basic Information \u00b6 USAGE: make_function(infile,outfile) PURPOSE: make a matlab script a function that returns a structure INPUTS: The script is read from infile. OUTPUTS: The function is written into outfile.","title":"make_function.m"},{"location":"function-guide/utilities/make_function_m/#make_functionm","text":"","title":"make_function.m"},{"location":"function-guide/utilities/make_function_m/#basic-information","text":"USAGE: make_function(infile,outfile) PURPOSE: make a matlab script a function that returns a structure INPUTS: The script is read from infile. OUTPUTS: The function is written into outfile.","title":"Basic Information"},{"location":"function-guide/utilities/make_psc_file_m/","text":"make_psc_file.m \u00b6 Basic Information \u00b6 SYNTAX: make_psc_file(figures,filename) PURPOSE: Make a color postscript file for printing or viewing with \"gs\". INPUT: figures = list (vector) of figure numbers filename = name of postscript file to create OUTPUT: postscript file","title":"make_psc_file.m"},{"location":"function-guide/utilities/make_psc_file_m/#make_psc_filem","text":"","title":"make_psc_file.m"},{"location":"function-guide/utilities/make_psc_file_m/#basic-information","text":"SYNTAX: make_psc_file(figures,filename) PURPOSE: Make a color postscript file for printing or viewing with \"gs\". INPUT: figures = list (vector) of figure numbers filename = name of postscript file to create OUTPUT: postscript file","title":"Basic Information"},{"location":"function-guide/utilities/max_max_m/","text":"max_max.m \u00b6 Basic Information \u00b6 max_max.m function returns the maximum value of an array and the i,j index's SYNTAX: [mx,i,j]= max_max(array); INPUT: array= input 2-d array OUTPUT: mx= scaler of maximum value i= row of maximum value j= column of maximum value Caution: only tested on 2-d arrays (not on vectors or scalars)","title":"max_max.m"},{"location":"function-guide/utilities/max_max_m/#max_maxm","text":"","title":"max_max.m"},{"location":"function-guide/utilities/max_max_m/#basic-information","text":"max_max.m function returns the maximum value of an array and the i,j index's SYNTAX: [mx,i,j]= max_max(array); INPUT: array= input 2-d array OUTPUT: mx= scaler of maximum value i= row of maximum value j= column of maximum value Caution: only tested on 2-d arrays (not on vectors or scalars)","title":"Basic Information"},{"location":"function-guide/utilities/min_min_m/","text":"min_min.m \u00b6 Basic Information \u00b6 min_min.m function returns the minimum value of an array and the i,j index's SYNTAX: [mn,i,j]= min_min(array); INPUT: array= input 2-d array OUTPUT: mn= scaler of maximum value i= row of maximum value j= column of maximum value Caution: only tested on 2-d arrays (not on vectors or scalars)","title":"min_min.m"},{"location":"function-guide/utilities/min_min_m/#min_minm","text":"","title":"min_min.m"},{"location":"function-guide/utilities/min_min_m/#basic-information","text":"min_min.m function returns the minimum value of an array and the i,j index's SYNTAX: [mn,i,j]= min_min(array); INPUT: array= input 2-d array OUTPUT: mn= scaler of maximum value i= row of maximum value j= column of maximum value Caution: only tested on 2-d arrays (not on vectors or scalars)","title":"Basic Information"},{"location":"function-guide/utilities/mk_var_m/","text":"mk_var.m \u00b6 Basic Information \u00b6 mk_var sets variable = value if it does not exist in the calling workspace same as: if exist('variable') variable = value; end SYNTAX: numvar= mk_var(variable,value); INPUT: variable= name of variable to make (IF IT DOESNT ALREADY EXIST) value= value of variable Default: []; OUTPUT: makes \"variable=value\" in calling workspace if it doesnt exist numvar = number of variables made (0 if no variables made -1 if error) LIMITATIONS: variable can be an string array containing a list of vairables however value then must be a single variable, or an array with same row length as variable. If not it sets all variables to value.","title":"mk_var.m"},{"location":"function-guide/utilities/mk_var_m/#mk_varm","text":"","title":"mk_var.m"},{"location":"function-guide/utilities/mk_var_m/#basic-information","text":"mk_var sets variable = value if it does not exist in the calling workspace same as: if exist('variable') variable = value; end SYNTAX: numvar= mk_var(variable,value); INPUT: variable= name of variable to make (IF IT DOESNT ALREADY EXIST) value= value of variable Default: []; OUTPUT: makes \"variable=value\" in calling workspace if it doesnt exist numvar = number of variables made (0 if no variables made -1 if error) LIMITATIONS: variable can be an string array containing a list of vairables however value then must be a single variable, or an array with same row length as variable. If not it sets all variables to value.","title":"Basic Information"},{"location":"function-guide/utilities/modulo_m/","text":"modulo.m \u00b6 Basic Information \u00b6 SYNTAX: modvalue = modulo(number,base) PURPOSE: Calculates remainder when number is divided by base value. INPUT: number = number to reduce modulo base base = base of modular arithmetic OUTPUT: modvalue = number reduced modulo base RESTRICTIONS: This works for \"all\" floating point numbers and for every pair of integers I've tried, but since matlab does only floating point arithmetic I expect that some combination of integers will give the wrong answer. Some additional logic needs to be added sometime to address this.","title":"modulo.m"},{"location":"function-guide/utilities/modulo_m/#modulom","text":"","title":"modulo.m"},{"location":"function-guide/utilities/modulo_m/#basic-information","text":"SYNTAX: modvalue = modulo(number,base) PURPOSE: Calculates remainder when number is divided by base value. INPUT: number = number to reduce modulo base base = base of modular arithmetic OUTPUT: modvalue = number reduced modulo base RESTRICTIONS: This works for \"all\" floating point numbers and for every pair of integers I've tried, but since matlab does only floating point arithmetic I expect that some combination of integers will give the wrong answer. Some additional logic needs to be added sometime to address this.","title":"Basic Information"},{"location":"function-guide/utilities/netcdf_R14_m/","text":"netcdf_R14.m \u00b6 Basic Information \u00b6 Function to read NetCDF files S = netcdf(File) Input Arguments File = NetCDF file to read Optional Input Arguments: 'Var',Var - Read data for VarArray(Var), default [1:length(S.VarArray)] 'Rec',Rec - Read data for Record(Rec), default [1:S.NumRecs] Output Arguments: S = Structure of NetCDF data organised as per NetCDF definition Notes: Only version 1, classic 32bit, NetCDF files are supported. By default data are extracted into the S.VarArray().Data field for all variables. To read the header only call S = netcdf(File,'Var',[]); SEE ALSO ---------------------------------------------------------------------------","title":"netcdf_R14.m"},{"location":"function-guide/utilities/netcdf_R14_m/#netcdf_r14m","text":"","title":"netcdf_R14.m"},{"location":"function-guide/utilities/netcdf_R14_m/#basic-information","text":"Function to read NetCDF files S = netcdf(File) Input Arguments File = NetCDF file to read Optional Input Arguments: 'Var',Var - Read data for VarArray(Var), default [1:length(S.VarArray)] 'Rec',Rec - Read data for Record(Rec), default [1:S.NumRecs] Output Arguments: S = Structure of NetCDF data organised as per NetCDF definition Notes: Only version 1, classic 32bit, NetCDF files are supported. By default data are extracted into the S.VarArray().Data field for all variables. To read the header only call S = netcdf(File,'Var',[]); SEE ALSO ---------------------------------------------------------------------------","title":"Basic Information"},{"location":"function-guide/utilities/ot_script_m/","text":"ot_script.m \u00b6 Basic Information \u00b6 SYNTAX: ot_script PURPOSE: writes variable identified by string vnam into base area INPUT: vnam= name of variable to write to the base area ex: vnam='vac_objects'; vnam='time'; vnam= 'ip'; ... OUTPUT: variable identified by string vnam is set in base area EXAMPLE USE in Function to allow call of function as script if nargout<=0 vnam= 'rbs'; ot_script; vnam= 'minimize_i'; ot_script end NOTE: This script when used inside a function allows the function to act like a script for output to base. If variable doesnt exist it isnt set RESTRICTIONS: vnam must be a character variable presently only puts output variables in base (not calling routine) Caution: overwrites variable identified in vnam in base See also in_script","title":"ot_script.m"},{"location":"function-guide/utilities/ot_script_m/#ot_scriptm","text":"","title":"ot_script.m"},{"location":"function-guide/utilities/ot_script_m/#basic-information","text":"SYNTAX: ot_script PURPOSE: writes variable identified by string vnam into base area INPUT: vnam= name of variable to write to the base area ex: vnam='vac_objects'; vnam='time'; vnam= 'ip'; ... OUTPUT: variable identified by string vnam is set in base area EXAMPLE USE in Function to allow call of function as script if nargout<=0 vnam= 'rbs'; ot_script; vnam= 'minimize_i'; ot_script end NOTE: This script when used inside a function allows the function to act like a script for output to base. If variable doesnt exist it isnt set RESTRICTIONS: vnam must be a character variable presently only puts output variables in base (not calling routine) Caution: overwrites variable identified in vnam in base See also in_script","title":"Basic Information"},{"location":"function-guide/utilities/packnlstr_m/","text":"packnlstr.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: Pack namelist string (remove all the extraneous separators). INPUT: str_in = string to pack OUTPUT: str_out = string after packing","title":"packnlstr.m"},{"location":"function-guide/utilities/packnlstr_m/#packnlstrm","text":"","title":"packnlstr.m"},{"location":"function-guide/utilities/packnlstr_m/#basic-information","text":"SYNTAX: PURPOSE: Pack namelist string (remove all the extraneous separators). INPUT: str_in = string to pack OUTPUT: str_out = string after packing","title":"Basic Information"},{"location":"function-guide/utilities/parseXML_m/","text":"parseXML.m \u00b6 Basic Information \u00b6 SYNTAX: theStruct = parseXML(filename) PURPOSE: Convert XML file to a MATLAB structure. INPUT: input_file = xml file to parse OUTPUT: theStruct = matlab structure (DOM format) parsed from xml file RESTRICTIONS: METHOD: For a description of a Document Object Model (DOM), see Mathworks online help at: https://www.mathworks.com/help/releases/R2017a/matlab/import_export/importing-xml-documents.html#bsmj8la","title":"parseXML.m"},{"location":"function-guide/utilities/parseXML_m/#parsexmlm","text":"","title":"parseXML.m"},{"location":"function-guide/utilities/parseXML_m/#basic-information","text":"SYNTAX: theStruct = parseXML(filename) PURPOSE: Convert XML file to a MATLAB structure. INPUT: input_file = xml file to parse OUTPUT: theStruct = matlab structure (DOM format) parsed from xml file RESTRICTIONS: METHOD: For a description of a Document Object Model (DOM), see Mathworks online help at: https://www.mathworks.com/help/releases/R2017a/matlab/import_export/importing-xml-documents.html#bsmj8la","title":"Basic Information"},{"location":"function-guide/utilities/parse_filename_m/","text":"parse_filename.m \u00b6 Basic Information \u00b6 PURPOSE: determine the directory, name and extention of a file SYNTAX: [dir,nam,ext]= parse_filename(string_in) INPUT: string_in= string containing full file name (ex: /dir/subdir/name.ext) OUTPUT: (example: /dir/subdir/name.ext) dir= directory name of file with last / (ex: /dir/subdir/) nam= name of file without extention (ex: name) ext= extention name with pre . (ex: .ext) CAUTION: Only works for single row vector of ASCII characterics","title":"parse_filename.m"},{"location":"function-guide/utilities/parse_filename_m/#parse_filenamem","text":"","title":"parse_filename.m"},{"location":"function-guide/utilities/parse_filename_m/#basic-information","text":"PURPOSE: determine the directory, name and extention of a file SYNTAX: [dir,nam,ext]= parse_filename(string_in) INPUT: string_in= string containing full file name (ex: /dir/subdir/name.ext) OUTPUT: (example: /dir/subdir/name.ext) dir= directory name of file with last / (ex: /dir/subdir/) nam= name of file without extention (ex: name) ext= extention name with pre . (ex: .ext) CAUTION: Only works for single row vector of ASCII characterics","title":"Basic Information"},{"location":"function-guide/utilities/pause_fig_m/","text":"pause_fig.m \u00b6 Basic Information \u00b6 pause_fig pauses for look at figure SYNTAX: pause_fig(pause_it) INPUT: [default] pause_it= 0; No pause - do nothing pause_it= 1; = pause, and wait for key stroke pause_it= 2.1; any +number other than 0 or 1 causes pause for # seconds OUTPUT: No Output => Just types Paused at gcf and pauses","title":"pause_fig.m"},{"location":"function-guide/utilities/pause_fig_m/#pause_figm","text":"","title":"pause_fig.m"},{"location":"function-guide/utilities/pause_fig_m/#basic-information","text":"pause_fig pauses for look at figure SYNTAX: pause_fig(pause_it) INPUT: [default] pause_it= 0; No pause - do nothing pause_it= 1; = pause, and wait for key stroke pause_it= 2.1; any +number other than 0 or 1 causes pause for # seconds OUTPUT: No Output => Just types Paused at gcf and pauses","title":"Basic Information"},{"location":"function-guide/utilities/print_figs_m/","text":"print_figs.m \u00b6 Basic Information \u00b6 prints figures using \"print -depsc f#\" where # is figure number SYNTAX: print_figs; Prints all open figures print_figs(fig_nums); Prints fig_nums vector of figures print_figs(fig_nums,pre); Uses pre for name of file prepend (fig1) print_figs(fig_nums,[],prt_opt); use different -depsc output INPUT: [default] fig_nums= list of figure numbers to print [defaults to all open figures] pre= name to prepend infront of # in file name ['f'] prt_opt= printer device option ['-dpesc'] OUTPUT: figures are created with f#.eps file names where # are figure numbers","title":"print_figs.m"},{"location":"function-guide/utilities/print_figs_m/#print_figsm","text":"","title":"print_figs.m"},{"location":"function-guide/utilities/print_figs_m/#basic-information","text":"prints figures using \"print -depsc f#\" where # is figure number SYNTAX: print_figs; Prints all open figures print_figs(fig_nums); Prints fig_nums vector of figures print_figs(fig_nums,pre); Uses pre for name of file prepend (fig1) print_figs(fig_nums,[],prt_opt); use different -depsc output INPUT: [default] fig_nums= list of figure numbers to print [defaults to all open figures] pre= name to prepend infront of # in file name ['f'] prt_opt= printer device option ['-dpesc'] OUTPUT: figures are created with f#.eps file names where # are figure numbers","title":"Basic Information"},{"location":"function-guide/utilities/progressbar_m/","text":"progressbar.m \u00b6 Basic Information \u00b6 Description: progressbar() provides an indication of the progress of some task using graphics and text. Calling progressbar repeatedly will update the figure and automatically estimate the amount of time remaining. This implementation of progressbar is intended to be extremely simple to use while providing a high quality user experience. Features: - Can add progressbar to existing m-files with a single line of code. - Supports multiple bars in one figure to show progress of nested loops. - Optional labels on bars. - Figure closes automatically when task is complete. - Only one figure can exist so old figures don't clutter the desktop. - Remaining time estimate is accurate even if the figure gets closed. - Minimal execution time. Won't slow down code. - Randomized color. When a programmer gets bored... Example Function Calls For Single Bar Usage: progressbar Initialize/reset progressbar(0) Initialize/reset progressbar('Label') Initialize/reset and label the bar progressbar(0.5) Update progressbar(1) Close Example Function Calls For Multi Bar Usage: progressbar(0, 0) Initialize/reset two bars progressbar('A', '') Initialize/reset two bars with one label progressbar('', 'B') Initialize/reset two bars with one label progressbar('A', 'B') Initialize/reset two bars with two labels progressbar(0.3) Update 1st bar progressbar(0.3, []) Update 1st bar progressbar([], 0.3) Update 2nd bar progressbar(0.7, 0.9) Update both bars progressbar(1) Close progressbar(1, []) Close progressbar(1, 0.4) Close Notes: For best results, call progressbar with all zero (or all string) inputs before any processing. This sets the proper starting time reference to calculate time remaining. Bar color is choosen randomly when the figure is created or reset. Clicking the bar will cause a random color change. Demos: Single bar m = 500; progressbar Init single bar for i = 1:m pause(0.01) Do something important progressbar(i/m) Update progress bar end Simple multi bar (update one bar at a time) m = 4; n = 3; p = 100; progressbar(0,0,0) Init 3 bars for i = 1:m progressbar([],0) Reset 2nd bar for j = 1:n progressbar([],[],0) Reset 3rd bar for k = 1:p pause(0.01) Do something important progressbar([],[],k/p) Update 3rd bar end progressbar([],j/n) Update 2nd bar end progressbar(i/m) Update 1st bar end Fancy multi bar (use labels and update all bars at once) m = 4; n = 3; p = 100; progressbar('Monte Carlo Trials','Simulation','Component') Init 3 bars for i = 1:m for j = 1:n for k = 1:p pause(0.01) Do something important Update all bars frac3 = k/p; frac2 = ((j-1) + frac3) / n; frac1 = ((i-1) + frac2) / m; progressbar(frac1, frac2, frac3) end end end Author: Steve Hoelzer Revisions: 2002-Feb-27 Created function 2002-Mar-19 Updated title text order 2002-Apr-11 Use floor instead of round for percentdone 2002-Jun-06 Updated for speed using patch (Thanks to waitbar.m) 2002-Jun-19 Choose random patch color when a new figure is created 2002-Jun-24 Click on bar or axes to choose new random color 2002-Jun-27 Calc time left, reset progress bar when fractiondone == 0 2002-Jun-28 Remove extraText var, add position var 2002-Jul-18 fractiondone input is optional 2002-Jul-19 Allow position to specify screen coordinates 2002-Jul-22 Clear vars used in color change callback routine 2002-Jul-29 Position input is always specified in pixels 2002-Sep-09 Change order of title bar text 2003-Jun-13 Change 'min' to 'm' because of built in function 'min' 2003-Sep-08 Use callback for changing color instead of string 2003-Sep-10 Use persistent vars for speed, modify titlebarstr 2003-Sep-25 Correct titlebarstr for 0 case 2003-Nov-25 Clear all persistent vars when percentdone = 100 2004-Jan-22 Cleaner reset process, don't create figure if percentdone = 100 2004-Jan-27 Handle incorrect position input 2004-Feb-16 Minimum time interval between updates 2004-Apr-01 Cleaner process of enforcing minimum time interval 2004-Oct-08 Seperate function for timeleftstr, expand to include days 2004-Oct-20 Efficient if-else structure for sec2timestr 2006-Sep-11 Width is a multiple of height (don't stretch on widescreens) 2010-Sep-21 Major overhaul to support multiple bars and add labels 2011-Feb-02 By Anders Welander: Added feature to write message in title","title":"progressbar.m"},{"location":"function-guide/utilities/progressbar_m/#progressbarm","text":"","title":"progressbar.m"},{"location":"function-guide/utilities/progressbar_m/#basic-information","text":"Description: progressbar() provides an indication of the progress of some task using graphics and text. Calling progressbar repeatedly will update the figure and automatically estimate the amount of time remaining. This implementation of progressbar is intended to be extremely simple to use while providing a high quality user experience. Features: - Can add progressbar to existing m-files with a single line of code. - Supports multiple bars in one figure to show progress of nested loops. - Optional labels on bars. - Figure closes automatically when task is complete. - Only one figure can exist so old figures don't clutter the desktop. - Remaining time estimate is accurate even if the figure gets closed. - Minimal execution time. Won't slow down code. - Randomized color. When a programmer gets bored... Example Function Calls For Single Bar Usage: progressbar Initialize/reset progressbar(0) Initialize/reset progressbar('Label') Initialize/reset and label the bar progressbar(0.5) Update progressbar(1) Close Example Function Calls For Multi Bar Usage: progressbar(0, 0) Initialize/reset two bars progressbar('A', '') Initialize/reset two bars with one label progressbar('', 'B') Initialize/reset two bars with one label progressbar('A', 'B') Initialize/reset two bars with two labels progressbar(0.3) Update 1st bar progressbar(0.3, []) Update 1st bar progressbar([], 0.3) Update 2nd bar progressbar(0.7, 0.9) Update both bars progressbar(1) Close progressbar(1, []) Close progressbar(1, 0.4) Close Notes: For best results, call progressbar with all zero (or all string) inputs before any processing. This sets the proper starting time reference to calculate time remaining. Bar color is choosen randomly when the figure is created or reset. Clicking the bar will cause a random color change. Demos: Single bar m = 500; progressbar Init single bar for i = 1:m pause(0.01) Do something important progressbar(i/m) Update progress bar end Simple multi bar (update one bar at a time) m = 4; n = 3; p = 100; progressbar(0,0,0) Init 3 bars for i = 1:m progressbar([],0) Reset 2nd bar for j = 1:n progressbar([],[],0) Reset 3rd bar for k = 1:p pause(0.01) Do something important progressbar([],[],k/p) Update 3rd bar end progressbar([],j/n) Update 2nd bar end progressbar(i/m) Update 1st bar end Fancy multi bar (use labels and update all bars at once) m = 4; n = 3; p = 100; progressbar('Monte Carlo Trials','Simulation','Component') Init 3 bars for i = 1:m for j = 1:n for k = 1:p pause(0.01) Do something important Update all bars frac3 = k/p; frac2 = ((j-1) + frac3) / n; frac1 = ((i-1) + frac2) / m; progressbar(frac1, frac2, frac3) end end end Author: Steve Hoelzer Revisions: 2002-Feb-27 Created function 2002-Mar-19 Updated title text order 2002-Apr-11 Use floor instead of round for percentdone 2002-Jun-06 Updated for speed using patch (Thanks to waitbar.m) 2002-Jun-19 Choose random patch color when a new figure is created 2002-Jun-24 Click on bar or axes to choose new random color 2002-Jun-27 Calc time left, reset progress bar when fractiondone == 0 2002-Jun-28 Remove extraText var, add position var 2002-Jul-18 fractiondone input is optional 2002-Jul-19 Allow position to specify screen coordinates 2002-Jul-22 Clear vars used in color change callback routine 2002-Jul-29 Position input is always specified in pixels 2002-Sep-09 Change order of title bar text 2003-Jun-13 Change 'min' to 'm' because of built in function 'min' 2003-Sep-08 Use callback for changing color instead of string 2003-Sep-10 Use persistent vars for speed, modify titlebarstr 2003-Sep-25 Correct titlebarstr for 0 case 2003-Nov-25 Clear all persistent vars when percentdone = 100 2004-Jan-22 Cleaner reset process, don't create figure if percentdone = 100 2004-Jan-27 Handle incorrect position input 2004-Feb-16 Minimum time interval between updates 2004-Apr-01 Cleaner process of enforcing minimum time interval 2004-Oct-08 Seperate function for timeleftstr, expand to include days 2004-Oct-20 Efficient if-else structure for sec2timestr 2006-Sep-11 Width is a multiple of height (don't stretch on widescreens) 2010-Sep-21 Major overhaul to support multiple bars and add labels 2011-Feb-02 By Anders Welander: Added feature to write message in title","title":"Basic Information"},{"location":"function-guide/utilities/quadg_m/","text":"quadg.m \u00b6 Basic Information \u00b6 QUADG Numerical quadrature using open methods. Q = QUADG(fun,a,b) approximates the integral of fun from a to b using some type of Gaussian quadrature. The default type is a Gauss-Kronrod, 7(15) order. Q = QUADG(fun,a,b,options) allows integrations option to be specified. Q = QUADG(fun,a,b,options,p1,p2,...) will pass the extra parameters p1, p2, ... to fun. Options is a structure specifying any of the following options: Field name Parameter Possibilites and {Default} options.tol Tolerance [{1e-6}, any fractional number] options.diplay Display on/off [{'off'}, 'on'] options.nodes nodes [vector, {Gauss-Kronrod nodes}] options.weights weights [matrix, {Gauss-Kronrod weights}] Using options=[] will use the default options. Tolerance is based on the relative error. With double-precision arithmetic, feasible values for this parameter range from 1e-15 to 1. The default is 1e-6. Setting the display on shows the integrand samples and a histogram of their distribution, as well as a table reporting the progress of the integration as it proceeds. Note that the display will slow down the performance of the quadrature. The nodes and weights parameters are discussed in the \"Advanced Features\" section in the source code just after the help entry. Type 'edit quadg' to see this note. There's no need to use this option unless you like playing with other people's source code and know what you're doing (and can figure out what I was doing). Example: f = inline('cos(x).*sin(x.*x)'); options.display = 'on'; quadg(f,-2*pi,2*pi,options) Increasing the range of this quadrature will cause most recursive to slow dramatically and run out of stack space. See the source code for additional comments. See also QUADL, QUAD, DBLQUAD, INLINE, @.","title":"quadg.m"},{"location":"function-guide/utilities/quadg_m/#quadgm","text":"","title":"quadg.m"},{"location":"function-guide/utilities/quadg_m/#basic-information","text":"QUADG Numerical quadrature using open methods. Q = QUADG(fun,a,b) approximates the integral of fun from a to b using some type of Gaussian quadrature. The default type is a Gauss-Kronrod, 7(15) order. Q = QUADG(fun,a,b,options) allows integrations option to be specified. Q = QUADG(fun,a,b,options,p1,p2,...) will pass the extra parameters p1, p2, ... to fun. Options is a structure specifying any of the following options: Field name Parameter Possibilites and {Default} options.tol Tolerance [{1e-6}, any fractional number] options.diplay Display on/off [{'off'}, 'on'] options.nodes nodes [vector, {Gauss-Kronrod nodes}] options.weights weights [matrix, {Gauss-Kronrod weights}] Using options=[] will use the default options. Tolerance is based on the relative error. With double-precision arithmetic, feasible values for this parameter range from 1e-15 to 1. The default is 1e-6. Setting the display on shows the integrand samples and a histogram of their distribution, as well as a table reporting the progress of the integration as it proceeds. Note that the display will slow down the performance of the quadrature. The nodes and weights parameters are discussed in the \"Advanced Features\" section in the source code just after the help entry. Type 'edit quadg' to see this note. There's no need to use this option unless you like playing with other people's source code and know what you're doing (and can figure out what I was doing). Example: f = inline('cos(x).*sin(x.*x)'); options.display = 'on'; quadg(f,-2*pi,2*pi,options) Increasing the range of this quadrature will cause most recursive to slow dramatically and run out of stack space. See the source code for additional comments. See also QUADL, QUAD, DBLQUAD, INLINE, @.","title":"Basic Information"},{"location":"function-guide/utilities/read_lines_m/","text":"read_lines.m \u00b6 Basic Information \u00b6 function [tit,narray,array]= read_lines(file_name) reads data from file file_name which is expected to be lines.dat It reads sets of data until the eof is found or a n=-99 is incoundered Format of file is: Title for data set 1 n, data, data, .... where: n= number of records to follow in data set x, y, z, ... data to be read into array stored by row : read n data records x, y, z, ... data to be read into array stored by row repete above for next data set output: tit = array containing titles read for each data set narray(:,1) = Number of rows in array for each data set narray(:,2:end) = other data read in the 2nd data set record array = Data storage of all data sets stored sequential by row length(narray(:,1)= Number of data sets","title":"read_lines.m"},{"location":"function-guide/utilities/read_lines_m/#read_linesm","text":"","title":"read_lines.m"},{"location":"function-guide/utilities/read_lines_m/#basic-information","text":"function [tit,narray,array]= read_lines(file_name) reads data from file file_name which is expected to be lines.dat It reads sets of data until the eof is found or a n=-99 is incoundered Format of file is: Title for data set 1 n, data, data, .... where: n= number of records to follow in data set x, y, z, ... data to be read into array stored by row : read n data records x, y, z, ... data to be read into array stored by row repete above for next data set output: tit = array containing titles read for each data set narray(:,1) = Number of rows in array for each data set narray(:,2:end) = other data read in the 2nd data set record array = Data storage of all data sets stored sequential by row length(narray(:,1)= Number of data sets","title":"Basic Information"},{"location":"function-guide/utilities/read_namelist_m/","text":"read_namelist.m \u00b6 Basic Information \u00b6 SYNTAX: FUNCTION CALL: [nlnames,nlstr,nlall]= read_namelist(filename,to_upper); SCRIPT CALL (compatable with old script) read_namelist; SCRIPT FORM reads & writes to caller area PURPOSE: Read a FORTRAN namelist file and create variables in the matlab workspace defined by variables in the namelist. INPUT: [default] filename = name of namelist file to read to_upper = 1; makes variables UPPER case; -1= LOWER case;s [0] NOTE: if any input variable missing it looks 1st in \"caller\" then in \"base\" OUTPUT: nlnames= Name of all namelists found in file nlstr= Structure of namelist and variables nlall= total list of all namelists and variable (for write_namelist) NOTE: if output variable \"nlstr\" is not present, routine puts all namelist variables in \"caller\" routine. Same for \"nlall\" (duplicate variable names in \"caller\" routine are overwritten) NOTE: To get all structure namelist variables into environment: [names, isstruc]= struct_to_ws(nlstr); Do 1st level if any(isstruc) Loop to do 2nd level id= find(isstruc); for ii= 1:length(id) str= ['[names1,isstruc1]= struct_to_ws(' char(names(id(ii))) ');']; eval(str) end for end if any clear nlstr RESTRICTIONS: won't work if '=' signs in quotes in any of string data won't work for multiple (*) string variables","title":"read_namelist.m"},{"location":"function-guide/utilities/read_namelist_m/#read_namelistm","text":"","title":"read_namelist.m"},{"location":"function-guide/utilities/read_namelist_m/#basic-information","text":"SYNTAX: FUNCTION CALL: [nlnames,nlstr,nlall]= read_namelist(filename,to_upper); SCRIPT CALL (compatable with old script) read_namelist; SCRIPT FORM reads & writes to caller area PURPOSE: Read a FORTRAN namelist file and create variables in the matlab workspace defined by variables in the namelist. INPUT: [default] filename = name of namelist file to read to_upper = 1; makes variables UPPER case; -1= LOWER case;s [0] NOTE: if any input variable missing it looks 1st in \"caller\" then in \"base\" OUTPUT: nlnames= Name of all namelists found in file nlstr= Structure of namelist and variables nlall= total list of all namelists and variable (for write_namelist) NOTE: if output variable \"nlstr\" is not present, routine puts all namelist variables in \"caller\" routine. Same for \"nlall\" (duplicate variable names in \"caller\" routine are overwritten) NOTE: To get all structure namelist variables into environment: [names, isstruc]= struct_to_ws(nlstr); Do 1st level if any(isstruc) Loop to do 2nd level id= find(isstruc); for ii= 1:length(id) str= ['[names1,isstruc1]= struct_to_ws(' char(names(id(ii))) ');']; eval(str) end for end if any clear nlstr RESTRICTIONS: won't work if '=' signs in quotes in any of string data won't work for multiple (*) string variables","title":"Basic Information"},{"location":"function-guide/utilities/read_namelist_new_m/","text":"read_namelist_new.m \u00b6 Basic Information \u00b6 SYNTAX: read_namelist PURPOSE: Read a FORTRAN namelist file and create variables in the matlab workspace defined by variables in the namelist. INPUT: [default] filename = name of namelist file to read to_upper = 1; makes all variables UPPER case [0] to_upper =-1; makes all variables lower case [0] OUTPUT: varlist = list of variables read from namelist file All variables found in namelist(s) within the file are made into matlab variables. Duplicate names are overwritten with subsequent data. RESTRICTIONS: (1) won't work if '=' signs in quotes in any of data (2) won't work for multiple (*) string variables","title":"read_namelist_new.m"},{"location":"function-guide/utilities/read_namelist_new_m/#read_namelist_newm","text":"","title":"read_namelist_new.m"},{"location":"function-guide/utilities/read_namelist_new_m/#basic-information","text":"SYNTAX: read_namelist PURPOSE: Read a FORTRAN namelist file and create variables in the matlab workspace defined by variables in the namelist. INPUT: [default] filename = name of namelist file to read to_upper = 1; makes all variables UPPER case [0] to_upper =-1; makes all variables lower case [0] OUTPUT: varlist = list of variables read from namelist file All variables found in namelist(s) within the file are made into matlab variables. Duplicate names are overwritten with subsequent data. RESTRICTIONS: (1) won't work if '=' signs in quotes in any of data (2) won't work for multiple (*) string variables","title":"Basic Information"},{"location":"function-guide/utilities/read_point_m/","text":"read_point.m \u00b6 Basic Information \u00b6 point_list=read_point(point_file); read point names into an array of characters Input: point_file= File name with point names in it rmemptyln= remove empty lines (optional) [1] Note: Each point name should start on a seperate line line length no longer restricted Comments can be included in file by starting the line with or ? For points you dont want to include in read simply put at start of line Output: point_list= list of point names found in file, one point per row","title":"read_point.m"},{"location":"function-guide/utilities/read_point_m/#read_pointm","text":"","title":"read_point.m"},{"location":"function-guide/utilities/read_point_m/#basic-information","text":"point_list=read_point(point_file); read point names into an array of characters Input: point_file= File name with point names in it rmemptyln= remove empty lines (optional) [1] Note: Each point name should start on a seperate line line length no longer restricted Comments can be included in file by starting the line with or ? For points you dont want to include in read simply put at start of line Output: point_list= list of point names found in file, one point per row","title":"Basic Information"},{"location":"function-guide/utilities/regstrmatch_m/","text":"regstrmatch.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: Regular string match a'la UNIX string matching. INPUT: OUTPUT: RESTRICTIONS: Only one of * or is permitted in string_pattern.","title":"regstrmatch.m"},{"location":"function-guide/utilities/regstrmatch_m/#regstrmatchm","text":"","title":"regstrmatch.m"},{"location":"function-guide/utilities/regstrmatch_m/#basic-information","text":"SYNTAX: PURPOSE: Regular string match a'la UNIX string matching. INPUT: OUTPUT: RESTRICTIONS: Only one of * or is permitted in string_pattern.","title":"Basic Information"},{"location":"function-guide/utilities/remove_space_m/","text":"remove_space.m \u00b6 Basic Information \u00b6 SYNTAX: string_ot= remove_space(string_in, position); PURPOSE: Removes spaces in string (like deblank but allows different location removal) INPUT: [default] string_in= input string (single row string NOT string array) position= 0 all spaces, 1=front, [2=END], 3=front&end {OPTIONAL) OUTPUT: string_ot= output string with spaces removed RESTRICTIONS: Only tested on 2-d arrays (not on vectors or scalars)","title":"remove_space.m"},{"location":"function-guide/utilities/remove_space_m/#remove_spacem","text":"","title":"remove_space.m"},{"location":"function-guide/utilities/remove_space_m/#basic-information","text":"SYNTAX: string_ot= remove_space(string_in, position); PURPOSE: Removes spaces in string (like deblank but allows different location removal) INPUT: [default] string_in= input string (single row string NOT string array) position= 0 all spaces, 1=front, [2=END], 3=front&end {OPTIONAL) OUTPUT: string_ot= output string with spaces removed RESTRICTIONS: Only tested on 2-d arrays (not on vectors or scalars)","title":"Basic Information"},{"location":"function-guide/utilities/removes_space_m/","text":"removes_space.m \u00b6 Basic Information \u00b6 removes spaces in sring (like deblank but allows different location removal) SYNTAX: string_ot= removes_space(string_in, position); INPUT: [default] string_in= input string position= 0 all spaces, 1=front, [2=END], 3=front&end {OPTIONAL) note: this recursively runs remove_space on each line of string_in OUTPUT: string_ot= output string with spaces removed Note: This works on columns","title":"removes_space.m"},{"location":"function-guide/utilities/removes_space_m/#removes_spacem","text":"","title":"removes_space.m"},{"location":"function-guide/utilities/removes_space_m/#basic-information","text":"removes spaces in sring (like deblank but allows different location removal) SYNTAX: string_ot= removes_space(string_in, position); INPUT: [default] string_in= input string position= 0 all spaces, 1=front, [2=END], 3=front&end {OPTIONAL) note: this recursively runs remove_space on each line of string_in OUTPUT: string_ot= output string with spaces removed Note: This works on columns","title":"Basic Information"},{"location":"function-guide/utilities/rmchar_m/","text":"rmchar.m \u00b6 Basic Information \u00b6 SYNTAX: result = rmchar(string,char) PURPOSE: Remove all instances of a specified character from a string. INPUT: string = string to remove character from char = character to remove OUTPUT: result = string after removing char","title":"rmchar.m"},{"location":"function-guide/utilities/rmchar_m/#rmcharm","text":"","title":"rmchar.m"},{"location":"function-guide/utilities/rmchar_m/#basic-information","text":"SYNTAX: result = rmchar(string,char) PURPOSE: Remove all instances of a specified character from a string. INPUT: string = string to remove character from char = character to remove OUTPUT: result = string after removing char","title":"Basic Information"},{"location":"function-guide/utilities/save_mat_m/","text":"save_mat.m \u00b6 Basic Information \u00b6 save_mat.m: Script to save list of variables defined in var_list into a Matlab binary file (.mat format) defined by SAVE_FILE. Routine will identify variables defined in var_list which are not in environment and will continue saving without these variables. var_list can be list of variables or file .ptn with list of variables. Use LOAD to restore variables from saved file. SYNTAX: save_mat INPUT: [default] save_file= name of save file to create [save.mat] var_list= list of variables to save or name of .ptn file with list 1st checks if var_list is a file, 2nd as variable list if var_list doesn exist it saves all variables Example as list: var_list = ['ncc '; 'variable1'; 'variable2']; Example as file: var_list = 'variable.ptn'; where variable.ptn file is: comment line ncc varable1 comment line not copied variable2 OUTPUT: list_save= list of variables saved in file SAVE_FILE Creates file with name defined by SAVE_FILE [save.mat] containing all variable defined in VAR_LIST. Those that dont exist aren't saved Saves ALL VARIABLES if VAR_LIST doesnt exist. NOTE: To read Save set use: load(save_file); load save.mat;","title":"save_mat.m"},{"location":"function-guide/utilities/save_mat_m/#save_matm","text":"","title":"save_mat.m"},{"location":"function-guide/utilities/save_mat_m/#basic-information","text":"save_mat.m: Script to save list of variables defined in var_list into a Matlab binary file (.mat format) defined by SAVE_FILE. Routine will identify variables defined in var_list which are not in environment and will continue saving without these variables. var_list can be list of variables or file .ptn with list of variables. Use LOAD to restore variables from saved file. SYNTAX: save_mat INPUT: [default] save_file= name of save file to create [save.mat] var_list= list of variables to save or name of .ptn file with list 1st checks if var_list is a file, 2nd as variable list if var_list doesn exist it saves all variables Example as list: var_list = ['ncc '; 'variable1'; 'variable2']; Example as file: var_list = 'variable.ptn'; where variable.ptn file is: comment line ncc varable1 comment line not copied variable2 OUTPUT: list_save= list of variables saved in file SAVE_FILE Creates file with name defined by SAVE_FILE [save.mat] containing all variable defined in VAR_LIST. Those that dont exist aren't saved Saves ALL VARIABLES if VAR_LIST doesnt exist. NOTE: To read Save set use: load(save_file); load save.mat;","title":"Basic Information"},{"location":"function-guide/utilities/save_whos_data_m/","text":"save_whos_data.m \u00b6 Basic Information \u00b6 SYNTAX: save_whos_data(whos_data) PURPOSE: Save to file the information you get when typing \"whos\". INPUT: whos_data = data structure you get by typing >> whos_data = whos OUTPUT: Local file called \"whos_data.dat\".","title":"save_whos_data.m"},{"location":"function-guide/utilities/save_whos_data_m/#save_whos_datam","text":"","title":"save_whos_data.m"},{"location":"function-guide/utilities/save_whos_data_m/#basic-information","text":"SYNTAX: save_whos_data(whos_data) PURPOSE: Save to file the information you get when typing \"whos\". INPUT: whos_data = data structure you get by typing >> whos_data = whos OUTPUT: Local file called \"whos_data.dat\".","title":"Basic Information"},{"location":"function-guide/utilities/search_path_m/","text":"search_path.m \u00b6 Basic Information \u00b6 SYNTAX: results = search_path(string,path_depth,search_depth) PURPOSE: String search of the matlabpath for documentation about a function, or model, or whatever, whose documentation contains the search string. (See also lookfor, whatfunction) INPUT: string = string to search for path_depth = one of the following (optional argument): - integer specifying how many directories in path to search - string specifying last directory to search (e.g. 'GAcontrol') - 'all', i.e. search all directories (default) search_depth = 'shallow' or 'deep' (optional, default='shallow') 'shallow' = look at Contents.m files only 'deep' = search both Contents.m files and all m-files (deep search takes awhile) OUTPUT: results = string containing documentation lines where strings matched and files where found RESTRICTIONS: Bug in MATLAB restricts when the 'deep' option will work. Uses the \"unix\" command to find m-files in a directory and sometimes this command doesn't work.","title":"search_path.m"},{"location":"function-guide/utilities/search_path_m/#search_pathm","text":"","title":"search_path.m"},{"location":"function-guide/utilities/search_path_m/#basic-information","text":"SYNTAX: results = search_path(string,path_depth,search_depth) PURPOSE: String search of the matlabpath for documentation about a function, or model, or whatever, whose documentation contains the search string. (See also lookfor, whatfunction) INPUT: string = string to search for path_depth = one of the following (optional argument): - integer specifying how many directories in path to search - string specifying last directory to search (e.g. 'GAcontrol') - 'all', i.e. search all directories (default) search_depth = 'shallow' or 'deep' (optional, default='shallow') 'shallow' = look at Contents.m files only 'deep' = search both Contents.m files and all m-files (deep search takes awhile) OUTPUT: results = string containing documentation lines where strings matched and files where found RESTRICTIONS: Bug in MATLAB restricts when the 'deep' option will work. Uses the \"unix\" command to find m-files in a directory and sometimes this command doesn't work.","title":"Basic Information"},{"location":"function-guide/utilities/set_mat_v6_m/","text":"set_mat_v6.m \u00b6 Basic Information \u00b6 set_mat_v6 sets default \"save\" to produce Version 6 compatable .mat files SYNTAX: set_mat_v6","title":"set_mat_v6.m"},{"location":"function-guide/utilities/set_mat_v6_m/#set_mat_v6m","text":"","title":"set_mat_v6.m"},{"location":"function-guide/utilities/set_mat_v6_m/#basic-information","text":"set_mat_v6 sets default \"save\" to produce Version 6 compatable .mat files SYNTAX: set_mat_v6","title":"Basic Information"},{"location":"function-guide/utilities/set_save_v6_m/","text":"set_save_v6.m \u00b6 Basic Information \u00b6 set_save_v6 sets default \"save\" to produce Version 6 compatable .mat files SYNTAX: set_save_v6","title":"set_save_v6.m"},{"location":"function-guide/utilities/set_save_v6_m/#set_save_v6m","text":"","title":"set_save_v6.m"},{"location":"function-guide/utilities/set_save_v6_m/#basic-information","text":"set_save_v6 sets default \"save\" to produce Version 6 compatable .mat files SYNTAX: set_save_v6","title":"Basic Information"},{"location":"function-guide/utilities/slope_m/","text":"slope.m \u00b6 Basic Information \u00b6 SYNTAX: m = slope(x,y) PURPOSE: Calculate slope of line specified by two points. INPUT: x = length 2 vector giving x values y = length 2 vector giving y values OUTPUT: m = slope of line","title":"slope.m"},{"location":"function-guide/utilities/slope_m/#slopem","text":"","title":"slope.m"},{"location":"function-guide/utilities/slope_m/#basic-information","text":"SYNTAX: m = slope(x,y) PURPOSE: Calculate slope of line specified by two points. INPUT: x = length 2 vector giving x values y = length 2 vector giving y values OUTPUT: m = slope of line","title":"Basic Information"},{"location":"function-guide/utilities/space_m/","text":"space.m \u00b6 Basic Information \u00b6 SYNTAX: space PURPOSE: print a blank line to screen","title":"space.m"},{"location":"function-guide/utilities/space_m/#spacem","text":"","title":"space.m"},{"location":"function-guide/utilities/space_m/#basic-information","text":"SYNTAX: space PURPOSE: print a blank line to screen","title":"Basic Information"},{"location":"function-guide/utilities/splitstring_m/","text":"splitstring.m \u00b6 Basic Information \u00b6 SYNTAX: len =splitstring( str, varargin ) PURPOSE: ARRAY = SPLITSTRING( STR, DELIM, ALLOWEMPTYENTRIES ) splits the character string STR, using the delimiter DELIM (which must be a character array). ARRAY is a cell array containing the resulting strings. If DELIM is not specified, space delimiter is assumed (see ISSPACE documentation). ALLOWEMPTYENTRIES should be a logical single element, specifying weather empty elements should be included in the results. If not specified, the value of ALLOWEMPTYENTRIES is false. INPUT: string = text string to find length of varargin is either DELIM or ALLOWEMPTYENTRIES OUTPUT: len = length of character string","title":"splitstring.m"},{"location":"function-guide/utilities/splitstring_m/#splitstringm","text":"","title":"splitstring.m"},{"location":"function-guide/utilities/splitstring_m/#basic-information","text":"SYNTAX: len =splitstring( str, varargin ) PURPOSE: ARRAY = SPLITSTRING( STR, DELIM, ALLOWEMPTYENTRIES ) splits the character string STR, using the delimiter DELIM (which must be a character array). ARRAY is a cell array containing the resulting strings. If DELIM is not specified, space delimiter is assumed (see ISSPACE documentation). ALLOWEMPTYENTRIES should be a logical single element, specifying weather empty elements should be included in the results. If not specified, the value of ALLOWEMPTYENTRIES is false. INPUT: string = text string to find length of varargin is either DELIM or ALLOWEMPTYENTRIES OUTPUT: len = length of character string","title":"Basic Information"},{"location":"function-guide/utilities/strarr_to_cellarr_m/","text":"strarr_to_cellarr.m \u00b6 Basic Information \u00b6 SYNTAX: cellarr = strarr_to_cellarr(strarr) PURPOSE: Convert string array with multiple strings on each line, delimited by spaces or tabs, to cell array. INPUT: strarr = either a string array or (an integer) file id corresponding to a data file (open for reading) containing the string array. OUTPUT: cellarr = cell array containing strings defined by strarr","title":"strarr_to_cellarr.m"},{"location":"function-guide/utilities/strarr_to_cellarr_m/#strarr_to_cellarrm","text":"","title":"strarr_to_cellarr.m"},{"location":"function-guide/utilities/strarr_to_cellarr_m/#basic-information","text":"SYNTAX: cellarr = strarr_to_cellarr(strarr) PURPOSE: Convert string array with multiple strings on each line, delimited by spaces or tabs, to cell array. INPUT: strarr = either a string array or (an integer) file id corresponding to a data file (open for reading) containing the string array. OUTPUT: cellarr = cell array containing strings defined by strarr","title":"Basic Information"},{"location":"function-guide/utilities/strcombine_m/","text":"strcombine.m \u00b6 Basic Information \u00b6 PURPOSE: strcombine finds single string from combination of 1st identical characters of str1 & str2 (or all rows of strs array). ex: str1= 'id1 ', str2= 'id2' => strot='id' SYNTAX: strot = strcombine(str1,str2); 2 single row character array strot = strcombine(str); multi row character array INPUT: [default] str1, str2= single row character array strs= multi row character array Output: strot= single row string containing identical starting characters Note: Trailing blanks are not considered characters function is case sensitive so use upper/lower to get identical case","title":"strcombine.m"},{"location":"function-guide/utilities/strcombine_m/#strcombinem","text":"","title":"strcombine.m"},{"location":"function-guide/utilities/strcombine_m/#basic-information","text":"PURPOSE: strcombine finds single string from combination of 1st identical characters of str1 & str2 (or all rows of strs array). ex: str1= 'id1 ', str2= 'id2' => strot='id' SYNTAX: strot = strcombine(str1,str2); 2 single row character array strot = strcombine(str); multi row character array INPUT: [default] str1, str2= single row character array strs= multi row character array Output: strot= single row string containing identical starting characters Note: Trailing blanks are not considered characters function is case sensitive so use upper/lower to get identical case","title":"Basic Information"},{"location":"function-guide/utilities/stringlen_m/","text":"stringlen.m \u00b6 Basic Information \u00b6 SYNTAX: len = stringlen(string) PURPOSE: Find length of string as defined by locating last nonblank character INPUT: string = text string to find length of OUTPUT: len = length of character string","title":"stringlen.m"},{"location":"function-guide/utilities/stringlen_m/#stringlenm","text":"","title":"stringlen.m"},{"location":"function-guide/utilities/stringlen_m/#basic-information","text":"SYNTAX: len = stringlen(string) PURPOSE: Find length of string as defined by locating last nonblank character INPUT: string = text string to find length of OUTPUT: len = length of character string","title":"Basic Information"},{"location":"function-guide/utilities/strlen_m/","text":"strlen.m \u00b6 Basic Information \u00b6 SYNTAX: len = strlen(string) PURPOSE: Find length of string as defined by locating last nonblank character INPUT: string = text string to find length of OUTPUT: len = length of character string","title":"strlen.m"},{"location":"function-guide/utilities/strlen_m/#strlenm","text":"","title":"strlen.m"},{"location":"function-guide/utilities/strlen_m/#basic-information","text":"SYNTAX: len = strlen(string) PURPOSE: Find length of string as defined by locating last nonblank character INPUT: string = text string to find length of OUTPUT: len = length of character string","title":"Basic Information"},{"location":"function-guide/utilities/strmatch_anywhr_m/","text":"strmatch_anywhr.m \u00b6 Basic Information \u00b6 SYNTAX: FUNCTION CALL: irow= strmatch_anywhr(str,strs); rows containing str [irow, jcol]= strmatch_anywhr(str,strs,'all'); return all matches PURPOSE: Returns rows of strs which have str anywhere in line INPUT: [default] str= single row of text (ex: 'F2a') strs= string array to look for str (ex: strvcat('PF1a','PF2a') flag= 'all'; returns all matches [remove duplicate row entrys] OUTPUT: irow= row index of strs which have str (ex: 2) jcol= colum index of 1st occurance of strs (ex: 2) RESTRICTIONS: str and strs must be type character; str is a single row","title":"strmatch_anywhr.m"},{"location":"function-guide/utilities/strmatch_anywhr_m/#strmatch_anywhrm","text":"","title":"strmatch_anywhr.m"},{"location":"function-guide/utilities/strmatch_anywhr_m/#basic-information","text":"SYNTAX: FUNCTION CALL: irow= strmatch_anywhr(str,strs); rows containing str [irow, jcol]= strmatch_anywhr(str,strs,'all'); return all matches PURPOSE: Returns rows of strs which have str anywhere in line INPUT: [default] str= single row of text (ex: 'F2a') strs= string array to look for str (ex: strvcat('PF1a','PF2a') flag= 'all'; returns all matches [remove duplicate row entrys] OUTPUT: irow= row index of strs which have str (ex: 2) jcol= colum index of 1st occurance of strs (ex: 2) RESTRICTIONS: str and strs must be type character; str is a single row","title":"Basic Information"},{"location":"function-guide/utilities/strmatch_cell_m/","text":"strmatch_cell.m \u00b6 Basic Information \u00b6 SYNTAX: idx = strmatch_cell(str,cellarray) PURPOSE: Replacement for matlab strmatch function, which doesn't work correctly for cell arrays. INPUT: str = string cellarray = cell array (n x 1) of strings OUTPUT: idx = indices of matching entries in cellarray","title":"strmatch_cell.m"},{"location":"function-guide/utilities/strmatch_cell_m/#strmatch_cellm","text":"","title":"strmatch_cell.m"},{"location":"function-guide/utilities/strmatch_cell_m/#basic-information","text":"SYNTAX: idx = strmatch_cell(str,cellarray) PURPOSE: Replacement for matlab strmatch function, which doesn't work correctly for cell arrays. INPUT: str = string cellarray = cell array (n x 1) of strings OUTPUT: idx = indices of matching entries in cellarray","title":"Basic Information"},{"location":"function-guide/utilities/strmatch_end_m/","text":"strmatch_end.m \u00b6 Basic Information \u00b6 PURPOSE: STRSATCH finds STRIN at END of STRBASE and returns pointer This is like strmatch except it looks at end of each row for strin blanks at end of array are ignored. Good for finding things like: ZBBBS in charter array containing row with: eq.RESULTS.GEQDSK.ZBBBS SYNTAX: id = strmatch_end(strin,strbase) match 1st characters of strin id = strmatch_end(strin,strbase,'exact') exact match , no warnings INPUT: [default] strin= array of strings to find index in strbase strbase= array of strings to search for strin exact= 'exact' then strings must be exact, {optional} [] Output: id= pointer in strbase array for strings in strin id = -1 problem in arguments [] number indicates element of strin not found in strbase NOTE: Previous versions had 'exact' by default. New version does not use 'exact' as default YOU MUST INCLUDE IT AS AN INPUT VARIABLE NOTE: Now strin & strbase can be cell strings or string arrays","title":"strmatch_end.m"},{"location":"function-guide/utilities/strmatch_end_m/#strmatch_endm","text":"","title":"strmatch_end.m"},{"location":"function-guide/utilities/strmatch_end_m/#basic-information","text":"PURPOSE: STRSATCH finds STRIN at END of STRBASE and returns pointer This is like strmatch except it looks at end of each row for strin blanks at end of array are ignored. Good for finding things like: ZBBBS in charter array containing row with: eq.RESULTS.GEQDSK.ZBBBS SYNTAX: id = strmatch_end(strin,strbase) match 1st characters of strin id = strmatch_end(strin,strbase,'exact') exact match , no warnings INPUT: [default] strin= array of strings to find index in strbase strbase= array of strings to search for strin exact= 'exact' then strings must be exact, {optional} [] Output: id= pointer in strbase array for strings in strin id = -1 problem in arguments [] number indicates element of strin not found in strbase NOTE: Previous versions had 'exact' by default. New version does not use 'exact' as default YOU MUST INCLUDE IT AS AN INPUT VARIABLE NOTE: Now strin & strbase can be cell strings or string arrays","title":"Basic Information"},{"location":"function-guide/utilities/strsfind_m/","text":"strsfind.m \u00b6 Basic Information \u00b6 SYNTAX: [jtext,ipatt] = strsfind(text,patterns); PURPOSE: Multiple \"patterns\" version of \"strfind\" Finds patterns (1 or more rows) in single text (single row) NOTE: trailing blanks in patterns are removed INPUT: text= single row of text (ex: '/home/leuer/tokamaks/nstx/efit/') patterns= patterns to search \"text\" (ex: ['east'; 'nstx'; 'iter'...]) NOTE: trailing blanks in patterns(ii,:) are removed OUTPUT: jtext= index in text(j) of start of pattern ipatt= row of patterns assoicated with a each particular jtext id note: jtext and ipatt have same length RESTRICTIONS: text and patterns must be type character; text is a single row","title":"strsfind.m"},{"location":"function-guide/utilities/strsfind_m/#strsfindm","text":"","title":"strsfind.m"},{"location":"function-guide/utilities/strsfind_m/#basic-information","text":"SYNTAX: [jtext,ipatt] = strsfind(text,patterns); PURPOSE: Multiple \"patterns\" version of \"strfind\" Finds patterns (1 or more rows) in single text (single row) NOTE: trailing blanks in patterns are removed INPUT: text= single row of text (ex: '/home/leuer/tokamaks/nstx/efit/') patterns= patterns to search \"text\" (ex: ['east'; 'nstx'; 'iter'...]) NOTE: trailing blanks in patterns(ii,:) are removed OUTPUT: jtext= index in text(j) of start of pattern ipatt= row of patterns assoicated with a each particular jtext id note: jtext and ipatt have same length RESTRICTIONS: text and patterns must be type character; text is a single row","title":"Basic Information"},{"location":"function-guide/utilities/strsmatchs_m/","text":"strsmatchs.m \u00b6 Basic Information \u00b6 PURPOSE: STRSMATCHS finds pointers in character array STRBASE for array STRIN. This is like STRSMATCH except it will return all matches in strbase for a particular row character in strin. If more than one entry is found in strbase then the output has entries in strbase. SYNTAX: id = strsmatchs(strin,strbase) match 1st characters of strin id = strsmatchs(strin,strbase,'exact') exact match of characters INPUT: [default] strin= array of strings to find index in strbase strbase= array of strings to search for strin exact= 'exact' then strings must be exact, {optional} [] idebug= 1; turn on warning messages [0] Output: id= pointer in strbase array for strings in strin id = -1 problem in arguments 0 number indicates element of strin not found in strbase NOTE: Previous versions had 'exact' by default. New version does not use 'exact' as default YOU MUST INCLUDE IT AS AN INPUT VARIABLE NOTE: Now strin & strbase can be cell strings or string arrays SEE: strmatch, /users/leuer/matlab/util/strsmatch","title":"strsmatchs.m"},{"location":"function-guide/utilities/strsmatchs_m/#strsmatchsm","text":"","title":"strsmatchs.m"},{"location":"function-guide/utilities/strsmatchs_m/#basic-information","text":"PURPOSE: STRSMATCHS finds pointers in character array STRBASE for array STRIN. This is like STRSMATCH except it will return all matches in strbase for a particular row character in strin. If more than one entry is found in strbase then the output has entries in strbase. SYNTAX: id = strsmatchs(strin,strbase) match 1st characters of strin id = strsmatchs(strin,strbase,'exact') exact match of characters INPUT: [default] strin= array of strings to find index in strbase strbase= array of strings to search for strin exact= 'exact' then strings must be exact, {optional} [] idebug= 1; turn on warning messages [0] Output: id= pointer in strbase array for strings in strin id = -1 problem in arguments 0 number indicates element of strin not found in strbase NOTE: Previous versions had 'exact' by default. New version does not use 'exact' as default YOU MUST INCLUDE IT AS AN INPUT VARIABLE NOTE: Now strin & strbase can be cell strings or string arrays SEE: strmatch, /users/leuer/matlab/util/strsmatch","title":"Basic Information"},{"location":"function-guide/utilities/struct_names_m/","text":"struct_names.m \u00b6 Basic Information \u00b6 PURPOSE: Returns names of all variables and substructures within structure SYNTAX: [var_names, str_names]= struct_names(struc); Normal Execution INPUT: <default> struc structure object to find internal variable and structure names OUTPUT: var_names full name of all variables in structure (ex. eq.GEQDSK.PSIRZ) str_names full name of all substructures (ex. eq.GEQDSK) NOTE: TO GET ALL VARIABLES IN STRUCTURE TO WORKSPACE see struct_to_ws_all NOTE: Uses Recursive execution of struct_names to get all variables and structures in recursive operation is includes additional inputs: [var_names, str_names]= struct_names(struc, var_names, str_names, pre_name); where: var_names input var_names to append output str_names input str_names to append output pre_name is name of previous structure to prepend on str_names","title":"struct_names.m"},{"location":"function-guide/utilities/struct_names_m/#struct_namesm","text":"","title":"struct_names.m"},{"location":"function-guide/utilities/struct_names_m/#basic-information","text":"PURPOSE: Returns names of all variables and substructures within structure SYNTAX: [var_names, str_names]= struct_names(struc); Normal Execution INPUT: <default> struc structure object to find internal variable and structure names OUTPUT: var_names full name of all variables in structure (ex. eq.GEQDSK.PSIRZ) str_names full name of all substructures (ex. eq.GEQDSK) NOTE: TO GET ALL VARIABLES IN STRUCTURE TO WORKSPACE see struct_to_ws_all NOTE: Uses Recursive execution of struct_names to get all variables and structures in recursive operation is includes additional inputs: [var_names, str_names]= struct_names(struc, var_names, str_names, pre_name); where: var_names input var_names to append output str_names input str_names to append output pre_name is name of previous structure to prepend on str_names","title":"Basic Information"},{"location":"function-guide/utilities/struct_to_ws_all_m/","text":"struct_to_ws_all.m \u00b6 Basic Information \u00b6 PURPOSE: Places all variables found in structure in WS works through all substructures to find ALL variables (no structures copied to WS only variables) SYNTAX: [names, str_names]= struct_to_ws_all(struc); INPUT: <default> s = Any Matlab Structure toupper = 1; make all variables UPPER CASE, -1=lower case, <0>=no change putwhere = 'base'; puts variables in base WS; <'caller'>=in calling routine OUTPUT: names name of all variables made in environment (ex. PSIRZ) str_names full name of all substructures found in struc (ex. eq.GEQDSK) NOTE: No structures copied to WS (only variables are copied) NOTE: Uses Recursive execution of struc_names to get all variables and structures SEE: struct_to_ws for only 1st level (variables and structures copy to environment)","title":"struct_to_ws_all.m"},{"location":"function-guide/utilities/struct_to_ws_all_m/#struct_to_ws_allm","text":"","title":"struct_to_ws_all.m"},{"location":"function-guide/utilities/struct_to_ws_all_m/#basic-information","text":"PURPOSE: Places all variables found in structure in WS works through all substructures to find ALL variables (no structures copied to WS only variables) SYNTAX: [names, str_names]= struct_to_ws_all(struc); INPUT: <default> s = Any Matlab Structure toupper = 1; make all variables UPPER CASE, -1=lower case, <0>=no change putwhere = 'base'; puts variables in base WS; <'caller'>=in calling routine OUTPUT: names name of all variables made in environment (ex. PSIRZ) str_names full name of all substructures found in struc (ex. eq.GEQDSK) NOTE: No structures copied to WS (only variables are copied) NOTE: Uses Recursive execution of struc_names to get all variables and structures SEE: struct_to_ws for only 1st level (variables and structures copy to environment)","title":"Basic Information"},{"location":"function-guide/utilities/strwcmp_m/","text":"strwcmp.m \u00b6 Basic Information \u00b6 STRWCMP compares two strings allowing wildcards. S = STRWCMP(STR1, STR2) returns TRUE if the two strings STR1 and STR2 match. One of the strings may contain one or more '*' as wildcard characters. The comparison is case sensitive. If the strings are matrices they are treated as vectors. S = STRWCMP(STR1, STR2, 'I') ignores the case.","title":"strwcmp.m"},{"location":"function-guide/utilities/strwcmp_m/#strwcmpm","text":"","title":"strwcmp.m"},{"location":"function-guide/utilities/strwcmp_m/#basic-information","text":"STRWCMP compares two strings allowing wildcards. S = STRWCMP(STR1, STR2) returns TRUE if the two strings STR1 and STR2 match. One of the strings may contain one or more '*' as wildcard characters. The comparison is case sensitive. If the strings are matrices they are treated as vectors. S = STRWCMP(STR1, STR2, 'I') ignores the case.","title":"Basic Information"},{"location":"function-guide/utilities/submatrix_poly_m/","text":"submatrix_poly.m \u00b6 Basic Information \u00b6 SYNTAX: submatrix = submatrix_poly(matrix,rowindex,colindex) PURPOSE: Extract selected submatrix out of matrix of polynomials. INPUT: matrix = matrix of polys to extract from rowindex = indices of rows to extract colindex = indices of columns to extract OUTPUT: submatrix = extracted sub-matrix","title":"submatrix_poly.m"},{"location":"function-guide/utilities/submatrix_poly_m/#submatrix_polym","text":"","title":"submatrix_poly.m"},{"location":"function-guide/utilities/submatrix_poly_m/#basic-information","text":"SYNTAX: submatrix = submatrix_poly(matrix,rowindex,colindex) PURPOSE: Extract selected submatrix out of matrix of polynomials. INPUT: matrix = matrix of polys to extract from rowindex = indices of rows to extract colindex = indices of columns to extract OUTPUT: submatrix = extracted sub-matrix","title":"Basic Information"},{"location":"function-guide/utilities/tok_from_pwd_m/","text":"tok_from_pwd.m \u00b6 Basic Information \u00b6 PURPOSE: determines \"tokamak\" from your \"present working directory\" pwd sets global variable TOKAMAK runs startup_\"tok\".m routine for particular machine SYNTAX: tokamak= tok_from_pwd; tok_from_pwd tokamak= tok_from_pwd(tokamak); if you know tokamak to work on tokamak= tok_from_pwd([]); return tokamak but no run of startup INPUT: tokamak= OPTIONAL name of tokamak is known [default= looks in pwd] OUTPUT: tokamak= tokamak name based on search of pwd runs appropriate startup routine as long as tokamak not empty EXAMPLE: pwd= '/home/leuer/tokamaks/d3d/d3d_sim' tokamak= tok_from_pwd; ==> tokamak= 'd3d'; TOKAMAK= 'd3d'; Routine runs: ...startup_d3d.m","title":"tok_from_pwd.m"},{"location":"function-guide/utilities/tok_from_pwd_m/#tok_from_pwdm","text":"","title":"tok_from_pwd.m"},{"location":"function-guide/utilities/tok_from_pwd_m/#basic-information","text":"PURPOSE: determines \"tokamak\" from your \"present working directory\" pwd sets global variable TOKAMAK runs startup_\"tok\".m routine for particular machine SYNTAX: tokamak= tok_from_pwd; tok_from_pwd tokamak= tok_from_pwd(tokamak); if you know tokamak to work on tokamak= tok_from_pwd([]); return tokamak but no run of startup INPUT: tokamak= OPTIONAL name of tokamak is known [default= looks in pwd] OUTPUT: tokamak= tokamak name based on search of pwd runs appropriate startup routine as long as tokamak not empty EXAMPLE: pwd= '/home/leuer/tokamaks/d3d/d3d_sim' tokamak= tok_from_pwd; ==> tokamak= 'd3d'; TOKAMAK= 'd3d'; Routine runs: ...startup_d3d.m","title":"Basic Information"},{"location":"function-guide/utilities/truncate_header_m/","text":"truncate_header.m \u00b6 Basic Information \u00b6 USAGE: truncate_header(infile,outfile,nlines) PURPOSE: remove header from a file INPUTS: infile = input file outfile = output file nlines = ??? OUTPUTS: none","title":"truncate_header.m"},{"location":"function-guide/utilities/truncate_header_m/#truncate_headerm","text":"","title":"truncate_header.m"},{"location":"function-guide/utilities/truncate_header_m/#basic-information","text":"USAGE: truncate_header(infile,outfile,nlines) PURPOSE: remove header from a file INPUTS: infile = input file outfile = output file nlines = ??? OUTPUTS: none","title":"Basic Information"},{"location":"function-guide/utilities/valsim_m/","text":"valsim.m \u00b6 Basic Information \u00b6 valsim(source_array) INPUT ptns = strlist object containing the names of the points to plot source_array = cell array of data_source objects dia = txttab object output_ps = (OPTIONAL) File name of output ps file. If specified, plots will be written to a *.ps file specified by this argument.","title":"valsim.m"},{"location":"function-guide/utilities/valsim_m/#valsimm","text":"","title":"valsim.m"},{"location":"function-guide/utilities/valsim_m/#basic-information","text":"valsim(source_array) INPUT ptns = strlist object containing the names of the points to plot source_array = cell array of data_source objects dia = txttab object output_ps = (OPTIONAL) File name of output ps file. If specified, plots will be written to a *.ps file specified by this argument.","title":"Basic Information"},{"location":"function-guide/utilities/wait_m/","text":"wait.m \u00b6 Basic Information \u00b6 SYNTAX: wait(message) PURPOSE: Procedure to implement a pause with a message to let user know that carriage return is required in order to continue. (This eliminates confusion over whether long wait for MATLAB is due to a pause or to a very long computation.) If the environemt variable 'SKIPWAIT' exists on the workspace, then the pause is bypassed. This is useful for automated builds. INPUT: message = optional string to print out at pause OUTPUT: printed message to terminal","title":"wait.m"},{"location":"function-guide/utilities/wait_m/#waitm","text":"","title":"wait.m"},{"location":"function-guide/utilities/wait_m/#basic-information","text":"SYNTAX: wait(message) PURPOSE: Procedure to implement a pause with a message to let user know that carriage return is required in order to continue. (This eliminates confusion over whether long wait for MATLAB is due to a pause or to a very long computation.) If the environemt variable 'SKIPWAIT' exists on the workspace, then the pause is bypassed. This is useful for automated builds. INPUT: message = optional string to print out at pause OUTPUT: printed message to terminal","title":"Basic Information"},{"location":"function-guide/utilities/whatfunction_m/","text":"whatfunction.m \u00b6 Basic Information \u00b6 SYNTAX: whatfunction(name_string) PURPOSE: Find a function name given only a partial name string. (See also lookfor, search_path) INPUT: name_string = function name string to match OUTPUT: names of functions containing name_string RESTRICTIONS: Bug in MATLAB restricts when this command will work. Uses the \"unix\" command to find m-files in a directory and sometimes this command doesn't work.","title":"whatfunction.m"},{"location":"function-guide/utilities/whatfunction_m/#whatfunctionm","text":"","title":"whatfunction.m"},{"location":"function-guide/utilities/whatfunction_m/#basic-information","text":"SYNTAX: whatfunction(name_string) PURPOSE: Find a function name given only a partial name string. (See also lookfor, search_path) INPUT: name_string = function name string to match OUTPUT: names of functions containing name_string RESTRICTIONS: Bug in MATLAB restricts when this command will work. Uses the \"unix\" command to find m-files in a directory and sometimes this command doesn't work.","title":"Basic Information"},{"location":"function-guide/utilities/whoss_m/","text":"whoss.m \u00b6 Basic Information \u00b6 WHOSS is like whos except it prints out actual variable value instead of size information. It prints out first couple values of an array SYNTAX: whoss (structure and usage similar to whos) whoss a* *name* ... out= whoss(var1,var2,...) doesnt work for structures","title":"whoss.m"},{"location":"function-guide/utilities/whoss_m/#whossm","text":"","title":"whoss.m"},{"location":"function-guide/utilities/whoss_m/#basic-information","text":"WHOSS is like whos except it prints out actual variable value instead of size information. It prints out first couple values of an array SYNTAX: whoss (structure and usage similar to whos) whoss a* *name* ... out= whoss(var1,var2,...) doesnt work for structures","title":"Basic Information"},{"location":"function-guide/utilities/whox_m/","text":"whox.m \u00b6 Basic Information \u00b6 WHOX List current variables as WHOS but also expand structures to see all fields inside WHOX by itself will list all variables with expanded structures WHOX with one or more arguments will list those variables that match at least one of the arguments. If an argument contains points, each 'field' of the argument must match the field of the variable. Examples: whox *.* List only fields of structures whox *.*.* List only fields of fields of structures whox *.*.*.EC* Find fields that begin with EC 3 levels down See also WHOS.","title":"whox.m"},{"location":"function-guide/utilities/whox_m/#whoxm","text":"","title":"whox.m"},{"location":"function-guide/utilities/whox_m/#basic-information","text":"WHOX List current variables as WHOS but also expand structures to see all fields inside WHOX by itself will list all variables with expanded structures WHOX with one or more arguments will list those variables that match at least one of the arguments. If an argument contains points, each 'field' of the argument must match the field of the variable. Examples: whox *.* List only fields of structures whox *.*.* List only fields of fields of structures whox *.*.*.EC* Find fields that begin with EC 3 levels down See also WHOS.","title":"Basic Information"},{"location":"function-guide/utilities/whoxx_m/","text":"whoxx.m \u00b6 Basic Information \u00b6 WHOXX List current variables with expanded structures like WHOX and also list first few values when output goes to the screen WHOXX by itself will list all variables with expanded structures WHOXX with one or more arguments will list those variables that match at least one of the arguments. If an argument contains points, each 'field' of the argument must match the field of the variable. Examples: whoxx *.* List only fields of structures whoxx *.*.* List only fields of fields of structures whoxx *.*.*.EC* Find fields that begin with EC 3 levels down See also WHOSS.","title":"whoxx.m"},{"location":"function-guide/utilities/whoxx_m/#whoxxm","text":"","title":"whoxx.m"},{"location":"function-guide/utilities/whoxx_m/#basic-information","text":"WHOXX List current variables with expanded structures like WHOX and also list first few values when output goes to the screen WHOXX by itself will list all variables with expanded structures WHOXX with one or more arguments will list those variables that match at least one of the arguments. If an argument contains points, each 'field' of the argument must match the field of the variable. Examples: whoxx *.* List only fields of structures whoxx *.*.* List only fields of fields of structures whoxx *.*.*.EC* Find fields that begin with EC 3 levels down See also WHOSS.","title":"Basic Information"},{"location":"function-guide/utilities/write_ascii_table_m/","text":"write_ascii_table.m \u00b6 Basic Information \u00b6 SYNTAX: write_ascii_table(table,filename,format) PURPOSE: Write out table to ascii file for easy import into MSWord INPUT: table = table to write filename = name of file to write table into format = can be either string or integer. string = defines format for write to file integer = defines number of digits to write out for each entry OUTPUT: file with formatted data (name=filename)","title":"write_ascii_table.m"},{"location":"function-guide/utilities/write_ascii_table_m/#write_ascii_tablem","text":"","title":"write_ascii_table.m"},{"location":"function-guide/utilities/write_ascii_table_m/#basic-information","text":"SYNTAX: write_ascii_table(table,filename,format) PURPOSE: Write out table to ascii file for easy import into MSWord INPUT: table = table to write filename = name of file to write table into format = can be either string or integer. string = defines format for write to file integer = defines number of digits to write out for each entry OUTPUT: file with formatted data (name=filename)","title":"Basic Information"},{"location":"function-guide/utilities/write_flat_m/","text":"write_flat.m \u00b6 Basic Information \u00b6 function dum = write_flat(dataobj,output_file,flag) Matlab m-file to write dataobj to flatfile output_file.flat in flat format = single ascii number per line followed by CR. Usage: >>write_flat(data,'filename'); Inputs: dataobj = data object desired to write to file output_file in flat format output_file = (quoted) string denoting name of output file flag (optional) = 1 to write matrix dimensions in first 2 lines, 0 to omit (in this case, 1st line = # of rows, 2nd line=# of cols) Restrictions: None","title":"write_flat.m"},{"location":"function-guide/utilities/write_flat_m/#write_flatm","text":"","title":"write_flat.m"},{"location":"function-guide/utilities/write_flat_m/#basic-information","text":"function dum = write_flat(dataobj,output_file,flag) Matlab m-file to write dataobj to flatfile output_file.flat in flat format = single ascii number per line followed by CR. Usage: >>write_flat(data,'filename'); Inputs: dataobj = data object desired to write to file output_file in flat format output_file = (quoted) string denoting name of output file flag (optional) = 1 to write matrix dimensions in first 2 lines, 0 to omit (in this case, 1st line = # of rows, 2nd line=# of cols) Restrictions: None","title":"Basic Information"},{"location":"function-guide/utilities/write_namelist_m/","text":"write_namelist.m \u00b6 Basic Information \u00b6 SYNTAX: write_namelist runs like script with variableread from calling routn. PURPOSE: write FORTRAN namelist file . Typically used after a read_namelist has been read in and data changed and then written out. INPUT: [default] nlall= namelist names and variables (typical from read_namelist) filename_ot = name of namelist file to written to_upper = 1; Variables: 1-UPPER CASE, -1=LOWER CASE, [0=no change] n_per_line = number of numeric data to put on single line [5] OUTPUT: All variables found in namelist(s) within the file are made into matlab variables. Duplicate names are overwritten with subsequent data. nlnames= Character Array contaning names of each namelist read NAMELIST_list= list of each variable in NAMELIST NAMELIST is name of each item in nlnames ex. if file contains &IN then IN_list contains variable nms. nlall= total list of all namelists and variable (write_namelist) RESTRICTIONS:","title":"write_namelist.m"},{"location":"function-guide/utilities/write_namelist_m/#write_namelistm","text":"","title":"write_namelist.m"},{"location":"function-guide/utilities/write_namelist_m/#basic-information","text":"SYNTAX: write_namelist runs like script with variableread from calling routn. PURPOSE: write FORTRAN namelist file . Typically used after a read_namelist has been read in and data changed and then written out. INPUT: [default] nlall= namelist names and variables (typical from read_namelist) filename_ot = name of namelist file to written to_upper = 1; Variables: 1-UPPER CASE, -1=LOWER CASE, [0=no change] n_per_line = number of numeric data to put on single line [5] OUTPUT: All variables found in namelist(s) within the file are made into matlab variables. Duplicate names are overwritten with subsequent data. nlnames= Character Array contaning names of each namelist read NAMELIST_list= list of each variable in NAMELIST NAMELIST is name of each item in nlnames ex. if file contains &IN then IN_list contains variable nms. nlall= total list of all namelists and variable (write_namelist) RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/utilities/ws2struct_m/","text":"ws2struct.m \u00b6 Basic Information \u00b6 @(#)ws2struct.m 1.1 14/02/14 USAGE: ws2struct PURPOSE: This function allows to save all the variables from the 'caller' workspace into a struct array INPUTS: OUTPUTS: RESTRICTIONS: METHOD: Example: a='LALALA' b=[1:12:258] c={'cell1', 'cell2', 'cell3'} d=768 e=true(3) theworkspace=ws2struct(); theworkspace = a: 'LALALA' b: [1x22 double] c: {'cell1' 'cell2' 'cell3'} d: 768 e: [3x3 logical] VERSION WRITTEN BY: Matthew J. Lanctot on March 19 2013 MODIFICATION HISTORY: 2013-03-19 Created","title":"ws2struct.m"},{"location":"function-guide/utilities/ws2struct_m/#ws2structm","text":"","title":"ws2struct.m"},{"location":"function-guide/utilities/ws2struct_m/#basic-information","text":"@(#)ws2struct.m 1.1 14/02/14 USAGE: ws2struct PURPOSE: This function allows to save all the variables from the 'caller' workspace into a struct array INPUTS: OUTPUTS: RESTRICTIONS: METHOD: Example: a='LALALA' b=[1:12:258] c={'cell1', 'cell2', 'cell3'} d=768 e=true(3) theworkspace=ws2struct(); theworkspace = a: 'LALALA' b: [1x22 double] c: {'cell1' 'cell2' 'cell3'} d: 768 e: [3x3 logical] VERSION WRITTEN BY: Matthew J. Lanctot on March 19 2013 MODIFICATION HISTORY: 2013-03-19 Created","title":"Basic Information"},{"location":"function-guide/utilities/zero_crossing_m/","text":"zero_crossing.m \u00b6 Basic Information \u00b6 SYNTAX: [zero_x_set,nearest_idx] = zero_crossing(x,y,plot_zeros) PURPOSE: For a function defined by (x,y) data pairs, estimate the value(s) of x at which the function crosses y=0 (assuming linear interpolation between data points). INPUT: x,y = set of data pairs defining function plot_zeros = (optional) flag to plot zeros on top of function OUTPUT: zero_x_set = x values at which y=0 nearest_idx = index of point nearest to the zero crossing","title":"zero_crossing.m"},{"location":"function-guide/utilities/zero_crossing_m/#zero_crossingm","text":"","title":"zero_crossing.m"},{"location":"function-guide/utilities/zero_crossing_m/#basic-information","text":"SYNTAX: [zero_x_set,nearest_idx] = zero_crossing(x,y,plot_zeros) PURPOSE: For a function defined by (x,y) data pairs, estimate the value(s) of x at which the function crosses y=0 (assuming linear interpolation between data points). INPUT: x,y = set of data pairs defining function plot_zeros = (optional) flag to plot zeros on top of function OUTPUT: zero_x_set = x values at which y=0 nearest_idx = index of point nearest to the zero crossing","title":"Basic Information"},{"location":"function-guide/validation/Contents_m/","text":"Contents.m \u00b6 Basic Information \u00b6 Model validation functions: clean_fresp_data = clean (manually) data generated by compare_vacuum_fresp.m compare_isobgd_data.m = compare EFIT response at control pts with rigid model prediction compare_system_outputs = compare simulated data from plasma response with measurements compare_vacuum_fresp = compare simulated data from vacuum response with measurements get_signals = device-independent function to fetch data for modeled signals Imodel_1coil.m = create model with 1 coil Idot input from system model","title":"Contents.m"},{"location":"function-guide/validation/Contents_m/#contentsm","text":"","title":"Contents.m"},{"location":"function-guide/validation/Contents_m/#basic-information","text":"Model validation functions: clean_fresp_data = clean (manually) data generated by compare_vacuum_fresp.m compare_isobgd_data.m = compare EFIT response at control pts with rigid model prediction compare_system_outputs = compare simulated data from plasma response with measurements compare_vacuum_fresp = compare simulated data from vacuum response with measurements get_signals = device-independent function to fetch data for modeled signals Imodel_1coil.m = create model with 1 coil Idot input from system model","title":"Basic Information"},{"location":"function-guide/validation/Imodel_1coil_m/","text":"Imodel_1coil.m \u00b6 Basic Information \u00b6 SYNTAX: model = Imodel_1coil(tok_system,coil_index,output_index) PURPOSE: Construct a 1 coil Icdot-input A,B,C,D model from the full voltage input model. (Preliminary version.) INPUT: tok_system = full voltage input system model coil_index = see compare_vacuum_fresp (needs clarifying) output_index = indices of outputs to include in generated model OUTPUT: model = A,B,C,D model representing response to current in selected coil. RESTRICTIONS: tok_system.dmat rows corresponding to output_index must = 0.","title":"Imodel_1coil.m"},{"location":"function-guide/validation/Imodel_1coil_m/#imodel_1coilm","text":"","title":"Imodel_1coil.m"},{"location":"function-guide/validation/Imodel_1coil_m/#basic-information","text":"SYNTAX: model = Imodel_1coil(tok_system,coil_index,output_index) PURPOSE: Construct a 1 coil Icdot-input A,B,C,D model from the full voltage input model. (Preliminary version.) INPUT: tok_system = full voltage input system model coil_index = see compare_vacuum_fresp (needs clarifying) output_index = indices of outputs to include in generated model OUTPUT: model = A,B,C,D model representing response to current in selected coil. RESTRICTIONS: tok_system.dmat rows corresponding to output_index must = 0.","title":"Basic Information"},{"location":"function-guide/validation/clean_fresp_data_m/","text":"clean_fresp_data.m \u00b6 Basic Information \u00b6 SYNTAX: clean_fresp_data PURPOSE: Perform some manual \"cleaning\" of measured frequency response data. INPUT: coil = string defining signal name of coil from which data was generated model_type = type of model that generated data : 0=voltage input, 1=current input These define input files <coil>_fresp_mdltype<model_type>.mat that are loaded for cleaning. OUTPUT: Cleaned data is stored in files <coil>_fresp_mdltype<model_type>_cleaned.mat RESTRICTIONS: Input file with name convention described above must exist and contain output generated by compare_vacuum_fresp.m. METHOD: Bode plots comparing measured freq. response samples overlayed on model shown for reference. Interactive prompts provide user options to clean the data: n: normalize first so that measured and modeled DC gain match k: keep all data samples d: delete all data samples m: manually select samples for deletion","title":"clean_fresp_data.m"},{"location":"function-guide/validation/clean_fresp_data_m/#clean_fresp_datam","text":"","title":"clean_fresp_data.m"},{"location":"function-guide/validation/clean_fresp_data_m/#basic-information","text":"SYNTAX: clean_fresp_data PURPOSE: Perform some manual \"cleaning\" of measured frequency response data. INPUT: coil = string defining signal name of coil from which data was generated model_type = type of model that generated data : 0=voltage input, 1=current input These define input files <coil>_fresp_mdltype<model_type>.mat that are loaded for cleaning. OUTPUT: Cleaned data is stored in files <coil>_fresp_mdltype<model_type>_cleaned.mat RESTRICTIONS: Input file with name convention described above must exist and contain output generated by compare_vacuum_fresp.m. METHOD: Bode plots comparing measured freq. response samples overlayed on model shown for reference. Interactive prompts provide user options to clean the data: n: normalize first so that measured and modeled DC gain match k: keep all data samples d: delete all data samples m: manually select samples for deletion","title":"Basic Information"},{"location":"function-guide/validation/compare_isobgd_data_m/","text":"compare_isobgd_data.m \u00b6 Basic Information \u00b6 SYNTAX: compare_isobgd_data PURPOSE: To extract coil current and R,z-data from efit-generated g0-files, read isoflux/Bgrid Green functions, and compare EFIT response at control points with predicted values from rigid predictors generated by rzrig. Also does R,Z comparison from compare_efit_rig along the way. (Works only for D3D right now, but should be generalizable.) INPUT: shot = shot number of data to compare with model. Must agree with g0-files in default directory. model_shotnum = shot number of model (appearing in model data file names, e.g. out_objs_<shot>_<time>.mat) model_dir = directory where out_objs*, out2_objs*, drzdi* files located tref = reference time for EFIT data (in ms) model_tref = reference time for model files (in ms) t1ms = initial g0-file time (msec) t2ms = final g0-file time (msec) dtms = time interval (msec) between g0-file times eqdir = directory w/ eqdsk files (end with \"/\", eg '/matlab/plresp/') efit_times (optional) = vector of efit_times (if not supplied, constructs from t1ms,t2ms,dtms). create_plotfile = 1 if you want color postscript file of all plots ildefit = 1 to load EFIT data (0 to disable to save time for later runs) iloaddi = 1 to load model response files (0 to disable loading) ikillE = 1 to kill effect of E-coil currents in prediction (else incl) iuseIp = 1 to use drdip object in predicted response niso = index of isoflux segment to use for comparison nbgd = index of Bgrid row to use for comparison icompall = flag to enable comparison plotting of entire segments for all time points (scroll through with CR...) 1=plot, 0=skip (if skip just compares average over the segment) create_plotfile = set to 1 to create *.psc file containing plots (optional, default = 0) OUTPUT: t = time vector (secs) zm_efit = vertical position data vector from EFIT g0-file data zo_efit = LCFS vertical position data vector from EFIT g0-file data z_rig = vertical position data vector from rigid predictor dzdis rm_efit = vertical position data vector from EFIT g0-file data ro_efit = LCFS vertical position data vector from EFIT g0-file data r_rig = vertical position data vector from vst predictor drdi Plots comparison of EFIT and corresponding R,Z predictor data in figures 1 and 2. RESTRICTIONS: Must have generated efits in eqdir from t1ms to t2ms","title":"compare_isobgd_data.m"},{"location":"function-guide/validation/compare_isobgd_data_m/#compare_isobgd_datam","text":"","title":"compare_isobgd_data.m"},{"location":"function-guide/validation/compare_isobgd_data_m/#basic-information","text":"SYNTAX: compare_isobgd_data PURPOSE: To extract coil current and R,z-data from efit-generated g0-files, read isoflux/Bgrid Green functions, and compare EFIT response at control points with predicted values from rigid predictors generated by rzrig. Also does R,Z comparison from compare_efit_rig along the way. (Works only for D3D right now, but should be generalizable.) INPUT: shot = shot number of data to compare with model. Must agree with g0-files in default directory. model_shotnum = shot number of model (appearing in model data file names, e.g. out_objs_<shot>_<time>.mat) model_dir = directory where out_objs*, out2_objs*, drzdi* files located tref = reference time for EFIT data (in ms) model_tref = reference time for model files (in ms) t1ms = initial g0-file time (msec) t2ms = final g0-file time (msec) dtms = time interval (msec) between g0-file times eqdir = directory w/ eqdsk files (end with \"/\", eg '/matlab/plresp/') efit_times (optional) = vector of efit_times (if not supplied, constructs from t1ms,t2ms,dtms). create_plotfile = 1 if you want color postscript file of all plots ildefit = 1 to load EFIT data (0 to disable to save time for later runs) iloaddi = 1 to load model response files (0 to disable loading) ikillE = 1 to kill effect of E-coil currents in prediction (else incl) iuseIp = 1 to use drdip object in predicted response niso = index of isoflux segment to use for comparison nbgd = index of Bgrid row to use for comparison icompall = flag to enable comparison plotting of entire segments for all time points (scroll through with CR...) 1=plot, 0=skip (if skip just compares average over the segment) create_plotfile = set to 1 to create *.psc file containing plots (optional, default = 0) OUTPUT: t = time vector (secs) zm_efit = vertical position data vector from EFIT g0-file data zo_efit = LCFS vertical position data vector from EFIT g0-file data z_rig = vertical position data vector from rigid predictor dzdis rm_efit = vertical position data vector from EFIT g0-file data ro_efit = LCFS vertical position data vector from EFIT g0-file data r_rig = vertical position data vector from vst predictor drdi Plots comparison of EFIT and corresponding R,Z predictor data in figures 1 and 2. RESTRICTIONS: Must have generated efits in eqdir from t1ms to t2ms","title":"Basic Information"},{"location":"function-guide/validation/compare_system_outputs_m/","text":"compare_system_outputs.m \u00b6 Basic Information \u00b6 SYNTAX: compare_system_outputs PURPOSE: Compare outputs of generic-constructed system model with measured signals that correspond to these outputs. This script builds the model, simulates system outputs (driven by measurements) and compares those simulations with measured data. INPUT (see build_<tokamak>_sys help for additional inputs): tokamak = name of tokamak (e.g. 'd3d', 'kstar', 'nstx', ...) config_name = string defining model configuration ichooseq = see input to build_tokamak_system.m (ichooseq=0 => vacuum model) model_shotnum = shot number to derive model from (only required if ichooseq > 0) equil_time = time of plasma equilibrium in sec (only required if ichooseq > 0) efit_source = source of mdsplus efit (only required if ichooseq = 4) data_shotnum = number of shot to get data for model comparison tmin, tmax = min and max times (sec) for data window out_signals_col = index of column in output_signals array to define measured data to compare against output_index = indices of model outputs to compare model and data (coil currents are always included) input_index = indices of model inputs (coil circuits) that are connected to power supplies (default = all) output_index = defines which outputs to look at (default = all) get_data_fn_input = string defining function to call when fetching input signals get_data_fn_output = string defining function to call when fetching output signals model_type = 1 for coil current inputs, 0 for voltage inputs (default = 0) iplcirc = set to 1 to include plasma current circuit, else 0 (default 1, only needed if ichooseq>0) first_time = set to 1 first time this script used (optional, default=1) equil_avg_time = [sec] window over which to avg ptname data used to calculate nominal equilibrium (optional, default=10ms) cutoff = cutoff frequency (in Hz) to filter signals when plotting ohstates_idx = index of coils to use to ramp in coil nominal trajectories for Ip drive OUTPUT: comparison plots for model versus data.","title":"compare_system_outputs.m"},{"location":"function-guide/validation/compare_system_outputs_m/#compare_system_outputsm","text":"","title":"compare_system_outputs.m"},{"location":"function-guide/validation/compare_system_outputs_m/#basic-information","text":"SYNTAX: compare_system_outputs PURPOSE: Compare outputs of generic-constructed system model with measured signals that correspond to these outputs. This script builds the model, simulates system outputs (driven by measurements) and compares those simulations with measured data. INPUT (see build_<tokamak>_sys help for additional inputs): tokamak = name of tokamak (e.g. 'd3d', 'kstar', 'nstx', ...) config_name = string defining model configuration ichooseq = see input to build_tokamak_system.m (ichooseq=0 => vacuum model) model_shotnum = shot number to derive model from (only required if ichooseq > 0) equil_time = time of plasma equilibrium in sec (only required if ichooseq > 0) efit_source = source of mdsplus efit (only required if ichooseq = 4) data_shotnum = number of shot to get data for model comparison tmin, tmax = min and max times (sec) for data window out_signals_col = index of column in output_signals array to define measured data to compare against output_index = indices of model outputs to compare model and data (coil currents are always included) input_index = indices of model inputs (coil circuits) that are connected to power supplies (default = all) output_index = defines which outputs to look at (default = all) get_data_fn_input = string defining function to call when fetching input signals get_data_fn_output = string defining function to call when fetching output signals model_type = 1 for coil current inputs, 0 for voltage inputs (default = 0) iplcirc = set to 1 to include plasma current circuit, else 0 (default 1, only needed if ichooseq>0) first_time = set to 1 first time this script used (optional, default=1) equil_avg_time = [sec] window over which to avg ptname data used to calculate nominal equilibrium (optional, default=10ms) cutoff = cutoff frequency (in Hz) to filter signals when plotting ohstates_idx = index of coils to use to ramp in coil nominal trajectories for Ip drive OUTPUT: comparison plots for model versus data.","title":"Basic Information"},{"location":"function-guide/validation/compare_vacuum_fresp_m/","text":"compare_vacuum_fresp.m \u00b6 Basic Information \u00b6 SYNTAX: compare_vacuum_fresp PURPOSE: Use in analyzing sine-wave excitation data collected for model validation. Perform generic build of single-input system model, then compare frequency response of that model with frequency response data calculated from acquired experiment data. INPUT: tokamak = name of tokamak (e.g. 'd3d', 'kstar', 'nstx', ...) config_name = string specifying which model configuration to use model_type = type of model to generate: 0=voltage input, 1=current input fresp_data_input = array of structures, each structure containing data for response to 1 input: input_index = value depends on model_type: if 0, set to index of model input that is connected to a power supply during experiment if 1, must be set to 1 sin_shots = single shot number or vector of shot numbers, one for each interval defined below t_intervals = array of pairs [ [tstart(1), tend(1)]; [tstart(2), tend(2)]; ... ] defining time intervals containing sine wave data (of a single frequency) to be analyzed f_intervals = array of pairs [fmin,fmax] = intervals in frequency (Hz) to search for sine wave frequency dc_shot = shot number containing data from which to compute dc gain dc_interval = time interval [tstart, tend] (containing ~constant data) to use for dc gain calculation get_data_fn_input = string defining function to call when fetching input signals get_data_fn_output = string defining function to call when fetching output signals cccirc = vector defining coil connections (see help build_tokamak_system) OR (not both) netlist = netlist input defining coil connections (see help build_tokamak_system) PLUS, add any other parameters that build_<device>_sys needs to execute OPTIONAL INPUTS: output_set = column number in the tok_system.output_signals array to use to define output signals (default 1) output_index = indices of model outputs to compare model and data or 'all' (default 'all') model_type = 0 for voltage input, or 1 for current input (default 0) drift_correct = vector [tmin1,tmax1] or [tmin1,tmax1,tmin2,tmax2] defining times to compute offset(s) needed to correct for integrator drift; 2 times=>offset only, 4 times=>correct linear drift freq_vals = interval of frequency values (Hz) to include in modeled frequency response plots (default is defined to cover experiment data frequency responses) show_plots = set >= 1 to see plots during calculation of frequency response (default 0), larger => more info verbose = set to value greater than 0 to get diagnostic prints, larger value gives more info save_response = set to 1 to save frequency response in file named <coil>_fresp.mat (default 0) snr_reject_thresh = reject calculated frequency response if output SNR (dB) < this value (default 20) snr_accept_thresh = automatically accept calculated response f output SNR (dB) > this value (default 26) sin_offset_intvals dc_offset_intvals min_ncounts = minimum number of digitizer counts required in dynamic range of data; if an output signal has less dynamic range than this value, the response data for that signal is ignored (default 7) create_plotfile = set to 1 to create postscript file containing all frequency response plots (default 0) OUTPUT: comparison plots for model frequency response versus gain/phase computed from experimental data. RESTRICTIONS: Currently only models correctly those outputs without direct feedthrough (i.e. with D=0 in plant model) when model_type = 1. Also, the netlist input option does not work correctly yet.","title":"compare_vacuum_fresp.m"},{"location":"function-guide/validation/compare_vacuum_fresp_m/#compare_vacuum_frespm","text":"","title":"compare_vacuum_fresp.m"},{"location":"function-guide/validation/compare_vacuum_fresp_m/#basic-information","text":"SYNTAX: compare_vacuum_fresp PURPOSE: Use in analyzing sine-wave excitation data collected for model validation. Perform generic build of single-input system model, then compare frequency response of that model with frequency response data calculated from acquired experiment data. INPUT: tokamak = name of tokamak (e.g. 'd3d', 'kstar', 'nstx', ...) config_name = string specifying which model configuration to use model_type = type of model to generate: 0=voltage input, 1=current input fresp_data_input = array of structures, each structure containing data for response to 1 input: input_index = value depends on model_type: if 0, set to index of model input that is connected to a power supply during experiment if 1, must be set to 1 sin_shots = single shot number or vector of shot numbers, one for each interval defined below t_intervals = array of pairs [ [tstart(1), tend(1)]; [tstart(2), tend(2)]; ... ] defining time intervals containing sine wave data (of a single frequency) to be analyzed f_intervals = array of pairs [fmin,fmax] = intervals in frequency (Hz) to search for sine wave frequency dc_shot = shot number containing data from which to compute dc gain dc_interval = time interval [tstart, tend] (containing ~constant data) to use for dc gain calculation get_data_fn_input = string defining function to call when fetching input signals get_data_fn_output = string defining function to call when fetching output signals cccirc = vector defining coil connections (see help build_tokamak_system) OR (not both) netlist = netlist input defining coil connections (see help build_tokamak_system) PLUS, add any other parameters that build_<device>_sys needs to execute OPTIONAL INPUTS: output_set = column number in the tok_system.output_signals array to use to define output signals (default 1) output_index = indices of model outputs to compare model and data or 'all' (default 'all') model_type = 0 for voltage input, or 1 for current input (default 0) drift_correct = vector [tmin1,tmax1] or [tmin1,tmax1,tmin2,tmax2] defining times to compute offset(s) needed to correct for integrator drift; 2 times=>offset only, 4 times=>correct linear drift freq_vals = interval of frequency values (Hz) to include in modeled frequency response plots (default is defined to cover experiment data frequency responses) show_plots = set >= 1 to see plots during calculation of frequency response (default 0), larger => more info verbose = set to value greater than 0 to get diagnostic prints, larger value gives more info save_response = set to 1 to save frequency response in file named <coil>_fresp.mat (default 0) snr_reject_thresh = reject calculated frequency response if output SNR (dB) < this value (default 20) snr_accept_thresh = automatically accept calculated response f output SNR (dB) > this value (default 26) sin_offset_intvals dc_offset_intvals min_ncounts = minimum number of digitizer counts required in dynamic range of data; if an output signal has less dynamic range than this value, the response data for that signal is ignored (default 7) create_plotfile = set to 1 to create postscript file containing all frequency response plots (default 0) OUTPUT: comparison plots for model frequency response versus gain/phase computed from experimental data. RESTRICTIONS: Currently only models correctly those outputs without direct feedthrough (i.e. with D=0 in plant model) when model_type = 1. Also, the netlist input option does not work correctly yet.","title":"Basic Information"},{"location":"function-guide/validation/get_signals_m/","text":"get_signals.m \u00b6 Basic Information \u00b6 SYNTAX: [d,t,ier]=get_signals(shotnum,signal_names,tmin,tmax,get_data_fn,options) PURPOSE: Generic function for fetching signals of the type stored in the \"output_signals\" field of the generic system model data structure. INPUT: shotnum = shot number signal_names = signal names, either string array or cell array (1 column). Can be a numerical expression involving valid pointnames. tmin, tmax = min and max time for data interval get_data_fn = string defining function to call to get data; must have argument list of the form: (shotnum,signal_name,tmin,tmax) options = structure defining optional processing to do, allowed fields = drift_correct = vector [tmin1,tmax1] or [tmin1,tmax1,tmin2,tmax2] defining times to compute offset(s) needed to correct for integrator drift; 2 times=>offset only, 4 times=>correct linear drift (tmin, tmax must be chosen where the data \"should\" be zero) resample_time = time vector at which to resample data OR integer 1 indicating resample time is defined by signal in first entry of signal_names verbose = set>=1 to display various messages (larger # => more msgs) (If an option is not specified, the operation is not performed.) OUTPUT: d = data array; one column per signal name t = corresponding time vector ier = number of signal ptnames that could not be successfully fetched RESTRICTIONS: Doesn't currently handle multiple signals with different timebases - logic needs to be added.","title":"get_signals.m"},{"location":"function-guide/validation/get_signals_m/#get_signalsm","text":"","title":"get_signals.m"},{"location":"function-guide/validation/get_signals_m/#basic-information","text":"SYNTAX: [d,t,ier]=get_signals(shotnum,signal_names,tmin,tmax,get_data_fn,options) PURPOSE: Generic function for fetching signals of the type stored in the \"output_signals\" field of the generic system model data structure. INPUT: shotnum = shot number signal_names = signal names, either string array or cell array (1 column). Can be a numerical expression involving valid pointnames. tmin, tmax = min and max time for data interval get_data_fn = string defining function to call to get data; must have argument list of the form: (shotnum,signal_name,tmin,tmax) options = structure defining optional processing to do, allowed fields = drift_correct = vector [tmin1,tmax1] or [tmin1,tmax1,tmin2,tmax2] defining times to compute offset(s) needed to correct for integrator drift; 2 times=>offset only, 4 times=>correct linear drift (tmin, tmax must be chosen where the data \"should\" be zero) resample_time = time vector at which to resample data OR integer 1 indicating resample time is defined by signal in first entry of signal_names verbose = set>=1 to display various messages (larger # => more msgs) (If an option is not specified, the operation is not performed.) OUTPUT: d = data array; one column per signal name t = corresponding time vector ier = number of signal ptnames that could not be successfully fetched RESTRICTIONS: Doesn't currently handle multiple signals with different timebases - logic needs to be added.","title":"Basic Information"},{"location":"function-guide/validation/overlay_fresp_data_m/","text":"overlay_fresp_data.m \u00b6 Basic Information \u00b6 SYNTAX: overlay_fresp_data(fresp_data) PURPOSE: Overlay measured frequency response data samples on top of bode plot. INPUT: fresp_data: structure containing: wout = frequencies (Hz) of bode plot mag = magnitudes in bode plot phi = phases in bode plot (degrees) f = frequencies (Hz) of measured frequency response data g = gain of measured frequency response data ph = phase (deg) measured frequency response data model_type = 0 for voltage input, 1 for current input tok_system = system model from build_<device>_sys.m coil_index = index of coil defining input to model (if model_type=1) output_set = column of output_signals array used to compute responses output_index = index of all output signals used to compute responses inp_num = index of input of model being shown in bode plot out_num = index of output of model being shown in bode plot OUTPUT: Overlay plot, measured samples on top of \"continuous\" modeled response.","title":"overlay_fresp_data.m"},{"location":"function-guide/validation/overlay_fresp_data_m/#overlay_fresp_datam","text":"","title":"overlay_fresp_data.m"},{"location":"function-guide/validation/overlay_fresp_data_m/#basic-information","text":"SYNTAX: overlay_fresp_data(fresp_data) PURPOSE: Overlay measured frequency response data samples on top of bode plot. INPUT: fresp_data: structure containing: wout = frequencies (Hz) of bode plot mag = magnitudes in bode plot phi = phases in bode plot (degrees) f = frequencies (Hz) of measured frequency response data g = gain of measured frequency response data ph = phase (deg) measured frequency response data model_type = 0 for voltage input, 1 for current input tok_system = system model from build_<device>_sys.m coil_index = index of coil defining input to model (if model_type=1) output_set = column of output_signals array used to compute responses output_index = index of all output signals used to compute responses inp_num = index of input of model being shown in bode plot out_num = index of output of model being shown in bode plot OUTPUT: Overlay plot, measured samples on top of \"continuous\" modeled response.","title":"Basic Information"},{"location":"function-guide/validation/validate_isoflux_response_m/","text":"validate_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: validate_isoflux_response PURPOSE: Comparison of isoflux model predictions with experimental data. INPUT: shotnum = shot number to use for validation data tmin,tmax = min and max times to get data from shot dt_smooth = window length (sec) for smoothing isoflux_response = structure built by build_isoflux_response.m tok_data_struct = vacuum model structure resp_mdl = either the rzrig_data or gspert_data structure (from system model) equil_data = equilibrium used to generate resp_mdl (equil time must be in [tmin,tmax]) OUTPUT: comparison plots of predicted isoflux errors versus errors during shot","title":"validate_isoflux_response.m"},{"location":"function-guide/validation/validate_isoflux_response_m/#validate_isoflux_responsem","text":"","title":"validate_isoflux_response.m"},{"location":"function-guide/validation/validate_isoflux_response_m/#basic-information","text":"SYNTAX: validate_isoflux_response PURPOSE: Comparison of isoflux model predictions with experimental data. INPUT: shotnum = shot number to use for validation data tmin,tmax = min and max times to get data from shot dt_smooth = window length (sec) for smoothing isoflux_response = structure built by build_isoflux_response.m tok_data_struct = vacuum model structure resp_mdl = either the rzrig_data or gspert_data structure (from system model) equil_data = equilibrium used to generate resp_mdl (equil time must be in [tmin,tmax]) OUTPUT: comparison plots of predicted isoflux errors versus errors during shot","title":"Basic Information"},{"location":"tutorials/documentation/","text":"How to write documentation \u00b6 All documentation is written in an extended Markdown markup language. TokSys documentation is created using the MkDocs static site generator with the MkDocs-Material theme which has extended Markdown capabilities. Installing Documentation Dependencies \u00b6 pip pip install mkdocs pip install pymdown-extensions pip install mkdocs-material pip install mkdocs-material-extensions conda conda config --add channels conda-forge conda config --set channel_priority strict conda install mkdocs conda install pymdown-extensions conda install mkdocs-material conda install mkdocs-material-extensions Documentation Pages \u00b6 As mentioned, documentation pages are written in an extended Markdown. MkDocs parses Markdown files contained in the docs directory. To create a new documenation page just make a new Markdown file in the docs directory and MkDocs will transform it into valid HTML. For example, the markdown file for this page is located at docs/tutorials/documentation.md . Note The documentation page title is taken from the first Markdown header in the file and not the name of the file. Function and Script Documentation \u00b6 Documentation can be written along side code. For example: Matlab function c = add ( a,b ) % SYNTAX: c = add(a,b) % % PURPOSE: Add two numbers % % INPUT: % a, b = two numbers % % OUTPUT: % c = sum of a and b %+## Extra Markdown %+ %+Here is some extra information that might be useful %+ %+\\begin{equation} %+ c = a + b %+\\end{equation} %+ %+!!! warning \"Deprecated\" %+ This function has been deprecated. Please use the built in + operator % Regular code follows Python def add ( a , b ): # SYNTAX: c = add(a,b) # # PURPOSE: Add two numbers # # INPUT: # a, b = two numbers # # OUTPUT: # c = sum of a and b #+## Extra Markdown #+ #+Here is some extra information that might be useful #+ #+\\begin{equation} #+ c = a + b #+\\end{equation} #+ #+!!! warning \"Deprecated\" #+ This function has been deprecated. Please use the built in + operator # Regular code follows C int add ( int a , int b ) { // SYNTAX: c = add(a,b) // // PURPOSE: Add two numbers // // INPUT: // a, b = two numbers // // OUTPUT: // c = sum of a and b //+## Extra Markdown //+ //+Here is some extra information that might be useful //+ //+\\begin{equation} //+ c = a + b //+\\end{equation} //+ //+!!! warning \"Deprecated\" //+ This function has been deprecated. Please use the built in + operator // Regular code follows Fortran 77 real function add ( a , b ) result ( c ) C SYNTAX : c = add ( a , b ) C C PURPOSE : Add two numbers C C INPUT : C a , b = two numbers C C OUTPUT : C c = sum of a and b C + ## Extra Markdown C + C + Here is some extra information that might be useful C + C + \\ begin { equation } C + c = a + b C + \\ end { equation } C + C + !!! warning \"Deprecated\" C + This function has been deprecated . Please use the built in + operator C Regular code follows Fortran 90+ real function add ( a , b ) result ( c ) ! SYNTAX: c = add(a,b) ! ! PURPOSE: Add two numbers ! ! INPUT: ! a, b = two numbers ! ! OUTPUT: ! c = sum of a and b !+## Extra Markdown !+ !+Here is some extra information that might be useful !+ !+\\begin{equation} !+ c = a + b !+\\end{equation} !+ !+!!! warning \"Deprecated\" !+ This function has been deprecated. Please use the built in + operator ! Regular code follows Tip The fields SYNTAX or USAGE , PURPOSE , INPUT , and OUTPUT in the first part of the documentation is recommended The script create_docs is used to extract the documentation from the source files. The script does two passes over a file. The first pass is to extract the basic information denoted by the first continguous comment block denoted by a single comment mark e.g. % or // depending on the source file. This documentation is interpreted as raw text and is wrapped in a markdown code block. Note Matlab documentation denoted by a single % will be displayed when using Matlab's built-in help command The second pass extracts the contents in the first contiguous comment block denoted denoted with a comment mark and a + sign e.g. %+ . This documenation is interpreted as markdown. The above examples will be rendered as the following: Example Documentation Basic Information \u00b6 SYNTAX: c = add(a,b) PURPOSE: Add two numbers INPUT: a, b = two numbers OUTPUT: c = sum of a and b Extra Markdown \u00b6 Here is some extra information that might be useful \\[\\begin{equation} c = a + b \\end{equation}\\] Deprecated This function has been deprecated. Please use the built in + operator To extract the inline documentation from the source files run the following in the docs directory rm -rf function -guide # remove old files ./create_docs ../matlab function -guide This will create a cooresponding markdown file for every source file in the matlab directory in the docs/function-guide directory with the directory tree mirroring the matlab directory. For example, the documenation in matlab/GAcontrol/bodehz.m gets parsed into a file called docs/function-guide/GAcontrol/bodehz_m.md . Previewing the Documentation Website \u00b6 You can create a live preview your documentation by running mkdocs serve # Creates a live-updating webpage at http://127.0.0.1:8000 Building the Website \u00b6 You can create the function/script documentation by running makeit docs in the TokSys directory. This will pull the documenation from the source files using the create_docs script and build the website fom the Markdown files in the docs directory. Deploying Website \u00b6 Todo Automagically deploy website when pushed to repo","title":"How to write documentation"},{"location":"tutorials/documentation/#how-to-write-documentation","text":"All documentation is written in an extended Markdown markup language. TokSys documentation is created using the MkDocs static site generator with the MkDocs-Material theme which has extended Markdown capabilities.","title":"How to write documentation"},{"location":"tutorials/documentation/#installing-documentation-dependencies","text":"pip pip install mkdocs pip install pymdown-extensions pip install mkdocs-material pip install mkdocs-material-extensions conda conda config --add channels conda-forge conda config --set channel_priority strict conda install mkdocs conda install pymdown-extensions conda install mkdocs-material conda install mkdocs-material-extensions","title":"Installing Documentation Dependencies"},{"location":"tutorials/documentation/#documentation-pages","text":"As mentioned, documentation pages are written in an extended Markdown. MkDocs parses Markdown files contained in the docs directory. To create a new documenation page just make a new Markdown file in the docs directory and MkDocs will transform it into valid HTML. For example, the markdown file for this page is located at docs/tutorials/documentation.md . Note The documentation page title is taken from the first Markdown header in the file and not the name of the file.","title":"Documentation Pages"},{"location":"tutorials/documentation/#function-and-script-documentation","text":"Documentation can be written along side code. For example: Matlab function c = add ( a,b ) % SYNTAX: c = add(a,b) % % PURPOSE: Add two numbers % % INPUT: % a, b = two numbers % % OUTPUT: % c = sum of a and b %+## Extra Markdown %+ %+Here is some extra information that might be useful %+ %+\\begin{equation} %+ c = a + b %+\\end{equation} %+ %+!!! warning \"Deprecated\" %+ This function has been deprecated. Please use the built in + operator % Regular code follows Python def add ( a , b ): # SYNTAX: c = add(a,b) # # PURPOSE: Add two numbers # # INPUT: # a, b = two numbers # # OUTPUT: # c = sum of a and b #+## Extra Markdown #+ #+Here is some extra information that might be useful #+ #+\\begin{equation} #+ c = a + b #+\\end{equation} #+ #+!!! warning \"Deprecated\" #+ This function has been deprecated. Please use the built in + operator # Regular code follows C int add ( int a , int b ) { // SYNTAX: c = add(a,b) // // PURPOSE: Add two numbers // // INPUT: // a, b = two numbers // // OUTPUT: // c = sum of a and b //+## Extra Markdown //+ //+Here is some extra information that might be useful //+ //+\\begin{equation} //+ c = a + b //+\\end{equation} //+ //+!!! warning \"Deprecated\" //+ This function has been deprecated. Please use the built in + operator // Regular code follows Fortran 77 real function add ( a , b ) result ( c ) C SYNTAX : c = add ( a , b ) C C PURPOSE : Add two numbers C C INPUT : C a , b = two numbers C C OUTPUT : C c = sum of a and b C + ## Extra Markdown C + C + Here is some extra information that might be useful C + C + \\ begin { equation } C + c = a + b C + \\ end { equation } C + C + !!! warning \"Deprecated\" C + This function has been deprecated . Please use the built in + operator C Regular code follows Fortran 90+ real function add ( a , b ) result ( c ) ! SYNTAX: c = add(a,b) ! ! PURPOSE: Add two numbers ! ! INPUT: ! a, b = two numbers ! ! OUTPUT: ! c = sum of a and b !+## Extra Markdown !+ !+Here is some extra information that might be useful !+ !+\\begin{equation} !+ c = a + b !+\\end{equation} !+ !+!!! warning \"Deprecated\" !+ This function has been deprecated. Please use the built in + operator ! Regular code follows Tip The fields SYNTAX or USAGE , PURPOSE , INPUT , and OUTPUT in the first part of the documentation is recommended The script create_docs is used to extract the documentation from the source files. The script does two passes over a file. The first pass is to extract the basic information denoted by the first continguous comment block denoted by a single comment mark e.g. % or // depending on the source file. This documentation is interpreted as raw text and is wrapped in a markdown code block. Note Matlab documentation denoted by a single % will be displayed when using Matlab's built-in help command The second pass extracts the contents in the first contiguous comment block denoted denoted with a comment mark and a + sign e.g. %+ . This documenation is interpreted as markdown. The above examples will be rendered as the following: Example Documentation","title":"Function and Script Documentation"},{"location":"tutorials/documentation/#basic-information","text":"SYNTAX: c = add(a,b) PURPOSE: Add two numbers INPUT: a, b = two numbers OUTPUT: c = sum of a and b","title":"Basic Information"},{"location":"tutorials/documentation/#extra-markdown","text":"Here is some extra information that might be useful \\[\\begin{equation} c = a + b \\end{equation}\\] Deprecated This function has been deprecated. Please use the built in + operator To extract the inline documentation from the source files run the following in the docs directory rm -rf function -guide # remove old files ./create_docs ../matlab function -guide This will create a cooresponding markdown file for every source file in the matlab directory in the docs/function-guide directory with the directory tree mirroring the matlab directory. For example, the documenation in matlab/GAcontrol/bodehz.m gets parsed into a file called docs/function-guide/GAcontrol/bodehz_m.md .","title":"Extra Markdown"},{"location":"tutorials/documentation/#previewing-the-documentation-website","text":"You can create a live preview your documentation by running mkdocs serve # Creates a live-updating webpage at http://127.0.0.1:8000","title":"Previewing the Documentation Website"},{"location":"tutorials/documentation/#building-the-website","text":"You can create the function/script documentation by running makeit docs in the TokSys directory. This will pull the documenation from the source files using the create_docs script and build the website fom the Markdown files in the docs directory.","title":"Building the Website"},{"location":"tutorials/documentation/#deploying-website","text":"Todo Automagically deploy website when pushed to repo","title":"Deploying Website"}]}