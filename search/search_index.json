{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 This document describes how to use the collection of matlab functions and scripts, collectively called the Tokamak System toolbox or simply TokSys, which provides tools for tokamak system modeling and simulation, model validation, data analysis, and control design. Help If any description is incorrect or confusing, please contact Mike Walker at walker@fusion.gat.com . This document focuses on the description of those portions of TokSys that are applicable to plasma shape and position control design, testing, and data analysis because the methods for those applications have been largely standardized. However, TokSys also contains a number of tools relevant for other control development and analysis tasks, both general (e.g. data access and signal processing) and specific (e.g., for control of NTMs, RWMs, ONFR, etc.). All models produced using the tools described in this document use the convention that a positive toroidal current is a counter-clockwise current flow when viewed from above. Conductor voltages V are assumed connected such that V>0 causes coil currents Icoil to increase (in the absence of plasma). All data contained in the models described in this document use MKS units by default, i.e. Amps for current, Webers for flux, and Tesla for magnetic field. However, there is an option provided in some of the model calculation tools to produce data objects with currents in Mega-Amp-turns. Any talks or publications containing results derived from the use of the TokSys toolset should contain an attribution for GA TokSys. Linearized plasma models for boundary control development \u00b6 The model building environment consists of matlab functions and scripts to perform the following major functions: - Construct tokamak data objects such as conductor resistances, mutual inductances, and other Green functions, which are all defined by the device geometry in the absence of plasma. - Read in a plasma equilibrium around which a linearized model will be generated. - Combine the tokamak information in (a) with the specified plasma in (b) to generate the linearized model (See equation 1). - Compare the derived linearized model with experimentally measured data, as part of a model validation process. The TokSys toolbox has been used to derive models for the ITER, EAST, KSTAR, NSTX, MAST-U, DIII-D, SST-1, and Pegasus tokamaks, and the proposed Fusion Development Facility (FDF), among others. The developed models have been validated on DIII-D and NSTX and have been used to develop plasma controllers on DIII-D, ITER, EAST, KSTAR and Pegasus. Although even unvalidated or partially-validated models have proven very useful for developing and testing control software, use in a model-based control design requires that a real model-validation effort must be undertaken and completed before such controllers can be used with confidence in controlling plasmas. Model validation must include testing of individual component models, not just the final integrated model. Large integrated models are virtually never correct the first time used (or the 2nd, 3rd, ...) and typically cannot be made correct without identifying the source(s) of model discrepancy. Identifying sources of model discrepancy requires investigating individual components of the model. The development and use of a common toolset for multiple devices has significant advantages beyond the obvious issue of software re-use. In all cases, the models generated are first principles physics models, constructed without any \"tuning\" or \"fudge factors\", except for use of direct measurements of certain quantities such as coil resistance or inductance. Validation of this type of model versus experimental data on existing devices provides confidence in both the modeling approach and the model implementation when using the tools to extrapolate to model generation for devices that do not yet exist. Section 3 describes the modeling approach used by TokSys. Section 4 provides an overview of the organization and structure of the many modeling, analysis, and design functions. Section 5 provides instructions for how to make the Toksys tools available in your Matlab session. Section 6 provides a high-level summary list of device-independent modeling and analysis functions that are available when the Toksys tools are available in your session. Section 7 describes the process of constructing plasma response models, outlined in steps (a) through (c) above. Section 8 describes how the core set of generic modeling tools are used and expanded upon for modeling specific tokamaks and plasmas. Section 9 describes the process used for validation of TokSys models and the TokSys tools available to support this process. Section 10 describes a methodology employed to connect simulations constructed using TokSys models with a version of the real-time plasma control system (PCS), for those devices whose PCS is derived from the DIII-D PCS. Section 11 provides further details for some of the modeling tools. This section will be expanded in future versions of this document. Plasma Control Modeling Approach \u00b6 The set of modeling tools in this toolbox automate the majority of the process of generating dynamic models for the tokamak and plasma poloidal field systems involved in plasma shape, position, and plasma current control. Key products of the model development process are linear models of the form \\[\\begin{equation} \\begin{aligned} \\dot{I} &= \\mathbf{A}I + \\mathbf{B}v + \\mathbf{F}w \\\\\\ y &= \\mathbf{C}I + \\mathbf{D}v + \\mathbf{H}w \\end{aligned} \\label{eq:dynamics} \\end{equation}\\] that represent the dynamics of evolution of currents in toroidal conductors (control coils, passive structure, and plasma) within the tokamak and include the effect of the nonstationary plasma on these dynamics. Here, \\(I\\) represents the toroidal currents in coils, passive conductors, and the bulk plasma, \\(v\\) represents coil power supply voltages, \\(y\\) represents magnetic measurements such as flux, field, or current, and \\(w\\) represents disturbance inputs which can be used to model the effect of changes in \\(\\beta_p\\) , \\(l_i\\) , or of noise. The matrices \\(\\mathbf{A} = -(\\mathbf{M}^*)^{-1}\\mathbf{R}\\) and \\(\\mathbf{B} = (\\mathbf{M}^*)^{-1}\\mathbf{V}\\) are computed from the conductor resistance matrix \\(\\mathbf{R}\\) , a plasma-modified mutual inductance matrix \\(\\mathbf{M}^*\\) (see [2]), and a matrix \\(\\mathbf{V}\\) that maps power supply source voltages into voltages applied to control coils. The matrix \\(\\mathbf{C}\\) is given primarily by the Green functions from currents to magnetic diagnostics, and \\(\\mathbf{D}\\) is usually 0. We refer to the first equation in \\(\\eqref{eq:dynamics}\\) as the \"dynamics equation\" because it describes how the dynamical system defined by the collection of toroidal conductor and plasma currents evolves. We refer to the second equation in \\(\\eqref{eq:dynamics}\\) as the \"output equation\" because it defines how the multiple magnetic diagnostics (B-probes, flux loops, coil and vessel Rogowskis, etc) depend on the toroidal currents and input voltages. The most basic and most mature plasma model construction method we use is based on the rigid plasma model approach described in [2]. Alternatives to this approach, including a nonrigid linear model [3] or nonlinear models [4] have also been integrated in this environment. Use of the nonrigid model requires only small variations from use of the rigid model, so we will confine the discussion in this document primarily to rigid plasma model development. Note Use of the nonlinear models will not be described here. TokSys Toolbox File Structure \u00b6 The TokSys toolbox consists of a large collection of matlab functions organized into separate Linux directories according to similar functionality. There are three types of matlab files used for modeling: TokSys Matlab functions and models, generically applicable to any tokamak. Device-specific matlab functions and models, which invoke the TokSys modeling tools. General Matlab functions, which are invoked by both of the above. A TokSys installation consists of all three of these function sets plus additional tools for other related modeling and analysis purposes. The directory structure for such an installation is illustrated below. Figure 1: Illustration of TokSys installation directory structure The TokSys general modeling functions and generic matlab functions are located under the matlab path in the above figure. Device-specific functions are located under the tokamaks path. In addition to these two sets of directories, the TokSys toolset sits \"on top\" of the ITER PCSSP (Plasma Control System Simulation Platform) toolset, whose directories are structured similarly (see below). Figure 2: Illustration of PCSSP installation directory structure Codes and models specific to ITER are maintained as part of PCSSP, using the same separation between generally-applicable and device-specific functions and models. The structure shown in the figures above represent the installation at DIII-D. Most installations will have only one of the device directories under the \"tokamaks\" branch of Toksys, i.e. corresponding to the device local to where the toolset is installed. TokSys follows the usual matlab convention for providing on-line documentation to users in the form of function header documentation and Contents.m files. Each subdirectory in TokSys contains a Contents.m file that provides a summary of functions available in that directory. This summary of functions is available at the matlab command line by typing \"help\" followed by the directory name. Each function or script contains a standard format header, which describes how to use the function. This description is available at the matlab command line by typing \"help\" followed by the function name. Note These tools can serve as the foundation for the construction of your own specialized set of functions for tokamak modeling. Source code for all functions is provided and therefore can be modified locally. Warning DO NOT modify the source files in the installed area. Instead, make a copy of the source file in a separate directory, modify it there, then add that directory name to the matlab path in front of the TokSys directories. Matlab executes the first version of a file that it finds in its search path. TokSys Generic Function Directories \u00b6 We provide here a list of the subdirectories of the matlab directory shown in Figure 1. These subdirectories are intended to contain matlab scripts and functions that are applicable to any of the tokamak models we support and, in many cases, generally applicable to any tokamak. While this objective has been essentially reached for most sub-directories, there are a few of the functional areas listed below that are still evolving. 3d Three-dimensional electromagnetic analysis calculations breakdown Generic plasma breakdown/rampup calculations circuit_models Conductor circuit modeling functions comm_tbx Public domain Communications Toolbox (not well-tested) design Control design tools dcontrol Public domain Digital Control toolbox (not well-tested) dina Functions related to DINA plasma simulation code (not maintained) dmp Matlab DMP tools efit Functions related to EFIT reconstruction code. GAcomm GA-developed communication functions (mostly Ultra-Wideband) GAcontrol GA-developed control design utility functions. GAgraphics GA-developed graphics functions GAsignal GA-developed signal processing functions geom Tokamak geometry manipulation tools jfit Functions related to JFIT Magnetics Fitting Code mag Magnetics Calculation Tools math Math calculations mdsplus MDSplus data extraction and manipulation functions ntm NTM control functions PCS Generic functions for interaction with PCS. Applicable to any installation of the DIII-D PCS. plasma_models Functions for generating plasma (or plasma+device) models. plresp (NOT Generic yet) pubgraphics Public domain graphics functions. RWM Functions for developing or analyzing RWM control (not currently available) regression Functions for regression simserver Functions for creating simserver simulations (to connect with PCS). teq Functions for interacting with Corsica and TEQ. (NOT Generic yet) tok_models Functions for generating plasma (or plasma+device) models toksim Toksim library and support functions utilities Utility functions validation Functions for model validation","title":"Overview"},{"location":"#overview","text":"This document describes how to use the collection of matlab functions and scripts, collectively called the Tokamak System toolbox or simply TokSys, which provides tools for tokamak system modeling and simulation, model validation, data analysis, and control design. Help If any description is incorrect or confusing, please contact Mike Walker at walker@fusion.gat.com . This document focuses on the description of those portions of TokSys that are applicable to plasma shape and position control design, testing, and data analysis because the methods for those applications have been largely standardized. However, TokSys also contains a number of tools relevant for other control development and analysis tasks, both general (e.g. data access and signal processing) and specific (e.g., for control of NTMs, RWMs, ONFR, etc.). All models produced using the tools described in this document use the convention that a positive toroidal current is a counter-clockwise current flow when viewed from above. Conductor voltages V are assumed connected such that V>0 causes coil currents Icoil to increase (in the absence of plasma). All data contained in the models described in this document use MKS units by default, i.e. Amps for current, Webers for flux, and Tesla for magnetic field. However, there is an option provided in some of the model calculation tools to produce data objects with currents in Mega-Amp-turns. Any talks or publications containing results derived from the use of the TokSys toolset should contain an attribution for GA TokSys.","title":"Overview"},{"location":"#linearized-plasma-models-for-boundary-control-development","text":"The model building environment consists of matlab functions and scripts to perform the following major functions: - Construct tokamak data objects such as conductor resistances, mutual inductances, and other Green functions, which are all defined by the device geometry in the absence of plasma. - Read in a plasma equilibrium around which a linearized model will be generated. - Combine the tokamak information in (a) with the specified plasma in (b) to generate the linearized model (See equation 1). - Compare the derived linearized model with experimentally measured data, as part of a model validation process. The TokSys toolbox has been used to derive models for the ITER, EAST, KSTAR, NSTX, MAST-U, DIII-D, SST-1, and Pegasus tokamaks, and the proposed Fusion Development Facility (FDF), among others. The developed models have been validated on DIII-D and NSTX and have been used to develop plasma controllers on DIII-D, ITER, EAST, KSTAR and Pegasus. Although even unvalidated or partially-validated models have proven very useful for developing and testing control software, use in a model-based control design requires that a real model-validation effort must be undertaken and completed before such controllers can be used with confidence in controlling plasmas. Model validation must include testing of individual component models, not just the final integrated model. Large integrated models are virtually never correct the first time used (or the 2nd, 3rd, ...) and typically cannot be made correct without identifying the source(s) of model discrepancy. Identifying sources of model discrepancy requires investigating individual components of the model. The development and use of a common toolset for multiple devices has significant advantages beyond the obvious issue of software re-use. In all cases, the models generated are first principles physics models, constructed without any \"tuning\" or \"fudge factors\", except for use of direct measurements of certain quantities such as coil resistance or inductance. Validation of this type of model versus experimental data on existing devices provides confidence in both the modeling approach and the model implementation when using the tools to extrapolate to model generation for devices that do not yet exist. Section 3 describes the modeling approach used by TokSys. Section 4 provides an overview of the organization and structure of the many modeling, analysis, and design functions. Section 5 provides instructions for how to make the Toksys tools available in your Matlab session. Section 6 provides a high-level summary list of device-independent modeling and analysis functions that are available when the Toksys tools are available in your session. Section 7 describes the process of constructing plasma response models, outlined in steps (a) through (c) above. Section 8 describes how the core set of generic modeling tools are used and expanded upon for modeling specific tokamaks and plasmas. Section 9 describes the process used for validation of TokSys models and the TokSys tools available to support this process. Section 10 describes a methodology employed to connect simulations constructed using TokSys models with a version of the real-time plasma control system (PCS), for those devices whose PCS is derived from the DIII-D PCS. Section 11 provides further details for some of the modeling tools. This section will be expanded in future versions of this document.","title":"Linearized plasma models for boundary control development"},{"location":"#plasma-control-modeling-approach","text":"The set of modeling tools in this toolbox automate the majority of the process of generating dynamic models for the tokamak and plasma poloidal field systems involved in plasma shape, position, and plasma current control. Key products of the model development process are linear models of the form \\[\\begin{equation} \\begin{aligned} \\dot{I} &= \\mathbf{A}I + \\mathbf{B}v + \\mathbf{F}w \\\\\\ y &= \\mathbf{C}I + \\mathbf{D}v + \\mathbf{H}w \\end{aligned} \\label{eq:dynamics} \\end{equation}\\] that represent the dynamics of evolution of currents in toroidal conductors (control coils, passive structure, and plasma) within the tokamak and include the effect of the nonstationary plasma on these dynamics. Here, \\(I\\) represents the toroidal currents in coils, passive conductors, and the bulk plasma, \\(v\\) represents coil power supply voltages, \\(y\\) represents magnetic measurements such as flux, field, or current, and \\(w\\) represents disturbance inputs which can be used to model the effect of changes in \\(\\beta_p\\) , \\(l_i\\) , or of noise. The matrices \\(\\mathbf{A} = -(\\mathbf{M}^*)^{-1}\\mathbf{R}\\) and \\(\\mathbf{B} = (\\mathbf{M}^*)^{-1}\\mathbf{V}\\) are computed from the conductor resistance matrix \\(\\mathbf{R}\\) , a plasma-modified mutual inductance matrix \\(\\mathbf{M}^*\\) (see [2]), and a matrix \\(\\mathbf{V}\\) that maps power supply source voltages into voltages applied to control coils. The matrix \\(\\mathbf{C}\\) is given primarily by the Green functions from currents to magnetic diagnostics, and \\(\\mathbf{D}\\) is usually 0. We refer to the first equation in \\(\\eqref{eq:dynamics}\\) as the \"dynamics equation\" because it describes how the dynamical system defined by the collection of toroidal conductor and plasma currents evolves. We refer to the second equation in \\(\\eqref{eq:dynamics}\\) as the \"output equation\" because it defines how the multiple magnetic diagnostics (B-probes, flux loops, coil and vessel Rogowskis, etc) depend on the toroidal currents and input voltages. The most basic and most mature plasma model construction method we use is based on the rigid plasma model approach described in [2]. Alternatives to this approach, including a nonrigid linear model [3] or nonlinear models [4] have also been integrated in this environment. Use of the nonrigid model requires only small variations from use of the rigid model, so we will confine the discussion in this document primarily to rigid plasma model development. Note Use of the nonlinear models will not be described here.","title":"Plasma Control Modeling Approach"},{"location":"#toksys-toolbox-file-structure","text":"The TokSys toolbox consists of a large collection of matlab functions organized into separate Linux directories according to similar functionality. There are three types of matlab files used for modeling: TokSys Matlab functions and models, generically applicable to any tokamak. Device-specific matlab functions and models, which invoke the TokSys modeling tools. General Matlab functions, which are invoked by both of the above. A TokSys installation consists of all three of these function sets plus additional tools for other related modeling and analysis purposes. The directory structure for such an installation is illustrated below. Figure 1: Illustration of TokSys installation directory structure The TokSys general modeling functions and generic matlab functions are located under the matlab path in the above figure. Device-specific functions are located under the tokamaks path. In addition to these two sets of directories, the TokSys toolset sits \"on top\" of the ITER PCSSP (Plasma Control System Simulation Platform) toolset, whose directories are structured similarly (see below). Figure 2: Illustration of PCSSP installation directory structure Codes and models specific to ITER are maintained as part of PCSSP, using the same separation between generally-applicable and device-specific functions and models. The structure shown in the figures above represent the installation at DIII-D. Most installations will have only one of the device directories under the \"tokamaks\" branch of Toksys, i.e. corresponding to the device local to where the toolset is installed. TokSys follows the usual matlab convention for providing on-line documentation to users in the form of function header documentation and Contents.m files. Each subdirectory in TokSys contains a Contents.m file that provides a summary of functions available in that directory. This summary of functions is available at the matlab command line by typing \"help\" followed by the directory name. Each function or script contains a standard format header, which describes how to use the function. This description is available at the matlab command line by typing \"help\" followed by the function name. Note These tools can serve as the foundation for the construction of your own specialized set of functions for tokamak modeling. Source code for all functions is provided and therefore can be modified locally. Warning DO NOT modify the source files in the installed area. Instead, make a copy of the source file in a separate directory, modify it there, then add that directory name to the matlab path in front of the TokSys directories. Matlab executes the first version of a file that it finds in its search path.","title":"TokSys Toolbox File Structure"},{"location":"#toksys-generic-function-directories","text":"We provide here a list of the subdirectories of the matlab directory shown in Figure 1. These subdirectories are intended to contain matlab scripts and functions that are applicable to any of the tokamak models we support and, in many cases, generally applicable to any tokamak. While this objective has been essentially reached for most sub-directories, there are a few of the functional areas listed below that are still evolving. 3d Three-dimensional electromagnetic analysis calculations breakdown Generic plasma breakdown/rampup calculations circuit_models Conductor circuit modeling functions comm_tbx Public domain Communications Toolbox (not well-tested) design Control design tools dcontrol Public domain Digital Control toolbox (not well-tested) dina Functions related to DINA plasma simulation code (not maintained) dmp Matlab DMP tools efit Functions related to EFIT reconstruction code. GAcomm GA-developed communication functions (mostly Ultra-Wideband) GAcontrol GA-developed control design utility functions. GAgraphics GA-developed graphics functions GAsignal GA-developed signal processing functions geom Tokamak geometry manipulation tools jfit Functions related to JFIT Magnetics Fitting Code mag Magnetics Calculation Tools math Math calculations mdsplus MDSplus data extraction and manipulation functions ntm NTM control functions PCS Generic functions for interaction with PCS. Applicable to any installation of the DIII-D PCS. plasma_models Functions for generating plasma (or plasma+device) models. plresp (NOT Generic yet) pubgraphics Public domain graphics functions. RWM Functions for developing or analyzing RWM control (not currently available) regression Functions for regression simserver Functions for creating simserver simulations (to connect with PCS). teq Functions for interacting with Corsica and TEQ. (NOT Generic yet) tok_models Functions for generating plasma (or plasma+device) models toksim Toksim library and support functions utilities Utility functions validation Functions for model validation","title":"TokSys Generic Function Directories"},{"location":"02_install/","text":"Installation \u00b6 This section describes how to set up the Toksys/PCSSP tools for use by your Matlab session. Many users will want to use only the installed versions of these toolboxes. Standard installation of Toksys/PCSSP at sites outside of GA is done by Brian Sammuli (sammuli@fusion.gat.com) in coordination with system administrators at each installation site. However, if you want to be able to make changes to existing Toksys functions or add new functions and submit the modified or new functions to the Toksys code base, you will need to use a version of Toksys cloned from the Git repository. Using previously installed Toksys and PCSSP \u00b6 Add the directory <toksys_root>/startups , where <toksys_root> is the installed TokSys root directory, to the linux environment variable MATLABPATH . For example, at D3D the command would be bash export MATLABPATH = /fusion/projects/codes/toksys/GAtools: $MATLABPATH tsch setenv MATLABPATH /fusion/projects/codes/toksys/GAtools: $MATLABPATH To start using TokSys start Matlab and run >> toksys_startup Note On iris and saturn at D3D, the command module load toksys steps up the environmental variables for you, but requires that you run module load matlab first. Using custom version of Toksys (and of PCSSP if desired) \u00b6 The easiest method is to clone it into the TokSys directory tree, e.g.: git clone git@odin.gat.com:TOKSYS/toksys.git cd toksys git clone ssh://git@git.iter.org/pcs/pcssp.git makeit The final makeit command performs the actions necessary to compile all S-functions in the Toksys and PCSSP directory trees. Alternatively, the PCSSP directory can be in a different location (either installed or cloned), in which case you can simply provide a link to it in the TokSys directory structure, e.g: git clone git@odin.gat.com:TOKSYS/toksys.git cd toksys ln -s <pcssp_root> pcssp makeit where <pcssp_root> is the root directory of the cloned (or installed) PCSSP directory tree The instructions above provide the necessary steps to make the Toksys/PCSSP tool sets usable and to add their locations to the search path in your Matlab session. If, in addition, you want to use these tools to perform modeling, control design, or analysis for a particular device, you will also need to type (in Matlab): >> < device_name > _startup where represents the name of the device, e.g. >> d3d_startup >> kstar_startup It is often convenient make provision for the default (generic) Matlab to always be in the search path when starting up Matlab. To enable this, create a file startup.m in your directory ~/matlab containing the line toksys_startup","title":"Installation"},{"location":"02_install/#installation","text":"This section describes how to set up the Toksys/PCSSP tools for use by your Matlab session. Many users will want to use only the installed versions of these toolboxes. Standard installation of Toksys/PCSSP at sites outside of GA is done by Brian Sammuli (sammuli@fusion.gat.com) in coordination with system administrators at each installation site. However, if you want to be able to make changes to existing Toksys functions or add new functions and submit the modified or new functions to the Toksys code base, you will need to use a version of Toksys cloned from the Git repository.","title":"Installation"},{"location":"02_install/#using-previously-installed-toksys-and-pcssp","text":"Add the directory <toksys_root>/startups , where <toksys_root> is the installed TokSys root directory, to the linux environment variable MATLABPATH . For example, at D3D the command would be bash export MATLABPATH = /fusion/projects/codes/toksys/GAtools: $MATLABPATH tsch setenv MATLABPATH /fusion/projects/codes/toksys/GAtools: $MATLABPATH To start using TokSys start Matlab and run >> toksys_startup Note On iris and saturn at D3D, the command module load toksys steps up the environmental variables for you, but requires that you run module load matlab first.","title":"Using previously installed Toksys and PCSSP"},{"location":"02_install/#using-custom-version-of-toksys-and-of-pcssp-if-desired","text":"The easiest method is to clone it into the TokSys directory tree, e.g.: git clone git@odin.gat.com:TOKSYS/toksys.git cd toksys git clone ssh://git@git.iter.org/pcs/pcssp.git makeit The final makeit command performs the actions necessary to compile all S-functions in the Toksys and PCSSP directory trees. Alternatively, the PCSSP directory can be in a different location (either installed or cloned), in which case you can simply provide a link to it in the TokSys directory structure, e.g: git clone git@odin.gat.com:TOKSYS/toksys.git cd toksys ln -s <pcssp_root> pcssp makeit where <pcssp_root> is the root directory of the cloned (or installed) PCSSP directory tree The instructions above provide the necessary steps to make the Toksys/PCSSP tool sets usable and to add their locations to the search path in your Matlab session. If, in addition, you want to use these tools to perform modeling, control design, or analysis for a particular device, you will also need to type (in Matlab): >> < device_name > _startup where represents the name of the device, e.g. >> d3d_startup >> kstar_startup It is often convenient make provision for the default (generic) Matlab to always be in the search path when starting up Matlab. To enable this, create a file startup.m in your directory ~/matlab containing the line toksys_startup","title":"Using custom version of Toksys (and of PCSSP if desired)"},{"location":"other_docs/","text":"Further Documentation \u00b6 General Toksys \u00b6 D3D \u00b6 description [] NSTX-U \u00b6 Todo Links to EPM docs from epm.odin","title":"Further Documentation"},{"location":"other_docs/#further-documentation","text":"","title":"Further Documentation"},{"location":"other_docs/#general-toksys","text":"","title":"General Toksys"},{"location":"other_docs/#d3d","text":"description []","title":"D3D"},{"location":"other_docs/#nstx-u","text":"Todo Links to EPM docs from epm.odin","title":"NSTX-U"},{"location":"function-guide/check_pcssp_conflicts_m/","text":"check_pcssp_conflicts.m \u00b6 Basic Information \u00b6 SYNTAX: common_names = check_pcssp_conflicts() PURPOSE: Check for name conflicts with PCSSP. INPUT: none (reads GATOOLS_ROOT and PCSSP_root environment variables) OUTPUT: common_names = cell_array containing list of names in both","title":"check_pcssp_conflicts.m"},{"location":"function-guide/check_pcssp_conflicts_m/#check_pcssp_conflictsm","text":"","title":"check_pcssp_conflicts.m"},{"location":"function-guide/check_pcssp_conflicts_m/#basic-information","text":"SYNTAX: common_names = check_pcssp_conflicts() PURPOSE: Check for name conflicts with PCSSP. INPUT: none (reads GATOOLS_ROOT and PCSSP_root environment variables) OUTPUT: common_names = cell_array containing list of names in both","title":"Basic Information"},{"location":"function-guide/licenses_needed_m/","text":"licenses_needed.m \u00b6 Basic Information \u00b6 SYNTAX: plist = licenses_needed(root_dir) PURPOSE: Determine all matlab/simulink products that are needed to support the hierarchy of tools under root_dir. (This function takes a long time to run.) INPUT: root_dir = root directory of files to evaluate OUTPUT: plist = matlab/simulink product list Dependencies \u00b6","title":"licenses_needed.m"},{"location":"function-guide/licenses_needed_m/#licenses_neededm","text":"","title":"licenses_needed.m"},{"location":"function-guide/licenses_needed_m/#basic-information","text":"SYNTAX: plist = licenses_needed(root_dir) PURPOSE: Determine all matlab/simulink products that are needed to support the hierarchy of tools under root_dir. (This function takes a long time to run.) INPUT: root_dir = root directory of files to evaluate OUTPUT: plist = matlab/simulink product list","title":"Basic Information"},{"location":"function-guide/licenses_needed_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/3d/calcGpx0529a_m/","text":"calcGpx0529a.m \u00b6 Basic Information \u00b6 SYNTAX: [Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m) Dependencies \u00b6 green_paths2pts","title":"calcGpx0529a.m"},{"location":"function-guide/3d/calcGpx0529a_m/#calcgpx0529am","text":"","title":"calcGpx0529a.m"},{"location":"function-guide/3d/calcGpx0529a_m/#basic-information","text":"SYNTAX: [Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m)","title":"Basic Information"},{"location":"function-guide/3d/calcGpx0529a_m/#dependencies","text":"green_paths2pts","title":"Dependencies"},{"location":"function-guide/3d/calc_GpxX_m/","text":"calc_GpxX.m \u00b6 Basic Information \u00b6 SYNTAX: [Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m) Dependencies \u00b6 green_paths2pts","title":"calc_GpxX.m"},{"location":"function-guide/3d/calc_GpxX_m/#calc_gpxxm","text":"","title":"calc_GpxX.m"},{"location":"function-guide/3d/calc_GpxX_m/#basic-information","text":"SYNTAX: [Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m)","title":"Basic Information"},{"location":"function-guide/3d/calc_GpxX_m/#dependencies","text":"green_paths2pts","title":"Dependencies"},{"location":"function-guide/3d/calc_Gpx_m/","text":"calc_Gpx.m \u00b6 Basic Information \u00b6 SYNTAX: [Gpx,Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpx = Green function matrix for total poloidal Bp [T/MA] Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m) Dependencies \u00b6 green_paths2pts","title":"calc_Gpx.m"},{"location":"function-guide/3d/calc_Gpx_m/#calc_gpxm","text":"","title":"calc_Gpx.m"},{"location":"function-guide/3d/calc_Gpx_m/#basic-information","text":"SYNTAX: [Gpx,Gpxr,Gpxz,Gpxt] = calc_Gpx(pts,tlt,XXpaths,XXfracp) PURPOSE: Calc Green function matrix between conductor set X whose paths are described by cell array XXpaths (see mut_paths2paths), and set of points pts given as npts x 3 matrix (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). INPUTS: pts = array specifying points: npts x 3 matrix (cols=R,Z,phi) tlt = vector of tilt angles (upward pointing probe has tilt = 0 rad, probe on R+1 has tilt = + some rad) XXpaths = cell array of paths XXfracp = fraction of current in each path (see mut_paths2paths) OUTPUTS: Gpx = Green function matrix for total poloidal Bp [T/MA] Gpxr = Green function matrix for Br [T/MA] Gpxz = Green function matrix for Bz [T/MA] Gpxt = Green function matrix for Btor [T/MA] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... In a single (contguous) path specified by Paths{ii}, all the fracs must be the same as frac(1). METHOD: Uses green_paths2pts.m (which will call mag_fil_pt.m)","title":"Basic Information"},{"location":"function-guide/3d/calc_Gpx_m/#dependencies","text":"green_paths2pts","title":"Dependencies"},{"location":"function-guide/3d/calc_Mxx_m/","text":"calc_Mxx.m \u00b6 Basic Information \u00b6 SYNTAX: Mxx = calc_Mxx(XXpaths,XXfracp,as) PURPOSE: Calc self inductance of conductor X whose paths are described by cell array XXpaths (see mut_paths2paths) INPUTS: as = scalar or vector of radii of paths in conductor X OUTPUTS: Mxx = self inductance of conductor X [uH] RESTRICTIONS: X Paths cell arrays must contain filament matrices in FILC convention... METHOD: Uses mut_paths2paths.m Dependencies \u00b6 self_paths mut_paths2paths","title":"calc_Mxx.m"},{"location":"function-guide/3d/calc_Mxx_m/#calc_mxxm","text":"","title":"calc_Mxx.m"},{"location":"function-guide/3d/calc_Mxx_m/#basic-information","text":"SYNTAX: Mxx = calc_Mxx(XXpaths,XXfracp,as) PURPOSE: Calc self inductance of conductor X whose paths are described by cell array XXpaths (see mut_paths2paths) INPUTS: as = scalar or vector of radii of paths in conductor X OUTPUTS: Mxx = self inductance of conductor X [uH] RESTRICTIONS: X Paths cell arrays must contain filament matrices in FILC convention... METHOD: Uses mut_paths2paths.m","title":"Basic Information"},{"location":"function-guide/3d/calc_Mxx_m/#dependencies","text":"self_paths mut_paths2paths","title":"Dependencies"},{"location":"function-guide/3d/calc_Mxy_m/","text":"calc_Mxy.m \u00b6 Basic Information \u00b6 SYNTAX: Mxy = calc_Mxy(XXpaths,XXfracp,YYpaths,YYfracp) PURPOSE: Calc mutual inductance matrix between conductors X and Y, whose paths are described by cell arrays XXpaths and YYpaths (see mut_paths2paths) INPUTS: OUTPUTS: Mxy = mutual inductance matrix [uH] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... METHOD: Uses mut_paths2paths.m Dependencies \u00b6 mut_paths2paths","title":"calc_Mxy.m"},{"location":"function-guide/3d/calc_Mxy_m/#calc_mxym","text":"","title":"calc_Mxy.m"},{"location":"function-guide/3d/calc_Mxy_m/#basic-information","text":"SYNTAX: Mxy = calc_Mxy(XXpaths,XXfracp,YYpaths,YYfracp) PURPOSE: Calc mutual inductance matrix between conductors X and Y, whose paths are described by cell arrays XXpaths and YYpaths (see mut_paths2paths) INPUTS: OUTPUTS: Mxy = mutual inductance matrix [uH] RESTRICTIONS: X and Y cannot be the same conductors (use calc_Mxx for that). Both Xand Y Paths cell arrays must contain filament matrices in FILC convention... METHOD: Uses mut_paths2paths.m","title":"Basic Information"},{"location":"function-guide/3d/calc_Mxy_m/#dependencies","text":"mut_paths2paths","title":"Dependencies"},{"location":"function-guide/3d/expand_fils_m/","text":"expand_fils.m \u00b6 Basic Information \u00b6 SYNTAX: nufils = expand_fils(fils,rwnorm,Rref) PURPOSE: Expand filaments in minor radial position according to rwnorm (eg creates marginal wall position with rwnorm=rwmarginal/rwactual) in toroidal geometry. INPUTS: fils = filament array rwnorm = marginal wall minor radial position normalized to rw_actual (rwnorm=rwmarginal/rwactual; ref'd at midplane) Rref = major radius of reference pt (z=0 taken to be the vertical posit. of the reference point) from which expansion happens OUTPUTS: nufils = new (expanded) filaments RESTRICTIONS: rwnorm must not be large enough to cause the *inboard* wall to cross the machine center line (for the moment): no safeguard is provided in present version to prevent this... METHOD: Dependencies \u00b6","title":"expand_fils.m"},{"location":"function-guide/3d/expand_fils_m/#expand_filsm","text":"","title":"expand_fils.m"},{"location":"function-guide/3d/expand_fils_m/#basic-information","text":"SYNTAX: nufils = expand_fils(fils,rwnorm,Rref) PURPOSE: Expand filaments in minor radial position according to rwnorm (eg creates marginal wall position with rwnorm=rwmarginal/rwactual) in toroidal geometry. INPUTS: fils = filament array rwnorm = marginal wall minor radial position normalized to rw_actual (rwnorm=rwmarginal/rwactual; ref'd at midplane) Rref = major radius of reference pt (z=0 taken to be the vertical posit. of the reference point) from which expansion happens OUTPUTS: nufils = new (expanded) filaments RESTRICTIONS: rwnorm must not be large enough to cause the *inboard* wall to cross the machine center line (for the moment): no safeguard is provided in present version to prevent this... METHOD:","title":"Basic Information"},{"location":"function-guide/3d/expand_fils_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/3d/fil_length_m/","text":"fil_length.m \u00b6 Basic Information \u00b6 SYNTAX: length = fil_length(fil) PURPOSE: Calculate length of filament (or lengths of all in array of filaments) Filament spec is JAL standard [x1,y1,z1,x2,y2,z2] (or columns of same) INPUTS: fil = filament vector or array OUTPUTS: length = length of filament (or vector with lengths of setof filaments) RESTRICTIONS: METHOD: Dependencies \u00b6","title":"fil_length.m"},{"location":"function-guide/3d/fil_length_m/#fil_lengthm","text":"","title":"fil_length.m"},{"location":"function-guide/3d/fil_length_m/#basic-information","text":"SYNTAX: length = fil_length(fil) PURPOSE: Calculate length of filament (or lengths of all in array of filaments) Filament spec is JAL standard [x1,y1,z1,x2,y2,z2] (or columns of same) INPUTS: fil = filament vector or array OUTPUTS: length = length of filament (or vector with lengths of setof filaments) RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/3d/fil_length_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/3d/fils2paths_m/","text":"fils2paths.m \u00b6 Basic Information \u00b6 SYNTAX: [VVpaths,VVfracp] = fils2paths(VVfils,VVfrac,nfilp); PURPOSE: Convert fils to paths (Note fils NOT FILSC notation!!!) INPUTS: OUTPUTS: RESTRICTIONS: METHOD: Dependencies \u00b6 fil_to_filc","title":"fils2paths.m"},{"location":"function-guide/3d/fils2paths_m/#fils2pathsm","text":"","title":"fils2paths.m"},{"location":"function-guide/3d/fils2paths_m/#basic-information","text":"SYNTAX: [VVpaths,VVfracp] = fils2paths(VVfils,VVfrac,nfilp); PURPOSE: Convert fils to paths (Note fils NOT FILSC notation!!!) INPUTS: OUTPUTS: RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/3d/fils2paths_m/#dependencies","text":"fil_to_filc","title":"Dependencies"},{"location":"function-guide/3d/green_paths2ptsORIG_m/","text":"green_paths2ptsORIG.m \u00b6 Basic Information \u00b6 SYNTAX: [Gr, Gz, Gt] = green_paths2pts(pts,Paths) PURPOSE: INPUTS: pts = pts geometry array (npts x 3) (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit. OR can be a *single* path, described by a filament *array* OUTPUTS: Gr,Gz,Gt = (npts,npaths) Green fun matrices from all paths in Paths to all pts in pts (all equally weighted). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD: Dependencies \u00b6 mag_fil_pt","title":"green_paths2ptsORIG.m"},{"location":"function-guide/3d/green_paths2ptsORIG_m/#green_paths2ptsorigm","text":"","title":"green_paths2ptsORIG.m"},{"location":"function-guide/3d/green_paths2ptsORIG_m/#basic-information","text":"SYNTAX: [Gr, Gz, Gt] = green_paths2pts(pts,Paths) PURPOSE: INPUTS: pts = pts geometry array (npts x 3) (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit. OR can be a *single* path, described by a filament *array* OUTPUTS: Gr,Gz,Gt = (npts,npaths) Green fun matrices from all paths in Paths to all pts in pts (all equally weighted). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/green_paths2ptsORIG_m/#dependencies","text":"mag_fil_pt","title":"Dependencies"},{"location":"function-guide/3d/green_paths2pts_m/","text":"green_paths2pts.m \u00b6 Basic Information \u00b6 SYNTAX: [Gr, Gz, Gt] = green_paths2pts(pts,Paths) PURPOSE: INPUTS: pts = pts geometry array (npts x 3) (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit. OR can be a *single* path, described by a filament *array* OUTPUTS: Gr,Gz,Gt = (npts,npaths) Green fun matrices from all paths in Paths to all pts in pts (all equally weighted). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD: Dependencies \u00b6 mag_fil_pt filc_to_fil","title":"green_paths2pts.m"},{"location":"function-guide/3d/green_paths2pts_m/#green_paths2ptsm","text":"","title":"green_paths2pts.m"},{"location":"function-guide/3d/green_paths2pts_m/#basic-information","text":"SYNTAX: [Gr, Gz, Gt] = green_paths2pts(pts,Paths) PURPOSE: INPUTS: pts = pts geometry array (npts x 3) (columns are R,Z,phi; R,Z in m; phi=tor angle in radians). Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit. OR can be a *single* path, described by a filament *array* OUTPUTS: Gr,Gz,Gt = (npts,npaths) Green fun matrices from all paths in Paths to all pts in pts (all equally weighted). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/green_paths2pts_m/#dependencies","text":"mag_fil_pt filc_to_fil","title":"Dependencies"},{"location":"function-guide/3d/make_hel_fils_m/","text":"make_hel_fils.m \u00b6 Basic Information \u00b6 SYNTAX: [fils,frac,Paths,fracp] = make_hel_fils(polpts,mmode,nmode, ... Rref,phase,iplot) PURPOSE: Construct helical filament sets for nonaxisymmetric mode on continuous surface such as plasma or vessel wall. INPUTS: polpts = set of poloidal points = (npts,2) matrix [x,z] [m] mmode = m poloidal mode number nmode = n toroidal mode number Rref = reference major radius [m] phase = (optional) phase relative to toroidal angle phi=0; phase=0 (default) gives cos mode, phase=-pi/2 gives sin mode. iplot = (optional) flag to select plotting: 0=no plot(default), 1= plot helicity = (optional) +1 for LH (default), -1 for RH OUTPUTS: fils = matrix describing set of filaments in [x1,y1,z1,x2,y2,z2] format frac = fraction of current in each filament (const on each hel winding) Paths = cell array of filament sets corr to each *path* in hel windings (note that the Paths cell array is a *column* cell array, dims {npaths,1} to allow row dimension to be used for modes...) NOTE WELL that the Paths matrices are in FILC format!!! fracp = vector of fracs corr to each *path* RESTRICTIONS: # of pts in polpts must be even multiple of mmode, and should be >> 1 (for example for 3,1 mode must have multiple of 3, like 24, 36, 60... Multiples of 12 are nice, since contain factors 2,3,4) METHOD: Dependencies \u00b6 fil_to_filc pts_to_fil","title":"make_hel_fils.m"},{"location":"function-guide/3d/make_hel_fils_m/#make_hel_filsm","text":"","title":"make_hel_fils.m"},{"location":"function-guide/3d/make_hel_fils_m/#basic-information","text":"SYNTAX: [fils,frac,Paths,fracp] = make_hel_fils(polpts,mmode,nmode, ... Rref,phase,iplot) PURPOSE: Construct helical filament sets for nonaxisymmetric mode on continuous surface such as plasma or vessel wall. INPUTS: polpts = set of poloidal points = (npts,2) matrix [x,z] [m] mmode = m poloidal mode number nmode = n toroidal mode number Rref = reference major radius [m] phase = (optional) phase relative to toroidal angle phi=0; phase=0 (default) gives cos mode, phase=-pi/2 gives sin mode. iplot = (optional) flag to select plotting: 0=no plot(default), 1= plot helicity = (optional) +1 for LH (default), -1 for RH OUTPUTS: fils = matrix describing set of filaments in [x1,y1,z1,x2,y2,z2] format frac = fraction of current in each filament (const on each hel winding) Paths = cell array of filament sets corr to each *path* in hel windings (note that the Paths cell array is a *column* cell array, dims {npaths,1} to allow row dimension to be used for modes...) NOTE WELL that the Paths matrices are in FILC format!!! fracp = vector of fracs corr to each *path* RESTRICTIONS: # of pts in polpts must be even multiple of mmode, and should be >> 1 (for example for 3,1 mode must have multiple of 3, like 24, 36, 60... Multiples of 12 are nice, since contain factors 2,3,4) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/make_hel_fils_m/#dependencies","text":"fil_to_filc pts_to_fil","title":"Dependencies"},{"location":"function-guide/3d/make_rec_filsORIG_m/","text":"make_rec_filsORIG.m \u00b6 Basic Information \u00b6 SYNTAX: [RECpts,RECfils] = make_rec_fils(zphis,thetas,rs,tilts,dzphis, ... hs,Rref,nfils) PURPOSE: Construct corner pts and filaments for picture frame coils in *toroidal* geometry (with horizontal legs curving around toroidal direction, but not necessarily at same minor or major radius...). INPUTS: (vectors are all 1x2) zphis = vector of phi=toroidal angle positions of frame *centers*. [rad] thetas = vector of theta (angular) positions of frame centers [rad] poloidal angle rel. to the major axis of the torus at R=Rref rs = vector of R (major radial) positions of frame centers [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to major radius R [rad] (when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames angular width dphi in [rad] hs = vector of full heights of frames [m] Rref = Reference major radius for toroidal case nfils = (opt) vec of # of sub-filaments to split legs into (def=10) OUTPUTS: RECpts = matrix of points making up rec coil rows of [x,y,z] RECfils = matrix of filaments [x1,y1,z1,x2,y2,z2] RESTRICTIONS: METHOD: For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles. Dependencies \u00b6 pts_to_fil","title":"make_rec_filsORIG.m"},{"location":"function-guide/3d/make_rec_filsORIG_m/#make_rec_filsorigm","text":"","title":"make_rec_filsORIG.m"},{"location":"function-guide/3d/make_rec_filsORIG_m/#basic-information","text":"SYNTAX: [RECpts,RECfils] = make_rec_fils(zphis,thetas,rs,tilts,dzphis, ... hs,Rref,nfils) PURPOSE: Construct corner pts and filaments for picture frame coils in *toroidal* geometry (with horizontal legs curving around toroidal direction, but not necessarily at same minor or major radius...). INPUTS: (vectors are all 1x2) zphis = vector of phi=toroidal angle positions of frame *centers*. [rad] thetas = vector of theta (angular) positions of frame centers [rad] poloidal angle rel. to the major axis of the torus at R=Rref rs = vector of R (major radial) positions of frame centers [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to major radius R [rad] (when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames angular width dphi in [rad] hs = vector of full heights of frames [m] Rref = Reference major radius for toroidal case nfils = (opt) vec of # of sub-filaments to split legs into (def=10) OUTPUTS: RECpts = matrix of points making up rec coil rows of [x,y,z] RECfils = matrix of filaments [x1,y1,z1,x2,y2,z2] RESTRICTIONS: METHOD: For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"Basic Information"},{"location":"function-guide/3d/make_rec_filsORIG_m/#dependencies","text":"pts_to_fil","title":"Dependencies"},{"location":"function-guide/3d/make_rec_fils_m/","text":"make_rec_fils.m \u00b6 Basic Information \u00b6 SYNTAX: [RECpts,RECfils] = make_rec_fils(zphis,thetas,rs,tilts,dzphis, ... hs,Rref,nfils) PURPOSE: Construct corner pts and filaments for picture frame coils in *toroidal* geometry (with horizontal legs curving around toroidal direction, but not necessarily at same minor or major radius...). INPUTS: (vectors are all 1x2) zphis = vector of phi=toroidal angle positions of frame *centers*. [rad] thetas = vector of theta (angular) positions of frame centers [rad] poloidal angle rel. to the major axis of the torus at R=Rref rs = vector of R (major radial) positions of frame centers [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to major radius R [rad] (when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames angular width dphi in [rad] hs = vector of full heights of frames [m] Rref = Reference major radius for toroidal case nfils = (opt) vec of # of sub-filaments to split legs into (def=10) OUTPUTS: RECpts = matrix of points making up rec coil rows of [x,y,z] RECfils = matrix of filaments [x1,y1,z1,x2,y2,z2] RESTRICTIONS: METHOD: For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles. Dependencies \u00b6 pts_to_fil","title":"make_rec_fils.m"},{"location":"function-guide/3d/make_rec_fils_m/#make_rec_filsm","text":"","title":"make_rec_fils.m"},{"location":"function-guide/3d/make_rec_fils_m/#basic-information","text":"SYNTAX: [RECpts,RECfils] = make_rec_fils(zphis,thetas,rs,tilts,dzphis, ... hs,Rref,nfils) PURPOSE: Construct corner pts and filaments for picture frame coils in *toroidal* geometry (with horizontal legs curving around toroidal direction, but not necessarily at same minor or major radius...). INPUTS: (vectors are all 1x2) zphis = vector of phi=toroidal angle positions of frame *centers*. [rad] thetas = vector of theta (angular) positions of frame centers [rad] poloidal angle rel. to the major axis of the torus at R=Rref rs = vector of R (major radial) positions of frame centers [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to major radius R [rad] (when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames angular width dphi in [rad] hs = vector of full heights of frames [m] Rref = Reference major radius for toroidal case nfils = (opt) vec of # of sub-filaments to split legs into (def=10) OUTPUTS: RECpts = matrix of points making up rec coil rows of [x,y,z] RECfils = matrix of filaments [x1,y1,z1,x2,y2,z2] RESTRICTIONS: METHOD: For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"Basic Information"},{"location":"function-guide/3d/make_rec_fils_m/#dependencies","text":"pts_to_fil","title":"Dependencies"},{"location":"function-guide/3d/make_tor_fils_m/","text":"make_tor_fils.m \u00b6 Basic Information \u00b6 SYNTAX: [fils,frac,Paths,fracp] = make_tor_fils(polpts,Rref,mmode, ... nvvtor,iplot) PURPOSE: Construct toroidal filament sets for axisymmetric mode on continuous surface such as plasma or vessel wall. INPUTS: polpts = set of poloidal points = (npts,2) matrix [x,z] [m] mmode = m poloidal mode number Rref = reference major radius [m] nvvtor = # of toroidal pts iplot = (optional) flag to select plotting: 0=no plot(default), 1= plot OUTPUTS: fils = matrix describing set of filaments in [x1,y1,z1,x2,y2,z2] format frac = fraction of current in each filament (const on each hel winding) Paths = cell array of filament sets corr to each *path* in hel windings (note that the Paths cell array is a *column* cell array, dims {npaths,1} to allow row dimension to be used for modes...) NOTE WELL that the Paths matrices are in FILC format!!!! fracp = vector of fracs corr to each *path* RESTRICTIONS: # of pts in polpts must be even multiple of mmode, and should be >> 1 (for example for 3,1 mode must have multiple of 3, like 24, 36, 60... Multiples of 12 are nice, since contain factors 2,3,4) METHOD: Dependencies \u00b6 fil_to_filc pts_to_fil","title":"make_tor_fils.m"},{"location":"function-guide/3d/make_tor_fils_m/#make_tor_filsm","text":"","title":"make_tor_fils.m"},{"location":"function-guide/3d/make_tor_fils_m/#basic-information","text":"SYNTAX: [fils,frac,Paths,fracp] = make_tor_fils(polpts,Rref,mmode, ... nvvtor,iplot) PURPOSE: Construct toroidal filament sets for axisymmetric mode on continuous surface such as plasma or vessel wall. INPUTS: polpts = set of poloidal points = (npts,2) matrix [x,z] [m] mmode = m poloidal mode number Rref = reference major radius [m] nvvtor = # of toroidal pts iplot = (optional) flag to select plotting: 0=no plot(default), 1= plot OUTPUTS: fils = matrix describing set of filaments in [x1,y1,z1,x2,y2,z2] format frac = fraction of current in each filament (const on each hel winding) Paths = cell array of filament sets corr to each *path* in hel windings (note that the Paths cell array is a *column* cell array, dims {npaths,1} to allow row dimension to be used for modes...) NOTE WELL that the Paths matrices are in FILC format!!!! fracp = vector of fracs corr to each *path* RESTRICTIONS: # of pts in polpts must be even multiple of mmode, and should be >> 1 (for example for 3,1 mode must have multiple of 3, like 24, 36, 60... Multiples of 12 are nice, since contain factors 2,3,4) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/make_tor_fils_m/#dependencies","text":"fil_to_filc pts_to_fil","title":"Dependencies"},{"location":"function-guide/3d/make_wallmesh_m/","text":"make_wallmesh.m \u00b6 Basic Information \u00b6 SYNTAX: [vvPfils,vvTfils,Cvpol,Cvtor] = make_wallmesh(vvpolpts,torangs, ... iclosepol,iclosetor,iplot,Rref); PURPOSE: Generate filament array for mesh representation of toroidal wall or wall segment. INPUTS: vvpolpts = array of poloidal points for wall representation (npts,2) [R(:) Z(:)] [m] torangs = toroidal angles for wall discretization [deg] iclosepol = flag =1 to select closing of wall in pol direction (def=1) iclosetor = flag =1 to select closing of wall in tor direction (def=1) iplot = flag to select plotting if 3D geometry OUTPUTS: vvPfils = filament array for poloidal-pointing filaments in mesh representation vvTfils = filament array for toroidal-pointing filaments in mesh representation Cvpol = constraint matrix for poloidal filaments (total constraint matrix is Cvv=[Cvpol Cvtor], total filament matrix is vvfils = [vvPfils; vvTfils]) Cvtor = constraint matrix for toroidal filaments RESTRICTIONS: METHOD: Two filament arrays are produced, one for poloidally-pointing filaments and one for toroidally-pointing filaments. Poloidal and toroidal filaments with the same index emerge from the same point. Filaments associated with a given point are the right-pointing toroidal and the upward-pointing poloidal filament. Constraint matrix represents the node current equations: # of rows = total # of pts (=npolpts*ntorpts), while # of columns = # of pol fils + # of tor fils = 2x(tot # of pts). Constraint equation is thus C*I=0, so current vectors lie in null space of constraint matrix. Dependencies \u00b6 plot_fils fil_to_filc","title":"make_wallmesh.m"},{"location":"function-guide/3d/make_wallmesh_m/#make_wallmeshm","text":"","title":"make_wallmesh.m"},{"location":"function-guide/3d/make_wallmesh_m/#basic-information","text":"SYNTAX: [vvPfils,vvTfils,Cvpol,Cvtor] = make_wallmesh(vvpolpts,torangs, ... iclosepol,iclosetor,iplot,Rref); PURPOSE: Generate filament array for mesh representation of toroidal wall or wall segment. INPUTS: vvpolpts = array of poloidal points for wall representation (npts,2) [R(:) Z(:)] [m] torangs = toroidal angles for wall discretization [deg] iclosepol = flag =1 to select closing of wall in pol direction (def=1) iclosetor = flag =1 to select closing of wall in tor direction (def=1) iplot = flag to select plotting if 3D geometry OUTPUTS: vvPfils = filament array for poloidal-pointing filaments in mesh representation vvTfils = filament array for toroidal-pointing filaments in mesh representation Cvpol = constraint matrix for poloidal filaments (total constraint matrix is Cvv=[Cvpol Cvtor], total filament matrix is vvfils = [vvPfils; vvTfils]) Cvtor = constraint matrix for toroidal filaments RESTRICTIONS: METHOD: Two filament arrays are produced, one for poloidally-pointing filaments and one for toroidally-pointing filaments. Poloidal and toroidal filaments with the same index emerge from the same point. Filaments associated with a given point are the right-pointing toroidal and the upward-pointing poloidal filament. Constraint matrix represents the node current equations: # of rows = total # of pts (=npolpts*ntorpts), while # of columns = # of pol fils + # of tor fils = 2x(tot # of pts). Constraint equation is thus C*I=0, so current vectors lie in null space of constraint matrix.","title":"Basic Information"},{"location":"function-guide/3d/make_wallmesh_m/#dependencies","text":"plot_fils fil_to_filc","title":"Dependencies"},{"location":"function-guide/3d/mut_fil_fil_m/","text":"mut_fil_fil.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the mutual inductance between two sets of filaments A & B. Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. Sending filament set is \"A\", receiving filament set is \"B\" Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: mut_fil_fil(xa,xb,fa,fb) INPUT: (a= sending filament, b= receiving filament) xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] xb = same for receiving filaments [xb,yb,zb,dxb,dyb,dzb] fa,fb= Optional: fraction of current in filament for parallel filaments OUTPUT: m == mutual inductance between filament sets A to B [H] CAUTION: Will not work for filaments on top of each other (ie self inductance) Dependencies \u00b6 fil_regrid fil_a z_dircos fil_to_filc pts_to_fil","title":"mut_fil_fil.m"},{"location":"function-guide/3d/mut_fil_fil_m/#mut_fil_film","text":"","title":"mut_fil_fil.m"},{"location":"function-guide/3d/mut_fil_fil_m/#basic-information","text":"PURPOSE: Calculate the mutual inductance between two sets of filaments A & B. Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. Sending filament set is \"A\", receiving filament set is \"B\" Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: mut_fil_fil(xa,xb,fa,fb) INPUT: (a= sending filament, b= receiving filament) xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] xb = same for receiving filaments [xb,yb,zb,dxb,dyb,dzb] fa,fb= Optional: fraction of current in filament for parallel filaments OUTPUT: m == mutual inductance between filament sets A to B [H] CAUTION: Will not work for filaments on top of each other (ie self inductance)","title":"Basic Information"},{"location":"function-guide/3d/mut_fil_fil_m/#dependencies","text":"fil_regrid fil_a z_dircos fil_to_filc pts_to_fil","title":"Dependencies"},{"location":"function-guide/3d/mut_filcs2filcs_m/","text":"mut_filcs2filcs.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate mutual inductances between sets of conductors described by cells of filc arrays SYNTAX: M = mut_filcs2filcs(filcs1,filcs2,aa1,aa2,f1,f2) INPUT: filcs1, filcs2 = CELLS of filament matrices defined by [xc,yc,zc,dx,dy,dz] aa1, aa2, radii of fils, = sqrt(cross sectional area / pi) aa1 is required if any conductor in set 1 is identical to any in 2 f1, f2 (optional) = fraction of current in a filament (for parallel fils) OUTPUT: M = matrix of mutuals from set filcs1 to set filcs2 of conductors [H] RESTRICTIONS: METHOD: Calls mut_fil_fil if the fils are different and self_filDH if same Dependencies \u00b6 mut_fil_fil self_filDH","title":"mut_filcs2filcs.m"},{"location":"function-guide/3d/mut_filcs2filcs_m/#mut_filcs2filcsm","text":"","title":"mut_filcs2filcs.m"},{"location":"function-guide/3d/mut_filcs2filcs_m/#basic-information","text":"PURPOSE: Calculate mutual inductances between sets of conductors described by cells of filc arrays SYNTAX: M = mut_filcs2filcs(filcs1,filcs2,aa1,aa2,f1,f2) INPUT: filcs1, filcs2 = CELLS of filament matrices defined by [xc,yc,zc,dx,dy,dz] aa1, aa2, radii of fils, = sqrt(cross sectional area / pi) aa1 is required if any conductor in set 1 is identical to any in 2 f1, f2 (optional) = fraction of current in a filament (for parallel fils) OUTPUT: M = matrix of mutuals from set filcs1 to set filcs2 of conductors [H] RESTRICTIONS: METHOD: Calls mut_fil_fil if the fils are different and self_filDH if same","title":"Basic Information"},{"location":"function-guide/3d/mut_filcs2filcs_m/#dependencies","text":"mut_fil_fil self_filDH","title":"Dependencies"},{"location":"function-guide/3d/mut_fine_fil_m/","text":"mut_fine_fil.m \u00b6 Basic Information \u00b6 SYNTAX: mutuals = mut_fine_fil(acoil_data,bfils,nrecta) PURPOSE: Compute mutual inductance from a set of axisymmetric conductors to a set of straight line (filc) conductors. Filament conductors (identified by setting dR=dZ=0 in acoil_data) are allowed. INPUT: acoil_data = data describing geometry of coil set A Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. bfilcs is a cell array of conductors. Each cell has segments in rows and 6 columns [x y z dx dy dz] for center and vector of each segment. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (Henries) RESTRICTIONS: METHOD: Each conductor in set A is partitioned into a bunch of tiny rectangles. Flux through B is line integrated vector potential from A. Dependencies \u00b6 bld_subelements","title":"mut_fine_fil.m"},{"location":"function-guide/3d/mut_fine_fil_m/#mut_fine_film","text":"","title":"mut_fine_fil.m"},{"location":"function-guide/3d/mut_fine_fil_m/#basic-information","text":"SYNTAX: mutuals = mut_fine_fil(acoil_data,bfils,nrecta) PURPOSE: Compute mutual inductance from a set of axisymmetric conductors to a set of straight line (filc) conductors. Filament conductors (identified by setting dR=dZ=0 in acoil_data) are allowed. INPUT: acoil_data = data describing geometry of coil set A Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. bfilcs is a cell array of conductors. Each cell has segments in rows and 6 columns [x y z dx dy dz] for center and vector of each segment. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (Henries) RESTRICTIONS: METHOD: Each conductor in set A is partitioned into a bunch of tiny rectangles. Flux through B is line integrated vector potential from A.","title":"Basic Information"},{"location":"function-guide/3d/mut_fine_fil_m/#dependencies","text":"bld_subelements","title":"Dependencies"},{"location":"function-guide/3d/mut_paths2paths_m/","text":"mut_paths2paths.m \u00b6 Basic Information \u00b6 SYNTAX: mut = mut_paths2paths(Paths1,Paths2) PURPOSE: INPUTS: Paths1,Paths2 = {npaths,1} cell arrays of (nfils,6) matrices specifying paths in two circuits. OR either or both can be a *single* path, described by a filament *array* OUTPUTS: mut = (npaths1,npaths2) mutual inductance matrix from all paths in Paths2 to all paths in Paths1 (all equally weighted). [H] RESTRICTIONS: Assumes none of the paths in Paths1 overlap any of the paths in Paths2 (to handle the case when, for example, Paths1=Paths2, use function self_paths.m) NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD: Calls mut_fil_fil.m Dependencies \u00b6 mut_fil_fil","title":"mut_paths2paths.m"},{"location":"function-guide/3d/mut_paths2paths_m/#mut_paths2pathsm","text":"","title":"mut_paths2paths.m"},{"location":"function-guide/3d/mut_paths2paths_m/#basic-information","text":"SYNTAX: mut = mut_paths2paths(Paths1,Paths2) PURPOSE: INPUTS: Paths1,Paths2 = {npaths,1} cell arrays of (nfils,6) matrices specifying paths in two circuits. OR either or both can be a *single* path, described by a filament *array* OUTPUTS: mut = (npaths1,npaths2) mutual inductance matrix from all paths in Paths2 to all paths in Paths1 (all equally weighted). [H] RESTRICTIONS: Assumes none of the paths in Paths1 overlap any of the paths in Paths2 (to handle the case when, for example, Paths1=Paths2, use function self_paths.m) NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD: Calls mut_fil_fil.m","title":"Basic Information"},{"location":"function-guide/3d/mut_paths2paths_m/#dependencies","text":"mut_fil_fil","title":"Dependencies"},{"location":"function-guide/3d/mut_rec2recOLD_m/","text":"mut_rec2recOLD.m \u00b6 Basic Information \u00b6 SYNTAX: mut = mut_rec2rec(zs,thetas,rs,dzs,dthetas,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical geometry. INPUTS: zs = vector of z (axial) positions of frame *centers* [m] thetas = vector of theta (angular) positions of frame centers [rad] rs = vector of r (radial) positions of *axial legs* [m] dzs = vector of \"widths\" of frames [m] dthetas = vector of angular-extents of frames [rad] Note that this just defines the locations of the axial legs... The \"theta\" legs are still straight lines connecting the ends of the axial legs. nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator). Dependencies \u00b6 pts_to_fil fil_regrid fil_to_filc mut_fil_fil","title":"mut_rec2recOLD.m"},{"location":"function-guide/3d/mut_rec2recOLD_m/#mut_rec2recoldm","text":"","title":"mut_rec2recOLD.m"},{"location":"function-guide/3d/mut_rec2recOLD_m/#basic-information","text":"SYNTAX: mut = mut_rec2rec(zs,thetas,rs,dzs,dthetas,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical geometry. INPUTS: zs = vector of z (axial) positions of frame *centers* [m] thetas = vector of theta (angular) positions of frame centers [rad] rs = vector of r (radial) positions of *axial legs* [m] dzs = vector of \"widths\" of frames [m] dthetas = vector of angular-extents of frames [rad] Note that this just defines the locations of the axial legs... The \"theta\" legs are still straight lines connecting the ends of the axial legs. nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator).","title":"Basic Information"},{"location":"function-guide/3d/mut_rec2recOLD_m/#dependencies","text":"pts_to_fil fil_regrid fil_to_filc mut_fil_fil","title":"Dependencies"},{"location":"function-guide/3d/mut_rec2recX_m/","text":"mut_rec2recX.m \u00b6 Basic Information \u00b6 SYNTAX: mut = mut_rec2rec(zphis,thetas,rs,tilts,dzphis,hs, ... Rref,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical or toroidal geometry (with straight legs parallel to axial or toroidal direction respectively but not necessarily at same minor or major radius). INPUTS: (vectors are all 1x2) zphis = vector of z (axial) (OR phi=toroidal angle) positions of frame *centers*. If Rref=0, zphis specifies z positions. If Rref=1, zphis specifies phi toroidal angles. [m if z, rad if phi] thetas = vector of theta (angular) positions of frame centers [rad] (absolute cylindrical angle if Rref=0, or poloidal angle relative to the major axis of the torus at R=Rref for Rref~=0) rs = vector of r (minor radial) positions of frame centers for Rref=0, or R (major radial) positions of frame centers for Rref~=0 [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to minor radius if Rref=0, or relative to major radius R if Rref~=0 [rad] (If Rref=0, when coil frame is tangent to cyl the tilt = 0) (If Rref~=0, when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames (linear width in [m] for Rref=0 and angular width dphi in [rad] for Rref~=0) hs = vector of full heights of frames [m] Rref = (opt) Reference major radius for toroidal case AND flag to specify whether cylindrical (=0, default) or toroidal (NOT =0) (units of [m] in toroidal case, and used only as flag in cylindrical) (def = 0) nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator). For cylindrical geometry, r,theta plane in this code correspond to x,y plane in mut_fil_fil, and z = z (axial direction of cylinder). For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles. Dependencies \u00b6 fil_regrid mut_fil_fil fil_to_filc pts_to_fil","title":"mut_rec2recX.m"},{"location":"function-guide/3d/mut_rec2recX_m/#mut_rec2recxm","text":"","title":"mut_rec2recX.m"},{"location":"function-guide/3d/mut_rec2recX_m/#basic-information","text":"SYNTAX: mut = mut_rec2rec(zphis,thetas,rs,tilts,dzphis,hs, ... Rref,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical or toroidal geometry (with straight legs parallel to axial or toroidal direction respectively but not necessarily at same minor or major radius). INPUTS: (vectors are all 1x2) zphis = vector of z (axial) (OR phi=toroidal angle) positions of frame *centers*. If Rref=0, zphis specifies z positions. If Rref=1, zphis specifies phi toroidal angles. [m if z, rad if phi] thetas = vector of theta (angular) positions of frame centers [rad] (absolute cylindrical angle if Rref=0, or poloidal angle relative to the major axis of the torus at R=Rref for Rref~=0) rs = vector of r (minor radial) positions of frame centers for Rref=0, or R (major radial) positions of frame centers for Rref~=0 [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to minor radius if Rref=0, or relative to major radius R if Rref~=0 [rad] (If Rref=0, when coil frame is tangent to cyl the tilt = 0) (If Rref~=0, when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames (linear width in [m] for Rref=0 and angular width dphi in [rad] for Rref~=0) hs = vector of full heights of frames [m] Rref = (opt) Reference major radius for toroidal case AND flag to specify whether cylindrical (=0, default) or toroidal (NOT =0) (units of [m] in toroidal case, and used only as flag in cylindrical) (def = 0) nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator). For cylindrical geometry, r,theta plane in this code correspond to x,y plane in mut_fil_fil, and z = z (axial direction of cylinder). For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"Basic Information"},{"location":"function-guide/3d/mut_rec2recX_m/#dependencies","text":"fil_regrid mut_fil_fil fil_to_filc pts_to_fil","title":"Dependencies"},{"location":"function-guide/3d/mut_rec2rec_m/","text":"mut_rec2rec.m \u00b6 Basic Information \u00b6 SYNTAX: mut = mut_rec2rec(zphis,thetas,rs,tilts,dzphis,hs, ... Rref,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical or toroidal geometry (with straight legs parallel to axial or toroidal direction respectively but not necessarily at same minor or major radius). INPUTS: (vectors are all 1x2) zphis = vector of z (axial) (OR phi=toroidal angle) positions of frame *centers*. If Rref=0, zphis specifies z positions. If Rref=1, zphis specifies phi toroidal angles. [m if z, rad if phi] thetas = vector of theta (angular) positions of frame centers [rad] (absolute cylindrical angle if Rref=0, or poloidal angle relative to the major axis of the torus at R=Rref for Rref~=0) rs = vector of r (minor radial) positions of frame centers for Rref=0, or R (major radial) positions of frame centers for Rref~=0 [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to minor radius if Rref=0, or relative to major radius R if Rref~=0 [rad] (If Rref=0, when coil frame is tangent to cyl the tilt = 0) (If Rref~=0, when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames (linear width in [m] for Rref=0 and angular width dphi in [rad] for Rref~=0) hs = vector of full heights of frames [m] Rref = (opt) Reference major radius for toroidal case AND flag to specify whether cylindrical (=0, default) or toroidal (NOT =0) (units of [m] in toroidal case, and used only as flag in cylindrical) (def = 0) nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator). For cylindrical geometry, r,theta plane in this code correspond to x,y plane in mut_fil_fil, and z = z (axial direction of cylinder). For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles. Dependencies \u00b6 fil_regrid mut_fil_fil fil_to_filc pts_to_fil","title":"mut_rec2rec.m"},{"location":"function-guide/3d/mut_rec2rec_m/#mut_rec2recm","text":"","title":"mut_rec2rec.m"},{"location":"function-guide/3d/mut_rec2rec_m/#basic-information","text":"SYNTAX: mut = mut_rec2rec(zphis,thetas,rs,tilts,dzphis,hs, ... Rref,nfils,iplot) PURPOSE: Calculate mutuals between 2 rectangular picture frame coils in cylindrical or toroidal geometry (with straight legs parallel to axial or toroidal direction respectively but not necessarily at same minor or major radius). INPUTS: (vectors are all 1x2) zphis = vector of z (axial) (OR phi=toroidal angle) positions of frame *centers*. If Rref=0, zphis specifies z positions. If Rref=1, zphis specifies phi toroidal angles. [m if z, rad if phi] thetas = vector of theta (angular) positions of frame centers [rad] (absolute cylindrical angle if Rref=0, or poloidal angle relative to the major axis of the torus at R=Rref for Rref~=0) rs = vector of r (minor radial) positions of frame centers for Rref=0, or R (major radial) positions of frame centers for Rref~=0 [m] tilts = angle made by normal vector to picture frame (generated by right hand rule from coil current) rel to minor radius if Rref=0, or relative to major radius R if Rref~=0 [rad] (If Rref=0, when coil frame is tangent to cyl the tilt = 0) (If Rref~=0, when coil frame is *vertical* the tilt = 0) dzphis = vector of full widths of frames (linear width in [m] for Rref=0 and angular width dphi in [rad] for Rref~=0) hs = vector of full heights of frames [m] Rref = (opt) Reference major radius for toroidal case AND flag to specify whether cylindrical (=0, default) or toroidal (NOT =0) (units of [m] in toroidal case, and used only as flag in cylindrical) (def = 0) nfils = (opt) vec of # of sub-filaments to split legs into (def=10) iplot = (opt) if =1, plot 3D geometry (def=0) OUTPUTS: mut = mutual inductance [uH] RESTRICTIONS: Presently set up for only 2 coils... METHOD: Uses Jim Leuer's mut_fil_fil.m (3d filamentary segment to filamentary segment mutual calculator). For cylindrical geometry, r,theta plane in this code correspond to x,y plane in mut_fil_fil, and z = z (axial direction of cylinder). For toroidal geometry, r,phi in this code correspond to x,y plane in mut_fil_fil (which is the plane defined by major radius and toroidal angle phi in torus), and theta is poloidal angle in tokamak convention. The z direction is thus the same as the usual convention for tokamak geometry: poloidal, or \"vertical\" z. Rref is used as ref major radius of torus for applying poloidal angles.","title":"Basic Information"},{"location":"function-guide/3d/mut_rec2rec_m/#dependencies","text":"fil_regrid mut_fil_fil fil_to_filc pts_to_fil","title":"Dependencies"},{"location":"function-guide/3d/plot_fils_m/","text":"plot_fils.m \u00b6 Basic Information \u00b6 SYNTAX: h = plot_fils(fils,clstr,lw,frac) PURPOSE: Plot filaments in standard filament specification matrix (npts,6): [x1,y1,z1,x2,y2,z2] INPUTS: fils = filament specification matrix (npts,6): [x1,y1,z1,x2,y2,z2] (or cell with several (npts,6) elements) clstr = (optional) color/linetype string (def= 'g' for green/solid) lw = (optional) linewidth (def=4) frac = (optional) scale factor, must have same number of rows as fils segments with frac>0 are plotted green and frac<0 are plotted red); OUTPUTS: h = figure handle Dependencies \u00b6","title":"plot_fils.m"},{"location":"function-guide/3d/plot_fils_m/#plot_filsm","text":"","title":"plot_fils.m"},{"location":"function-guide/3d/plot_fils_m/#basic-information","text":"SYNTAX: h = plot_fils(fils,clstr,lw,frac) PURPOSE: Plot filaments in standard filament specification matrix (npts,6): [x1,y1,z1,x2,y2,z2] INPUTS: fils = filament specification matrix (npts,6): [x1,y1,z1,x2,y2,z2] (or cell with several (npts,6) elements) clstr = (optional) color/linetype string (def= 'g' for green/solid) lw = (optional) linewidth (def=4) frac = (optional) scale factor, must have same number of rows as fils segments with frac>0 are plotted green and frac<0 are plotted red); OUTPUTS: h = figure handle","title":"Basic Information"},{"location":"function-guide/3d/plot_fils_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/3d/self_barDH_m/","text":"self_barDH.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the self inductance of a set of bars A Bar is defined by center and deltas x= [xc,yc,zc,dx,dy,dz] and perimeters, pa, which is all that is needed to compute self inductance. self_bar is related to self_fil which computes self inductance of filament set. Cross-inductances are calculated as filaments using fil_a; only diagonals (and thus single bars) have self inductances calculated as bars. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_barDH(xa,pa,fa,full) INPUT: xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] pa = Perimeters of bars for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of bar A sets [H] RESTRICTIONS: CAUTION: Filament perimeter pa cannot be zero METHOD: Uses AIP handbook expression for self inductance of rectangular X-sect bar: Dependencies \u00b6 z_dircos fil_a","title":"self_barDH.m"},{"location":"function-guide/3d/self_barDH_m/#self_bardhm","text":"","title":"self_barDH.m"},{"location":"function-guide/3d/self_barDH_m/#basic-information","text":"PURPOSE: Calculate the self inductance of a set of bars A Bar is defined by center and deltas x= [xc,yc,zc,dx,dy,dz] and perimeters, pa, which is all that is needed to compute self inductance. self_bar is related to self_fil which computes self inductance of filament set. Cross-inductances are calculated as filaments using fil_a; only diagonals (and thus single bars) have self inductances calculated as bars. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_barDH(xa,pa,fa,full) INPUT: xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] pa = Perimeters of bars for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of bar A sets [H] RESTRICTIONS: CAUTION: Filament perimeter pa cannot be zero METHOD: Uses AIP handbook expression for self inductance of rectangular X-sect bar:","title":"Basic Information"},{"location":"function-guide/3d/self_barDH_m/#dependencies","text":"z_dircos fil_a","title":"Dependencies"},{"location":"function-guide/3d/self_filDH_m/","text":"self_filDH.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,aa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero Dependencies \u00b6 z_dircos fil_a","title":"self_filDH.m"},{"location":"function-guide/3d/self_filDH_m/#self_fildhm","text":"","title":"self_filDH.m"},{"location":"function-guide/3d/self_filDH_m/#basic-information","text":"PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,aa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero","title":"Basic Information"},{"location":"function-guide/3d/self_filDH_m/#dependencies","text":"z_dircos fil_a","title":"Dependencies"},{"location":"function-guide/3d/self_fil_m/","text":"self_fil.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero Dependencies \u00b6 fil_regrid mut_fil_fil fil_a z_dircos fil_to_filc pts_to_fil","title":"self_fil.m"},{"location":"function-guide/3d/self_fil_m/#self_film","text":"","title":"self_fil.m"},{"location":"function-guide/3d/self_fil_m/#basic-information","text":"PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero","title":"Basic Information"},{"location":"function-guide/3d/self_fil_m/#dependencies","text":"fil_regrid mut_fil_fil fil_a z_dircos fil_to_filc pts_to_fil","title":"Dependencies"},{"location":"function-guide/3d/self_paths_m/","text":"self_paths.m \u00b6 Basic Information \u00b6 SYNTAX: selfind = self_paths(Paths,as) PURPOSE: INPUTS: Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit for which want self inductance. as = (npaths,1) vector of minor radii corr to each path [m] OUTPUTS: selfind = (npaths,npaths) mutual inductance *matrix* from all paths in Paths to all paths in Paths (all equally weighted). Actual self inductance calculated for diagonals (coincident paths). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD: Dependencies \u00b6 mut_fil_fil self_fil","title":"self_paths.m"},{"location":"function-guide/3d/self_paths_m/#self_pathsm","text":"","title":"self_paths.m"},{"location":"function-guide/3d/self_paths_m/#basic-information","text":"SYNTAX: selfind = self_paths(Paths,as) PURPOSE: INPUTS: Paths = {npaths,1} cell array of (nfils,6) matrices specifying paths in circuit for which want self inductance. as = (npaths,1) vector of minor radii corr to each path [m] OUTPUTS: selfind = (npaths,npaths) mutual inductance *matrix* from all paths in Paths to all paths in Paths (all equally weighted). Actual self inductance calculated for diagonals (coincident paths). [H] RESTRICTIONS: NOTE WELL: Paths matrices MUST be in FILC format!!!! (ie use fil_to_filc *first* before calling this function...) METHOD:","title":"Basic Information"},{"location":"function-guide/3d/self_paths_m/#dependencies","text":"mut_fil_fil self_fil","title":"Dependencies"},{"location":"function-guide/GAcontrol/CTinpstuff_m/","text":"CTinpstuff.m \u00b6 Basic Information \u00b6 SYNTAX: [numxinp,ndf,inppoint,names,namelen,maxlen,err] = CTinpstuff(inputvar); PURPOSE: May be able to use ordinary inpstuff.m (belongs to mutools) INPUT: inputvar = string with the name of the inputs to the global system OUTPUT: numxinp = number of total inputs (addition of the input channels of all the different inputs) ndf = number of different inputs inppoint = Each row corresponds to each different input [starting point of channels, number of channels] names = names of the input namelen = length of input names maxlen = maximum length of the input names err = error alert Dependencies \u00b6","title":"CTinpstuff.m"},{"location":"function-guide/GAcontrol/CTinpstuff_m/#ctinpstuffm","text":"","title":"CTinpstuff.m"},{"location":"function-guide/GAcontrol/CTinpstuff_m/#basic-information","text":"SYNTAX: [numxinp,ndf,inppoint,names,namelen,maxlen,err] = CTinpstuff(inputvar); PURPOSE: May be able to use ordinary inpstuff.m (belongs to mutools) INPUT: inputvar = string with the name of the inputs to the global system OUTPUT: numxinp = number of total inputs (addition of the input channels of all the different inputs) ndf = number of different inputs inppoint = Each row corresponds to each different input [starting point of channels, number of channels] names = names of the input namelen = length of input names maxlen = maximum length of the input names err = error alert","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTinpstuff_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/CTnamstuff_m/","text":"CTnamstuff.m \u00b6 Basic Information \u00b6 SYNTAX: [numsys,names,namelen,maxlen] = CTnamstuff(systemnames); PURPOSE: May be able to use ordinary namstuff.m (belongs to mutools) INPUT: systemnames = string with the names of the different systems OUTPUT: numsys = number of systems names = names of systems namelen = length of system names maxlen = maximum length of the system names Dependencies \u00b6","title":"CTnamstuff.m"},{"location":"function-guide/GAcontrol/CTnamstuff_m/#ctnamstuffm","text":"","title":"CTnamstuff.m"},{"location":"function-guide/GAcontrol/CTnamstuff_m/#basic-information","text":"SYNTAX: [numsys,names,namelen,maxlen] = CTnamstuff(systemnames); PURPOSE: May be able to use ordinary namstuff.m (belongs to mutools) INPUT: systemnames = string with the names of the different systems OUTPUT: numsys = number of systems names = names of systems namelen = length of system names maxlen = maximum length of the system names","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTnamstuff_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/CTpass1_m/","text":"CTpass1.m \u00b6 Basic Information \u00b6 SYNTAX: [arraydata,arraylen,err] = pass1(var) PURPOSE: Parses a string of semicolon separated tokens into array of individual token strings. INPUT: var = string variable containing semicolon separated tokens OUTPUT: arraydata = array of tokens which were separated by semicolons in var arraylen = vector of lengths of token strings in arraydata err = error code, if 0 everything is OK Dependencies \u00b6","title":"CTpass1.m"},{"location":"function-guide/GAcontrol/CTpass1_m/#ctpass1m","text":"","title":"CTpass1.m"},{"location":"function-guide/GAcontrol/CTpass1_m/#basic-information","text":"SYNTAX: [arraydata,arraylen,err] = pass1(var) PURPOSE: Parses a string of semicolon separated tokens into array of individual token strings. INPUT: var = string variable containing semicolon separated tokens OUTPUT: arraydata = array of tokens which were separated by semicolons in var arraylen = vector of lengths of token strings in arraydata err = error code, if 0 everything is OK","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTpass1_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/CTpass2_m/","text":"CTpass2.m \u00b6 Basic Information \u00b6 SYNTAX: [od,odl,fromsys,gains,er] = ... CTpass2(tokidx,strtok,toklens,names,namelens,sysd) PURPOSE: This works on the data between colons on a INPUT_TO_SYS, determining which system the outputs come from (FROMSYS), which particular outputs (OD), and the scalar gain (GAINS). INPUT: tokidx = index into array strtok defining token to work on(?) strtok = array containing string tokens (parsed by CTpass1) toklens = length of strings in each entry of strtok names = array of system names namelens = length of string for each entry in names sysdata = matrix defining number of states, outputs, inputs for each system listed in names OUTPUT: od odl fromsys = system from which ... gains er = error code, if 0 then everything is OK Dependencies \u00b6","title":"CTpass2.m"},{"location":"function-guide/GAcontrol/CTpass2_m/#ctpass2m","text":"","title":"CTpass2.m"},{"location":"function-guide/GAcontrol/CTpass2_m/#basic-information","text":"SYNTAX: [od,odl,fromsys,gains,er] = ... CTpass2(tokidx,strtok,toklens,names,namelens,sysd) PURPOSE: This works on the data between colons on a INPUT_TO_SYS, determining which system the outputs come from (FROMSYS), which particular outputs (OD), and the scalar gain (GAINS). INPUT: tokidx = index into array strtok defining token to work on(?) strtok = array containing string tokens (parsed by CTpass1) toklens = length of strings in each entry of strtok names = array of system names namelens = length of string for each entry in names sysdata = matrix defining number of states, outputs, inputs for each system listed in names OUTPUT: od odl fromsys = system from which ... gains er = error code, if 0 then everything is OK","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTpass2_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/CTpass3_m/","text":"CTpass3.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: INPUT: j od odl OUTPUT: out err Dependencies \u00b6","title":"CTpass3.m"},{"location":"function-guide/GAcontrol/CTpass3_m/#ctpass3m","text":"","title":"CTpass3.m"},{"location":"function-guide/GAcontrol/CTpass3_m/#basic-information","text":"SYNTAX: PURPOSE: INPUT: j od odl OUTPUT: out err","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTpass3_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/CTsysbal_m/","text":"CTsysbal.m \u00b6 Basic Information \u00b6 SYNTAX: function [sysout,sig] = sysbal(sys,tol) PURPOSE: Finds a truncated balanced realization of the system state-space model. Eigenvalues of A must have negative real part. The result is truncated to retain all Hankel- singular values greater than TOL. If TOL is omitted then it is set to max(sig(1)*1.0E-12,1.0E-16). INPUT: sys = tol = OUTPUT: sysout = sig = RESTRICTIONS: The systems are expressed in Control Toolbox format. METHOD: WRITTEN BY: Eugenio Schuster ON 8/3/02 Dependencies \u00b6","title":"CTsysbal.m"},{"location":"function-guide/GAcontrol/CTsysbal_m/#ctsysbalm","text":"","title":"CTsysbal.m"},{"location":"function-guide/GAcontrol/CTsysbal_m/#basic-information","text":"SYNTAX: function [sysout,sig] = sysbal(sys,tol) PURPOSE: Finds a truncated balanced realization of the system state-space model. Eigenvalues of A must have negative real part. The result is truncated to retain all Hankel- singular values greater than TOL. If TOL is omitted then it is set to max(sig(1)*1.0E-12,1.0E-16). INPUT: sys = tol = OUTPUT: sysout = sig = RESTRICTIONS: The systems are expressed in Control Toolbox format. METHOD: WRITTEN BY: Eugenio Schuster ON 8/3/02","title":"Basic Information"},{"location":"function-guide/GAcontrol/CTsysbal_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/Hanus_cntlr2_m/","text":"Hanus_cntlr2.m \u00b6 Basic Information \u00b6 SYNTAX: [AH,BH,CH,DH] = Hanus_cntlr2(Ac,Bc,Cc,Dc,refcols,meascols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. This version is different from the original in that inputs keep their same order. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous refcols = columns of input matrices (Bc,Dc) corresp. to references meascols = columns of input matrices (Bc,Dc) corresp. to measurements OUTPUT: AH,BH,CH,DH = Hanus controller RESTRICTIONS: This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987 Dependencies \u00b6","title":"Hanus_cntlr2.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr2_m/#hanus_cntlr2m","text":"","title":"Hanus_cntlr2.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr2_m/#basic-information","text":"SYNTAX: [AH,BH,CH,DH] = Hanus_cntlr2(Ac,Bc,Cc,Dc,refcols,meascols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. This version is different from the original in that inputs keep their same order. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous refcols = columns of input matrices (Bc,Dc) corresp. to references meascols = columns of input matrices (Bc,Dc) corresp. to measurements OUTPUT: AH,BH,CH,DH = Hanus controller RESTRICTIONS: This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987","title":"Basic Information"},{"location":"function-guide/GAcontrol/Hanus_cntlr2_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/Hanus_cntlr_m/","text":"Hanus_cntlr.m \u00b6 Basic Information \u00b6 SYNTAX: [AH,BH,CH,DH,Cr,Dr,Dinv] = Hanus_cntlr(Ac,Bc,Cc,Dc,refcols,meascols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous refcols = columns of input matrices (Bc,Dc) corresp. to references meascols = columns of input matrices (Bc,Dc) corresp. to measurements OUTPUT: AH,BH,CH,DH = Hanus controller system description Cr,Dr = output matrices which compute realizable reference (realizable ref.= Cr*[cntlr state] + Dr*[cntlr inputs] Note: no matter where reference signal comes into input controller, Hanus controller arranges inputs as [measurements, references, limited outputs] RESTRICTIONS: This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987 Dependencies \u00b6","title":"Hanus_cntlr.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr_m/#hanus_cntlrm","text":"","title":"Hanus_cntlr.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr_m/#basic-information","text":"SYNTAX: [AH,BH,CH,DH,Cr,Dr,Dinv] = Hanus_cntlr(Ac,Bc,Cc,Dc,refcols,meascols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous refcols = columns of input matrices (Bc,Dc) corresp. to references meascols = columns of input matrices (Bc,Dc) corresp. to measurements OUTPUT: AH,BH,CH,DH = Hanus controller system description Cr,Dr = output matrices which compute realizable reference (realizable ref.= Cr*[cntlr state] + Dr*[cntlr inputs] Note: no matter where reference signal comes into input controller, Hanus controller arranges inputs as [measurements, references, limited outputs] RESTRICTIONS: This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987","title":"Basic Information"},{"location":"function-guide/GAcontrol/Hanus_cntlr_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/Hanus_cntlr_rev1_m/","text":"Hanus_cntlr_rev1.m \u00b6 Basic Information \u00b6 SYNTAX: [AH,BH,CH,DH,Cr,Dr,D1inv] = Hanus_cntlr(Ac,Bc,Cc,Dc,rcols,mcols,scols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous rcols = columns of input matrices (Bc,Dc) corresp. to references mcols = columns of input matrices (Bc,Dc) corresp. to measurements scols = columns of input matrices (Bc,Dc) corresp. to chosen subblock (scols must = first noutputs columns of Dc, where noutputs = number of outputs) OUTPUT: AH,BH,CH,DH = Hanus controller system description Cr,Dr = output matrices which compute realizable reference (realizable ref.= Cr*[cntlr state] + Dr*[cntlr inputs] Note: no matter where reference signal comes into input controller, Hanus controller arranges inputs as [measurements, references, limited outputs] RESTRICTIONS: This version is experimental. It inverts a square subblock of the full D matrix chosen by the user. Explain why somewhere.... Right now, only works for Dc which has more columns than rows, and scols must be first set of colums in Dc. This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987 Dependencies \u00b6","title":"Hanus_cntlr_rev1.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr_rev1_m/#hanus_cntlr_rev1m","text":"","title":"Hanus_cntlr_rev1.m"},{"location":"function-guide/GAcontrol/Hanus_cntlr_rev1_m/#basic-information","text":"SYNTAX: [AH,BH,CH,DH,Cr,Dr,D1inv] = Hanus_cntlr(Ac,Bc,Cc,Dc,rcols,mcols,scols) PURPOSE: Convert controller to Hanus conditioned controller. This provides a means to eliminate anti-windup when output of the controller is limited in a known or measurable manner (e.g. by saturation). Constructed controller contains extra inputs for the signals representing the limited controller output. INPUT: Ac,Bc,Cc,Dc = controller to convert - either digital or continuous rcols = columns of input matrices (Bc,Dc) corresp. to references mcols = columns of input matrices (Bc,Dc) corresp. to measurements scols = columns of input matrices (Bc,Dc) corresp. to chosen subblock (scols must = first noutputs columns of Dc, where noutputs = number of outputs) OUTPUT: AH,BH,CH,DH = Hanus controller system description Cr,Dr = output matrices which compute realizable reference (realizable ref.= Cr*[cntlr state] + Dr*[cntlr inputs] Note: no matter where reference signal comes into input controller, Hanus controller arranges inputs as [measurements, references, limited outputs] RESTRICTIONS: This version is experimental. It inverts a square subblock of the full D matrix chosen by the user. Explain why somewhere.... Right now, only works for Dc which has more columns than rows, and scols must be first set of colums in Dc. This function only works on controllers Ac,Bc,Cc,Dc which feed references and measurements into controller separately. (I.e. NOT error feedback controllers.) Also, although theory predicts resulting controller should work for both continous and discrete controllers, I've only been able to make it work for discrete. METHOD: See R.Hanus, M.Kinnaert, J.L.Henrotte, \"Conditioning Technique, a General Anti-Windup and Bumpless Transfer Method\", Automatica, v.23, no.6, pp. 729-739,1987","title":"Basic Information"},{"location":"function-guide/GAcontrol/Hanus_cntlr_rev1_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/MRC_m/","text":"MRC.m \u00b6 Basic Information \u00b6 SYNTAX: controller = MRC(plant,ref_model) PURPOSE: Model reference control calculation. Given a model of the plant and a model of the desired closed loop response, compute a feedback controller that gives that closed loop response. This code has been tested, but not extensively. INPUT: plant = SISO model of plant (Control Toolbox format) ref_model = SISO model of desired response (Control Toolbox format) OUTPUT: controller = derived controller in (CT format): inputs = [ref, measured], output = input to plant RESTRICTIONS: plant: Must be stable with no (closed) right half plane zeros. ref_model: Must be stable with no (closed) right half plane zeros and same relative degree as plant. METHOD: Based on algorithm for Model Reference Control in W.S.Levine, The Control Handbook, CRC press, 1996 Dependencies \u00b6 wait compare_systems","title":"MRC.m"},{"location":"function-guide/GAcontrol/MRC_m/#mrcm","text":"","title":"MRC.m"},{"location":"function-guide/GAcontrol/MRC_m/#basic-information","text":"SYNTAX: controller = MRC(plant,ref_model) PURPOSE: Model reference control calculation. Given a model of the plant and a model of the desired closed loop response, compute a feedback controller that gives that closed loop response. This code has been tested, but not extensively. INPUT: plant = SISO model of plant (Control Toolbox format) ref_model = SISO model of desired response (Control Toolbox format) OUTPUT: controller = derived controller in (CT format): inputs = [ref, measured], output = input to plant RESTRICTIONS: plant: Must be stable with no (closed) right half plane zeros. ref_model: Must be stable with no (closed) right half plane zeros and same relative degree as plant. METHOD: Based on algorithm for Model Reference Control in W.S.Levine, The Control Handbook, CRC press, 1996","title":"Basic Information"},{"location":"function-guide/GAcontrol/MRC_m/#dependencies","text":"wait compare_systems","title":"Dependencies"},{"location":"function-guide/GAcontrol/analyze_Xpt_m/","text":"analyze_Xpt.m \u00b6 Basic Information \u00b6 SYNTAX: [rxpt,zxpt,figure_num] = ... analyze_Xpt(Psi0,BR0,BZ0,rgrid,zgrid,figure_num) PURPOSE: Locate X point using B-field on Xpoint grid. Optionally, make plots of flux and field with X point overlaid. INPUT: Psi0,BR0,BZ0 rgrid,zgrid figure_num = (optional, default = [] and no figures produced) OUTPUT: rxpt,zxpt = calculated x point (meters) Dependencies \u00b6 find_x_point","title":"analyze_Xpt.m"},{"location":"function-guide/GAcontrol/analyze_Xpt_m/#analyze_xptm","text":"","title":"analyze_Xpt.m"},{"location":"function-guide/GAcontrol/analyze_Xpt_m/#basic-information","text":"SYNTAX: [rxpt,zxpt,figure_num] = ... analyze_Xpt(Psi0,BR0,BZ0,rgrid,zgrid,figure_num) PURPOSE: Locate X point using B-field on Xpoint grid. Optionally, make plots of flux and field with X point overlaid. INPUT: Psi0,BR0,BZ0 rgrid,zgrid figure_num = (optional, default = [] and no figures produced) OUTPUT: rxpt,zxpt = calculated x point (meters)","title":"Basic Information"},{"location":"function-guide/GAcontrol/analyze_Xpt_m/#dependencies","text":"find_x_point","title":"Dependencies"},{"location":"function-guide/GAcontrol/approx_B_m/","text":"approx_B.m \u00b6 Basic Information \u00b6 SYNTAX: [figure_num] = approx_B(Psi0,BR0,BZ0,rgrid,zgrid,figure_num) PURPOSE: Compare BR0 and BZ0 on X point grid with approximation derived from Psi0 on X point grid. INPUT: Psi0 = flux on X point grid BR0 = Br on X point grid BZ0 = Bz on X point grid rgrid = r coordinates of Xpoint grid zgrid = z coordinates of Xpoint grid figure_num = last figure plotted Psi0,BR0,BZ0 all stored in vector (length nrb*nzb) form OUTPUT: figure_num = last figure plotted (updated for figures produced here) RESTRICTIONS: ASSUMES grid intervals of 3 cm in both r and z. Dependencies \u00b6","title":"approx_B.m"},{"location":"function-guide/GAcontrol/approx_B_m/#approx_bm","text":"","title":"approx_B.m"},{"location":"function-guide/GAcontrol/approx_B_m/#basic-information","text":"SYNTAX: [figure_num] = approx_B(Psi0,BR0,BZ0,rgrid,zgrid,figure_num) PURPOSE: Compare BR0 and BZ0 on X point grid with approximation derived from Psi0 on X point grid. INPUT: Psi0 = flux on X point grid BR0 = Br on X point grid BZ0 = Bz on X point grid rgrid = r coordinates of Xpoint grid zgrid = z coordinates of Xpoint grid figure_num = last figure plotted Psi0,BR0,BZ0 all stored in vector (length nrb*nzb) form OUTPUT: figure_num = last figure plotted (updated for figures produced here) RESTRICTIONS: ASSUMES grid intervals of 3 cm in both r and z.","title":"Basic Information"},{"location":"function-guide/GAcontrol/approx_B_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/bodehz_m/","text":"bodehz.m \u00b6 Basic Information \u00b6 SYNTAX: [mag,phi,wout] = bodehz(a,b,c,d,iu,w) PURPOSE: Bode frequency response for continuous-time linear systems. BODE(A,B,C,D,IU) produces a Bode plot from the single input IU to all the outputs of the continuous state-space system (A,B,C,D). IU is an index into the inputs of the system and specifies which input to use for the Bode response. The frequency range and number of points are chosen automatically. INPUT: a,b,c,d = system matrices iu = input number w = frequencies at which to calculate/plot freq. response (Hz) OUTPUT: bode plot of system, frequency in Hz (if no outputs specified) mag = magnitude of gain phi = phase lag (degrees) wout = frequencies (Hz) of mag, phi RESTRICTIONS: METHOD: Uses matlab bode function (which has CRAPPY defaults) See Also \u00b6 dbodehz References \u00b6 User Guide Dependencies \u00b6 wait","title":"bodehz.m"},{"location":"function-guide/GAcontrol/bodehz_m/#bodehzm","text":"","title":"bodehz.m"},{"location":"function-guide/GAcontrol/bodehz_m/#basic-information","text":"SYNTAX: [mag,phi,wout] = bodehz(a,b,c,d,iu,w) PURPOSE: Bode frequency response for continuous-time linear systems. BODE(A,B,C,D,IU) produces a Bode plot from the single input IU to all the outputs of the continuous state-space system (A,B,C,D). IU is an index into the inputs of the system and specifies which input to use for the Bode response. The frequency range and number of points are chosen automatically. INPUT: a,b,c,d = system matrices iu = input number w = frequencies at which to calculate/plot freq. response (Hz) OUTPUT: bode plot of system, frequency in Hz (if no outputs specified) mag = magnitude of gain phi = phase lag (degrees) wout = frequencies (Hz) of mag, phi RESTRICTIONS: METHOD: Uses matlab bode function (which has CRAPPY defaults)","title":"Basic Information"},{"location":"function-guide/GAcontrol/bodehz_m/#see-also","text":"dbodehz","title":"See Also"},{"location":"function-guide/GAcontrol/bodehz_m/#references","text":"User Guide","title":"References"},{"location":"function-guide/GAcontrol/bodehz_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/GAcontrol/compare_sv_m/","text":"compare_sv.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: Make comparison plots of specified open-loop singular values vs. achieved open loop singular values in NCF design. INPUT: wtd_plant = weighted plant WR*G*WL controller = controller constructed by ncfsyn omega = frequencies (rad/sec) at which to evaluate singular values figure_num = current figure number OUTPUT: plots of singular values of specified vs achieved open-loop system new_figure = updated current figure number RESTRICTIONS: METHOD: WRITTEN BY: Mike Walker ON 11/22/96 Dependencies \u00b6 wait","title":"compare_sv.m"},{"location":"function-guide/GAcontrol/compare_sv_m/#compare_svm","text":"","title":"compare_sv.m"},{"location":"function-guide/GAcontrol/compare_sv_m/#basic-information","text":"SYNTAX: PURPOSE: Make comparison plots of specified open-loop singular values vs. achieved open loop singular values in NCF design. INPUT: wtd_plant = weighted plant WR*G*WL controller = controller constructed by ncfsyn omega = frequencies (rad/sec) at which to evaluate singular values figure_num = current figure number OUTPUT: plots of singular values of specified vs achieved open-loop system new_figure = updated current figure number RESTRICTIONS: METHOD: WRITTEN BY: Mike Walker ON 11/22/96","title":"Basic Information"},{"location":"function-guide/GAcontrol/compare_sv_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/GAcontrol/compare_systems_m/","text":"compare_systems.m \u00b6 Basic Information \u00b6 SYNTAX: [figure_num,mag1,phi1,mag2,phi2,f]= ... compare_systems(system1, system2, figure_num, f) PURPOSE: Compare input-output response of MIMO systems. Overlays bode plots of 2 MIMO systems, 1-input and 1-output at a time to see if they represent approximately the same input-output system. INPUT: system1 = first system, in Control Toolbox system format system2 = second system, in Control Toolbox system format figure_num = (optional) next figure number in sequence f = frequency points(Hz) to plot bode plots at (optional, default is f=w/(2*pi), with w calculated by bode function) OUTPUT: figure_num = next figure number in sequence mag1,phi1 = frequency response for system 1, last input being viewed mag2,phi2 = frequency response for system 2, last input being viewed f = frequencies (Hz) corresponding to magi, phii RESTRICTIONS: system1 and system2 must have the same number of inputs and the same number of outputs. Dependencies \u00b6 wait","title":"compare_systems.m"},{"location":"function-guide/GAcontrol/compare_systems_m/#compare_systemsm","text":"","title":"compare_systems.m"},{"location":"function-guide/GAcontrol/compare_systems_m/#basic-information","text":"SYNTAX: [figure_num,mag1,phi1,mag2,phi2,f]= ... compare_systems(system1, system2, figure_num, f) PURPOSE: Compare input-output response of MIMO systems. Overlays bode plots of 2 MIMO systems, 1-input and 1-output at a time to see if they represent approximately the same input-output system. INPUT: system1 = first system, in Control Toolbox system format system2 = second system, in Control Toolbox system format figure_num = (optional) next figure number in sequence f = frequency points(Hz) to plot bode plots at (optional, default is f=w/(2*pi), with w calculated by bode function) OUTPUT: figure_num = next figure number in sequence mag1,phi1 = frequency response for system 1, last input being viewed mag2,phi2 = frequency response for system 2, last input being viewed f = frequencies (Hz) corresponding to magi, phii RESTRICTIONS: system1 and system2 must have the same number of inputs and the same number of outputs.","title":"Basic Information"},{"location":"function-guide/GAcontrol/compare_systems_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/GAcontrol/controllability_m/","text":"controllability.m \u00b6 Basic Information \u00b6 SYNTAX: [CC,nn,perp] = controllability(a,b,c,d,figure_num) PURPOSE: Calculate controllability matrix of a system. INPUT: a,b,c,d = system matrices figure_num = figure number on which to plot singular values of CC (optional, plot is produced only if this number is given) OUTPUT: CC = controllability matrix nn = nullspace of CC' (Anything in nn cannot be reached by the system [a,b,c,d] - See Kailath, Example 2.5-1.) perp = perp of nullspace of CC = \"reachable subspace\" Dependencies \u00b6","title":"controllability.m"},{"location":"function-guide/GAcontrol/controllability_m/#controllabilitym","text":"","title":"controllability.m"},{"location":"function-guide/GAcontrol/controllability_m/#basic-information","text":"SYNTAX: [CC,nn,perp] = controllability(a,b,c,d,figure_num) PURPOSE: Calculate controllability matrix of a system. INPUT: a,b,c,d = system matrices figure_num = figure number on which to plot singular values of CC (optional, plot is produced only if this number is given) OUTPUT: CC = controllability matrix nn = nullspace of CC' (Anything in nn cannot be reached by the system [a,b,c,d] - See Kailath, Example 2.5-1.) perp = perp of nullspace of CC = \"reachable subspace\"","title":"Basic Information"},{"location":"function-guide/GAcontrol/controllability_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/dbodehz_m/","text":"dbodehz.m \u00b6 Basic Information \u00b6 SYNTAX: [mag,phi,wout] = dbodehz(a,b,c,d,dt,iu,w) PURPOSE: Bode frequency response for continuous-time linear systems. BODE(A,B,C,D,dt,IU) produces a Bode plot from the single input IU to all the outputs of the continuous state-space system (A,B,C,D). IU is an index into the inputs of the system and specifies which input to use for the Bode response. The frequency range and number of points are chosen automatically. INPUT: a,b,c,d = system matrices dt = sample time of discrete system iu = input number w = frequencies at which to calculate/plot freq. response (Hz) OUTPUT: bode plot of system, frequency in Hz mag = magnitude of gain phi = phase lag (degrees) wout = frequencies (Hz) of mag, phi RESTRICTIONS: METHOD: Uses matlab dbode function (which has CRAPPY defaults) See Also \u00b6 bodehz References \u00b6 User Guide Dependencies \u00b6 wait","title":"dbodehz.m"},{"location":"function-guide/GAcontrol/dbodehz_m/#dbodehzm","text":"","title":"dbodehz.m"},{"location":"function-guide/GAcontrol/dbodehz_m/#basic-information","text":"SYNTAX: [mag,phi,wout] = dbodehz(a,b,c,d,dt,iu,w) PURPOSE: Bode frequency response for continuous-time linear systems. BODE(A,B,C,D,dt,IU) produces a Bode plot from the single input IU to all the outputs of the continuous state-space system (A,B,C,D). IU is an index into the inputs of the system and specifies which input to use for the Bode response. The frequency range and number of points are chosen automatically. INPUT: a,b,c,d = system matrices dt = sample time of discrete system iu = input number w = frequencies at which to calculate/plot freq. response (Hz) OUTPUT: bode plot of system, frequency in Hz mag = magnitude of gain phi = phase lag (degrees) wout = frequencies (Hz) of mag, phi RESTRICTIONS: METHOD: Uses matlab dbode function (which has CRAPPY defaults)","title":"Basic Information"},{"location":"function-guide/GAcontrol/dbodehz_m/#see-also","text":"bodehz","title":"See Also"},{"location":"function-guide/GAcontrol/dbodehz_m/#references","text":"User Guide","title":"References"},{"location":"function-guide/GAcontrol/dbodehz_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/GAcontrol/final_states_m/","text":"final_states.m \u00b6 Basic Information \u00b6 SYNTAX: [x,y,resid] = final_states(A,B,C,D,u) PURPOSE: Compute final states for system with constant input u. INPUT: A,B,C,D = system matrices u = (constant) input vector OUTPUT: x = states of system y = steady state output with input u resid = residual error (LHS*x - RHS) Dependencies \u00b6","title":"final_states.m"},{"location":"function-guide/GAcontrol/final_states_m/#final_statesm","text":"","title":"final_states.m"},{"location":"function-guide/GAcontrol/final_states_m/#basic-information","text":"SYNTAX: [x,y,resid] = final_states(A,B,C,D,u) PURPOSE: Compute final states for system with constant input u. INPUT: A,B,C,D = system matrices u = (constant) input vector OUTPUT: x = states of system y = steady state output with input u resid = residual error (LHS*x - RHS)","title":"Basic Information"},{"location":"function-guide/GAcontrol/final_states_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/find_x_point_m/","text":"find_x_point.m \u00b6 Basic Information \u00b6 SYNTAX: [dr,dz,drm,dzm,px] = find_x_point(pe,bre,bze,brepr, ... bzepr,brepz,bzepz,rm,delta_r,delta_z,rsign,zsign) PURPOSE: Calculates X point location by linear expansion about a grid point in the X point grid. INPUT: pe = flux at expansion point bre = br at expansion point bze = bz at expansion point brepr = br at expansion point + one step in r bzepr = bz at expansion point + one step in r brepz = br at expansion point + one step in z bzepz = bz at expansion point + one step in z rm = r coordinate of expansion pt in meters delta_r = distance between X point grids in radial direction (m) delta_z = distance between X point grids in vertical direction (m) rsign = direction of one step in r zsign = direction of one step in z OUTPUT: dr,dz = displacement of X pt from expansion pt (units of grid spacings) drm,dzm = displacement of X point in meters px = estimated flux at the X point Dependencies \u00b6","title":"find_x_point.m"},{"location":"function-guide/GAcontrol/find_x_point_m/#find_x_pointm","text":"","title":"find_x_point.m"},{"location":"function-guide/GAcontrol/find_x_point_m/#basic-information","text":"SYNTAX: [dr,dz,drm,dzm,px] = find_x_point(pe,bre,bze,brepr, ... bzepr,brepz,bzepz,rm,delta_r,delta_z,rsign,zsign) PURPOSE: Calculates X point location by linear expansion about a grid point in the X point grid. INPUT: pe = flux at expansion point bre = br at expansion point bze = bz at expansion point brepr = br at expansion point + one step in r bzepr = bz at expansion point + one step in r brepz = br at expansion point + one step in z bzepz = bz at expansion point + one step in z rm = r coordinate of expansion pt in meters delta_r = distance between X point grids in radial direction (m) delta_z = distance between X point grids in vertical direction (m) rsign = direction of one step in r zsign = direction of one step in z OUTPUT: dr,dz = displacement of X pt from expansion pt (units of grid spacings) drm,dzm = displacement of X point in meters px = estimated flux at the X point","title":"Basic Information"},{"location":"function-guide/GAcontrol/find_x_point_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/gen_AW_m_m/","text":"gen_AW_m.m \u00b6 Basic Information \u00b6 SYNTAX: AW_m=gen_AW_m(Ad,Bd,c) PURPOSE: Generate antiwindup matrix, for bumpless transfer. INPUT: Ad, Bd = A,B matrices for A,B,C,D controller being switched to. c = number of powers of Ad to add for \"wind-on\". If c=-1, then c is computed using gamma=max(real(eig(Ad))) (must have |gamma|<1) (optional, default is c=size(Ad,1)) OUTPUT: AW_m = antiwindup matrix - apply to error at transition to \"wind-on\" the new controller Dependencies \u00b6","title":"gen_AW_m.m"},{"location":"function-guide/GAcontrol/gen_AW_m_m/#gen_aw_mm","text":"","title":"gen_AW_m.m"},{"location":"function-guide/GAcontrol/gen_AW_m_m/#basic-information","text":"SYNTAX: AW_m=gen_AW_m(Ad,Bd,c) PURPOSE: Generate antiwindup matrix, for bumpless transfer. INPUT: Ad, Bd = A,B matrices for A,B,C,D controller being switched to. c = number of powers of Ad to add for \"wind-on\". If c=-1, then c is computed using gamma=max(real(eig(Ad))) (must have |gamma|<1) (optional, default is c=size(Ad,1)) OUTPUT: AW_m = antiwindup matrix - apply to error at transition to \"wind-on\" the new controller","title":"Basic Information"},{"location":"function-guide/GAcontrol/gen_AW_m_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/improve_cond_m/","text":"improve_cond.m \u00b6 Basic Information \u00b6 SYNTAX: [T,condition] = improve_cond(A,B,C,D,condition_fn,old_T,n_iterations) PURPOSE: Improve the condition of the system through a state transformation T, where condition is defined by condition_fn. For example, condition of A or condition of the block A | B --------- C | D INPUT: A,B,C,D = system to improve condition for condition_fn = string = function to return a condition number (e.g. containing cond(A); see condition_A.m and condition_ABCD.m for examples.) old_T = square matrix (size A) = initial value for T (optional) n_iterations = max number of iterations in fmin u OUTPUT: T = state transformation which give minimum value of condition condition = value of condition achieved Dependencies \u00b6","title":"improve_cond.m"},{"location":"function-guide/GAcontrol/improve_cond_m/#improve_condm","text":"","title":"improve_cond.m"},{"location":"function-guide/GAcontrol/improve_cond_m/#basic-information","text":"SYNTAX: [T,condition] = improve_cond(A,B,C,D,condition_fn,old_T,n_iterations) PURPOSE: Improve the condition of the system through a state transformation T, where condition is defined by condition_fn. For example, condition of A or condition of the block A | B --------- C | D INPUT: A,B,C,D = system to improve condition for condition_fn = string = function to return a condition number (e.g. containing cond(A); see condition_A.m and condition_ABCD.m for examples.) old_T = square matrix (size A) = initial value for T (optional) n_iterations = max number of iterations in fmin u OUTPUT: T = state transformation which give minimum value of condition condition = value of condition achieved","title":"Basic Information"},{"location":"function-guide/GAcontrol/improve_cond_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/plot_simulink_shapes_m/","text":"plot_simulink_shapes.m \u00b6 Basic Information \u00b6 SYNTAX: plot_simulink_shapes PURPOSE: Plot results of SIMULINK simulations which use the S-file sim_Xpt2.c in an EFIT type contour plot. INPUT: algorithm = one of 'isosnull', 'isousnull', or 'isodnull' filename = g0 file containing equilibrium around which plant model was created tstart = first time to plot simulated boundary (seconds), default 0.0 stepsize = steps for boundary plots (seconds), default 0.01s plot_geometry = set to 1 to plot D3d geometry around equil. (default 0) axis_to_show = plot range to show = argument to axis function (optional, default = [1 2.3 -1.4 1.4] figure_num (generated by simulink simulation and its setup process): time_sim0 = output of simulink model nsegments Xpt_sim tgt_sim simXpt2_flux_sim OUTPUT: plot - Steps through multiple time slices: - shows yellow x on control segments where flux = Xpt flux - connects yellow line between these x's and to Xpt. - shows yellow * for location of magnetic axis (location is updated for z coordinate, r coordinate is assumed fixed) - shows target points with red + - original equilibrium shown in white (with mag axis = x) figure_num RESTRICTIONS: (1) requires g0* file exist METHOD: The flux on each control segment at time t is approximated by adding the flux on the segment at equilibrium to the change in flux of the chosen control point (on that segment) from equilibrium. Then the point on the segment whose flux is closest to the Xpt flux value at time t is used to define the boundary location at time t. Dependencies \u00b6 read_gfile wait zero_crossing","title":"plot_simulink_shapes.m"},{"location":"function-guide/GAcontrol/plot_simulink_shapes_m/#plot_simulink_shapesm","text":"","title":"plot_simulink_shapes.m"},{"location":"function-guide/GAcontrol/plot_simulink_shapes_m/#basic-information","text":"SYNTAX: plot_simulink_shapes PURPOSE: Plot results of SIMULINK simulations which use the S-file sim_Xpt2.c in an EFIT type contour plot. INPUT: algorithm = one of 'isosnull', 'isousnull', or 'isodnull' filename = g0 file containing equilibrium around which plant model was created tstart = first time to plot simulated boundary (seconds), default 0.0 stepsize = steps for boundary plots (seconds), default 0.01s plot_geometry = set to 1 to plot D3d geometry around equil. (default 0) axis_to_show = plot range to show = argument to axis function (optional, default = [1 2.3 -1.4 1.4] figure_num (generated by simulink simulation and its setup process): time_sim0 = output of simulink model nsegments Xpt_sim tgt_sim simXpt2_flux_sim OUTPUT: plot - Steps through multiple time slices: - shows yellow x on control segments where flux = Xpt flux - connects yellow line between these x's and to Xpt. - shows yellow * for location of magnetic axis (location is updated for z coordinate, r coordinate is assumed fixed) - shows target points with red + - original equilibrium shown in white (with mag axis = x) figure_num RESTRICTIONS: (1) requires g0* file exist METHOD: The flux on each control segment at time t is approximated by adding the flux on the segment at equilibrium to the change in flux of the chosen control point (on that segment) from equilibrium. Then the point on the segment whose flux is closest to the Xpt flux value at time t is used to define the boundary location at time t.","title":"Basic Information"},{"location":"function-guide/GAcontrol/plot_simulink_shapes_m/#dependencies","text":"read_gfile wait zero_crossing","title":"Dependencies"},{"location":"function-guide/GAcontrol/remove_algebraic_m/","text":"remove_algebraic.m \u00b6 Basic Information \u00b6 SYNTAX: [A1,B1,C1,D1,E1,T,K] = remove_algebraic(A,B,C,D,E,condn) PURPOSE: Remove algebraic relationships from a system in descriptor form: E dx/dt = Ax + Bu y = Cx + Du for 2 cases: (1) where a row of E is identically 0. (2) where E = identity INPUT: A,B,C,D,E = descriptor system with (possible) algebraic relation (E is optional, default = identity) condn = set = 1 to improve system condition as well as remove algebraic, set = 0 to only remove algebraic (optional, default=1) OUTPUT: A1,B1,C1,D1,E1 = descriptor system with algebraic relation removed T = state transformation matrix: x = T*x1, where x1 is new state vector K = If E~=identity, matrix describing algebraic relationship: states removed = K * (remaining states) If E==identity, K = indices of states deleted from x1 RESTRICTIONS: This routine is not truly general purpose yet. Needs to be extended to the case where a row of E can be brought to 0 using elementary operations. Dependencies \u00b6","title":"remove_algebraic.m"},{"location":"function-guide/GAcontrol/remove_algebraic_m/#remove_algebraicm","text":"","title":"remove_algebraic.m"},{"location":"function-guide/GAcontrol/remove_algebraic_m/#basic-information","text":"SYNTAX: [A1,B1,C1,D1,E1,T,K] = remove_algebraic(A,B,C,D,E,condn) PURPOSE: Remove algebraic relationships from a system in descriptor form: E dx/dt = Ax + Bu y = Cx + Du for 2 cases: (1) where a row of E is identically 0. (2) where E = identity INPUT: A,B,C,D,E = descriptor system with (possible) algebraic relation (E is optional, default = identity) condn = set = 1 to improve system condition as well as remove algebraic, set = 0 to only remove algebraic (optional, default=1) OUTPUT: A1,B1,C1,D1,E1 = descriptor system with algebraic relation removed T = state transformation matrix: x = T*x1, where x1 is new state vector K = If E~=identity, matrix describing algebraic relationship: states removed = K * (remaining states) If E==identity, K = indices of states deleted from x1 RESTRICTIONS: This routine is not truly general purpose yet. Needs to be extended to the case where a row of E can be brought to 0 using elementary operations.","title":"Basic Information"},{"location":"function-guide/GAcontrol/remove_algebraic_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/seg_error_name_m/","text":"seg_error_name.m \u00b6 Basic Information \u00b6 SYNTAX: ptname = seg_error_name(algorithm,error) PURPOSE: Returns the ptname for the error'th segment when specified algorithm is used. INPUT: algorithm = one of 'isosnull', 'isodnull', 'isousnull', or 'equilibrium' error = one of 'br1', 'br2', 'bz1', 'bz2', or an (integer) segment number OUTPUT: ptname Dependencies \u00b6 wait","title":"seg_error_name.m"},{"location":"function-guide/GAcontrol/seg_error_name_m/#seg_error_namem","text":"","title":"seg_error_name.m"},{"location":"function-guide/GAcontrol/seg_error_name_m/#basic-information","text":"SYNTAX: ptname = seg_error_name(algorithm,error) PURPOSE: Returns the ptname for the error'th segment when specified algorithm is used. INPUT: algorithm = one of 'isosnull', 'isodnull', 'isousnull', or 'equilibrium' error = one of 'br1', 'br2', 'bz1', 'bz2', or an (integer) segment number OUTPUT: ptname","title":"Basic Information"},{"location":"function-guide/GAcontrol/seg_error_name_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/GAcontrol/sysbal_trans_m/","text":"sysbal_trans.m \u00b6 Basic Information \u00b6 SYNTAX: [sysout,sig,Tleft,Tright] = sysbal_trans(sys,tol) PURPOSE: Does same work as sysbal, plus provides the transformation matrices for the resulting state space change of coordinates. Finds a truncated balanced realization of the system state-space model. Eigenvalues of A must have negative real part. The result is truncated to retain all Hankel- singular values greater than TOL. If TOL is omitted then it is set to max(sig(1)*1.0E-12,1.0E-16). INPUT: sys = system (muSYN packed) to balance/reduce OUTPUT: sysout = balanced/reduced system sig = Hankel singular values Tleft,Tright = matrices which multiply original A0,B0,C0 so that new system (sysout) is constructed by change of coordinates + truncation A1 = Tleft*A0*Tright, B1 = Tleft*B0, C1 = C0*Tright See also: HANKMR, REORDSYS, FRWTBAL, SFRWTBLD, SNCFBAL, SRELBAL, SRESID, SVD, and TRUNC. Dependencies \u00b6","title":"sysbal_trans.m"},{"location":"function-guide/GAcontrol/sysbal_trans_m/#sysbal_transm","text":"","title":"sysbal_trans.m"},{"location":"function-guide/GAcontrol/sysbal_trans_m/#basic-information","text":"SYNTAX: [sysout,sig,Tleft,Tright] = sysbal_trans(sys,tol) PURPOSE: Does same work as sysbal, plus provides the transformation matrices for the resulting state space change of coordinates. Finds a truncated balanced realization of the system state-space model. Eigenvalues of A must have negative real part. The result is truncated to retain all Hankel- singular values greater than TOL. If TOL is omitted then it is set to max(sig(1)*1.0E-12,1.0E-16). INPUT: sys = system (muSYN packed) to balance/reduce OUTPUT: sysout = balanced/reduced system sig = Hankel singular values Tleft,Tright = matrices which multiply original A0,B0,C0 so that new system (sysout) is constructed by change of coordinates + truncation A1 = Tleft*A0*Tright, B1 = Tleft*B0, C1 = C0*Tright See also: HANKMR, REORDSYS, FRWTBAL, SFRWTBLD, SNCFBAL, SRELBAL, SRESID, SVD, and TRUNC.","title":"Basic Information"},{"location":"function-guide/GAcontrol/sysbal_trans_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/sysconnect_m/","text":"sysconnect.m \u00b6 Basic Information \u00b6 SYNTAX: [systot,ierr] = sysconnect(system_defns, sys1, sys2, ...) PURPOSE: Connect together multiple systems in Control Toolbox format. Note that Control Toolbox functions tend to produce poorly conditioned system matrices. Use remove_algebraic.m to improve conditioning. INPUT: sys_defns= structure containing definitions of system to build. Structure must contain at least the fields: systemnames, inputvar, outputvar and \"input_to_\"... for each system listed in systemnames. Format is the same as for sysic in the muSYN toolbox. sys1, sys2, ... = systems defined in \"systemnames\" - must be in the same order as listed in systemnames Example: sys_defns = struct('systemnames','DIIID1 ip_feedback', ... 'inputvar','[choppers(18); dist(4)]', ... 'outputvar','[DIIID1]', ... 'input_to_DIIID1','[ip_feedback; choppers; dist]', ... 'input_to_ip_feedback','[DIIID1(46)]'); (then, for arguments, sys1 = DIIID1, sys2 = ip_feedback) OUTPUT: systot = connected together system ierr = error code, different from 0 if error prevented systot from being successfully built SEE ALSO: sysmult, sysinfo RESTRICTIONS: Cannot handle arithmetic operations inside the string (e.g. sys1+sys2, 2*sys3, etc.) like sysic can. Dependencies \u00b6 CTpass2 CTpass1 sysinfo CTinpstuff CTpass3 CTnamstuff updateQ","title":"sysconnect.m"},{"location":"function-guide/GAcontrol/sysconnect_m/#sysconnectm","text":"","title":"sysconnect.m"},{"location":"function-guide/GAcontrol/sysconnect_m/#basic-information","text":"SYNTAX: [systot,ierr] = sysconnect(system_defns, sys1, sys2, ...) PURPOSE: Connect together multiple systems in Control Toolbox format. Note that Control Toolbox functions tend to produce poorly conditioned system matrices. Use remove_algebraic.m to improve conditioning. INPUT: sys_defns= structure containing definitions of system to build. Structure must contain at least the fields: systemnames, inputvar, outputvar and \"input_to_\"... for each system listed in systemnames. Format is the same as for sysic in the muSYN toolbox. sys1, sys2, ... = systems defined in \"systemnames\" - must be in the same order as listed in systemnames Example: sys_defns = struct('systemnames','DIIID1 ip_feedback', ... 'inputvar','[choppers(18); dist(4)]', ... 'outputvar','[DIIID1]', ... 'input_to_DIIID1','[ip_feedback; choppers; dist]', ... 'input_to_ip_feedback','[DIIID1(46)]'); (then, for arguments, sys1 = DIIID1, sys2 = ip_feedback) OUTPUT: systot = connected together system ierr = error code, different from 0 if error prevented systot from being successfully built SEE ALSO: sysmult, sysinfo RESTRICTIONS: Cannot handle arithmetic operations inside the string (e.g. sys1+sys2, 2*sys3, etc.) like sysic can.","title":"Basic Information"},{"location":"function-guide/GAcontrol/sysconnect_m/#dependencies","text":"CTpass2 CTpass1 sysinfo CTinpstuff CTpass3 CTnamstuff updateQ","title":"Dependencies"},{"location":"function-guide/GAcontrol/sysinfo_m/","text":"sysinfo.m \u00b6 Basic Information \u00b6 SYNTAX: [type,noutput,ninput,nstates] = sysinfo(system,debug) PURPOSE: Provide information about the system contained in a Control Toolbox system object. Works for system and ordinary matrix objects. INPUT: system = system in Control Toolbox packed format, or matrix debug = if 1, you get printed info OUTPUT: type = either 'syst' or 'cons' noutput = number of outputs ninput = number of inputs nstates = number of states (0 for matrix) Dependencies \u00b6","title":"sysinfo.m"},{"location":"function-guide/GAcontrol/sysinfo_m/#sysinfom","text":"","title":"sysinfo.m"},{"location":"function-guide/GAcontrol/sysinfo_m/#basic-information","text":"SYNTAX: [type,noutput,ninput,nstates] = sysinfo(system,debug) PURPOSE: Provide information about the system contained in a Control Toolbox system object. Works for system and ordinary matrix objects. INPUT: system = system in Control Toolbox packed format, or matrix debug = if 1, you get printed info OUTPUT: type = either 'syst' or 'cons' noutput = number of outputs ninput = number of inputs nstates = number of states (0 for matrix)","title":"Basic Information"},{"location":"function-guide/GAcontrol/sysinfo_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/sysmult_m/","text":"sysmult.m \u00b6 Basic Information \u00b6 SYNTAX: sysout = sysmult(sys1,sys2,...) PURPOSE: Multiply several systems together. Systems are either in Control Toolbox packed format or simple matrices. INPUT: sys1, sys2, ... = systems to be multiplied OUTPUT: sysout = product of systems RESTRICTIONS: (1) Maximum of 10 arguments (2) Uses Control Toolbox Dependencies \u00b6","title":"sysmult.m"},{"location":"function-guide/GAcontrol/sysmult_m/#sysmultm","text":"","title":"sysmult.m"},{"location":"function-guide/GAcontrol/sysmult_m/#basic-information","text":"SYNTAX: sysout = sysmult(sys1,sys2,...) PURPOSE: Multiply several systems together. Systems are either in Control Toolbox packed format or simple matrices. INPUT: sys1, sys2, ... = systems to be multiplied OUTPUT: sysout = product of systems RESTRICTIONS: (1) Maximum of 10 arguments (2) Uses Control Toolbox","title":"Basic Information"},{"location":"function-guide/GAcontrol/sysmult_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAcontrol/transform_states_m/","text":"transform_states.m \u00b6 Basic Information \u00b6 SYNTAX: [an,bn,cn,dn]=transform_states(A,B,C,D,T) -1 PURPOSE: Performs the similarity transform z = T x. The resulting state space system is: . -1 -1 z = [T AT] z + [T B] u y = [CT ] z + Du NOTE: In most cases, the function ss2ss will perform the same function, but in some cases, the \"balance\" function returns T that is nearly singular. In that case, ss2ss requires T^-1 and doesn't perform well. INPUT: A,B,C,D = original system description T = state transformation OUTPUT: an,bn,cn,dn = transformed system description","title":"transform_states.m"},{"location":"function-guide/GAcontrol/transform_states_m/#transform_statesm","text":"","title":"transform_states.m"},{"location":"function-guide/GAcontrol/transform_states_m/#basic-information","text":"SYNTAX: [an,bn,cn,dn]=transform_states(A,B,C,D,T) -1 PURPOSE: Performs the similarity transform z = T x. The resulting state space system is: . -1 -1 z = [T AT] z + [T B] u y = [CT ] z + Du NOTE: In most cases, the function ss2ss will perform the same function, but in some cases, the \"balance\" function returns T that is nearly singular. In that case, ss2ss requires T^-1 and doesn't perform well. INPUT: A,B,C,D = original system description T = state transformation OUTPUT: an,bn,cn,dn = transformed system description","title":"Basic Information"},{"location":"function-guide/GAcontrol/updateQ_m/","text":"updateQ.m \u00b6 Basic Information \u00b6 SYNTAX: [Q,ierr] = updateQ(ksys,tokarr,Q,system_data,numsys,sysnames) PURPOSE: Add connections for the ksys'th system to the connection matrix Q. INPUT: ksys = number of system being worked on tokarr = array of tokens for input to ksys'th system Q = connection matrix for connect.m in Control Toolbox system_data= array containin #states, inputs, outputs for each system numsys = number of total systems sysnames = names of all systems OUTPUT: Q = connection matrix after update ierr = error code, different from 0 if error in construction Dependencies \u00b6","title":"updateQ.m"},{"location":"function-guide/GAcontrol/updateQ_m/#updateqm","text":"","title":"updateQ.m"},{"location":"function-guide/GAcontrol/updateQ_m/#basic-information","text":"SYNTAX: [Q,ierr] = updateQ(ksys,tokarr,Q,system_data,numsys,sysnames) PURPOSE: Add connections for the ksys'th system to the connection matrix Q. INPUT: ksys = number of system being worked on tokarr = array of tokens for input to ksys'th system Q = connection matrix for connect.m in Control Toolbox system_data= array containin #states, inputs, outputs for each system numsys = number of total systems sysnames = names of all systems OUTPUT: Q = connection matrix after update ierr = error code, different from 0 if error in construction","title":"Basic Information"},{"location":"function-guide/GAcontrol/updateQ_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAgraphics/add_lines_m/","text":"add_lines.m \u00b6 Basic Information \u00b6 SYNTAX: add_lines(xlocs,figure_num,subpl_num) PURPOSE: Draw vertical lines in plot window at specified x locations. INPUT: xlocs = vector of x axis locations at which to draw lines figure_num = figure number (optional, default=current figure) NOT WORKING YET: subpl_num = subplot number (optional, default=current subplot) OUTPUT: none RESTRICTIONS: This function should be called after any adjustment of axes in order to ensure lines go all the way from bottom to top of plot. Dependencies \u00b6","title":"add_lines.m"},{"location":"function-guide/GAgraphics/add_lines_m/#add_linesm","text":"","title":"add_lines.m"},{"location":"function-guide/GAgraphics/add_lines_m/#basic-information","text":"SYNTAX: add_lines(xlocs,figure_num,subpl_num) PURPOSE: Draw vertical lines in plot window at specified x locations. INPUT: xlocs = vector of x axis locations at which to draw lines figure_num = figure number (optional, default=current figure) NOT WORKING YET: subpl_num = subplot number (optional, default=current subplot) OUTPUT: none RESTRICTIONS: This function should be called after any adjustment of axes in order to ensure lines go all the way from bottom to top of plot.","title":"Basic Information"},{"location":"function-guide/GAgraphics/add_lines_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAgraphics/contour_smooth_m/","text":"contour_smooth.m \u00b6 Basic Information \u00b6 PURPOSE: smooth contour and make uniform spacing in length SYNTAX: con_out= contour_smooth(con,iplt,isym); INPUT: con= contour vector from con=contour(...) or con=contourc(...) iplt= 0=> no plot; 1=> plot each contour [0] isym= plot symbol i.e. 'r--' ['y-'] OUTPUT: con_out= smoothed contour with equal grid spacing FILE: contour_smooth.m Dependencies \u00b6","title":"contour_smooth.m"},{"location":"function-guide/GAgraphics/contour_smooth_m/#contour_smoothm","text":"","title":"contour_smooth.m"},{"location":"function-guide/GAgraphics/contour_smooth_m/#basic-information","text":"PURPOSE: smooth contour and make uniform spacing in length SYNTAX: con_out= contour_smooth(con,iplt,isym); INPUT: con= contour vector from con=contour(...) or con=contourc(...) iplt= 0=> no plot; 1=> plot each contour [0] isym= plot symbol i.e. 'r--' ['y-'] OUTPUT: con_out= smoothed contour with equal grid spacing FILE: contour_smooth.m","title":"Basic Information"},{"location":"function-guide/GAgraphics/contour_smooth_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAgraphics/eps_all_figs_m/","text":"eps_all_figs.m \u00b6 Basic Information \u00b6 SYNTAX: figs= eps_all_figs; makes f1.eps f2.eps ... all figs figs= eps_all_figs(fig_nums); makes f2.eps f?.eps ... from fig_nums figs= eps_all_figs([],1); prints all figures to file: figs.eps figs= eps_all_figs([],'ps'); prints to f2.ps instead of .eps PURPOSE: makes f#.eps for each figure in fig_nums (or all figures) # is number of each figure in fig_num (or all open figures) INPUT: [default] fig_nums = list of figure numbers (ex: fig_num= [1 3 5]; {default all figs} append = 1; append figures to single big .eps file [0] = 'ps' prints to ps instead of eps (does not append) OUTPUT: Files: f1.eps, f2.eps, .... f#.eps {NOTE: Will overwrite in local dir} if append=1 makes file: figs.ps figs = list of figure numbers printed Dependencies \u00b6 paper_position","title":"eps_all_figs.m"},{"location":"function-guide/GAgraphics/eps_all_figs_m/#eps_all_figsm","text":"","title":"eps_all_figs.m"},{"location":"function-guide/GAgraphics/eps_all_figs_m/#basic-information","text":"SYNTAX: figs= eps_all_figs; makes f1.eps f2.eps ... all figs figs= eps_all_figs(fig_nums); makes f2.eps f?.eps ... from fig_nums figs= eps_all_figs([],1); prints all figures to file: figs.eps figs= eps_all_figs([],'ps'); prints to f2.ps instead of .eps PURPOSE: makes f#.eps for each figure in fig_nums (or all figures) # is number of each figure in fig_num (or all open figures) INPUT: [default] fig_nums = list of figure numbers (ex: fig_num= [1 3 5]; {default all figs} append = 1; append figures to single big .eps file [0] = 'ps' prints to ps instead of eps (does not append) OUTPUT: Files: f1.eps, f2.eps, .... f#.eps {NOTE: Will overwrite in local dir} if append=1 makes file: figs.ps figs = list of figure numbers printed","title":"Basic Information"},{"location":"function-guide/GAgraphics/eps_all_figs_m/#dependencies","text":"paper_position","title":"Dependencies"},{"location":"function-guide/GAgraphics/letter_figure_m/","text":"letter_figure.m \u00b6 Basic Information \u00b6 SYNTAX: letter_figure(corner,letter,figure_num,subpl_num) PURPOSE: Put a letter into a figure suitable for use as part of a figure in a report. INPUT: corner = one of 'ur','ul','lr','ll' letter = letter or label such as (a),(b),(c), ..., (1), (2), ... figure_num = figure number (optional, default=current figure) NOT WORKING YET: subpl_num = subplot number (optional, default=current subplot) OUTPUT: none RESTRICTIONS: This function should be called after any adjustment of axes to ensure that letter ends up in the corner of the final plot frame rather than in the corner of the unadjusted plot. Dependencies \u00b6","title":"letter_figure.m"},{"location":"function-guide/GAgraphics/letter_figure_m/#letter_figurem","text":"","title":"letter_figure.m"},{"location":"function-guide/GAgraphics/letter_figure_m/#basic-information","text":"SYNTAX: letter_figure(corner,letter,figure_num,subpl_num) PURPOSE: Put a letter into a figure suitable for use as part of a figure in a report. INPUT: corner = one of 'ur','ul','lr','ll' letter = letter or label such as (a),(b),(c), ..., (1), (2), ... figure_num = figure number (optional, default=current figure) NOT WORKING YET: subpl_num = subplot number (optional, default=current subplot) OUTPUT: none RESTRICTIONS: This function should be called after any adjustment of axes to ensure that letter ends up in the corner of the final plot frame rather than in the corner of the unadjusted plot.","title":"Basic Information"},{"location":"function-guide/GAgraphics/letter_figure_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAgraphics/next_line_type_m/","text":"next_line_type.m \u00b6 Basic Information \u00b6 SYNTAX: next_line_type(col_strs,sym_strs) PURPOSE: bring up a new line type INPUT: line_flag = set = 1 to connect symbols with line col_strs = array of color strings (optional) sym_strs = array of symbol strings (optional) OUTPUT: Dependencies \u00b6","title":"next_line_type.m"},{"location":"function-guide/GAgraphics/next_line_type_m/#next_line_typem","text":"","title":"next_line_type.m"},{"location":"function-guide/GAgraphics/next_line_type_m/#basic-information","text":"SYNTAX: next_line_type(col_strs,sym_strs) PURPOSE: bring up a new line type INPUT: line_flag = set = 1 to connect symbols with line col_strs = array of color strings (optional) sym_strs = array of symbol strings (optional) OUTPUT:","title":"Basic Information"},{"location":"function-guide/GAgraphics/next_line_type_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAgraphics/plot_vertlines_m/","text":"plot_vertlines.m \u00b6 Basic Information \u00b6 SYNTAX: plot_vertlines(line_locs) PURPOSE: Plot vertical lines from bottom to top of current figure and subplot. INPUT: line_locs = list of line locations on x-axis OUTPUT: none RESTRICTIONS: Plot must have hold on. Dependencies \u00b6","title":"plot_vertlines.m"},{"location":"function-guide/GAgraphics/plot_vertlines_m/#plot_vertlinesm","text":"","title":"plot_vertlines.m"},{"location":"function-guide/GAgraphics/plot_vertlines_m/#basic-information","text":"SYNTAX: plot_vertlines(line_locs) PURPOSE: Plot vertical lines from bottom to top of current figure and subplot. INPUT: line_locs = list of line locations on x-axis OUTPUT: none RESTRICTIONS: Plot must have hold on.","title":"Basic Information"},{"location":"function-guide/GAgraphics/plot_vertlines_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAgraphics/set_def_fig_loc_m/","text":"set_def_fig_loc.m \u00b6 Basic Information \u00b6 SYNTAX: ijdidj= set_def_fig_loc(ijdidj); vector ijdidj= i, j, di, dj screen pixels set_def_fig_loc; window bottom corner 1/2 screen set_def_fig_loc(frc); window bottom corner frc screen set_def_fig_loc(i,j); window bottom corner i,j pixel's set_def_fig_loc(i,j,di,dj) window corner i,j and size di dj pixels PURPOSE: Sets default figure pixel location relative to screen sets: set(0,'defaultFigurePosition',ijdidj). INPUT: ijdidj= scalar => fac of screen for bottom left window loc = ScreenSize(3,4)/ijdidj ijdidj= vector [2] or [4] [i, j, di, dj] pixel coordinates of figure in main screen (0) defaults i, j to ScreenSize(3,4)/2 defaults di,dj to DefaultFigurePosition(3,4) if 2 or 4 arguments present then assums arguments are i, j, di, dj OUTPUT: executes set(0,'defaultFigurePosition', ijdidj); RESTRICTIONS: Dependencies \u00b6","title":"set_def_fig_loc.m"},{"location":"function-guide/GAgraphics/set_def_fig_loc_m/#set_def_fig_locm","text":"","title":"set_def_fig_loc.m"},{"location":"function-guide/GAgraphics/set_def_fig_loc_m/#basic-information","text":"SYNTAX: ijdidj= set_def_fig_loc(ijdidj); vector ijdidj= i, j, di, dj screen pixels set_def_fig_loc; window bottom corner 1/2 screen set_def_fig_loc(frc); window bottom corner frc screen set_def_fig_loc(i,j); window bottom corner i,j pixel's set_def_fig_loc(i,j,di,dj) window corner i,j and size di dj pixels PURPOSE: Sets default figure pixel location relative to screen sets: set(0,'defaultFigurePosition',ijdidj). INPUT: ijdidj= scalar => fac of screen for bottom left window loc = ScreenSize(3,4)/ijdidj ijdidj= vector [2] or [4] [i, j, di, dj] pixel coordinates of figure in main screen (0) defaults i, j to ScreenSize(3,4)/2 defaults di,dj to DefaultFigurePosition(3,4) if 2 or 4 arguments present then assums arguments are i, j, di, dj OUTPUT: executes set(0,'defaultFigurePosition', ijdidj); RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/GAgraphics/set_def_fig_loc_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAplotting/data_access/pullShotData_m/","text":"pullShotData.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: INPUTS: OUTPUT: EXAMPLES: RESTRICTIONS: METHOD: WRITTEN BY: Jayson Barr Dependencies \u00b6 cellsEqual getTBase getmdsconn syncToTbase getmdata testmdsconn get_defaults_for_tok getDisruptTimes shotDataStruct sigStruct expandFigSigDef","title":"pullShotData.m"},{"location":"function-guide/GAplotting/data_access/pullShotData_m/#pullshotdatam","text":"","title":"pullShotData.m"},{"location":"function-guide/GAplotting/data_access/pullShotData_m/#basic-information","text":"SYNTAX: PURPOSE: INPUTS: OUTPUT: EXAMPLES: RESTRICTIONS: METHOD: WRITTEN BY: Jayson Barr","title":"Basic Information"},{"location":"function-guide/GAplotting/data_access/pullShotData_m/#dependencies","text":"cellsEqual getTBase getmdsconn syncToTbase getmdata testmdsconn get_defaults_for_tok getDisruptTimes shotDataStruct sigStruct expandFigSigDef","title":"Dependencies"},{"location":"function-guide/GAplotting/plotting/plotShot_m/","text":"plotShot.m \u00b6 Basic Information \u00b6 SYNTAX: [ shot_data, fig_handles, conn]=... plotShot(snlist, fig_setup, tokOrServer, figs_layout_spec, tightx, shot_data, conn, slice_options) PURPOSE: For quick plotting of experimental data, with options for more post-processing as needed. INPUTS: snlist = array of shot numbers to plot data from, or a single number if only one shot is desired. (Required input) fig_setup = a cellarray defining a figure or set of figures. For many examples, or quick layouts to start with, see bookmarks.m. (Required input) Basic spec for a signal definition (string!) is a string pointname followed by a series of deliminators before added options. Deliminators are nedded before adding these argurments, but if leaving default do not supply any deliminators not being used. Minimum: 'ptname' Common: 'ptname:tree' Full spec: 'ptname[chord]:tree#pltargs$label*calib@postprocfunc(t0,t1)&dependency1,dep2units?Description' * Note that everything but the ptname is optional! Details on each part of the spec (): ptname = pointname of desired signal [chord] = optional designation of chord location :tree = ptdata or a mdsplus tree where the data resides. If not set, first looks for ptdata, then searches for a tree where it finds the pointname. If in EFIT trees, the order of preference for EFIT to use is set per-tokamak in get_defaults_for_tok.m. For D3D, it is EFIT01,EFITRT1... *Note: if the user is defining a new signal that is constructed from multiple other signals via a post-processing function, then tree MUST be set to 'D' (which is to stand for derived). #pltargs = comma deliminated set of plotting arguments to be passed to the plot function. Do not use quotation marks. For example, to set the line-width to 2, you would put this in your signal spec: 'ptname#LineWidth,2' $label = a label to use for plotting y-axis and legend. using standard matlab stying. Example: 'ipsip$I_p' *calib = a multiplicative calibration factor to apply *instead* of the one stored in mdsplus @postprocfunc = a post-processing function to apply to the signal. This function must expect the appropriate inputs and give the right outputs. See all of provided functions in GAplotting/derivedd_data_funcs for examples. Many useful functions already exist. Of particular note is d_math. (t0,t1) = subwindow of time to include data from, if not desired to use the full time series &dependency1,dep2,dep3... = a list of other ptnames that must be loaded as well before applying the post-processing function to this signal. units = units for labelling in the plots. If not supplied, then first mdsplus will be checked to see if units are associated with the pointname. Then, get_defaults_for_tok.m will be used to check for noted units for pointnames listed there. ?Description = optional description of the signal, stored in the output data structure Separate subplots into sub-cell arrays: {{subplot1}, {subplot2}, {subplot3}} tokOrServer = the name of a tokamak or server address collect data from. For recognized tokamak names, the server address is known and applied (see get_defaults_for_tok.m). (Default: d3d) Tokamaks recognized: d3d, kstar, east, eastga, mastu, nstxu, jet *eastga = GA local server of subset of EAST data. figs_layout_spec = [# rows, # columns] for the layout of subplots in the output figures. If only one number is specified, it is assumed to be the number of rows, and # columns assumed to be 1. Set just an empty array like [] to auto-scale the # rows and # columns to fit all of the subplots defined in a single plot. (Default: []) *If the number of subplots define din fig_setup is larger than the #rows * # plots, then multiple figures will be generated, following the defined order of subplots defined in fit_setup, and each with [# rows, # columns]. tightx = Set to a true value if it is desired to have plots in the same column be closer together vertically, hiding the x-axis labels for all but the bottom plot. The x-axes will be linked so that all of the x-axes have the same scales, and change together. Especially useful for figures of several time-series signals. shot_data = a structure of the type produced by pullShotData.m. If provided, then before pulling data from servers this structure will be first checked to see if the data already exists locally. This is the same type as output by this function. This is to save time from repeatedly downloading data when unnecessary. If set to NaN, then just load all of the data first. (Default: nan = no starting data, just reload all needed) conn = an mds connection object as can be obtained from getmdsconn.m, which can be used to connect to a remote mds server. Reusing a connection save serious time in downloading data, using the getmdata.m function instead of getmds.m. Note that a connection of this type is also an output - allowing for easy reuse of connections to save time. Set to nan to ignore and just open a new connection. (Default: nan = open a new connection) slice_options = If it is desired to sync all loaded data to a common timebase, then define a structure here of the type expected by getTBase.m. See getTBase.m for how to define this structure if synchronizing timebase is desired. Set to nan to just keep the original timebase of each loaded signal. (Default: nan = keep indivicual, original signal timebases). OUTPUT: shot_data = a structure of the type produced by pullShotData.m, containing all data loaded for plotting. If the user supplied a shot_data structure as an input, the user-supplied data was used where possible, and any additional data was loaded as needed. See pullShotData.m for more detailed specification of the structure layout. fig_handles = an array of figure handles for each of the figures produced by this function while plotting. conn = a reusable mds connection object as can be obtained from getmdsconn.m, and the original user-given objust if this optional input was provided. See more details in input definition above or in getmdsconn.m EXAMPLES: plotShot(181035,{'ip','kappa:EFIT01','bmspinj'}) [shot_data,~,conn]=plotShot([181035,181041],{'ipsip','li','sysfpstrip'}) plotShot([181035,181041],{'ipsip','li','sysfpstrip'},'d3d',[],1,shot_data,conn) plotShot(95145,{'ip'},'east') plotShot(181035,bookmarks('basic','d3d'),'d3d') plotShot(181035,{'ipsip$I_p*1e6A'}) plotShot(181035,{'ip','gasTot:D@d_math&+gasa,+gasb,+gasc,+gasd,+gase'}) RESTRICTIONS: METHOD: WRITTEN BY: Jayson Barr","title":"plotShot.m"},{"location":"function-guide/GAplotting/plotting/plotShot_m/#plotshotm","text":"","title":"plotShot.m"},{"location":"function-guide/GAplotting/plotting/plotShot_m/#basic-information","text":"SYNTAX: [ shot_data, fig_handles, conn]=... plotShot(snlist, fig_setup, tokOrServer, figs_layout_spec, tightx, shot_data, conn, slice_options) PURPOSE: For quick plotting of experimental data, with options for more post-processing as needed. INPUTS: snlist = array of shot numbers to plot data from, or a single number if only one shot is desired. (Required input) fig_setup = a cellarray defining a figure or set of figures. For many examples, or quick layouts to start with, see bookmarks.m. (Required input) Basic spec for a signal definition (string!) is a string pointname followed by a series of deliminators before added options. Deliminators are nedded before adding these argurments, but if leaving default do not supply any deliminators not being used. Minimum: 'ptname' Common: 'ptname:tree' Full spec: 'ptname[chord]:tree#pltargs$label*calib@postprocfunc(t0,t1)&dependency1,dep2units?Description' * Note that everything but the ptname is optional! Details on each part of the spec (): ptname = pointname of desired signal [chord] = optional designation of chord location :tree = ptdata or a mdsplus tree where the data resides. If not set, first looks for ptdata, then searches for a tree where it finds the pointname. If in EFIT trees, the order of preference for EFIT to use is set per-tokamak in get_defaults_for_tok.m. For D3D, it is EFIT01,EFITRT1... *Note: if the user is defining a new signal that is constructed from multiple other signals via a post-processing function, then tree MUST be set to 'D' (which is to stand for derived). #pltargs = comma deliminated set of plotting arguments to be passed to the plot function. Do not use quotation marks. For example, to set the line-width to 2, you would put this in your signal spec: 'ptname#LineWidth,2' $label = a label to use for plotting y-axis and legend. using standard matlab stying. Example: 'ipsip$I_p' *calib = a multiplicative calibration factor to apply *instead* of the one stored in mdsplus @postprocfunc = a post-processing function to apply to the signal. This function must expect the appropriate inputs and give the right outputs. See all of provided functions in GAplotting/derivedd_data_funcs for examples. Many useful functions already exist. Of particular note is d_math. (t0,t1) = subwindow of time to include data from, if not desired to use the full time series &dependency1,dep2,dep3... = a list of other ptnames that must be loaded as well before applying the post-processing function to this signal. units = units for labelling in the plots. If not supplied, then first mdsplus will be checked to see if units are associated with the pointname. Then, get_defaults_for_tok.m will be used to check for noted units for pointnames listed there. ?Description = optional description of the signal, stored in the output data structure Separate subplots into sub-cell arrays: {{subplot1}, {subplot2}, {subplot3}} tokOrServer = the name of a tokamak or server address collect data from. For recognized tokamak names, the server address is known and applied (see get_defaults_for_tok.m). (Default: d3d) Tokamaks recognized: d3d, kstar, east, eastga, mastu, nstxu, jet *eastga = GA local server of subset of EAST data. figs_layout_spec = [# rows, # columns] for the layout of subplots in the output figures. If only one number is specified, it is assumed to be the number of rows, and # columns assumed to be 1. Set just an empty array like [] to auto-scale the # rows and # columns to fit all of the subplots defined in a single plot. (Default: []) *If the number of subplots define din fig_setup is larger than the #rows * # plots, then multiple figures will be generated, following the defined order of subplots defined in fit_setup, and each with [# rows, # columns]. tightx = Set to a true value if it is desired to have plots in the same column be closer together vertically, hiding the x-axis labels for all but the bottom plot. The x-axes will be linked so that all of the x-axes have the same scales, and change together. Especially useful for figures of several time-series signals. shot_data = a structure of the type produced by pullShotData.m. If provided, then before pulling data from servers this structure will be first checked to see if the data already exists locally. This is the same type as output by this function. This is to save time from repeatedly downloading data when unnecessary. If set to NaN, then just load all of the data first. (Default: nan = no starting data, just reload all needed) conn = an mds connection object as can be obtained from getmdsconn.m, which can be used to connect to a remote mds server. Reusing a connection save serious time in downloading data, using the getmdata.m function instead of getmds.m. Note that a connection of this type is also an output - allowing for easy reuse of connections to save time. Set to nan to ignore and just open a new connection. (Default: nan = open a new connection) slice_options = If it is desired to sync all loaded data to a common timebase, then define a structure here of the type expected by getTBase.m. See getTBase.m for how to define this structure if synchronizing timebase is desired. Set to nan to just keep the original timebase of each loaded signal. (Default: nan = keep indivicual, original signal timebases). OUTPUT: shot_data = a structure of the type produced by pullShotData.m, containing all data loaded for plotting. If the user supplied a shot_data structure as an input, the user-supplied data was used where possible, and any additional data was loaded as needed. See pullShotData.m for more detailed specification of the structure layout. fig_handles = an array of figure handles for each of the figures produced by this function while plotting. conn = a reusable mds connection object as can be obtained from getmdsconn.m, and the original user-given objust if this optional input was provided. See more details in input definition above or in getmdsconn.m EXAMPLES: plotShot(181035,{'ip','kappa:EFIT01','bmspinj'}) [shot_data,~,conn]=plotShot([181035,181041],{'ipsip','li','sysfpstrip'}) plotShot([181035,181041],{'ipsip','li','sysfpstrip'},'d3d',[],1,shot_data,conn) plotShot(95145,{'ip'},'east') plotShot(181035,bookmarks('basic','d3d'),'d3d') plotShot(181035,{'ipsip$I_p*1e6A'}) plotShot(181035,{'ip','gasTot:D@d_math&+gasa,+gasb,+gasc,+gasd,+gase'}) RESTRICTIONS: METHOD: WRITTEN BY: Jayson Barr","title":"Basic Information"},{"location":"function-guide/GAsignal/apply_inverse_filter_m/","text":"apply_inverse_filter.m \u00b6 Basic Information \u00b6 SYNTAX: [data_out,figure_num]= apply_inverse_filter(data_in,time_in,B,A,cutoff,figure_num) PURPOSE: Inverse filter data which has been filtered by a filter=B/A. The filter spectrum is inverted and multiplied by the data spectrum up to the cutoff frequency. Spectra above the corner frequency are set to 0. INPUTS: data_in = filtered data (must be uniformly sampled) time_in = time vector corresponding to data_in B,A = numerator and denominator of Laplace function description of filter cutoff = cutoff of inversion figure_num = turns on plotting of intermediate results if specified, plots beginning at figure(figure_num+1). (optional) OUTPUTS: data_out = data after inverse filtering Dependencies \u00b6","title":"apply_inverse_filter.m"},{"location":"function-guide/GAsignal/apply_inverse_filter_m/#apply_inverse_filterm","text":"","title":"apply_inverse_filter.m"},{"location":"function-guide/GAsignal/apply_inverse_filter_m/#basic-information","text":"SYNTAX: [data_out,figure_num]= apply_inverse_filter(data_in,time_in,B,A,cutoff,figure_num) PURPOSE: Inverse filter data which has been filtered by a filter=B/A. The filter spectrum is inverted and multiplied by the data spectrum up to the cutoff frequency. Spectra above the corner frequency are set to 0. INPUTS: data_in = filtered data (must be uniformly sampled) time_in = time vector corresponding to data_in B,A = numerator and denominator of Laplace function description of filter cutoff = cutoff of inversion figure_num = turns on plotting of intermediate results if specified, plots beginning at figure(figure_num+1). (optional) OUTPUTS: data_out = data after inverse filtering","title":"Basic Information"},{"location":"function-guide/GAsignal/apply_inverse_filter_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/bld_RC_filter_m/","text":"bld_RC_filter.m \u00b6 Basic Information \u00b6 SYNTAX: [num,den,RC] = bld_RC_filter(corner) PURPOSE: Build an RC filter transfer function with a given corner frequency. INPUT: corner = corner frequency (Hz) OUTPUT: num,den = transfer function of RC filter RC = RC value of filter (tau = 1/RC) Dependencies \u00b6","title":"bld_RC_filter.m"},{"location":"function-guide/GAsignal/bld_RC_filter_m/#bld_rc_filterm","text":"","title":"bld_RC_filter.m"},{"location":"function-guide/GAsignal/bld_RC_filter_m/#basic-information","text":"SYNTAX: [num,den,RC] = bld_RC_filter(corner) PURPOSE: Build an RC filter transfer function with a given corner frequency. INPUT: corner = corner frequency (Hz) OUTPUT: num,den = transfer function of RC filter RC = RC value of filter (tau = 1/RC)","title":"Basic Information"},{"location":"function-guide/GAsignal/bld_RC_filter_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/change_profile_coords_m/","text":"change_profile_coords.m \u00b6 Basic Information \u00b6 SYNTAX: profile_data = change_profile_coords(prof_data_in,coord,options) PURPOSE: Perform transformation of profile data to user-selected coordinate. INPUT: prof_data_in = data structure, which must contain the fields: time: column vector of profile times coord_vals: row vector of profile independent coordinate (normalized psi) values data: profile data, with each row a profile and time increasing down columns psimag: column vector containing psi value at magnetic axis for each time psibry: column vector containing psi value at boundary for each time coord = radial coordinates to convert to. One of: 'psi' (total poloidal flux) 'Phi' (total toroidal flux) 'rho' (GA defn of toroidal flux: sqrt(Phi^2/(pi*BT0) ) 'theta' (Lehigh coordinate: BT0*rho_bdry*rho/q ) options = structure containing optional or additional data: normalize = if 1, divide coord vals by boundary value, default 0 q_profiles = q-profile structure, needed if Phi, rho, or theta requested BT0 = Toroidal field in T at magnetic axis needed for Phi, rho, and theta, at times contained in prof_data_in. OUTPUT: profile_data = data structure, with same structure as prof_data_in RESTRICTIONS: (1) Most conversions require q profile (code complains if required). (2) Function now assumes that prof_data_in has coordinates of psinorm. This can be generalized later.","title":"change_profile_coords.m"},{"location":"function-guide/GAsignal/change_profile_coords_m/#change_profile_coordsm","text":"","title":"change_profile_coords.m"},{"location":"function-guide/GAsignal/change_profile_coords_m/#basic-information","text":"SYNTAX: profile_data = change_profile_coords(prof_data_in,coord,options) PURPOSE: Perform transformation of profile data to user-selected coordinate. INPUT: prof_data_in = data structure, which must contain the fields: time: column vector of profile times coord_vals: row vector of profile independent coordinate (normalized psi) values data: profile data, with each row a profile and time increasing down columns psimag: column vector containing psi value at magnetic axis for each time psibry: column vector containing psi value at boundary for each time coord = radial coordinates to convert to. One of: 'psi' (total poloidal flux) 'Phi' (total toroidal flux) 'rho' (GA defn of toroidal flux: sqrt(Phi^2/(pi*BT0) ) 'theta' (Lehigh coordinate: BT0*rho_bdry*rho/q ) options = structure containing optional or additional data: normalize = if 1, divide coord vals by boundary value, default 0 q_profiles = q-profile structure, needed if Phi, rho, or theta requested BT0 = Toroidal field in T at magnetic axis needed for Phi, rho, and theta, at times contained in prof_data_in. OUTPUT: profile_data = data structure, with same structure as prof_data_in RESTRICTIONS: (1) Most conversions require q profile (code complains if required). (2) Function now assumes that prof_data_in has coordinates of psinorm. This can be generalized later.","title":"Basic Information"},{"location":"function-guide/GAsignal/chirpmulti_fresp_m/","text":"chirpmulti_fresp.m \u00b6 Basic Information \u00b6 SYNTAX: [gain,phi,freq] = chirpmulti_fresp(input_d,input_t, output_d,output_t,min_freq, max_freq, in_yaxis, out_yaxis, inpowerof2, out_powerof2, npeaks, showplots) PURPOSE: multidimensional version of inout_fresp.m for chirp wave signal input. Modified from same type of algorithm for sine wave inputs. Not very successful in getting good data from chirp wave inputs because of S/N problems, so results should be viewed with suspicion. INPUT: input_d = input data vector input_t = input time vector output_d = output data vector output_t = output time vector min_freq = minimum frequency - don't look at spectrum below this max_freq = maximum frequency - don't look at spectrum above this in_yaxis = vector of ymin and ymax values for input data plots(optional) out_yaxis=vector of ymin and ymax values for output data plots(optional) powerof2 = integer = some power of 2 greater than the number of samples in either input_d or output_d, to use in fft (optional) signal is zero filled to this number. (this speeds up fft calculation as well as giving finer frequency sampling for more accurate gain/phase calculation) npeaks = number of points (peaks) in spectrum at which to compute resp. showplots= set=1 if you want to see plots, otherwise no plots (optional) OUTPUT: gain = calculated gain from input to output signal phi = calculated phase from input to output signal (degrees) freq = calculated frequency of input signal (output is checked also) RESTRICTIONS: (1) Both input and output data MUST have uniform sampling rate. (2) Both input and output data MUST represent same time window. Dependencies \u00b6 sample_time","title":"chirpmulti_fresp.m"},{"location":"function-guide/GAsignal/chirpmulti_fresp_m/#chirpmulti_frespm","text":"","title":"chirpmulti_fresp.m"},{"location":"function-guide/GAsignal/chirpmulti_fresp_m/#basic-information","text":"SYNTAX: [gain,phi,freq] = chirpmulti_fresp(input_d,input_t, output_d,output_t,min_freq, max_freq, in_yaxis, out_yaxis, inpowerof2, out_powerof2, npeaks, showplots) PURPOSE: multidimensional version of inout_fresp.m for chirp wave signal input. Modified from same type of algorithm for sine wave inputs. Not very successful in getting good data from chirp wave inputs because of S/N problems, so results should be viewed with suspicion. INPUT: input_d = input data vector input_t = input time vector output_d = output data vector output_t = output time vector min_freq = minimum frequency - don't look at spectrum below this max_freq = maximum frequency - don't look at spectrum above this in_yaxis = vector of ymin and ymax values for input data plots(optional) out_yaxis=vector of ymin and ymax values for output data plots(optional) powerof2 = integer = some power of 2 greater than the number of samples in either input_d or output_d, to use in fft (optional) signal is zero filled to this number. (this speeds up fft calculation as well as giving finer frequency sampling for more accurate gain/phase calculation) npeaks = number of points (peaks) in spectrum at which to compute resp. showplots= set=1 if you want to see plots, otherwise no plots (optional) OUTPUT: gain = calculated gain from input to output signal phi = calculated phase from input to output signal (degrees) freq = calculated frequency of input signal (output is checked also) RESTRICTIONS: (1) Both input and output data MUST have uniform sampling rate. (2) Both input and output data MUST represent same time window.","title":"Basic Information"},{"location":"function-guide/GAsignal/chirpmulti_fresp_m/#dependencies","text":"sample_time","title":"Dependencies"},{"location":"function-guide/GAsignal/clip_m/","text":"clip.m \u00b6 Basic Information \u00b6 SYNTAX: data_out = clip(data_in,minval,maxval) PURPOSE: Clip a signal and return the clipped version. INPUT: data_in = signal to be clipped minval = clip signal if below this value (either scalar or vector of same size as data_in) maxval = clip signal if above this value (either scalar or vector of same size as data_in) OUTPUT: data_out = clipped signal RESTRICTIONS: maxval >= minval Dependencies \u00b6 wait","title":"clip.m"},{"location":"function-guide/GAsignal/clip_m/#clipm","text":"","title":"clip.m"},{"location":"function-guide/GAsignal/clip_m/#basic-information","text":"SYNTAX: data_out = clip(data_in,minval,maxval) PURPOSE: Clip a signal and return the clipped version. INPUT: data_in = signal to be clipped minval = clip signal if below this value (either scalar or vector of same size as data_in) maxval = clip signal if above this value (either scalar or vector of same size as data_in) OUTPUT: data_out = clipped signal RESTRICTIONS: maxval >= minval","title":"Basic Information"},{"location":"function-guide/GAsignal/clip_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/GAsignal/correct_drift_intvals_m/","text":"correct_drift_intvals.m \u00b6 Basic Information \u00b6 SYNTAX: corrected_d = correct_drift_intvals(old_data,old_tvec,intval1,intval2) PURPOSE: Correct measured shot data for integrator drift. INPUT: old_data = data vector to correct for drift old_tvec = time vector corresponding to old_data intval1 = vector [tmin,tmax] to define offset near beginning of data intval2 = vector [tmin,tmax] to define offset near end of data (optional, default = remove offset from intval1 only) OUTPUT: corrected_d = data corrected for drift RESTRICTIONS: (1) Assumes approximately linear drift over duration of shot. METHOD: Samples are averaged in data defined by intervals to define beginning and end offsets. Beginning offset is subtracted out. A linear drift defined by the 2 offsets is assumed and corrected for in remainder of data. Dependencies \u00b6 wait","title":"correct_drift_intvals.m"},{"location":"function-guide/GAsignal/correct_drift_intvals_m/#correct_drift_intvalsm","text":"","title":"correct_drift_intvals.m"},{"location":"function-guide/GAsignal/correct_drift_intvals_m/#basic-information","text":"SYNTAX: corrected_d = correct_drift_intvals(old_data,old_tvec,intval1,intval2) PURPOSE: Correct measured shot data for integrator drift. INPUT: old_data = data vector to correct for drift old_tvec = time vector corresponding to old_data intval1 = vector [tmin,tmax] to define offset near beginning of data intval2 = vector [tmin,tmax] to define offset near end of data (optional, default = remove offset from intval1 only) OUTPUT: corrected_d = data corrected for drift RESTRICTIONS: (1) Assumes approximately linear drift over duration of shot. METHOD: Samples are averaged in data defined by intervals to define beginning and end offsets. Beginning offset is subtracted out. A linear drift defined by the 2 offsets is assumed and corrected for in remainder of data.","title":"Basic Information"},{"location":"function-guide/GAsignal/correct_drift_intvals_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/GAsignal/correct_drift_m/","text":"correct_drift.m \u00b6 Basic Information \u00b6 SYNTAX: corrected_d = correct_drift(old_data, old_tvec, nsamples, sampleloc) PURPOSE: Correct measured shot data for integrator drift. INPUT: old_data = data vector to correct for drift old_tvec = time vector corresponding to old_data nsamples = optional number of samples to use to calculate average offset at beginning and end (default 25) sampleloc= optional location of \"end\" (1st, last) set of samples for defining the average offset at \"end\" (default is last sample of vector) if not specified, or specified as a number <0, default=data length OUTPUT: corrected_d = data corrected for drift RESTRICTIONS: (1) Assumes approximately linear drift over duration of shot. (2) MUST HAVE >=28 samples both at beginning and end of shot from which to calculate beginning and end offsets (UNLESS nsamples < 25). METHOD: Samples are averaged at beginning and end of data to define beginning and end offsets. Beginning offset is subtracted out. A linear drift defined by the 2 offsets is assumed and corrected for in remainder of data. SEE ALSO: correct_drift_intvals Dependencies \u00b6","title":"correct_drift.m"},{"location":"function-guide/GAsignal/correct_drift_m/#correct_driftm","text":"","title":"correct_drift.m"},{"location":"function-guide/GAsignal/correct_drift_m/#basic-information","text":"SYNTAX: corrected_d = correct_drift(old_data, old_tvec, nsamples, sampleloc) PURPOSE: Correct measured shot data for integrator drift. INPUT: old_data = data vector to correct for drift old_tvec = time vector corresponding to old_data nsamples = optional number of samples to use to calculate average offset at beginning and end (default 25) sampleloc= optional location of \"end\" (1st, last) set of samples for defining the average offset at \"end\" (default is last sample of vector) if not specified, or specified as a number <0, default=data length OUTPUT: corrected_d = data corrected for drift RESTRICTIONS: (1) Assumes approximately linear drift over duration of shot. (2) MUST HAVE >=28 samples both at beginning and end of shot from which to calculate beginning and end offsets (UNLESS nsamples < 25). METHOD: Samples are averaged at beginning and end of data to define beginning and end offsets. Beginning offset is subtracted out. A linear drift defined by the 2 offsets is assumed and corrected for in remainder of data. SEE ALSO: correct_drift_intvals","title":"Basic Information"},{"location":"function-guide/GAsignal/correct_drift_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/correlate_m/","text":"correlate.m \u00b6 Basic Information \u00b6 SYNTAX: [corrfn,time] = correlate(data1,time1,data2,time2,dt,zl) PURPOSE: Compute approximation of analog correlation function: corrfn(t) = integral_{-infinity}^{+infinity} data1(s) data2(s+t) ds Numerical integration is done so that amplitude is approx. correct to represent the cross-correlation of the two continuous signals which these sampled data signals represent. Corresponding time data is produced rather than just sample indices. INPUT: data1, time1 = first signal data2, time2 = second signal (optional, if no 2nd signal then autocorrelation of 1st signal is computed) dt = time between samples (optional, default = min dt of time1, time2) zl = zero level = multiplier of average absolute value of computed correlation function, used to eliminate \"zero\" values at beginning and end of correlation function (optional, default = 1e-8). Set=0 to prevent zero eliminations. OUTPUT: corrfn, time = correlation function (either cross- or auto-) Dependencies \u00b6 resamplev sample_time","title":"correlate.m"},{"location":"function-guide/GAsignal/correlate_m/#correlatem","text":"","title":"correlate.m"},{"location":"function-guide/GAsignal/correlate_m/#basic-information","text":"SYNTAX: [corrfn,time] = correlate(data1,time1,data2,time2,dt,zl) PURPOSE: Compute approximation of analog correlation function: corrfn(t) = integral_{-infinity}^{+infinity} data1(s) data2(s+t) ds Numerical integration is done so that amplitude is approx. correct to represent the cross-correlation of the two continuous signals which these sampled data signals represent. Corresponding time data is produced rather than just sample indices. INPUT: data1, time1 = first signal data2, time2 = second signal (optional, if no 2nd signal then autocorrelation of 1st signal is computed) dt = time between samples (optional, default = min dt of time1, time2) zl = zero level = multiplier of average absolute value of computed correlation function, used to eliminate \"zero\" values at beginning and end of correlation function (optional, default = 1e-8). Set=0 to prevent zero eliminations. OUTPUT: corrfn, time = correlation function (either cross- or auto-)","title":"Basic Information"},{"location":"function-guide/GAsignal/correlate_m/#dependencies","text":"resamplev sample_time","title":"Dependencies"},{"location":"function-guide/GAsignal/detect_peaks_m/","text":"detect_peaks.m \u00b6 Basic Information \u00b6 SYNTAX: peak_locs = detect_peaks(data) PURPOSE: Find locations of local maxima of input data signal. INPUT: data = data to detect peaks in OUTPUT: peak_locs = sample numbers where peaks are located RESTRICTIONS: Use input -data to find local minima. Dependencies \u00b6","title":"detect_peaks.m"},{"location":"function-guide/GAsignal/detect_peaks_m/#detect_peaksm","text":"","title":"detect_peaks.m"},{"location":"function-guide/GAsignal/detect_peaks_m/#basic-information","text":"SYNTAX: peak_locs = detect_peaks(data) PURPOSE: Find locations of local maxima of input data signal. INPUT: data = data to detect peaks in OUTPUT: peak_locs = sample numbers where peaks are located RESTRICTIONS: Use input -data to find local minima.","title":"Basic Information"},{"location":"function-guide/GAsignal/detect_peaks_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/est_gamma_m/","text":"est_gamma.m \u00b6 Basic Information \u00b6 SYNTAX: [gam_est, zfit] = est_gamma(z_data,t_data,dtsm,iplot,fig_num1) PURPOSE: Estimate growth rate for exponential function of form z(t) = z00 + dz0*exp(gamma*t) INPUTS: z_data = z(t) data t_data = t vector dtsm = time interval for smoothdt (same units as t_data) iplot = flag to enable plotting: 1=plots,0=no plots(def) (optional) fig_num1 = first fig number to use, increments from there (optional, default = 1) OUTPUTS: gam_est = estimated growth rate (rad/units of t_data) zfit = fitted z(t) to test RESTRICTIONS: Units of dtsm must be same units as t_data METHOD: Take derivative of smoothed signal to eliminate z00, smooth, take deriv of log of that signal, average middle of signal to get gam_est. Then should use fit_gamma with the result... Dependencies \u00b6 deriv smoothdt fit_gamma","title":"est_gamma.m"},{"location":"function-guide/GAsignal/est_gamma_m/#est_gammam","text":"","title":"est_gamma.m"},{"location":"function-guide/GAsignal/est_gamma_m/#basic-information","text":"SYNTAX: [gam_est, zfit] = est_gamma(z_data,t_data,dtsm,iplot,fig_num1) PURPOSE: Estimate growth rate for exponential function of form z(t) = z00 + dz0*exp(gamma*t) INPUTS: z_data = z(t) data t_data = t vector dtsm = time interval for smoothdt (same units as t_data) iplot = flag to enable plotting: 1=plots,0=no plots(def) (optional) fig_num1 = first fig number to use, increments from there (optional, default = 1) OUTPUTS: gam_est = estimated growth rate (rad/units of t_data) zfit = fitted z(t) to test RESTRICTIONS: Units of dtsm must be same units as t_data METHOD: Take derivative of smoothed signal to eliminate z00, smooth, take deriv of log of that signal, average middle of signal to get gam_est. Then should use fit_gamma with the result...","title":"Basic Information"},{"location":"function-guide/GAsignal/est_gamma_m/#dependencies","text":"deriv smoothdt fit_gamma","title":"Dependencies"},{"location":"function-guide/GAsignal/find_delay_m/","text":"find_delay.m \u00b6 Basic Information \u00b6 SYNTAX: delay = find_delay(shotnum,ptname1,ptname2) PURPOSE: Find delay time between ptname1 and ptname2. Assumes they are both seperately digitized versions of the same signal. INPUT: shotnum = shot number ptname1 = first ptname ptname2 = second ptname OUTPUT: delay = time difference between the 2 (should be identical) signals Dependencies \u00b6 zero_crossings time_slice","title":"find_delay.m"},{"location":"function-guide/GAsignal/find_delay_m/#find_delaym","text":"","title":"find_delay.m"},{"location":"function-guide/GAsignal/find_delay_m/#basic-information","text":"SYNTAX: delay = find_delay(shotnum,ptname1,ptname2) PURPOSE: Find delay time between ptname1 and ptname2. Assumes they are both seperately digitized versions of the same signal. INPUT: shotnum = shot number ptname1 = first ptname ptname2 = second ptname OUTPUT: delay = time difference between the 2 (should be identical) signals","title":"Basic Information"},{"location":"function-guide/GAsignal/find_delay_m/#dependencies","text":"zero_crossings time_slice","title":"Dependencies"},{"location":"function-guide/GAsignal/find_local_max_m/","text":"find_local_max.m \u00b6 Basic Information \u00b6 SYNTAX: maxloc = find_local_max(x,y,max_locs,binsize) PURPOSE: find local maxima INPUT: x = x data for array y y = data to find local maxima in max_locs - number of maxima locations binsize = bin size - find only the max value in each bin of this size OUTPUT: maxloc = indices in arrays (x,y) of maxima Dependencies \u00b6","title":"find_local_max.m"},{"location":"function-guide/GAsignal/find_local_max_m/#find_local_maxm","text":"","title":"find_local_max.m"},{"location":"function-guide/GAsignal/find_local_max_m/#basic-information","text":"SYNTAX: maxloc = find_local_max(x,y,max_locs,binsize) PURPOSE: find local maxima INPUT: x = x data for array y y = data to find local maxima in max_locs - number of maxima locations binsize = bin size - find only the max value in each bin of this size OUTPUT: maxloc = indices in arrays (x,y) of maxima","title":"Basic Information"},{"location":"function-guide/GAsignal/find_local_max_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/find_vertices_m/","text":"find_vertices.m \u00b6 Basic Information \u00b6 SYNTAX: [x,y] = find_vertices(t,d,tol) PURPOSE: Find the vertices in a piecewise linear data. INPUT: d,t = data and time of piecewise linear data. tol = tolerance to determine when slope changes (optional,default=1e-3) OUTPUT: x,y = vertices where data \"breaks\" Dependencies \u00b6","title":"find_vertices.m"},{"location":"function-guide/GAsignal/find_vertices_m/#find_verticesm","text":"","title":"find_vertices.m"},{"location":"function-guide/GAsignal/find_vertices_m/#basic-information","text":"SYNTAX: [x,y] = find_vertices(t,d,tol) PURPOSE: Find the vertices in a piecewise linear data. INPUT: d,t = data and time of piecewise linear data. tol = tolerance to determine when slope changes (optional,default=1e-3) OUTPUT: x,y = vertices where data \"breaks\"","title":"Basic Information"},{"location":"function-guide/GAsignal/find_vertices_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/fit_gamma_m/","text":"fit_gamma.m \u00b6 Basic Information \u00b6 SYNTAX: [gamma,z_fit,residual,p,resnorm,exitflag,output] = ... fit_gamma(z_data,t_data,p_guess) PURPOSE: Fits offset exponential growth to z_data. Assumed form is therefore z(t-t_data(1))=z00 + dz0*exp(gamma*(t-t_data(1))) INPUTS: z_data = Data vector to be fitted t_data = Time vector for fitting p_guess = Initial guess for [z00,dz0,gamma] OUTPUTS: z_fit = Fitted data vector gamma = Fitted growth rate p = Fitted parameters [z00,dz0,gamma] residual = Residual vector resnorm = Squared 2-norm of residual exitflag = Describes why fit terminated (see lsqcurvefit help) output = Structure of fitting statistics RESTRICTIONS: METHOD: Least square fitting","title":"fit_gamma.m"},{"location":"function-guide/GAsignal/fit_gamma_m/#fit_gammam","text":"","title":"fit_gamma.m"},{"location":"function-guide/GAsignal/fit_gamma_m/#basic-information","text":"SYNTAX: [gamma,z_fit,residual,p,resnorm,exitflag,output] = ... fit_gamma(z_data,t_data,p_guess) PURPOSE: Fits offset exponential growth to z_data. Assumed form is therefore z(t-t_data(1))=z00 + dz0*exp(gamma*(t-t_data(1))) INPUTS: z_data = Data vector to be fitted t_data = Time vector for fitting p_guess = Initial guess for [z00,dz0,gamma] OUTPUTS: z_fit = Fitted data vector gamma = Fitted growth rate p = Fitted parameters [z00,dz0,gamma] residual = Residual vector resnorm = Squared 2-norm of residual exitflag = Describes why fit terminated (see lsqcurvefit help) output = Structure of fitting statistics RESTRICTIONS: METHOD: Least square fitting","title":"Basic Information"},{"location":"function-guide/GAsignal/fit_n012_m/","text":"fit_n012.m \u00b6 Basic Information \u00b6 SYNTAX: [amplitudes,phases,err,dtst] = fit_n012(t,data,angs,iplot); PURPOSE: Decompose data into n=0, n=1, n=2 components for each time point in t. INPUTS: t = time vector (nt,1) data = data array (nt,nangs) angs = vector of nangs angles corr. to columns of data array [degrees] iplot = (optional) flag to select plotting of error: iplot>0 plots (iplot=fig.num.), iplot=0 doesn't. Default=0 OUTPUTS: amplitudes = array of amplitudes over time (nt,3) = [a0(nt,1) a1(nt,1) a2(nt,1) phases = array of phase data over time (nt,3) (radians) = [zeros(nt,1) phi1(nt,1) phi2(nt,1)] (note that initial column of zeros is dummy) err = vector of RMS av error sum over angs as fraction of a0 (nt,1) dtst = signal composed of sum of n=0,1,2 components RESTRICTIONS: All elements of angs must lie in range 0<= angs <360. Angles must monotonically increase (and no repetitions in particular). Data must be real. METHOD: Simple linear fit of sin,cos basis functions. For each time point fits to corresponding row of data. Function for fitting is: a0 + a1*sin(1*ang + phi1) + a2*sin(2*ang + phi2) ...where rows of amplitudes contain [a0 a1 a2] and rows of phases contain [0 phi1 phi2]. The actual representation used in the fit is a0 + c1*sin(1*ang) + d1*cos(1*ang) + c2*sin(2*ang) + d2*cos(2*ang) ...which is converted to the amplitude,phase data for output. Dependencies \u00b6","title":"fit_n012.m"},{"location":"function-guide/GAsignal/fit_n012_m/#fit_n012m","text":"","title":"fit_n012.m"},{"location":"function-guide/GAsignal/fit_n012_m/#basic-information","text":"SYNTAX: [amplitudes,phases,err,dtst] = fit_n012(t,data,angs,iplot); PURPOSE: Decompose data into n=0, n=1, n=2 components for each time point in t. INPUTS: t = time vector (nt,1) data = data array (nt,nangs) angs = vector of nangs angles corr. to columns of data array [degrees] iplot = (optional) flag to select plotting of error: iplot>0 plots (iplot=fig.num.), iplot=0 doesn't. Default=0 OUTPUTS: amplitudes = array of amplitudes over time (nt,3) = [a0(nt,1) a1(nt,1) a2(nt,1) phases = array of phase data over time (nt,3) (radians) = [zeros(nt,1) phi1(nt,1) phi2(nt,1)] (note that initial column of zeros is dummy) err = vector of RMS av error sum over angs as fraction of a0 (nt,1) dtst = signal composed of sum of n=0,1,2 components RESTRICTIONS: All elements of angs must lie in range 0<= angs <360. Angles must monotonically increase (and no repetitions in particular). Data must be real. METHOD: Simple linear fit of sin,cos basis functions. For each time point fits to corresponding row of data. Function for fitting is: a0 + a1*sin(1*ang + phi1) + a2*sin(2*ang + phi2) ...where rows of amplitudes contain [a0 a1 a2] and rows of phases contain [0 phi1 phi2]. The actual representation used in the fit is a0 + c1*sin(1*ang) + d1*cos(1*ang) + c2*sin(2*ang) + d2*cos(2*ang) ...which is converted to the amplitude,phase data for output.","title":"Basic Information"},{"location":"function-guide/GAsignal/fit_n012_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/inout_fresp_m/","text":"inout_fresp.m \u00b6 Basic Information \u00b6 SYNTAX: fresp = inout_fresp(fresp_inputs) PURPOSE: Calculate frequency response for a generic input/output pair of sinusoidal signals. DC components of both signals are removed before calculating response. INPUT: fresp_inputs = structure containing: out_num = output number for output_d (use 1 if only one output) input_d = input data vector input_t = input time vector output_d = output data vector or matrix (i.e., one output per column) output_t = output time vector max_search_f = maximum frequency - don't look for spectral peaks past this max_plot_f = maximum frequency in plot of spectra of input/output signals And optionally: powerof2 = integer = some power of 2 greater than the number of samples in either input_d or output_d, to use in fft (optional) signal is zero filled to this number. (this speeds up fft calculation as well as giving finer frequency sampling for more accurate gain/phase calculation) showplots= set>=1 to see plots used in freq response calculation, otherwise 0 (default), use a value > 1 to cause program to wait after each plot reject_thresh = thresholds for declaring response = NaN when problems with data, e.g. input/output frequencies don't match, or SNR of output too small = [freq_thresh (), snr_thresh (dB)] (default = 10, 0 dB) verbose = set > 0 to get printed diagnostic information (larger numbers => more info) OUTPUT: fresp = structure containing: gain = calculated gain from input to output signal phi = calculated phase from input to output signal (degrees) freq = calculated frequency of input signal (output is checked also) max_in = maximum amplitude of input signal max_out= maximum amplitude of output signal RESTRICTIONS: (1) Both input and output data MUST have uniform sampling rate. (2) Both input and output data MUST represent same time window. Dependencies \u00b6 wait sample_time","title":"inout_fresp.m"},{"location":"function-guide/GAsignal/inout_fresp_m/#inout_frespm","text":"","title":"inout_fresp.m"},{"location":"function-guide/GAsignal/inout_fresp_m/#basic-information","text":"SYNTAX: fresp = inout_fresp(fresp_inputs) PURPOSE: Calculate frequency response for a generic input/output pair of sinusoidal signals. DC components of both signals are removed before calculating response. INPUT: fresp_inputs = structure containing: out_num = output number for output_d (use 1 if only one output) input_d = input data vector input_t = input time vector output_d = output data vector or matrix (i.e., one output per column) output_t = output time vector max_search_f = maximum frequency - don't look for spectral peaks past this max_plot_f = maximum frequency in plot of spectra of input/output signals And optionally: powerof2 = integer = some power of 2 greater than the number of samples in either input_d or output_d, to use in fft (optional) signal is zero filled to this number. (this speeds up fft calculation as well as giving finer frequency sampling for more accurate gain/phase calculation) showplots= set>=1 to see plots used in freq response calculation, otherwise 0 (default), use a value > 1 to cause program to wait after each plot reject_thresh = thresholds for declaring response = NaN when problems with data, e.g. input/output frequencies don't match, or SNR of output too small = [freq_thresh (), snr_thresh (dB)] (default = 10, 0 dB) verbose = set > 0 to get printed diagnostic information (larger numbers => more info) OUTPUT: fresp = structure containing: gain = calculated gain from input to output signal phi = calculated phase from input to output signal (degrees) freq = calculated frequency of input signal (output is checked also) max_in = maximum amplitude of input signal max_out= maximum amplitude of output signal RESTRICTIONS: (1) Both input and output data MUST have uniform sampling rate. (2) Both input and output data MUST represent same time window.","title":"Basic Information"},{"location":"function-guide/GAsignal/inout_fresp_m/#dependencies","text":"wait sample_time","title":"Dependencies"},{"location":"function-guide/GAsignal/integrate2D_m/","text":"integrate2D.m \u00b6 Basic Information \u00b6 SYNTAX: integral = integrate2D(x,y,z,xmin,xmax,ymin,ymax) PURPOSE: Compute approximate integral of data defined over an x-y grid. INPUT: z = data over grid x,y = x and y coordinates where data z is given xmin,xmax = x limits of integration (must be inside defined x values) (optional, default = min and max from x vector ymin,ymax = y limits of integration (must be inside defined y values) (optional, default = min and max from y vector OUTPUT: integral = value of integral Dependencies \u00b6","title":"integrate2D.m"},{"location":"function-guide/GAsignal/integrate2D_m/#integrate2dm","text":"","title":"integrate2D.m"},{"location":"function-guide/GAsignal/integrate2D_m/#basic-information","text":"SYNTAX: integral = integrate2D(x,y,z,xmin,xmax,ymin,ymax) PURPOSE: Compute approximate integral of data defined over an x-y grid. INPUT: z = data over grid x,y = x and y coordinates where data z is given xmin,xmax = x limits of integration (must be inside defined x values) (optional, default = min and max from x vector ymin,ymax = y limits of integration (must be inside defined y values) (optional, default = min and max from y vector OUTPUT: integral = value of integral","title":"Basic Information"},{"location":"function-guide/GAsignal/integrate2D_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/integrate_m/","text":"integrate.m \u00b6 Basic Information \u00b6 SYNTAX: integral = integrate(y,x,x1,x2,dx) PURPOSE: Calculate definite integral of y from x1 to x2 (approx.). INPUT: y = data y(x) to integrate x = independent variable corresponding to data y x1 = lower limit of integration x2 = upper limit of integration dx = fixed sampling rate (optional, default = compute from vector x) OUTPUT: integral = value of (approximate) integral RESTRICTIONS: (1) Right now, requires FIXED sampling rate. Can be upgraded to handle multiple sampling domains with some work. (2) To integrate from -infinity use x(1), to +infinity use x(end). This assumes that support of function y is captured by vector x. See also: integrate_t Dependencies \u00b6 sample_time","title":"integrate.m"},{"location":"function-guide/GAsignal/integrate_m/#integratem","text":"","title":"integrate.m"},{"location":"function-guide/GAsignal/integrate_m/#basic-information","text":"SYNTAX: integral = integrate(y,x,x1,x2,dx) PURPOSE: Calculate definite integral of y from x1 to x2 (approx.). INPUT: y = data y(x) to integrate x = independent variable corresponding to data y x1 = lower limit of integration x2 = upper limit of integration dx = fixed sampling rate (optional, default = compute from vector x) OUTPUT: integral = value of (approximate) integral RESTRICTIONS: (1) Right now, requires FIXED sampling rate. Can be upgraded to handle multiple sampling domains with some work. (2) To integrate from -infinity use x(1), to +infinity use x(end). This assumes that support of function y is captured by vector x. See also: integrate_t","title":"Basic Information"},{"location":"function-guide/GAsignal/integrate_m/#dependencies","text":"sample_time","title":"Dependencies"},{"location":"function-guide/GAsignal/integrate_t_m/","text":"integrate_t.m \u00b6 Basic Information \u00b6 SYNTAX: integral_t = integrate_t(data,time,t1,t2,IC,deltat,method) PURPOSE: Calculate indefinite integral of data from t1 to t (approx.) on interval [t1,t2]. INPUT: data = data to integrate (if more than one data vector, time vector must correspond to increasing row number) time = time corresponding to data t1 = lower limit of integration t2 = upper limit of integration IC = initial condition vector, size=1 x (# columns of data) (optional, default=0) deltat = fixed sampling rate (optional) method = set to 0 for rectangular (faster), 1 for trapezoidal (default) OUTPUT: integral_t = vector defined on time vector representing (approximately) integral of function data(t) from t1 to t. RESTRICTIONS: Right now, requires FIXED sampling rate. Can be upgraded to handle multiple time domains with some work. METHOD: Uses trapezoidal integration. (Assumes linear interpolation between samples.) Dependencies \u00b6 wait","title":"integrate_t.m"},{"location":"function-guide/GAsignal/integrate_t_m/#integrate_tm","text":"","title":"integrate_t.m"},{"location":"function-guide/GAsignal/integrate_t_m/#basic-information","text":"SYNTAX: integral_t = integrate_t(data,time,t1,t2,IC,deltat,method) PURPOSE: Calculate indefinite integral of data from t1 to t (approx.) on interval [t1,t2]. INPUT: data = data to integrate (if more than one data vector, time vector must correspond to increasing row number) time = time corresponding to data t1 = lower limit of integration t2 = upper limit of integration IC = initial condition vector, size=1 x (# columns of data) (optional, default=0) deltat = fixed sampling rate (optional) method = set to 0 for rectangular (faster), 1 for trapezoidal (default) OUTPUT: integral_t = vector defined on time vector representing (approximately) integral of function data(t) from t1 to t. RESTRICTIONS: Right now, requires FIXED sampling rate. Can be upgraded to handle multiple time domains with some work. METHOD: Uses trapezoidal integration. (Assumes linear interpolation between samples.)","title":"Basic Information"},{"location":"function-guide/GAsignal/integrate_t_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/GAsignal/linearfit2_m/","text":"linearfit2.m \u00b6 Basic Information \u00b6 SYNTAX: [p,norm_error] = linearfit2(data) PURPOSE: Do a linear fit to data of y = p(1) + p(2)*x. This version assumes that the data is both x and y data. INPUT: data = 2 column matrix, 1st col. = independent variable, 2nd = dependent OUTPUT: p = vector of length 2: p(1) = constant offset p(2) = linear multiplier SEE ALSO: linearfit Dependencies \u00b6","title":"linearfit2.m"},{"location":"function-guide/GAsignal/linearfit2_m/#linearfit2m","text":"","title":"linearfit2.m"},{"location":"function-guide/GAsignal/linearfit2_m/#basic-information","text":"SYNTAX: [p,norm_error] = linearfit2(data) PURPOSE: Do a linear fit to data of y = p(1) + p(2)*x. This version assumes that the data is both x and y data. INPUT: data = 2 column matrix, 1st col. = independent variable, 2nd = dependent OUTPUT: p = vector of length 2: p(1) = constant offset p(2) = linear multiplier SEE ALSO: linearfit","title":"Basic Information"},{"location":"function-guide/GAsignal/linearfit2_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/linearfit_m/","text":"linearfit.m \u00b6 Basic Information \u00b6 SYNTAX: [x,norm_error] = linearfit(data) PURPOSE: Do a linear fit to data and return intercept=x(1), slope=x(2). Also produce a plot overlaying line on the data for inspection. INPUT: data = vector of data to fit OUTPUT: x = intercept x(1) and slope x(2) of a line fit to data norm_error = normalized error between data and fitted line SEE ALSO: linearfit2 Dependencies \u00b6 lin_error","title":"linearfit.m"},{"location":"function-guide/GAsignal/linearfit_m/#linearfitm","text":"","title":"linearfit.m"},{"location":"function-guide/GAsignal/linearfit_m/#basic-information","text":"SYNTAX: [x,norm_error] = linearfit(data) PURPOSE: Do a linear fit to data and return intercept=x(1), slope=x(2). Also produce a plot overlaying line on the data for inspection. INPUT: data = vector of data to fit OUTPUT: x = intercept x(1) and slope x(2) of a line fit to data norm_error = normalized error between data and fitted line SEE ALSO: linearfit2","title":"Basic Information"},{"location":"function-guide/GAsignal/linearfit_m/#dependencies","text":"lin_error","title":"Dependencies"},{"location":"function-guide/GAsignal/make_stepfn_m/","text":"make_stepfn.m \u00b6 Basic Information \u00b6 SYNTAX: [d,t] = make_stepfn(data,time,timevec) PURPOSE: Make a step function from given (time,data) pairs and sampled on a given time base. INPUT: data = data to create step function from time = time vector corresponding to data timevec = times at which to create steps OUTPUT: d = step function data t = time vector for d (= timevec) RESTRICTIONS: This function assumes that timevec is much finer sampled than time vector. I don't know what happens if this is not true. SEE ALSO: stepfn Dependencies \u00b6","title":"make_stepfn.m"},{"location":"function-guide/GAsignal/make_stepfn_m/#make_stepfnm","text":"","title":"make_stepfn.m"},{"location":"function-guide/GAsignal/make_stepfn_m/#basic-information","text":"SYNTAX: [d,t] = make_stepfn(data,time,timevec) PURPOSE: Make a step function from given (time,data) pairs and sampled on a given time base. INPUT: data = data to create step function from time = time vector corresponding to data timevec = times at which to create steps OUTPUT: d = step function data t = time vector for d (= timevec) RESTRICTIONS: This function assumes that timevec is much finer sampled than time vector. I don't know what happens if this is not true. SEE ALSO: stepfn","title":"Basic Information"},{"location":"function-guide/GAsignal/make_stepfn_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/median_filter_m/","text":"median_filter.m \u00b6 Basic Information \u00b6 SYNTAX: result = median_filter(signal,filterlen) PURPOSE: median filter applied to a vector INPUT: signal = vector to filter filterlen = number of samples to use in median calculation (odd) OUTPUT: result = vector after median filtering SEE ALSO: percentile_filter Dependencies \u00b6","title":"median_filter.m"},{"location":"function-guide/GAsignal/median_filter_m/#median_filterm","text":"","title":"median_filter.m"},{"location":"function-guide/GAsignal/median_filter_m/#basic-information","text":"SYNTAX: result = median_filter(signal,filterlen) PURPOSE: median filter applied to a vector INPUT: signal = vector to filter filterlen = number of samples to use in median calculation (odd) OUTPUT: result = vector after median filtering SEE ALSO: percentile_filter","title":"Basic Information"},{"location":"function-guide/GAsignal/median_filter_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/percentile_filter_m/","text":"percentile_filter.m \u00b6 Basic Information \u00b6 SYNTAX: result = percentile_filter(signal,filterlen,percent) PURPOSE: Percentile filter applied to a vector. Percentile filter is a generalization of a median filter (median = 50). INPUT: signal = vector to filter filterlen = number of samples to use in filter window percent = specifies which sample to select out of filter window OUTPUT: result = vector after percentile filtering SEE ALSO: median_filter Dependencies \u00b6","title":"percentile_filter.m"},{"location":"function-guide/GAsignal/percentile_filter_m/#percentile_filterm","text":"","title":"percentile_filter.m"},{"location":"function-guide/GAsignal/percentile_filter_m/#basic-information","text":"SYNTAX: result = percentile_filter(signal,filterlen,percent) PURPOSE: Percentile filter applied to a vector. Percentile filter is a generalization of a median filter (median = 50). INPUT: signal = vector to filter filterlen = number of samples to use in filter window percent = specifies which sample to select out of filter window OUTPUT: result = vector after percentile filtering SEE ALSO: median_filter","title":"Basic Information"},{"location":"function-guide/GAsignal/percentile_filter_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/sample_time_m/","text":"sample_time.m \u00b6 Basic Information \u00b6 SYNTAX: [t0, dt, n] = sample_time(time_vec, sensitivity) PURPOSE: Gets the initial sampling time(s) and sampling interval(s) defined by the time vector. If the time between samples is not uniform the outputs will be vectors. INPUT: time_vec = time vector (usually returned by getptd) sensitivity = fraction of min time step to be used to detect change in time step (optional, default = 1e-2) OUTPUT: t0 = initial sample time beginning each time segment having different sample times dt = time between samples in each segment n = sample numbers corresponding to each t0 RESTRICTIONS: Certain time vectors, notably those corresponding to chopper data, have numerically nonuniform sampling over ANY interval and this procedure fails to return meaningful results. Dependencies \u00b6","title":"sample_time.m"},{"location":"function-guide/GAsignal/sample_time_m/#sample_timem","text":"","title":"sample_time.m"},{"location":"function-guide/GAsignal/sample_time_m/#basic-information","text":"SYNTAX: [t0, dt, n] = sample_time(time_vec, sensitivity) PURPOSE: Gets the initial sampling time(s) and sampling interval(s) defined by the time vector. If the time between samples is not uniform the outputs will be vectors. INPUT: time_vec = time vector (usually returned by getptd) sensitivity = fraction of min time step to be used to detect change in time step (optional, default = 1e-2) OUTPUT: t0 = initial sample time beginning each time segment having different sample times dt = time between samples in each segment n = sample numbers corresponding to each t0 RESTRICTIONS: Certain time vectors, notably those corresponding to chopper data, have numerically nonuniform sampling over ANY interval and this procedure fails to return meaningful results.","title":"Basic Information"},{"location":"function-guide/GAsignal/sample_time_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/shift_signal_m/","text":"shift_signal.m \u00b6 Basic Information \u00b6 SYNTAX: shift = shift_signal(signal,ishift, circular) PURPOSE: Shift signal by ishift samples INPUT: signal = signal to shift ishift = number of samples to shift (ishift>0 is shift to right) circular = set to 1 if signal is assumed circular, else 0 fill at ends (optional, default = 0) OUTPUT: shift = shifted signal Dependencies \u00b6","title":"shift_signal.m"},{"location":"function-guide/GAsignal/shift_signal_m/#shift_signalm","text":"","title":"shift_signal.m"},{"location":"function-guide/GAsignal/shift_signal_m/#basic-information","text":"SYNTAX: shift = shift_signal(signal,ishift, circular) PURPOSE: Shift signal by ishift samples INPUT: signal = signal to shift ishift = number of samples to shift (ishift>0 is shift to right) circular = set to 1 if signal is assumed circular, else 0 fill at ends (optional, default = 0) OUTPUT: shift = shifted signal","title":"Basic Information"},{"location":"function-guide/GAsignal/shift_signal_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/smoothdt_m/","text":"smoothdt.m \u00b6 Basic Information \u00b6 SYNTAX: dsmo = smoothdt(data,time,dtbox) dsmo = smoothdt(ts,dtbox) PURPOSE: Boxcar-average data within time intervals dtbox If data is a matrix, size(data,1) should equal length(time) INPUT: data = vector or matrix with data to smooth time = time vector, or just the time between samples dtbox = width of time window for smoothing ts = timeseries object OUTPUT: dsmo = data after boxcar smoothing Dependencies \u00b6","title":"smoothdt.m"},{"location":"function-guide/GAsignal/smoothdt_m/#smoothdtm","text":"","title":"smoothdt.m"},{"location":"function-guide/GAsignal/smoothdt_m/#basic-information","text":"SYNTAX: dsmo = smoothdt(data,time,dtbox) dsmo = smoothdt(ts,dtbox) PURPOSE: Boxcar-average data within time intervals dtbox If data is a matrix, size(data,1) should equal length(time) INPUT: data = vector or matrix with data to smooth time = time vector, or just the time between samples dtbox = width of time window for smoothing ts = timeseries object OUTPUT: dsmo = data after boxcar smoothing","title":"Basic Information"},{"location":"function-guide/GAsignal/smoothdt_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/spectrum_m/","text":"spectrum.m \u00b6 Basic Information \u00b6 SYNTAX: [spectrum_d,spectrum_f]=spectrum(data_vec,time_vec,... zero_fill,sample_check) PURPOSE: calculate spectrum of (uniformly sampled) data INPUT: data_vec = data vector to calculate spectrum for time_vec = corresponding time vector zero_fill = number of samples to fill out to with zeros (optional) sample_check= set=0 to turn off checking for uniform sampling (optional) OUTPUT: spectrum_d = spectrum data - fft divided by number of input samples spectrum_f = spectrum frequencies in Hz (frequency corresp. to each data sample) RESTRICTIONS: METHOD: The computed spectrum is normalized so that when a cosine wave signal is processed, a spectrum s(f) is produced with s(f0)+conj(s(-f0)) = amplitude of cosine wave, and phase approximately=0, where f0 is the frequency of the cosine wave Dependencies \u00b6 sample_time","title":"spectrum.m"},{"location":"function-guide/GAsignal/spectrum_m/#spectrumm","text":"","title":"spectrum.m"},{"location":"function-guide/GAsignal/spectrum_m/#basic-information","text":"SYNTAX: [spectrum_d,spectrum_f]=spectrum(data_vec,time_vec,... zero_fill,sample_check) PURPOSE: calculate spectrum of (uniformly sampled) data INPUT: data_vec = data vector to calculate spectrum for time_vec = corresponding time vector zero_fill = number of samples to fill out to with zeros (optional) sample_check= set=0 to turn off checking for uniform sampling (optional) OUTPUT: spectrum_d = spectrum data - fft divided by number of input samples spectrum_f = spectrum frequencies in Hz (frequency corresp. to each data sample) RESTRICTIONS: METHOD: The computed spectrum is normalized so that when a cosine wave signal is processed, a spectrum s(f) is produced with s(f0)+conj(s(-f0)) = amplitude of cosine wave, and phase approximately=0, where f0 is the frequency of the cosine wave","title":"Basic Information"},{"location":"function-guide/GAsignal/spectrum_m/#dependencies","text":"sample_time","title":"Dependencies"},{"location":"function-guide/GAsignal/stepfn_m/","text":"stepfn.m \u00b6 Basic Information \u00b6 SYNTAX: [dnew,tnew] = stepfn(d,t) PURPOSE: Make step function from sampled data. Use make_stepfn if you need uniformly sampled output data. INPUT: d = input data t = input time OUTPUT: dnew = output data tnew = output time (this WILL NOT be uniformly sampled) SEE ALSO: make_stepfn Dependencies \u00b6","title":"stepfn.m"},{"location":"function-guide/GAsignal/stepfn_m/#stepfnm","text":"","title":"stepfn.m"},{"location":"function-guide/GAsignal/stepfn_m/#basic-information","text":"SYNTAX: [dnew,tnew] = stepfn(d,t) PURPOSE: Make step function from sampled data. Use make_stepfn if you need uniformly sampled output data. INPUT: d = input data t = input time OUTPUT: dnew = output data tnew = output time (this WILL NOT be uniformly sampled) SEE ALSO: make_stepfn","title":"Basic Information"},{"location":"function-guide/GAsignal/stepfn_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/subsample_m/","text":"subsample.m \u00b6 Basic Information \u00b6 SYNTAX: [new_data,new_tvec] = subsample(old_data, old_tvec, increment, k0) PURPOSE: Subsample data vector at increments of \"increment\", starting at sample k0. INPUT: old_data = data to subsample (if data is matrix, time corresp. to column) old_tvec = time vector corresponding to old_data increment = increment to subsample (can be a vector) k0 = sample numbers at which to start subsampling (optional, default=1) (data is returned only for samples >= k0(1) ) EXAMPLE: If increment = [10 100], then k0 must exist and be the same size say, k0=[1 1000]. Then time and data vectors would be subsampled every 10 samples between 1 and 1000 (i.e. 1, 11, 21, 31, ..., 991) and every 100 samples thereafter until the end of the data. OUTPUT: new_data = subsampled data new_tvec = time vector corresponding to new_data Dependencies \u00b6","title":"subsample.m"},{"location":"function-guide/GAsignal/subsample_m/#subsamplem","text":"","title":"subsample.m"},{"location":"function-guide/GAsignal/subsample_m/#basic-information","text":"SYNTAX: [new_data,new_tvec] = subsample(old_data, old_tvec, increment, k0) PURPOSE: Subsample data vector at increments of \"increment\", starting at sample k0. INPUT: old_data = data to subsample (if data is matrix, time corresp. to column) old_tvec = time vector corresponding to old_data increment = increment to subsample (can be a vector) k0 = sample numbers at which to start subsampling (optional, default=1) (data is returned only for samples >= k0(1) ) EXAMPLE: If increment = [10 100], then k0 must exist and be the same size say, k0=[1 1000]. Then time and data vectors would be subsampled every 10 samples between 1 and 1000 (i.e. 1, 11, 21, 31, ..., 991) and every 100 samples thereafter until the end of the data. OUTPUT: new_data = subsampled data new_tvec = time vector corresponding to new_data","title":"Basic Information"},{"location":"function-guide/GAsignal/subsample_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/taufilter_m/","text":"taufilter.m \u00b6 Basic Information \u00b6 USAGE: dataf = taufilter(data,time,tau,dataf0) PURPOSE: Filter a signal with a one pole filter having a given time constant tau. INPUT: data = data to filter time = time values associated with each data point (in seconds) (can be uniformly or non-uniformly sampled) tau = time constant of filter (in seconds) dataf0 = initial value of filtered data (set to 0 for default) OUTPUT: dataf = filtered data Dependencies \u00b6","title":"taufilter.m"},{"location":"function-guide/GAsignal/taufilter_m/#taufilterm","text":"","title":"taufilter.m"},{"location":"function-guide/GAsignal/taufilter_m/#basic-information","text":"USAGE: dataf = taufilter(data,time,tau,dataf0) PURPOSE: Filter a signal with a one pole filter having a given time constant tau. INPUT: data = data to filter time = time values associated with each data point (in seconds) (can be uniformly or non-uniformly sampled) tau = time constant of filter (in seconds) dataf0 = initial value of filtered data (set to 0 for default) OUTPUT: dataf = filtered data","title":"Basic Information"},{"location":"function-guide/GAsignal/taufilter_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/GAsignal/zero_crossings_m/","text":"zero_crossings.m \u00b6 Basic Information \u00b6 SYNTAX: [ldg_edge_smple,trl_edge_smple,ldg_edge,trl_edge] = zero_crossings(data,time) PURPOSE: Estimate locations (sample indices) where data crosses zero. Optionally computes estimated times of zero crossings. INPUT: data = data vector to find zero crossings in time = time vector corresponding to data (optional, when input the ldg_edge and trl_edge outputs are computed) OUTPUT: ldg_edge_smple = sample numbers in \"data\" where data will cross zero with a positive slope going to next sample trl_edge_smple = sample numbers in \"data\" where data will cross zero with a negative slope going to next sample ldg_edge = time values corresponding to estimated zero crossing value trl_edge = time values corresponding to estimated zero crossing value Dependencies \u00b6","title":"zero_crossings.m"},{"location":"function-guide/GAsignal/zero_crossings_m/#zero_crossingsm","text":"","title":"zero_crossings.m"},{"location":"function-guide/GAsignal/zero_crossings_m/#basic-information","text":"SYNTAX: [ldg_edge_smple,trl_edge_smple,ldg_edge,trl_edge] = zero_crossings(data,time) PURPOSE: Estimate locations (sample indices) where data crosses zero. Optionally computes estimated times of zero crossings. INPUT: data = data vector to find zero crossings in time = time vector corresponding to data (optional, when input the ldg_edge and trl_edge outputs are computed) OUTPUT: ldg_edge_smple = sample numbers in \"data\" where data will cross zero with a positive slope going to next sample trl_edge_smple = sample numbers in \"data\" where data will cross zero with a negative slope going to next sample ldg_edge = time values corresponding to estimated zero crossing value trl_edge = time values corresponding to estimated zero crossing value","title":"Basic Information"},{"location":"function-guide/GAsignal/zero_crossings_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/PCS/bld_flux_err_m/","text":"bld_flux_err.m \u00b6 Basic Information \u00b6 SYNTAX: [flux_err,nerrors] = ... bld_flux_err(algorithm,isonms,iso_refs,ref_num,Xpt_cntl,units,bias) PURPOSE: Build the flux_err matrix needed to convert from absolute flux at the segment control points to relative flux (abs. flux - flux at the X point) INPUT: algorithm = one of 'isodnull', 'isosnull', or 'isousnull' isonms = names of isoflux segments iso_refs = isoflux reference signals ref_num = index of reference signal used by each segment in isonms Xpt_cntl = define type of control to use on Xpt(s), in pairs of [R,Z], e.g. ['S','X'] indicates R should be controlled by strike point, while Z should be controlled at the X point. For LSN or USN, use one pair while for DND, use two consecutive pairs, i.e. [R1,Z1,R2,Z2]. (optional, default = ['X','X'] for LSN, USN, ['X','X','X','X'] for DND) units = either 'Wb' or 'Wb/rad' (as in PCS), defining units for flux errors (optional, default = 'Wb') bias = used only if algorithm = 'isodnull'; one of: 1 = upper-bias shape (DRSEP>0) 0 = balanced shape (DRSEP=0) -1 = lower-bias shape (DRSEP<0) OUTPUT: flux_err = matrix to compute errors from flux values on isoflux segments. Columns are: isodnull: seg.flux,psi_grid1,BrBz_grid1,psi_grid2,BrBz_grid2,Fcoils others: seg.flux, psi_grid1, BrBz_grid1, Fcoils Rows are: isodnull: seg.flux_errs,BrBz_grid1,BrBz_grid2,symmetry_err,Fcoils others: seg.flux_errs, BrBz_grid1, Fcoils nerrors = number of rows corresponding to isoflux errors RESTRICTIONS: NOTE that this code assumes errors are in units of Wb, while in the PCS, they actually come in as Wb/rad. (Units conversion must be done.) Dependencies \u00b6 wait","title":"bld_flux_err.m"},{"location":"function-guide/PCS/bld_flux_err_m/#bld_flux_errm","text":"","title":"bld_flux_err.m"},{"location":"function-guide/PCS/bld_flux_err_m/#basic-information","text":"SYNTAX: [flux_err,nerrors] = ... bld_flux_err(algorithm,isonms,iso_refs,ref_num,Xpt_cntl,units,bias) PURPOSE: Build the flux_err matrix needed to convert from absolute flux at the segment control points to relative flux (abs. flux - flux at the X point) INPUT: algorithm = one of 'isodnull', 'isosnull', or 'isousnull' isonms = names of isoflux segments iso_refs = isoflux reference signals ref_num = index of reference signal used by each segment in isonms Xpt_cntl = define type of control to use on Xpt(s), in pairs of [R,Z], e.g. ['S','X'] indicates R should be controlled by strike point, while Z should be controlled at the X point. For LSN or USN, use one pair while for DND, use two consecutive pairs, i.e. [R1,Z1,R2,Z2]. (optional, default = ['X','X'] for LSN, USN, ['X','X','X','X'] for DND) units = either 'Wb' or 'Wb/rad' (as in PCS), defining units for flux errors (optional, default = 'Wb') bias = used only if algorithm = 'isodnull'; one of: 1 = upper-bias shape (DRSEP>0) 0 = balanced shape (DRSEP=0) -1 = lower-bias shape (DRSEP<0) OUTPUT: flux_err = matrix to compute errors from flux values on isoflux segments. Columns are: isodnull: seg.flux,psi_grid1,BrBz_grid1,psi_grid2,BrBz_grid2,Fcoils others: seg.flux, psi_grid1, BrBz_grid1, Fcoils Rows are: isodnull: seg.flux_errs,BrBz_grid1,BrBz_grid2,symmetry_err,Fcoils others: seg.flux_errs, BrBz_grid1, Fcoils nerrors = number of rows corresponding to isoflux errors RESTRICTIONS: NOTE that this code assumes errors are in units of Wb, while in the PCS, they actually come in as Wb/rad. (Units conversion must be done.)","title":"Basic Information"},{"location":"function-guide/PCS/bld_flux_err_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/PCS/bld_isoflux_response_m/","text":"bld_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: [Gcntl,Gcntlbetap,Gcntlli] = bld_isoflux_response(isoflux_defns, ... tok_system,RX,ZX,good_X_pt,do_model_validation,output_objs) PURPOSE: Build the Greens functions to isoflux segments and grid to incorporate into output equation of state space model. INPUT: isoflux_defns = structure containing: nsegments = number of segments in isoflux control ngrids = number of segments in isoflux control segment_resp_flag = scalar or vector value. If vector, this is the set of indices in each control segment to use to define response. If scalar, 1=average over segment, otherwise use center point. bgrid_resp_loc = scalar or vector. If vector, these are the (R,Z) target location(s) ([R,Z] or [R1,Z1,R2,Z2]). If scalar, 1= average over grid, 2=use pt nearest equil Xpt, else use grid center. tok_system = data structure created by build_tokamak_system.m RX,ZX = if only 1 Xpt grid, these define Xpt location for calculation of shape response; for DND, these are length 2 vectors, first entry for bottom Xpt,2nd for top (used only if bgrid_resp_loc=2) good_X_pt = set to 1 if values of RX, ZX are known good, else 0 do_model_validation = output_objs = data structure created by plasma_output.m OUTPUT: Gcntl = response of flux at isoflux control points and field at Xpts to changes in conductor currents. Outputs = [nsegments fluxes(Wb), flux,Br,Bz at Xpt1(Wb,T), flux,Br,Bz at Xpt2(Wb,T)] Inputs = currents conductors (E,F,vv,Ip). Units = A. Gcntlbetap = response of betap to same conductors Gcntlli = response of li to same conductors Dependencies \u00b6 wait","title":"bld_isoflux_response.m"},{"location":"function-guide/PCS/bld_isoflux_response_m/#bld_isoflux_responsem","text":"","title":"bld_isoflux_response.m"},{"location":"function-guide/PCS/bld_isoflux_response_m/#basic-information","text":"SYNTAX: [Gcntl,Gcntlbetap,Gcntlli] = bld_isoflux_response(isoflux_defns, ... tok_system,RX,ZX,good_X_pt,do_model_validation,output_objs) PURPOSE: Build the Greens functions to isoflux segments and grid to incorporate into output equation of state space model. INPUT: isoflux_defns = structure containing: nsegments = number of segments in isoflux control ngrids = number of segments in isoflux control segment_resp_flag = scalar or vector value. If vector, this is the set of indices in each control segment to use to define response. If scalar, 1=average over segment, otherwise use center point. bgrid_resp_loc = scalar or vector. If vector, these are the (R,Z) target location(s) ([R,Z] or [R1,Z1,R2,Z2]). If scalar, 1= average over grid, 2=use pt nearest equil Xpt, else use grid center. tok_system = data structure created by build_tokamak_system.m RX,ZX = if only 1 Xpt grid, these define Xpt location for calculation of shape response; for DND, these are length 2 vectors, first entry for bottom Xpt,2nd for top (used only if bgrid_resp_loc=2) good_X_pt = set to 1 if values of RX, ZX are known good, else 0 do_model_validation = output_objs = data structure created by plasma_output.m OUTPUT: Gcntl = response of flux at isoflux control points and field at Xpts to changes in conductor currents. Outputs = [nsegments fluxes(Wb), flux,Br,Bz at Xpt1(Wb,T), flux,Br,Bz at Xpt2(Wb,T)] Inputs = currents conductors (E,F,vv,Ip). Units = A. Gcntlbetap = response of betap to same conductors Gcntlli = response of li to same conductors","title":"Basic Information"},{"location":"function-guide/PCS/bld_isoflux_response_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/PCS/calc_PCS_PID_response_m/","text":"calc_PCS_PID_response.m \u00b6 Basic Information \u00b6 SYNTAX: PIDsys = calc_PCS_PID_response(dt,Gp,Gd,Gi,taup,taud,taui) PURPOSE: Compute (digital) frequency response of PCS PID implementation. (Response is nearly, but not quite, independent of dt - for dt small enough. Put in a reasonable approximate value.) INPUT: dt = sample time Gp = proportional gain Gd = derivative gain Gi = integral gain taup = proportional time constant (sec) taud = derivative time constant (sec) taui = integral time constant (sec) OUTPUT: PIDsys = digital transfer function model of PID algorithm (control toolbox packed format) Dependencies \u00b6 calc_PID_coeff","title":"calc_PCS_PID_response.m"},{"location":"function-guide/PCS/calc_PCS_PID_response_m/#calc_pcs_pid_responsem","text":"","title":"calc_PCS_PID_response.m"},{"location":"function-guide/PCS/calc_PCS_PID_response_m/#basic-information","text":"SYNTAX: PIDsys = calc_PCS_PID_response(dt,Gp,Gd,Gi,taup,taud,taui) PURPOSE: Compute (digital) frequency response of PCS PID implementation. (Response is nearly, but not quite, independent of dt - for dt small enough. Put in a reasonable approximate value.) INPUT: dt = sample time Gp = proportional gain Gd = derivative gain Gi = integral gain taup = proportional time constant (sec) taud = derivative time constant (sec) taui = integral time constant (sec) OUTPUT: PIDsys = digital transfer function model of PID algorithm (control toolbox packed format)","title":"Basic Information"},{"location":"function-guide/PCS/calc_PCS_PID_response_m/#dependencies","text":"calc_PID_coeff","title":"Dependencies"},{"location":"function-guide/PCS/calc_PID_coeff_m/","text":"calc_PID_coeff.m \u00b6 Basic Information \u00b6 SYNTAX: [P1,P2,D1,D2,I1,I2] = calc_PID_coeff(dt,taup,taud,taui) PURPOSE: Calculate PID coefficients as computed by PCS. Discrete filters constructed from these coefficients are: proportional: P1(z+1)/(z+P2) derivative: D1(z-1)/(z+D2) integral: I1(z+1)/(z+I2) INPUT: dt = sample time taup = proportional time constant (sec) taud = derivative time constant (sec) taui = integral time constant (sec) OUTPUT: P1,P2 = proportional calculation coefficients D1,D2 = derivative calculation coefficients I1,I2 = integral calculation coefficients","title":"calc_PID_coeff.m"},{"location":"function-guide/PCS/calc_PID_coeff_m/#calc_pid_coeffm","text":"","title":"calc_PID_coeff.m"},{"location":"function-guide/PCS/calc_PID_coeff_m/#basic-information","text":"SYNTAX: [P1,P2,D1,D2,I1,I2] = calc_PID_coeff(dt,taup,taud,taui) PURPOSE: Calculate PID coefficients as computed by PCS. Discrete filters constructed from these coefficients are: proportional: P1(z+1)/(z+P2) derivative: D1(z-1)/(z+D2) integral: I1(z+1)/(z+I2) INPUT: dt = sample time taup = proportional time constant (sec) taud = derivative time constant (sec) taui = integral time constant (sec) OUTPUT: P1,P2 = proportional calculation coefficients D1,D2 = derivative calculation coefficients I1,I2 = integral calculation coefficients","title":"Basic Information"},{"location":"function-guide/PCS/calc_isoflux_response_m/","text":"calc_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: [sizedata,control_pts,mutuals,brgreens,bzgreens] = ... calc_isoflux_response(seg_grid_name,dir,tok_data_struct) PURPOSE: Compute response to isoflux points and grids. INPUT: seg_grid_name = segment or grid name (e.g. '0degree', 'bot_3cm') dir = directory where data files defining isoflux objects stored tok_data_struct= vacuum model data objects structure OUTPUT: sizedata = structure defining contents of response data (see help for segment_response.m) control_pts = control points at which responses computed mutuals = mutuals, current sources (coils,vessel,grid) to control pts brgreens = green fns, current sources (coils,vessel,grid) to control pts bzgreens = green fns, current sources (coils,vessel,grid) to control pts (Units of current = Amp-turns. Flux is in Wb/rad. Field is in Tesla.) RESTRICTIONS: METHOD: Checks that seg_grid_name matches one of names in response_input_<device>.txt (i.e. exists as an rtefit response object), then computes response the same way as computed for rtefit.","title":"calc_isoflux_response.m"},{"location":"function-guide/PCS/calc_isoflux_response_m/#calc_isoflux_responsem","text":"","title":"calc_isoflux_response.m"},{"location":"function-guide/PCS/calc_isoflux_response_m/#basic-information","text":"SYNTAX: [sizedata,control_pts,mutuals,brgreens,bzgreens] = ... calc_isoflux_response(seg_grid_name,dir,tok_data_struct) PURPOSE: Compute response to isoflux points and grids. INPUT: seg_grid_name = segment or grid name (e.g. '0degree', 'bot_3cm') dir = directory where data files defining isoflux objects stored tok_data_struct= vacuum model data objects structure OUTPUT: sizedata = structure defining contents of response data (see help for segment_response.m) control_pts = control points at which responses computed mutuals = mutuals, current sources (coils,vessel,grid) to control pts brgreens = green fns, current sources (coils,vessel,grid) to control pts bzgreens = green fns, current sources (coils,vessel,grid) to control pts (Units of current = Amp-turns. Flux is in Wb/rad. Field is in Tesla.) RESTRICTIONS: METHOD: Checks that seg_grid_name matches one of names in response_input_<device>.txt (i.e. exists as an rtefit response object), then computes response the same way as computed for rtefit.","title":"Basic Information"},{"location":"function-guide/PCS/classify_param_names_m/","text":"classify_param_names.m \u00b6 Basic Information \u00b6 SYNTAX: [matrices, labeled_data, misc] = classify_param_names(list) PURPOSE: Get parameter data from the PCS setup file. INPUT: list = character matrix whose rows are parameter data block names, typically generated from a call to get_param_names OUTPUT: matrices = cell array of strings listing matrix block labeled_data = cell array of strings listing standard, labeled, data blocks with fields :data and :labels misc = cell array of strings listing blocks not classified as either matrices or labeled_data.","title":"classify_param_names.m"},{"location":"function-guide/PCS/classify_param_names_m/#classify_param_namesm","text":"","title":"classify_param_names.m"},{"location":"function-guide/PCS/classify_param_names_m/#basic-information","text":"SYNTAX: [matrices, labeled_data, misc] = classify_param_names(list) PURPOSE: Get parameter data from the PCS setup file. INPUT: list = character matrix whose rows are parameter data block names, typically generated from a call to get_param_names OUTPUT: matrices = cell array of strings listing matrix block labeled_data = cell array of strings listing standard, labeled, data blocks with fields :data and :labels misc = cell array of strings listing blocks not classified as either matrices or labeled_data.","title":"Basic Information"},{"location":"function-guide/PCS/get_cat_names_m/","text":"get_cat_names.m \u00b6 Basic Information \u00b6 SYNTAX: names = get_cat_names(shot,[server]) PURPOSE: Retrieves the names of the PCS categories for a given shot INPUT: shot = shot number to get category names data from [server] = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a category name. If none found, is empty matrix []. Dependencies \u00b6 get_pcs_server","title":"get_cat_names.m"},{"location":"function-guide/PCS/get_cat_names_m/#get_cat_namesm","text":"","title":"get_cat_names.m"},{"location":"function-guide/PCS/get_cat_names_m/#basic-information","text":"SYNTAX: names = get_cat_names(shot,[server]) PURPOSE: Retrieves the names of the PCS categories for a given shot INPUT: shot = shot number to get category names data from [server] = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a category name. If none found, is empty matrix [].","title":"Basic Information"},{"location":"function-guide/PCS/get_cat_names_m/#dependencies","text":"get_pcs_server","title":"Dependencies"},{"location":"function-guide/PCS/get_command_channels_m/","text":"get_command_channels.m \u00b6 Basic Information \u00b6 SYNTAX: [channels,cpus,gains,names] = get_command_channels(pcs_dir,tokamak,category,signal_names) PURPOSE: Get the command channel indices, cpu numbers that produces each command, and gain of the digital-to-analog convertor that sends out the command, for all commands to be used by simserver. Supports use of command signals from any category. INPUT: pcs_dir = directory where PCS has already been built tokamak = tokamak corresponding to PCS (one of 'd3d','east','kstar','nstx-u') category = string defining category whose commands are to be used OR 'default' (the standard PCS commands); the category is the short name in macros like CMD_<name>*, CMDA_<name>* in simulation_includes.m. Usually these are the same as those listed in categories.h, but not always. signal_names = cell array with names of command signals to be used by simserver or 'all' (optional; if not specified, the only valid returned argument is \"names\") OUTPUT: channels = vector of indices of the command channels comprising the PCS interface output, indexed from 1 cpus = vector of cpu numbers where intcom values are coming from, indexed from 1 gains = vector of DAC gains, indexed from 1 names = struct with fields = channel_names,gain_names, cpu_names, each providing a list of preprocessor variables defined for the specified tokamak and category (currently not returned if category='default') See also get_command_indices, get_cpu_indices, and get_command_da_gain for fetching DEFAULT commands Dependencies \u00b6 get_cpu_indices get_command_indices get_command_da_gain wait make_function truncate_header","title":"get_command_channels.m"},{"location":"function-guide/PCS/get_command_channels_m/#get_command_channelsm","text":"","title":"get_command_channels.m"},{"location":"function-guide/PCS/get_command_channels_m/#basic-information","text":"SYNTAX: [channels,cpus,gains,names] = get_command_channels(pcs_dir,tokamak,category,signal_names) PURPOSE: Get the command channel indices, cpu numbers that produces each command, and gain of the digital-to-analog convertor that sends out the command, for all commands to be used by simserver. Supports use of command signals from any category. INPUT: pcs_dir = directory where PCS has already been built tokamak = tokamak corresponding to PCS (one of 'd3d','east','kstar','nstx-u') category = string defining category whose commands are to be used OR 'default' (the standard PCS commands); the category is the short name in macros like CMD_<name>*, CMDA_<name>* in simulation_includes.m. Usually these are the same as those listed in categories.h, but not always. signal_names = cell array with names of command signals to be used by simserver or 'all' (optional; if not specified, the only valid returned argument is \"names\") OUTPUT: channels = vector of indices of the command channels comprising the PCS interface output, indexed from 1 cpus = vector of cpu numbers where intcom values are coming from, indexed from 1 gains = vector of DAC gains, indexed from 1 names = struct with fields = channel_names,gain_names, cpu_names, each providing a list of preprocessor variables defined for the specified tokamak and category (currently not returned if category='default') See also get_command_indices, get_cpu_indices, and get_command_da_gain for fetching DEFAULT commands","title":"Basic Information"},{"location":"function-guide/PCS/get_command_channels_m/#dependencies","text":"get_cpu_indices get_command_indices get_command_da_gain wait make_function truncate_header","title":"Dependencies"},{"location":"function-guide/PCS/get_command_da_gain_m/","text":"get_command_da_gain.m \u00b6 Basic Information \u00b6 USAGE: get_command_da_gain(ind_struct,commands,single,tokamak) PURPOSE: returns the digital-to-analog convertor (DAC) gains for given commands INPUTS: ind_struct structure data from simulation_includes.m commands cell array commands used as input into simulink simulation single if 1, return only a single value for gain tokamak name of tokamak OUTPUTS: gain: multiplier that converts DAC output volts to input counts (DA_GAIN in io_PCS.c) Dependencies \u00b6","title":"get_command_da_gain.m"},{"location":"function-guide/PCS/get_command_da_gain_m/#get_command_da_gainm","text":"","title":"get_command_da_gain.m"},{"location":"function-guide/PCS/get_command_da_gain_m/#basic-information","text":"USAGE: get_command_da_gain(ind_struct,commands,single,tokamak) PURPOSE: returns the digital-to-analog convertor (DAC) gains for given commands INPUTS: ind_struct structure data from simulation_includes.m commands cell array commands used as input into simulink simulation single if 1, return only a single value for gain tokamak name of tokamak OUTPUTS: gain: multiplier that converts DAC output volts to input counts (DA_GAIN in io_PCS.c)","title":"Basic Information"},{"location":"function-guide/PCS/get_command_da_gain_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/PCS/get_command_indices_m/","text":"get_command_indices.m \u00b6 Basic Information \u00b6 USAGE: indices = get_command_indices(ind_struct,commands,tokamak) PURPOSE: returns the channel indices given contents of simulation_input.m and a list of command names used in a simulink simulation INPUTS: ind_struct structure data from simulation_includes.m commands cell array commands used as input into simulink simulation OUTPUTS: indices integer array array of indexes linking commands with their associated values as specified by simulation_includes.m (in the INTEL_DIR directory) RESTRICTIONS: METHOD: Get this from CMD variables in simulation_includes.m Every PCS uses some different naming convention. Dependencies \u00b6","title":"get_command_indices.m"},{"location":"function-guide/PCS/get_command_indices_m/#get_command_indicesm","text":"","title":"get_command_indices.m"},{"location":"function-guide/PCS/get_command_indices_m/#basic-information","text":"USAGE: indices = get_command_indices(ind_struct,commands,tokamak) PURPOSE: returns the channel indices given contents of simulation_input.m and a list of command names used in a simulink simulation INPUTS: ind_struct structure data from simulation_includes.m commands cell array commands used as input into simulink simulation OUTPUTS: indices integer array array of indexes linking commands with their associated values as specified by simulation_includes.m (in the INTEL_DIR directory) RESTRICTIONS: METHOD: Get this from CMD variables in simulation_includes.m Every PCS uses some different naming convention.","title":"Basic Information"},{"location":"function-guide/PCS/get_command_indices_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/PCS/get_cpu_indices_m/","text":"get_cpu_indices.m \u00b6 Basic Information \u00b6 USAGE: get_cpu_indices PURPOSE: returns the cpu indices given contents of simulation_input.m and a list of command names used in a simulink simulation INPUTS: ind_struct structure data from simulation_input.m commands cell array commands used as input into simulink simulation OUTPUTS: cpus integer array array of indices linking commands with their associated cpus as specified by simulation_input.m RESTRICTIONS: METHOD: Get this from CPU variables in simulation_includes.m Every PCS uses some different naming convention. Dependencies \u00b6","title":"get_cpu_indices.m"},{"location":"function-guide/PCS/get_cpu_indices_m/#get_cpu_indicesm","text":"","title":"get_cpu_indices.m"},{"location":"function-guide/PCS/get_cpu_indices_m/#basic-information","text":"USAGE: get_cpu_indices PURPOSE: returns the cpu indices given contents of simulation_input.m and a list of command names used in a simulink simulation INPUTS: ind_struct structure data from simulation_input.m commands cell array commands used as input into simulink simulation OUTPUTS: cpus integer array array of indices linking commands with their associated cpus as specified by simulation_input.m RESTRICTIONS: METHOD: Get this from CPU variables in simulation_includes.m Every PCS uses some different naming convention.","title":"Basic Information"},{"location":"function-guide/PCS/get_cpu_indices_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/PCS/get_input_channels_m/","text":"get_input_channels.m \u00b6 Basic Information \u00b6 SYNTAX: [channels,names] = get_input_channels(pcs_dir,input_signals) PURPOSE: Fetch indices for PCS input signal channels, or provide names of input channels to choose from. INPUT: pcs_dir = directory where PCS has already been built input_signals = cell array of selected input signal names or 'all' to list all possible names in 2nd output argument OUTPUT: channels = indices of selected signals names = names of selected signals ind = the indices in input_signals for which channels were found Dependencies \u00b6 wait","title":"get_input_channels.m"},{"location":"function-guide/PCS/get_input_channels_m/#get_input_channelsm","text":"","title":"get_input_channels.m"},{"location":"function-guide/PCS/get_input_channels_m/#basic-information","text":"SYNTAX: [channels,names] = get_input_channels(pcs_dir,input_signals) PURPOSE: Fetch indices for PCS input signal channels, or provide names of input channels to choose from. INPUT: pcs_dir = directory where PCS has already been built input_signals = cell array of selected input signal names or 'all' to list all possible names in 2nd output argument OUTPUT: channels = indices of selected signals names = names of selected signals ind = the indices in input_signals for which channels were found","title":"Basic Information"},{"location":"function-guide/PCS/get_input_channels_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/PCS/get_param_names_m/","text":"get_param_names.m \u00b6 Basic Information \u00b6 SYNTAX: names = get_param_names(shot, category, phase, server) PURPOSE: Retrieves the names of the PCS parameter data blocks for a given shot,category, and phase. INPUT: shot = shot number to get category names data from category = pcs category phase = pcs phase server = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a parameter name. If none found, is empty matrix []. Dependencies \u00b6 get_pcs_server","title":"get_param_names.m"},{"location":"function-guide/PCS/get_param_names_m/#get_param_namesm","text":"","title":"get_param_names.m"},{"location":"function-guide/PCS/get_param_names_m/#basic-information","text":"SYNTAX: names = get_param_names(shot, category, phase, server) PURPOSE: Retrieves the names of the PCS parameter data blocks for a given shot,category, and phase. INPUT: shot = shot number to get category names data from category = pcs category phase = pcs phase server = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a parameter name. If none found, is empty matrix [].","title":"Basic Information"},{"location":"function-guide/PCS/get_param_names_m/#dependencies","text":"get_pcs_server","title":"Dependencies"},{"location":"function-guide/PCS/get_pcs_server_m/","text":"get_pcs_server.m \u00b6 Basic Information \u00b6 SYNTAX: name = get_pcs_server(server) PURPOSE: Determine name of mds server to use in fetching PCS data. INPUT: server = name of mds server to get data from. Specify as one of: - actual server name - device name (e.g. 'd3d', 'nstx') to get remote mds server - device name followed by ':local' to get local mds server - empty or missing argument - use default processing - 'local' - use default processing to get local server (Default is to use remote server for the device currently at the top of matlab search path, or local version if \"local\" specified.) OUTPUT: name = name of server Dependencies \u00b6 strlen","title":"get_pcs_server.m"},{"location":"function-guide/PCS/get_pcs_server_m/#get_pcs_serverm","text":"","title":"get_pcs_server.m"},{"location":"function-guide/PCS/get_pcs_server_m/#basic-information","text":"SYNTAX: name = get_pcs_server(server) PURPOSE: Determine name of mds server to use in fetching PCS data. INPUT: server = name of mds server to get data from. Specify as one of: - actual server name - device name (e.g. 'd3d', 'nstx') to get remote mds server - device name followed by ':local' to get local mds server - empty or missing argument - use default processing - 'local' - use default processing to get local server (Default is to use remote server for the device currently at the top of matlab search path, or local version if \"local\" specified.) OUTPUT: name = name of server","title":"Basic Information"},{"location":"function-guide/PCS/get_pcs_server_m/#dependencies","text":"strlen","title":"Dependencies"},{"location":"function-guide/PCS/get_pcssetup_calib_m/","text":"get_pcssetup_calib.m \u00b6 Basic Information \u00b6 SYNTAX: [calib,ptnames,ier]=get_pcssetup_calib(shotnum,idebug); PURPOSE: Get PCS shot diagniostic calibration data from shot startup file INPUT: shotnum = shot number to extract calibration data idebug = 1 for debug output [0] OUTPUT: calib = Calibration matrix [rc gain inherent_number vtophys] ptnames= Name of each dignostic, one for each row of calib ier = 0 if everything OK, else nonzero RESTRICTIONS: METHOD: Uses get_pcssetup_calib.c to read pcs setup data stored in ptdata Dependencies \u00b6 get_pcssetup_calib","title":"get_pcssetup_calib.m"},{"location":"function-guide/PCS/get_pcssetup_calib_m/#get_pcssetup_calibm","text":"","title":"get_pcssetup_calib.m"},{"location":"function-guide/PCS/get_pcssetup_calib_m/#basic-information","text":"SYNTAX: [calib,ptnames,ier]=get_pcssetup_calib(shotnum,idebug); PURPOSE: Get PCS shot diagniostic calibration data from shot startup file INPUT: shotnum = shot number to extract calibration data idebug = 1 for debug output [0] OUTPUT: calib = Calibration matrix [rc gain inherent_number vtophys] ptnames= Name of each dignostic, one for each row of calib ier = 0 if everything OK, else nonzero RESTRICTIONS: METHOD: Uses get_pcssetup_calib.c to read pcs setup data stored in ptdata","title":"Basic Information"},{"location":"function-guide/PCS/get_pcssetup_calib_m/#dependencies","text":"get_pcssetup_calib","title":"Dependencies"},{"location":"function-guide/PCS/get_pcssetup_m/","text":"get_pcssetup.m \u00b6 Basic Information \u00b6 SYNTAX: [data,ier] = get_pcssetup(shot,category,phase,data_name,server,debug) PURPOSE: Get parameter data from the PCS setup file. INPUT: shot = shot number to get data from category = one of the categories from PCS (e.g. \"Discharge Shape\", \"Error Field\", \"Neutral Beams\", etc.). CASE SENSITIVE phase = name of phase from PCS (e.g. \"ShotStart\") CASE SENSITIVE data_name = CASE INSENSITIVE server = server name (see get_pcs_server for processing of this input) debug (optional) = flag, set = 1 to get debug prints, else 0 OUTPUT: data = data structure containing parameter data with any relevant labels ier = error code, 0 = everything OK","title":"get_pcssetup.m"},{"location":"function-guide/PCS/get_pcssetup_m/#get_pcssetupm","text":"","title":"get_pcssetup.m"},{"location":"function-guide/PCS/get_pcssetup_m/#basic-information","text":"SYNTAX: [data,ier] = get_pcssetup(shot,category,phase,data_name,server,debug) PURPOSE: Get parameter data from the PCS setup file. INPUT: shot = shot number to get data from category = one of the categories from PCS (e.g. \"Discharge Shape\", \"Error Field\", \"Neutral Beams\", etc.). CASE SENSITIVE phase = name of phase from PCS (e.g. \"ShotStart\") CASE SENSITIVE data_name = CASE INSENSITIVE server = server name (see get_pcs_server for processing of this input) debug (optional) = flag, set = 1 to get debug prints, else 0 OUTPUT: data = data structure containing parameter data with any relevant labels ier = error code, 0 = everything OK","title":"Basic Information"},{"location":"function-guide/PCS/get_pcssetup_struct_m/","text":"get_pcssetup_struct.m \u00b6 Basic Information \u00b6 SYNTAX: setup = get_pcssetup_struct(shot, server, debug) PURPOSE: Get all parameter data from the PCS setup file and load it into a single matlab data structure. INPUT: shot = shot number to get data from server = server name (see get_pcs_server for processing of this input) debug = flag, set = 1 to get debug prints, else 0 OUTPUT: setup Each category/phase combination has three types of data, each of which is represented in the setup strucuture as a sub-structure. The matrices field contains data from matrix parameter data blocks. The labeled_data field contains structured data with labels. The misc field contains data that does not fit into the matrix or labeled data classifications. Setup has the following structure: setup. (category). --Struct. Name of pcs category. Spaces are replaced with '_'. If the leading character is a number, 'x' is prepended. (phase). --Struct. Name of pcs phase. Spaces are replaced with '_' If the leading character is a number, 'x' is prepended. matrices. --array of structs-- param_name --char array-- dims. --struct-- nmatrices nrows ncols matrix_names --char matrix-- col_names --char matrix-- row_names --char matrix-- data --3d matrix-- labeled_data --array of structs-- param_name --char array-- data_fields. --array of structs-- label --char array-- data misc param_name --char array-- data -- See note below-- Note on misc.data: When non-labeled or non-matrix data is retrieved, it is formatted one of two ways. If the data has a single field, then misc.data simply holds that fields data (e.g. misc.data = [3 3]). If the data has multiple fields, then misc.data has sub-fields with names field_0 ... field_N where N is the number of fields.","title":"get_pcssetup_struct.m"},{"location":"function-guide/PCS/get_pcssetup_struct_m/#get_pcssetup_structm","text":"","title":"get_pcssetup_struct.m"},{"location":"function-guide/PCS/get_pcssetup_struct_m/#basic-information","text":"SYNTAX: setup = get_pcssetup_struct(shot, server, debug) PURPOSE: Get all parameter data from the PCS setup file and load it into a single matlab data structure. INPUT: shot = shot number to get data from server = server name (see get_pcs_server for processing of this input) debug = flag, set = 1 to get debug prints, else 0 OUTPUT: setup Each category/phase combination has three types of data, each of which is represented in the setup strucuture as a sub-structure. The matrices field contains data from matrix parameter data blocks. The labeled_data field contains structured data with labels. The misc field contains data that does not fit into the matrix or labeled data classifications. Setup has the following structure: setup. (category). --Struct. Name of pcs category. Spaces are replaced with '_'. If the leading character is a number, 'x' is prepended. (phase). --Struct. Name of pcs phase. Spaces are replaced with '_' If the leading character is a number, 'x' is prepended. matrices. --array of structs-- param_name --char array-- dims. --struct-- nmatrices nrows ncols matrix_names --char matrix-- col_names --char matrix-- row_names --char matrix-- data --3d matrix-- labeled_data --array of structs-- param_name --char array-- data_fields. --array of structs-- label --char array-- data misc param_name --char array-- data -- See note below-- Note on misc.data: When non-labeled or non-matrix data is retrieved, it is formatted one of two ways. If the data has a single field, then misc.data simply holds that fields data (e.g. misc.data = [3 3]). If the data has multiple fields, then misc.data has sub-fields with names field_0 ... field_N where N is the number of fields.","title":"Basic Information"},{"location":"function-guide/PCS/get_pcssetup_waveform_m/","text":"get_pcssetup_waveform.m \u00b6 Basic Information \u00b6 SYNTAX: [data,time,ierror] = ... get_pcssetup_waveform(shot,category,phase,waveform,[server]); PURPOSE: Get waveform data from PCS setup file. INPUT: shot = shot number to get data from category = one of \"shape\", phase = string denoting which shot phase waveform = string denoting name of the waveform [server] = name of server to get data from (see get_pcs_server) OUTPUT: data = vector of doubles containing the y part of the waveform vertices time = vector of doubles containing the x part of the waveform vertices ierror = 0 if successful, non-zero otherwise. Error values: 1: Error, was not able to gather any infomation with the specified argument. 2: Warning. Arguments were ok, but there were no vertices to get. Dependencies \u00b6 get_pcs_server","title":"get_pcssetup_waveform.m"},{"location":"function-guide/PCS/get_pcssetup_waveform_m/#get_pcssetup_waveformm","text":"","title":"get_pcssetup_waveform.m"},{"location":"function-guide/PCS/get_pcssetup_waveform_m/#basic-information","text":"SYNTAX: [data,time,ierror] = ... get_pcssetup_waveform(shot,category,phase,waveform,[server]); PURPOSE: Get waveform data from PCS setup file. INPUT: shot = shot number to get data from category = one of \"shape\", phase = string denoting which shot phase waveform = string denoting name of the waveform [server] = name of server to get data from (see get_pcs_server) OUTPUT: data = vector of doubles containing the y part of the waveform vertices time = vector of doubles containing the x part of the waveform vertices ierror = 0 if successful, non-zero otherwise. Error values: 1: Error, was not able to gather any infomation with the specified argument. 2: Warning. Arguments were ok, but there were no vertices to get.","title":"Basic Information"},{"location":"function-guide/PCS/get_pcssetup_waveform_m/#dependencies","text":"get_pcs_server","title":"Dependencies"},{"location":"function-guide/PCS/get_phase_names_m/","text":"get_phase_names.m \u00b6 Basic Information \u00b6 SYNTAX: names = get_phase_names(shot, category, [server]) PURPOSE: Retrieves the names of the PCS phases for a given shot and category INPUT: shot = shot number to get category names data from category = pcs category [server] = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a phase name. If none found, is empty matrix []. RESTRICTIONS: METHOD: WRITTEN BY: Brian Sammuli ON Dec. 3, 2009 Dependencies \u00b6 get_pcs_server","title":"get_phase_names.m"},{"location":"function-guide/PCS/get_phase_names_m/#get_phase_namesm","text":"","title":"get_phase_names.m"},{"location":"function-guide/PCS/get_phase_names_m/#basic-information","text":"SYNTAX: names = get_phase_names(shot, category, [server]) PURPOSE: Retrieves the names of the PCS phases for a given shot and category INPUT: shot = shot number to get category names data from category = pcs category [server] = name of server to get data from (see get_pcs_server) for how this input is processed) OUTPUT: names = char matrix. Each row contains a phase name. If none found, is empty matrix []. RESTRICTIONS: METHOD: WRITTEN BY: Brian Sammuli ON Dec. 3, 2009","title":"Basic Information"},{"location":"function-guide/PCS/get_phase_names_m/#dependencies","text":"get_pcs_server","title":"Dependencies"},{"location":"function-guide/PCS/read_PCS_matrix_file_m/","text":"read_PCS_matrix_file.m \u00b6 Basic Information \u00b6 SYNTAX: read_PCS_matrix_file(matrix_file,matrix_data,rows,cols) PURPOSE: Write matrix data to a file readable by PCS. INPUT: matrix_file = name of file to read OUTPUT: matrix_data = data read from file rows = string array containing names corresponding to each row cols = string array containing names corresponding to each column Dependencies \u00b6 isblank","title":"read_PCS_matrix_file.m"},{"location":"function-guide/PCS/read_PCS_matrix_file_m/#read_pcs_matrix_filem","text":"","title":"read_PCS_matrix_file.m"},{"location":"function-guide/PCS/read_PCS_matrix_file_m/#basic-information","text":"SYNTAX: read_PCS_matrix_file(matrix_file,matrix_data,rows,cols) PURPOSE: Write matrix data to a file readable by PCS. INPUT: matrix_file = name of file to read OUTPUT: matrix_data = data read from file rows = string array containing names corresponding to each row cols = string array containing names corresponding to each column","title":"Basic Information"},{"location":"function-guide/PCS/read_PCS_matrix_file_m/#dependencies","text":"isblank","title":"Dependencies"},{"location":"function-guide/PCS/read_define_m/","text":"read_define.m \u00b6 Basic Information \u00b6 SYNTAX: d = read_define(filename,v) PURPOSE: read all instances of #define in a file INPUT: filename, file name including path and extension v, structure with variables required to evaluate define statements, e.g. v.CMD_BITS2VOLTS = 10/2047 OUTPUT: d, structure with fields set to values defined in the file RESTRICTIONS: assumes one space between #define and name in the file define statements must be terminated with line-feed or /* define statements that can't be evaluated are ignored fields in v named: i,j,k,m,n,p,s, are clobbered Dependencies \u00b6","title":"read_define.m"},{"location":"function-guide/PCS/read_define_m/#read_definem","text":"","title":"read_define.m"},{"location":"function-guide/PCS/read_define_m/#basic-information","text":"SYNTAX: d = read_define(filename,v) PURPOSE: read all instances of #define in a file INPUT: filename, file name including path and extension v, structure with variables required to evaluate define statements, e.g. v.CMD_BITS2VOLTS = 10/2047 OUTPUT: d, structure with fields set to values defined in the file RESTRICTIONS: assumes one space between #define and name in the file define statements must be terminated with line-feed or /* define statements that can't be evaluated are ignored fields in v named: i,j,k,m,n,p,s, are clobbered","title":"Basic Information"},{"location":"function-guide/PCS/read_define_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/PCS/read_pcs_ss_filter_m/","text":"read_pcs_ss_filter.m \u00b6 Basic Information \u00b6 USAGE: [A,B,C,D] = read_pcs_ss_filter(filtfile) PURPOSE: Read a standard PCS state-space filter file. INPUT: filtfile = string defining name of file OUTPUT: A,B,C,D = state space description of filter Dependencies \u00b6","title":"read_pcs_ss_filter.m"},{"location":"function-guide/PCS/read_pcs_ss_filter_m/#read_pcs_ss_filterm","text":"","title":"read_pcs_ss_filter.m"},{"location":"function-guide/PCS/read_pcs_ss_filter_m/#basic-information","text":"USAGE: [A,B,C,D] = read_pcs_ss_filter(filtfile) PURPOSE: Read a standard PCS state-space filter file. INPUT: filtfile = string defining name of file OUTPUT: A,B,C,D = state space description of filter","title":"Basic Information"},{"location":"function-guide/PCS/read_pcs_ss_filter_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/PCS/write_PCS_matrix_file_m/","text":"write_PCS_matrix_file.m \u00b6 Basic Information \u00b6 SYNTAX: write_PCS_matrix_file(matrix_file,matrix_data,rows,cols) PURPOSE: Write matrix data to a file readable by PCS. INPUT: matrix_file = name of file to write matrix_data = data to write to file rows = string array containing names corresponding to each row cols = string array containing names corresponding to each column OUTPUT: file written to disk Dependencies \u00b6 remove_space wait","title":"write_PCS_matrix_file.m"},{"location":"function-guide/PCS/write_PCS_matrix_file_m/#write_pcs_matrix_filem","text":"","title":"write_PCS_matrix_file.m"},{"location":"function-guide/PCS/write_PCS_matrix_file_m/#basic-information","text":"SYNTAX: write_PCS_matrix_file(matrix_file,matrix_data,rows,cols) PURPOSE: Write matrix data to a file readable by PCS. INPUT: matrix_file = name of file to write matrix_data = data to write to file rows = string array containing names corresponding to each row cols = string array containing names corresponding to each column OUTPUT: file written to disk","title":"Basic Information"},{"location":"function-guide/PCS/write_PCS_matrix_file_m/#dependencies","text":"remove_space wait","title":"Dependencies"},{"location":"function-guide/PCS/write_pcs_filter_m/","text":"write_pcs_filter.m \u00b6 Basic Information \u00b6 WRITE_PCS_FILTER Writes filter file for PCS data filtering. SYNTAX: write_pcs_filter(filtsys,filename) PURPOSE: Writes out PCS filter file (for use by Data Acquisition category) given a filter in state-space form. INPUTS: filtss = Filter state-space object filename = Name of saved file OUTPUTS: Text file RESTRICTIONS: METHOD: Dependencies \u00b6","title":"write_pcs_filter.m"},{"location":"function-guide/PCS/write_pcs_filter_m/#write_pcs_filterm","text":"","title":"write_pcs_filter.m"},{"location":"function-guide/PCS/write_pcs_filter_m/#basic-information","text":"WRITE_PCS_FILTER Writes filter file for PCS data filtering. SYNTAX: write_pcs_filter(filtsys,filename) PURPOSE: Writes out PCS filter file (for use by Data Acquisition category) given a filter in state-space form. INPUTS: filtss = Filter state-space object filename = Name of saved file OUTPUTS: Text file RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/PCS/write_pcs_filter_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/breakdown/calc_bd_traj_tok_m/","text":"calc_bd_traj_tok.m \u00b6 Basic Information \u00b6 SYNTAX: calc_bd_traj_tok PURPOSE: Compute breakdown current and voltage trajectories based on vacuum model M*dI/dt + R*I = V*v. INPUT: [default] r_plasma = Major R of plasma center (m) z_plasma = Z of plasma center (m) a_plasma= minor radius of plasma (m) npts_opt = number of points on boundary of plasma to optimize at Psidot_tgt= d/dt(Psi) at plasma center (scalar OR 1 x ntimes vector) optionally if exist('Emax') => Psidot_tgt computed from Emax Br_tgt = target radial field at pts on circle (npts_opt x 1 vector OR npts_opt x ntimes matrix for time-dependent) Bz_tgt = target vertical field at pts on circle (npts_opt x 1 vector OR npts_opt x ntimes matrix for time-dependent) Bzdot_tgt = dBz/dt at plasma center (scalar OR 1 x ntimes vector) wbr = vector of length npts_opt defining weights on Br at opt pts OR npts_opt x ntimes matrix for time-dependent) wbz = vector of length npts_opt defining weights on Bz at opt pts OR npts_opt x ntimes matrix for time-dependent) wbzdot = weight on Bzdot at plasma center (scalar OR 1 x ntimes vector) wpsidot = weight on Psidot at plasma (scalar OR 1 x ntimes vector) Vmin = minimum allowed voltage vector Vmax = maximum allowed voltage vector Idotmax = limits on absolute value of derivative of current in coils times = times at which flux, field, voltage target values specified nps = number of power supplies to drive (this needs to be generalized to specification of how to reduce degrees of freedom for optimization problem) I_init = initial currents vector (size = ncx x 1 for PF currents only OR (ncx+nvx) x 1 including vessel; optional, default = all zeros) pause_it= 1; => pause between figures [0]; rckts= array of Rckts values [ncx,max(iswtimes)] sets: Rckts= rckts(:,iswtimes(kk)) Rckts= additional circuit resistance - set to rckts (if rckts exists) cccirc= coil connective vector => defines final coil current states vccirc= voltage connection vector (like cccirc but for voltage inputs) default: [1:size(Bmat,2)]; => all input coils (kstar default) EAST: [1:6 1:6] iswtimes= times at which switch system matrix [1,zeros(size(times)-1,1)]; icoilc= print out of coilc_1.dat, _2.dat ... [0] ptimes= print times of coilc_?.dat files and incurment contour plots [times(1), 0 times(end)]; OUTPUT: Itraj = Current trajectories (ntimes x ncx) Vtraj = voltage trajectories (ntimes x nvoltx) psi_plasma = Flux at plasma center (ntimes x 1) (Vs) bz_opt0 = Bz at plasma center (ntimes x 1) (T) where: ncx= max(cccirc), nvoltx= max(vccirc) RESTRICTIONS: (1) Assumes that nps power supplies are the first nps out of ncx. (2) The PCS input mechanism (waveforms) restricts what can be used for voltage trajectories. This code assumes piecewise linear voltages continuously connected at discretely specified points. An alternative could be to use piecewise constant voltages that are discontinuous at these points. Minimum spacing of these points is 1ms. I'm not sure which alternative is better in this case. (3) At present it expects imks=1 iterminal=1 which brings in all objects in A, H, Ohm It is not clear if routine will work with other combination METHOD: Written to be consistent with: J.A.Leuer and J.C.Wesley, ITER Plasma Startup Modeling, 15th IEEE/NPSS Symp. on Fusion Eng., Oct.11-15, 1993, Hyannis, MA, p629 NOTE that current derivative constraint is only imposed at times in the input vector \"times\" - this is an approximation only. Dependencies \u00b6 yaxisloc_right eigsort pause_fig proj_turn date_stamp wait resamplev deriv subplot_ga rm_x_label paper_position mindbf_gen","title":"calc_bd_traj_tok.m"},{"location":"function-guide/breakdown/calc_bd_traj_tok_m/#calc_bd_traj_tokm","text":"","title":"calc_bd_traj_tok.m"},{"location":"function-guide/breakdown/calc_bd_traj_tok_m/#basic-information","text":"SYNTAX: calc_bd_traj_tok PURPOSE: Compute breakdown current and voltage trajectories based on vacuum model M*dI/dt + R*I = V*v. INPUT: [default] r_plasma = Major R of plasma center (m) z_plasma = Z of plasma center (m) a_plasma= minor radius of plasma (m) npts_opt = number of points on boundary of plasma to optimize at Psidot_tgt= d/dt(Psi) at plasma center (scalar OR 1 x ntimes vector) optionally if exist('Emax') => Psidot_tgt computed from Emax Br_tgt = target radial field at pts on circle (npts_opt x 1 vector OR npts_opt x ntimes matrix for time-dependent) Bz_tgt = target vertical field at pts on circle (npts_opt x 1 vector OR npts_opt x ntimes matrix for time-dependent) Bzdot_tgt = dBz/dt at plasma center (scalar OR 1 x ntimes vector) wbr = vector of length npts_opt defining weights on Br at opt pts OR npts_opt x ntimes matrix for time-dependent) wbz = vector of length npts_opt defining weights on Bz at opt pts OR npts_opt x ntimes matrix for time-dependent) wbzdot = weight on Bzdot at plasma center (scalar OR 1 x ntimes vector) wpsidot = weight on Psidot at plasma (scalar OR 1 x ntimes vector) Vmin = minimum allowed voltage vector Vmax = maximum allowed voltage vector Idotmax = limits on absolute value of derivative of current in coils times = times at which flux, field, voltage target values specified nps = number of power supplies to drive (this needs to be generalized to specification of how to reduce degrees of freedom for optimization problem) I_init = initial currents vector (size = ncx x 1 for PF currents only OR (ncx+nvx) x 1 including vessel; optional, default = all zeros) pause_it= 1; => pause between figures [0]; rckts= array of Rckts values [ncx,max(iswtimes)] sets: Rckts= rckts(:,iswtimes(kk)) Rckts= additional circuit resistance - set to rckts (if rckts exists) cccirc= coil connective vector => defines final coil current states vccirc= voltage connection vector (like cccirc but for voltage inputs) default: [1:size(Bmat,2)]; => all input coils (kstar default) EAST: [1:6 1:6] iswtimes= times at which switch system matrix [1,zeros(size(times)-1,1)]; icoilc= print out of coilc_1.dat, _2.dat ... [0] ptimes= print times of coilc_?.dat files and incurment contour plots [times(1), 0 times(end)]; OUTPUT: Itraj = Current trajectories (ntimes x ncx) Vtraj = voltage trajectories (ntimes x nvoltx) psi_plasma = Flux at plasma center (ntimes x 1) (Vs) bz_opt0 = Bz at plasma center (ntimes x 1) (T) where: ncx= max(cccirc), nvoltx= max(vccirc) RESTRICTIONS: (1) Assumes that nps power supplies are the first nps out of ncx. (2) The PCS input mechanism (waveforms) restricts what can be used for voltage trajectories. This code assumes piecewise linear voltages continuously connected at discretely specified points. An alternative could be to use piecewise constant voltages that are discontinuous at these points. Minimum spacing of these points is 1ms. I'm not sure which alternative is better in this case. (3) At present it expects imks=1 iterminal=1 which brings in all objects in A, H, Ohm It is not clear if routine will work with other combination METHOD: Written to be consistent with: J.A.Leuer and J.C.Wesley, ITER Plasma Startup Modeling, 15th IEEE/NPSS Symp. on Fusion Eng., Oct.11-15, 1993, Hyannis, MA, p629 NOTE that current derivative constraint is only imposed at times in the input vector \"times\" - this is an approximation only.","title":"Basic Information"},{"location":"function-guide/breakdown/calc_bd_traj_tok_m/#dependencies","text":"yaxisloc_right eigsort pause_fig proj_turn date_stamp wait resamplev deriv subplot_ga rm_x_label paper_position mindbf_gen","title":"Dependencies"},{"location":"function-guide/breakdown/connect_len_bkd_m/","text":"connect_len_bkd.m \u00b6 Basic Information \u00b6 SYNTAX: [conlen,crospos,turns] = ... connect_len_bkd(rlb,zlb,rgg,zgg,brg,bzg,rsb,zsb,Bt,R0,[maxturns]) PURPOSE: Calculate the approximate field line connection length from given starting points on a subgrid of the standard efit grid to a specified boundary. Also return the crossing point coords and the number of turns around the torus required to get there. INPUTS: [rsb,zsb]: (r,z) coordinates defining a boundary, the interior of which specifies the subset of rgg, zgg grid points that are used as the starting locations of the field lines to follow (meters). [rlb,zlb]: (r,z) coordinates defining 'limiter' boundary upon which the field lines impact that terminates the field line length calculation for each line (meters). rgg: Vector or matrix of poloidal radii of standard nz x nr tokamak grid (m) zgg: Vector or matrix of poloidal z-coords of standard tokamak grid (m) brg: Radial field value on standard tokamak grid (T) bzg: Verical field value on standard tokamak grid (T) Bt: Toroidal field (T) at radius R0 R0: Radius (m) where toroidal field is quoted. Bt(r) = Bt*R0/r maxturns: Maximum number of toroidal circuits to follow field lines. Default = 5000 if omitted. OUTPUTS: conlen: Vector of approximate length of field lines (meters) starting on grid points within [rsb,zsb] and ending on [rlb,zlb] defined 'limiter'. crospos: Matrix of final field line coords as they cross [rlb,zlb]. Rf=crospos(2,:); Zf=crospos(1,:) turns: Vector of number of toroidal circuits required for field line to cross [rlb,zlb] boundary. RESTRICTIONS: 1. Only valid if input fields brg, bzg are the entire poloidal field, so be sure to add PF coil and vacuum vessel contributions together to form brg, bzg. 2. The grid brg & bzg must be regular in the sense that the poloidal positions of brg, etc, can be defined by two vectors, rg (columns) and zg (rows). This is true for the standard tokamak poloidal grids. Substitute grids could be used if they follow this restriction. METHOD: This subroutine approximates the dR and dZ a field line traces out over one full circuit around the tokamak by calculating the slope the line has at a starting point in (R,phi) and (Z,phi) space, and intgrating that slope over 2*pi in phi. The connection length is then approximated as 2*pi*R and new slopes are calculated at the new R=R_old+dR, Z=Z_old+dZ and the process is iterated until R,Z cross the limiter boundary. The length of the last partial turn as the line crosses the boundary is NOT added to the total connection length for that line. Dependencies \u00b6","title":"connect_len_bkd.m"},{"location":"function-guide/breakdown/connect_len_bkd_m/#connect_len_bkdm","text":"","title":"connect_len_bkd.m"},{"location":"function-guide/breakdown/connect_len_bkd_m/#basic-information","text":"SYNTAX: [conlen,crospos,turns] = ... connect_len_bkd(rlb,zlb,rgg,zgg,brg,bzg,rsb,zsb,Bt,R0,[maxturns]) PURPOSE: Calculate the approximate field line connection length from given starting points on a subgrid of the standard efit grid to a specified boundary. Also return the crossing point coords and the number of turns around the torus required to get there. INPUTS: [rsb,zsb]: (r,z) coordinates defining a boundary, the interior of which specifies the subset of rgg, zgg grid points that are used as the starting locations of the field lines to follow (meters). [rlb,zlb]: (r,z) coordinates defining 'limiter' boundary upon which the field lines impact that terminates the field line length calculation for each line (meters). rgg: Vector or matrix of poloidal radii of standard nz x nr tokamak grid (m) zgg: Vector or matrix of poloidal z-coords of standard tokamak grid (m) brg: Radial field value on standard tokamak grid (T) bzg: Verical field value on standard tokamak grid (T) Bt: Toroidal field (T) at radius R0 R0: Radius (m) where toroidal field is quoted. Bt(r) = Bt*R0/r maxturns: Maximum number of toroidal circuits to follow field lines. Default = 5000 if omitted. OUTPUTS: conlen: Vector of approximate length of field lines (meters) starting on grid points within [rsb,zsb] and ending on [rlb,zlb] defined 'limiter'. crospos: Matrix of final field line coords as they cross [rlb,zlb]. Rf=crospos(2,:); Zf=crospos(1,:) turns: Vector of number of toroidal circuits required for field line to cross [rlb,zlb] boundary. RESTRICTIONS: 1. Only valid if input fields brg, bzg are the entire poloidal field, so be sure to add PF coil and vacuum vessel contributions together to form brg, bzg. 2. The grid brg & bzg must be regular in the sense that the poloidal positions of brg, etc, can be defined by two vectors, rg (columns) and zg (rows). This is true for the standard tokamak poloidal grids. Substitute grids could be used if they follow this restriction. METHOD: This subroutine approximates the dR and dZ a field line traces out over one full circuit around the tokamak by calculating the slope the line has at a starting point in (R,phi) and (Z,phi) space, and intgrating that slope over 2*pi in phi. The connection length is then approximated as 2*pi*R and new slopes are calculated at the new R=R_old+dR, Z=Z_old+dZ and the process is iterated until R,Z cross the limiter boundary. The length of the last partial turn as the line crosses the boundary is NOT added to the total connection length for that line.","title":"Basic Information"},{"location":"function-guide/breakdown/connect_len_bkd_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/breakdown/do_breakdown_tok_m/","text":"do_breakdown_tok.m \u00b6 Basic Information \u00b6 USAGE: [IM,figure_num]= do_breakdown_tok(IM_inputs,ramp_inputs, ... model_inputs,figure_num,pcs_files,pause_it) PURPOSE: Calculates Best Initial Magnetization and Breakdown Trajectories INPUTS (defaults=[..]): structure IM_inputs (Initial Magnetization (& Breakdown Ramp) Input): flux0= target flux at center (Vs) [3] bz_targ= target vertical field scaler or (npt,1) (T) [-0.00015] ic_min if exists => minimum coil current (A) [] ic_max if exists => maximum coil current (A) [] npt= Number of points on boundary for IM optimization [101] r_plasma= Major radius of breakdown circle [1.8]; z_plasma= Z Location of center of breakdown circle [0]; a_plasma= Minor radius of breakdown circle [0.4]; k_plasma= Elongation of breakdown circle [1.8]; d_plasma= Triangularity of breakdown circle [.5]; structure ramp_inputs (Breakdown Ramp Input): times time (s) interval for ramp, [0.001*[-12:1:12]']; times(1)= start ramp from IM, (negative start time) [-0.012] time=0 => breakdown time, (vector should have 0 in it) time(end)= end of simulation [+0.010] iswtimes [zeros(size(times))] Emx Central Electric Field times(1)=> times=0 (V/m) [0.3] Emn Central Electric Field at end of simulation [0.2] volt_fac= Voltage fractional increase for Ip calculation from VV EMF (1) li= Plasma internal inductance [0.5] beta= Plasma Beta [0]; cejima= Ejima coeficient for calculation of resistive flux [0.5]; ip_factor= Ip multiplier => reduce current requirement (and Bz) [1]; decay_index= n=-Rp/Zpt*Br_pt/Bz => 0 < n_stable < 1.5; [0.8] Vlimits = voltage limits on power supplies [make limits proportional to Nturns: 1-turn_Volt*N_turn= Vterminal_voltage] slew_limit= Idot limit on coils [19.5e+3 = ~ 20kA/s] wbr [200*[0, 1/sqrt(2) 1 1/sqrt(2) 0 1/sqrt(2) 1 1/sqrt(2)]'] wbz [200*[1, 1/sqrt(2) 0 1/sqrt(2) 1 1/sqrt(2) 0 1/sqrt(2)]'] wbzdot = [1] wpsidot = [0.2] structure model_inputs: Vmat = (must be in PCS order) tok_data_struct cccirc= PF circuit grouping vccirc = [1:max(cccirc)] vvgroup= VV grouping [vvid vvfraction] => 2 column matrix [] nps = number of power supplies scale_R_scpf [1] PSsys = power supply models (not used?) Rckt = resistances to add/replace coil resistance (essentialy 0) with switched in circuit resistors. Order must correspond to internal states. General Control Input pcs_files= 0; 1= Ouput PCS files on completion, 0=no files [0] pause_it= 0; => no pause, 1= pause, # = pause(pause-it) [0]; OUTPUTS: (primary output is \"*.dat\" files for PCS input [pcs_files=1]) structure IM: icc_ohmic= Optimum Ohmic Terminal Current vector (A) ic_ohmic = Optimum Ohmic Terminal Current vector (A-Turns) ict_ohmic= Optimum Ohmic Amp-Turn Current vector (A) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: uses standard tokamak vacuum objects for all magnetics Produces Amp-Turns. Should work on any tokamak but needs gneralization of cccirc code. METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m Dependencies \u00b6 pause_fig make_simserver_dat proj_turn dee_shape wait rectl ohmic_tok deriv calc_bd_traj_tok","title":"do_breakdown_tok.m"},{"location":"function-guide/breakdown/do_breakdown_tok_m/#do_breakdown_tokm","text":"","title":"do_breakdown_tok.m"},{"location":"function-guide/breakdown/do_breakdown_tok_m/#basic-information","text":"USAGE: [IM,figure_num]= do_breakdown_tok(IM_inputs,ramp_inputs, ... model_inputs,figure_num,pcs_files,pause_it) PURPOSE: Calculates Best Initial Magnetization and Breakdown Trajectories INPUTS (defaults=[..]): structure IM_inputs (Initial Magnetization (& Breakdown Ramp) Input): flux0= target flux at center (Vs) [3] bz_targ= target vertical field scaler or (npt,1) (T) [-0.00015] ic_min if exists => minimum coil current (A) [] ic_max if exists => maximum coil current (A) [] npt= Number of points on boundary for IM optimization [101] r_plasma= Major radius of breakdown circle [1.8]; z_plasma= Z Location of center of breakdown circle [0]; a_plasma= Minor radius of breakdown circle [0.4]; k_plasma= Elongation of breakdown circle [1.8]; d_plasma= Triangularity of breakdown circle [.5]; structure ramp_inputs (Breakdown Ramp Input): times time (s) interval for ramp, [0.001*[-12:1:12]']; times(1)= start ramp from IM, (negative start time) [-0.012] time=0 => breakdown time, (vector should have 0 in it) time(end)= end of simulation [+0.010] iswtimes [zeros(size(times))] Emx Central Electric Field times(1)=> times=0 (V/m) [0.3] Emn Central Electric Field at end of simulation [0.2] volt_fac= Voltage fractional increase for Ip calculation from VV EMF (1) li= Plasma internal inductance [0.5] beta= Plasma Beta [0]; cejima= Ejima coeficient for calculation of resistive flux [0.5]; ip_factor= Ip multiplier => reduce current requirement (and Bz) [1]; decay_index= n=-Rp/Zpt*Br_pt/Bz => 0 < n_stable < 1.5; [0.8] Vlimits = voltage limits on power supplies [make limits proportional to Nturns: 1-turn_Volt*N_turn= Vterminal_voltage] slew_limit= Idot limit on coils [19.5e+3 = ~ 20kA/s] wbr [200*[0, 1/sqrt(2) 1 1/sqrt(2) 0 1/sqrt(2) 1 1/sqrt(2)]'] wbz [200*[1, 1/sqrt(2) 0 1/sqrt(2) 1 1/sqrt(2) 0 1/sqrt(2)]'] wbzdot = [1] wpsidot = [0.2] structure model_inputs: Vmat = (must be in PCS order) tok_data_struct cccirc= PF circuit grouping vccirc = [1:max(cccirc)] vvgroup= VV grouping [vvid vvfraction] => 2 column matrix [] nps = number of power supplies scale_R_scpf [1] PSsys = power supply models (not used?) Rckt = resistances to add/replace coil resistance (essentialy 0) with switched in circuit resistors. Order must correspond to internal states. General Control Input pcs_files= 0; 1= Ouput PCS files on completion, 0=no files [0] pause_it= 0; => no pause, 1= pause, # = pause(pause-it) [0]; OUTPUTS: (primary output is \"*.dat\" files for PCS input [pcs_files=1]) structure IM: icc_ohmic= Optimum Ohmic Terminal Current vector (A) ic_ohmic = Optimum Ohmic Terminal Current vector (A-Turns) ict_ohmic= Optimum Ohmic Amp-Turn Current vector (A) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: uses standard tokamak vacuum objects for all magnetics Produces Amp-Turns. Should work on any tokamak but needs gneralization of cccirc code. METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m","title":"Basic Information"},{"location":"function-guide/breakdown/do_breakdown_tok_m/#dependencies","text":"pause_fig make_simserver_dat proj_turn dee_shape wait rectl ohmic_tok deriv calc_bd_traj_tok","title":"Dependencies"},{"location":"function-guide/breakdown/ohmic_tok_m/","text":"ohmic_tok.m \u00b6 Basic Information \u00b6 USAGE: ohmic_dist_data = ohmic_tok(ohmic_calc_inputs) PURPOSE: Calculates the Best Ohmic current distribution for F coils INPUTS: [default] ohmic_calc_inputs = structure, containing one or more of following: flux0= target flux at center, scaler (Vs) [1] bz_targ= target vertical field scaler or (npt,1) (T) [0] ic_min if exists => minimum coil current (A) => ic_min= -14500 ic_max if exists => maximum coil current (A) => ic_max= +14500 length(ic_min) = 1 or max(cccirc) npt= Number of points on boundary for optimization [101] r_plasma= Major radius of breakdown circle [1.8]; z_plasma= Z Location of center of breakdown circle [0]; a_plasma= Minor radius of breakdown circle [0.4]; k_plasma= Elongation of breakdown circle [1]; d_plasma= Triangularity of breakdown circle [0]; minimize_i = 0.1; Includes currents in opts. to reduce +-I [0] minimize_i weights how much I smooting to perform Value of 0 to 0.1 are reasonable tok_data_struct if this exists then uses existing tok_data_struct if it doesnt exist then loads KSTAR vacuum objects cccirc= circuit connection matrix [from tok_data_struct] pause_it= 1; => pause between figures [0]; tokamak= tokamak name prepended to each plot title []; OUTPUTS: ohmic_dist_data = structure, containing: icc_ohmic= Optimum Ohmic Terminal Current on circuit (cccirc) [12,1] (A) ic_ohmic = Optimum Ohmic Terminal (All Coil) Current vector [16,1] (A) ict_ohmic= Optimum Ohmic Amp-Turn Current vector [16,1] (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: reads in MA-turns standard tokamak vacuum objects calculates NOTE: Should work on any tokamak with gneralization of cccirc stuff below METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m now very similar to CUROPT by including Bz and constraints on currents now calculates based on terminal currents rather than (amp-turns) Dependencies \u00b6 pause_fig plot_box proj_turn dee_shape","title":"ohmic_tok.m"},{"location":"function-guide/breakdown/ohmic_tok_m/#ohmic_tokm","text":"","title":"ohmic_tok.m"},{"location":"function-guide/breakdown/ohmic_tok_m/#basic-information","text":"USAGE: ohmic_dist_data = ohmic_tok(ohmic_calc_inputs) PURPOSE: Calculates the Best Ohmic current distribution for F coils INPUTS: [default] ohmic_calc_inputs = structure, containing one or more of following: flux0= target flux at center, scaler (Vs) [1] bz_targ= target vertical field scaler or (npt,1) (T) [0] ic_min if exists => minimum coil current (A) => ic_min= -14500 ic_max if exists => maximum coil current (A) => ic_max= +14500 length(ic_min) = 1 or max(cccirc) npt= Number of points on boundary for optimization [101] r_plasma= Major radius of breakdown circle [1.8]; z_plasma= Z Location of center of breakdown circle [0]; a_plasma= Minor radius of breakdown circle [0.4]; k_plasma= Elongation of breakdown circle [1]; d_plasma= Triangularity of breakdown circle [0]; minimize_i = 0.1; Includes currents in opts. to reduce +-I [0] minimize_i weights how much I smooting to perform Value of 0 to 0.1 are reasonable tok_data_struct if this exists then uses existing tok_data_struct if it doesnt exist then loads KSTAR vacuum objects cccirc= circuit connection matrix [from tok_data_struct] pause_it= 1; => pause between figures [0]; tokamak= tokamak name prepended to each plot title []; OUTPUTS: ohmic_dist_data = structure, containing: icc_ohmic= Optimum Ohmic Terminal Current on circuit (cccirc) [12,1] (A) ic_ohmic = Optimum Ohmic Terminal (All Coil) Current vector [16,1] (A) ict_ohmic= Optimum Ohmic Amp-Turn Current vector [16,1] (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: reads in MA-turns standard tokamak vacuum objects calculates NOTE: Should work on any tokamak with gneralization of cccirc stuff below METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m now very similar to CUROPT by including Bz and constraints on currents now calculates based on terminal currents rather than (amp-turns)","title":"Basic Information"},{"location":"function-guide/breakdown/ohmic_tok_m/#dependencies","text":"pause_fig plot_box proj_turn dee_shape","title":"Dependencies"},{"location":"function-guide/circuit_models/BJacobians_m/","text":"BJacobians.m \u00b6 Basic Information \u00b6 SYNTAX: J=BJacobians(ra,za,rb,zb) PURPOSE: Compute Jacobian d(Br,Bz)/d(rb,zb) , where Br and Bz are the radial field components evaluated at (rb,zb) due to current source of 1 Amp at (ra,za). !!! NOTE: THIS DOES NOT COMPUTE d(Br,Bz)/d(ra,za) !!! INPUT: ra,za = (r,z) coordinates of current source (vectors) rb,zb = (r,z) coordinates of point where (Br,Bz) are measured (scalar) (units = meters) OUTPUT: J = Jacobian = [dbr/drb dbr/dzb dbz/drb dbz/dzb], (units = Tesla/Amp/m) Dependencies \u00b6 slope","title":"BJacobians.m"},{"location":"function-guide/circuit_models/BJacobians_m/#bjacobiansm","text":"","title":"BJacobians.m"},{"location":"function-guide/circuit_models/BJacobians_m/#basic-information","text":"SYNTAX: J=BJacobians(ra,za,rb,zb) PURPOSE: Compute Jacobian d(Br,Bz)/d(rb,zb) , where Br and Bz are the radial field components evaluated at (rb,zb) due to current source of 1 Amp at (ra,za). !!! NOTE: THIS DOES NOT COMPUTE d(Br,Bz)/d(ra,za) !!! INPUT: ra,za = (r,z) coordinates of current source (vectors) rb,zb = (r,z) coordinates of point where (Br,Bz) are measured (scalar) (units = meters) OUTPUT: J = Jacobian = [dbr/drb dbr/dzb dbz/drb dbz/dzb], (units = Tesla/Amp/m)","title":"Basic Information"},{"location":"function-guide/circuit_models/BJacobians_m/#dependencies","text":"slope","title":"Dependencies"},{"location":"function-guide/circuit_models/BJacobians_source_m/","text":"BJacobians_source.m \u00b6 Basic Information \u00b6 NOT TESTED SYNTAX: J=BJacobians_source(ra,za,rb,zb) PURPOSE: Compute Jacobian d(Br,Bz)/d(ra,za) , where Br and Bz are the radial field components evaluated at (rb,zb) due to current source at (ra,za). !!! NOTE: THIS DOES NOT COMPUTE d(Br,Bz)/d(rb,zb) !!! INPUT: ra,za = (r,z) coordinates of current source (vectors) rb,zb = (r,z) coordinates of point where (Br,Bz) are measured (scalar) (units = meters) OUTPUT: J = Jacobian = [dbrdr dbrdz dbzdr dbzdz], (units = Tesla/Amp/m) Dependencies \u00b6 slope","title":"BJacobians_source.m"},{"location":"function-guide/circuit_models/BJacobians_source_m/#bjacobians_sourcem","text":"","title":"BJacobians_source.m"},{"location":"function-guide/circuit_models/BJacobians_source_m/#basic-information","text":"NOT TESTED SYNTAX: J=BJacobians_source(ra,za,rb,zb) PURPOSE: Compute Jacobian d(Br,Bz)/d(ra,za) , where Br and Bz are the radial field components evaluated at (rb,zb) due to current source at (ra,za). !!! NOTE: THIS DOES NOT COMPUTE d(Br,Bz)/d(rb,zb) !!! INPUT: ra,za = (r,z) coordinates of current source (vectors) rb,zb = (r,z) coordinates of point where (Br,Bz) are measured (scalar) (units = meters) OUTPUT: J = Jacobian = [dbrdr dbrdz dbzdr dbzdz], (units = Tesla/Amp/m)","title":"Basic Information"},{"location":"function-guide/circuit_models/BJacobians_source_m/#dependencies","text":"slope","title":"Dependencies"},{"location":"function-guide/circuit_models/Jacsind_m/","text":"Jacsind.m \u00b6 Basic Information \u00b6 SYNTAX: dmdr = Jacsind(r,delr,delz) PURPOSE: Calculate Jacobian dmdr for source and msmnt point in same location. Assumes rectangular coil. INPUT: r = major radial location (meters) delr = width of rectangular coil delz = height of rectangular coil OUTPUT: J = Jacobian (units = Tesla/Amp) matrix, kth row of which holds [dm/d(ra) dm/d(za) dm/d(rb) dm/d(zb)] for the kth element in vectors r. (uH/m) RESTRICTIONS: Not accurate for delz/r > 2. (Huh?) METHOD: Self inductance does not depend on z position, so derivatives with respect to z are simply set to 0. does dr depend on whether source or measurement? WRITTEN BY: Mike Walker ON 11/11/96 (derived from Jim Leuer's RECTL function) Dependencies \u00b6","title":"Jacsind.m"},{"location":"function-guide/circuit_models/Jacsind_m/#jacsindm","text":"","title":"Jacsind.m"},{"location":"function-guide/circuit_models/Jacsind_m/#basic-information","text":"SYNTAX: dmdr = Jacsind(r,delr,delz) PURPOSE: Calculate Jacobian dmdr for source and msmnt point in same location. Assumes rectangular coil. INPUT: r = major radial location (meters) delr = width of rectangular coil delz = height of rectangular coil OUTPUT: J = Jacobian (units = Tesla/Amp) matrix, kth row of which holds [dm/d(ra) dm/d(za) dm/d(rb) dm/d(zb)] for the kth element in vectors r. (uH/m) RESTRICTIONS: Not accurate for delz/r > 2. (Huh?) METHOD: Self inductance does not depend on z position, so derivatives with respect to z are simply set to 0. does dr depend on whether source or measurement? WRITTEN BY: Mike Walker ON 11/11/96 (derived from Jim Leuer's RECTL function)","title":"Basic Information"},{"location":"function-guide/circuit_models/Jacsind_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/circuit_models/MJacobians_m/","text":"MJacobians.m \u00b6 Basic Information \u00b6 SYNTAX: J=MJacobians(ra,za,rb,zb) PURPOSE: Compute Jacobians dm(ra,za;rb,zb)/d(ra,za) and dm(ra,za;rb,zb)/d(rb,zb), where m(ra,za;rb,zb) is the mutual from (ra,za) to (rb,zb). INPUT: ra,za =(r,z) coordinates of current source (meters) rb,zb =(r,z) coordinates of point where psi is measured (meters) delr = delz = Legal input combinations are: - ra,za scalar, rb,zb column vectors of same length - rb,zb scalar, ra,za column vectors of same length - ra,za,rb,zb all column vectors of same length OUTPUT: J = Jacobian (units = Tesla/Amp) matrix, kth row of which holds [dm/d(ra) dm/d(za) dm/d(rb) dm/d(zb)] for the kth elements in vectors ra,za and/or rb,zb. RESTRICTIONS: Note that this function does not handle carefully the case where source and measurement location are very close. It DOES handle the case where source and measurement location are identical. METHOD: WRITTEN BY: Mike Walker ON 11/8/96 Dependencies \u00b6 slope Jacsind","title":"MJacobians.m"},{"location":"function-guide/circuit_models/MJacobians_m/#mjacobiansm","text":"","title":"MJacobians.m"},{"location":"function-guide/circuit_models/MJacobians_m/#basic-information","text":"SYNTAX: J=MJacobians(ra,za,rb,zb) PURPOSE: Compute Jacobians dm(ra,za;rb,zb)/d(ra,za) and dm(ra,za;rb,zb)/d(rb,zb), where m(ra,za;rb,zb) is the mutual from (ra,za) to (rb,zb). INPUT: ra,za =(r,z) coordinates of current source (meters) rb,zb =(r,z) coordinates of point where psi is measured (meters) delr = delz = Legal input combinations are: - ra,za scalar, rb,zb column vectors of same length - rb,zb scalar, ra,za column vectors of same length - ra,za,rb,zb all column vectors of same length OUTPUT: J = Jacobian (units = Tesla/Amp) matrix, kth row of which holds [dm/d(ra) dm/d(za) dm/d(rb) dm/d(zb)] for the kth elements in vectors ra,za and/or rb,zb. RESTRICTIONS: Note that this function does not handle carefully the case where source and measurement location are very close. It DOES handle the case where source and measurement location are identical. METHOD: WRITTEN BY: Mike Walker ON 11/8/96","title":"Basic Information"},{"location":"function-guide/circuit_models/MJacobians_m/#dependencies","text":"slope Jacsind","title":"Dependencies"},{"location":"function-guide/circuit_models/bld_filter_m/","text":"bld_filter.m \u00b6 Basic Information \u00b6 SYNTAX: [num,den]=bld_filter(type,corner) PURPOSE: Build a 4-pole Bessel or Chebyshev filter. (From FAX from Frequency Devices 1/21/94.) INPUTS: type = one of: 'Bessel' = bessel filter 'Chebyshev2' = .2dB Chebychev filter 'Chebyshev5' = .5dB Chebychev filter corner = corner frequency for filter (Hz) OUTPUTS: num, den = numerator and denominator polys in transfer function describing filter Dependencies \u00b6","title":"bld_filter.m"},{"location":"function-guide/circuit_models/bld_filter_m/#bld_filterm","text":"","title":"bld_filter.m"},{"location":"function-guide/circuit_models/bld_filter_m/#basic-information","text":"SYNTAX: [num,den]=bld_filter(type,corner) PURPOSE: Build a 4-pole Bessel or Chebyshev filter. (From FAX from Frequency Devices 1/21/94.) INPUTS: type = one of: 'Bessel' = bessel filter 'Chebyshev2' = .2dB Chebychev filter 'Chebyshev5' = .5dB Chebychev filter corner = corner frequency for filter (Hz) OUTPUTS: num, den = numerator and denominator polys in transfer function describing filter","title":"Basic Information"},{"location":"function-guide/circuit_models/bld_filter_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/circuit_models/cccirc_to_netlist_m/","text":"cccirc_to_netlist.m \u00b6 Basic Information \u00b6 SYNTAX: [netlist,inode1,inode2] = ... cccirc_to_netlist(cccirc,tok_data_struct,netlist_file) PURPOSE: Convert circuit connection defined by cccirc, vvgroup, and vvcirc into netlist. INPUT: cccirc = either cccirc vector or structure containing any combination of cccirc, vvgroup, and vvcirc tok_data_struct = vacuum data objects structure netlist_file = name of netlist file to create (optional, not created if no name specified) OUTPUT: netlist = similar to netlist input to Spice code, except that the \"value\" of M entries is the row corresponding to M and R matrices for that coil. Fictitious connections to ground are added to simplify the nodal analysis that occurs in building the system model. RESTRICTIONS: Code has been added to handle non-default vvgroup,vvcirc and the more complex code has been verified to work for default vvgroup, vvcirc but not extensively tested for non-default settings yet. Dependencies \u00b6 wait","title":"cccirc_to_netlist.m"},{"location":"function-guide/circuit_models/cccirc_to_netlist_m/#cccirc_to_netlistm","text":"","title":"cccirc_to_netlist.m"},{"location":"function-guide/circuit_models/cccirc_to_netlist_m/#basic-information","text":"SYNTAX: [netlist,inode1,inode2] = ... cccirc_to_netlist(cccirc,tok_data_struct,netlist_file) PURPOSE: Convert circuit connection defined by cccirc, vvgroup, and vvcirc into netlist. INPUT: cccirc = either cccirc vector or structure containing any combination of cccirc, vvgroup, and vvcirc tok_data_struct = vacuum data objects structure netlist_file = name of netlist file to create (optional, not created if no name specified) OUTPUT: netlist = similar to netlist input to Spice code, except that the \"value\" of M entries is the row corresponding to M and R matrices for that coil. Fictitious connections to ground are added to simplify the nodal analysis that occurs in building the system model. RESTRICTIONS: Code has been added to handle non-default vvgroup,vvcirc and the more complex code has been verified to work for default vvgroup, vvcirc but not extensively tested for non-default settings yet.","title":"Basic Information"},{"location":"function-guide/circuit_models/cccirc_to_netlist_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/circuit_models/dynamic_equil_m/","text":"dynamic_equil.m \u00b6 Basic Information \u00b6 SYNTAX: moving_equil = dynamic_equil(inputs) PURPOSE: Calculate \"moving equilibrium\" so that delta coordinates can be defined. Get objects to fit model where we take d/dt i_PF as input disturbance or forcing function. INPUT: (in structure \"inputs\") shotnum = shot number ip0 = approximate plasma current (Amps) vmat = mapping of input voltages to rows in state equation, after reduction vdata = approximate equil. power supply voltages (V) corresponding to cols in vmat good_vdata = vector of flags indicating which vdata values are \"good\" (0 or 1) tok_system = system model data structure for device being modeled Rp = plasma resistance ohstates_idx = indices of PF current states that participate in Ip control Optional (first 3 must be included or omitted together): LHSconstraint = defines extra LHS * (current states) = RHS constraints RHSconstraint = defines extra LHS * (current states) = RHS constraints constraint_str = string description of these constraints weight_coils = scalar or length ncx vector wtg factor for fitting coil currents (default=100) weight_volts = scalar or vector wtg factor (length(vdata)) for fitting power supply voltages (default=10) OUTPUT: (in structure moving_equil) equil_pt = nominal equilibrium to be used for linearization: RESTRICTIONS: If a particular voltage measurement is of poor or unknown quality, set the good_vdata flag = 0 and define a low fitting weight. METHOD: Performs a weighted least squares fit of free variables (see text variable \"var\" in output structure moving_equil) to shot data and constraint equations containing those variables defined by model circuit equations and physical constraints. \"Bad\" voltages are replaced by 0 during the fitting, but plots show comparison of input and fitted values. Dependencies \u00b6 update_constraint_eqns wait","title":"dynamic_equil.m"},{"location":"function-guide/circuit_models/dynamic_equil_m/#dynamic_equilm","text":"","title":"dynamic_equil.m"},{"location":"function-guide/circuit_models/dynamic_equil_m/#basic-information","text":"SYNTAX: moving_equil = dynamic_equil(inputs) PURPOSE: Calculate \"moving equilibrium\" so that delta coordinates can be defined. Get objects to fit model where we take d/dt i_PF as input disturbance or forcing function. INPUT: (in structure \"inputs\") shotnum = shot number ip0 = approximate plasma current (Amps) vmat = mapping of input voltages to rows in state equation, after reduction vdata = approximate equil. power supply voltages (V) corresponding to cols in vmat good_vdata = vector of flags indicating which vdata values are \"good\" (0 or 1) tok_system = system model data structure for device being modeled Rp = plasma resistance ohstates_idx = indices of PF current states that participate in Ip control Optional (first 3 must be included or omitted together): LHSconstraint = defines extra LHS * (current states) = RHS constraints RHSconstraint = defines extra LHS * (current states) = RHS constraints constraint_str = string description of these constraints weight_coils = scalar or length ncx vector wtg factor for fitting coil currents (default=100) weight_volts = scalar or vector wtg factor (length(vdata)) for fitting power supply voltages (default=10) OUTPUT: (in structure moving_equil) equil_pt = nominal equilibrium to be used for linearization: RESTRICTIONS: If a particular voltage measurement is of poor or unknown quality, set the good_vdata flag = 0 and define a low fitting weight. METHOD: Performs a weighted least squares fit of free variables (see text variable \"var\" in output structure moving_equil) to shot data and constraint equations containing those variables defined by model circuit equations and physical constraints. \"Bad\" voltages are replaced by 0 during the fitting, but plots show comparison of input and fitted values.","title":"Basic Information"},{"location":"function-guide/circuit_models/dynamic_equil_m/#dependencies","text":"update_constraint_eqns wait","title":"Dependencies"},{"location":"function-guide/circuit_models/echelon_m/","text":"echelon.m \u00b6 Basic Information \u00b6 SYNTAX: [Amod,nodelist,branchlist] = echelon(A,nodelist,branchlist) PURPOSE: Echelon algorithm. Calculation to define branches in tree and co-tree and the matrix mapping currents in co-tree branches to currents in branches of tree. INPUT: A = node incidence matrix nodelist = node numbers corresponding to each row of A branchlist = branch indices into the netlist corresponding to columns of A OUTPUT: Amod = modified incidence matrix, of the form [I Dc] nodelist = node numbers corresponding to each row of Amod branchlist = netlist branch indices corresponding to columns of Amod RESTRICTIONS: METHOD: Reduction to row-echelong form based on Gaussian elimination. Dependencies \u00b6","title":"echelon.m"},{"location":"function-guide/circuit_models/echelon_m/#echelonm","text":"","title":"echelon.m"},{"location":"function-guide/circuit_models/echelon_m/#basic-information","text":"SYNTAX: [Amod,nodelist,branchlist] = echelon(A,nodelist,branchlist) PURPOSE: Echelon algorithm. Calculation to define branches in tree and co-tree and the matrix mapping currents in co-tree branches to currents in branches of tree. INPUT: A = node incidence matrix nodelist = node numbers corresponding to each row of A branchlist = branch indices into the netlist corresponding to columns of A OUTPUT: Amod = modified incidence matrix, of the form [I Dc] nodelist = node numbers corresponding to each row of Amod branchlist = netlist branch indices corresponding to columns of Amod RESTRICTIONS: METHOD: Reduction to row-echelong form based on Gaussian elimination.","title":"Basic Information"},{"location":"function-guide/circuit_models/echelon_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/circuit_models/elt_to_corners_m/","text":"elt_to_corners.m \u00b6 Basic Information \u00b6 SYNTAX: corners = elt_to_corners(element) PURPOSE: Convert standard \"element form\" ([Z;R;dZ;dR;AC;AC2]) to set of corners of the element. (For a description of this standard form, see Toksys users guide.) INPUT: element = [Z;R;dZ;dR;AC;AC2] OUTPUT: corners = [x y], where x = [x1 x2 x3 x4]^T, y = [y1 y2 y3 y4]^T are coordinates of the four corners of the parallelogram. Dependencies \u00b6","title":"elt_to_corners.m"},{"location":"function-guide/circuit_models/elt_to_corners_m/#elt_to_cornersm","text":"","title":"elt_to_corners.m"},{"location":"function-guide/circuit_models/elt_to_corners_m/#basic-information","text":"SYNTAX: corners = elt_to_corners(element) PURPOSE: Convert standard \"element form\" ([Z;R;dZ;dR;AC;AC2]) to set of corners of the element. (For a description of this standard form, see Toksys users guide.) INPUT: element = [Z;R;dZ;dR;AC;AC2] OUTPUT: corners = [x y], where x = [x1 x2 x3 x4]^T, y = [y1 y2 y3 y4]^T are coordinates of the four corners of the parallelogram.","title":"Basic Information"},{"location":"function-guide/circuit_models/elt_to_corners_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/circuit_models/load_netlist_m/","text":"load_netlist.m \u00b6 Basic Information \u00b6 SYNTAX: [netlist,numNode,numV] = load_netlist(fname) PURPOSE: Takes a netlist (similar to SPICE), parses it to derive the circuit equations, then solves them symbolically. INPUT: fname = name of netlist file to load OUTPUT: netlist = netlist information in a data structure numNode = total number of nodes in model numV = number of voltage sources Dependencies \u00b6","title":"load_netlist.m"},{"location":"function-guide/circuit_models/load_netlist_m/#load_netlistm","text":"","title":"load_netlist.m"},{"location":"function-guide/circuit_models/load_netlist_m/#basic-information","text":"SYNTAX: [netlist,numNode,numV] = load_netlist(fname) PURPOSE: Takes a netlist (similar to SPICE), parses it to derive the circuit equations, then solves them symbolically. INPUT: fname = name of netlist file to load OUTPUT: netlist = netlist information in a data structure numNode = total number of nodes in model numV = number of voltage sources","title":"Basic Information"},{"location":"function-guide/circuit_models/load_netlist_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/circuit_models/make_incidence_m/","text":"make_incidence.m \u00b6 Basic Information \u00b6 SYNTAX: [A,nodelist,sorted_netlist,Midx] = make_incidence(netlist) PURPOSE: Construct incidence matrix. Sort so that branches representing voltage sources come first, then capacitors, then resistors. INPUT: OUTPUT: A = incidence matrix nodelist = set of all nodes specified in the netlist sorted_netlist = netlist with elements sorted according to the order in [1] Midx = indices of inductive ('M') conductors in sorted_netlist (in same order as original netlist) RESTRICTIONS: METHOD: Described in [1] M.L. Walker, \"A General Purpose Circuit Modeling Code for Tokamak Plasma Magnetic Control, General Atomics Engineering Physics Memo EPMmlw070120a, Jan. 20, 2007 Dependencies \u00b6 wait","title":"make_incidence.m"},{"location":"function-guide/circuit_models/make_incidence_m/#make_incidencem","text":"","title":"make_incidence.m"},{"location":"function-guide/circuit_models/make_incidence_m/#basic-information","text":"SYNTAX: [A,nodelist,sorted_netlist,Midx] = make_incidence(netlist) PURPOSE: Construct incidence matrix. Sort so that branches representing voltage sources come first, then capacitors, then resistors. INPUT: OUTPUT: A = incidence matrix nodelist = set of all nodes specified in the netlist sorted_netlist = netlist with elements sorted according to the order in [1] Midx = indices of inductive ('M') conductors in sorted_netlist (in same order as original netlist) RESTRICTIONS: METHOD: Described in [1] M.L. Walker, \"A General Purpose Circuit Modeling Code for Tokamak Plasma Magnetic Control, General Atomics Engineering Physics Memo EPMmlw070120a, Jan. 20, 2007","title":"Basic Information"},{"location":"function-guide/circuit_models/make_incidence_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/circuit_models/make_units_struct_m/","text":"make_units_struct.m \u00b6 Basic Information \u00b6 SYNTAX: units = make_units_struct(imks,iterminal) PURPOSE: Make units data structure for standard format tokamak data struct. INPUT: imks = if 1, input objects in datafiles are mks, else 0 (default=mA,uH) iterminal = if 1, input objects are terminal units, else 0 (default) OUTPUT: units = units of data objects Dependencies \u00b6","title":"make_units_struct.m"},{"location":"function-guide/circuit_models/make_units_struct_m/#make_units_structm","text":"","title":"make_units_struct.m"},{"location":"function-guide/circuit_models/make_units_struct_m/#basic-information","text":"SYNTAX: units = make_units_struct(imks,iterminal) PURPOSE: Make units data structure for standard format tokamak data struct. INPUT: imks = if 1, input objects in datafiles are mks, else 0 (default=mA,uH) iterminal = if 1, input objects are terminal units, else 0 (default) OUTPUT: units = units of data objects","title":"Basic Information"},{"location":"function-guide/circuit_models/make_units_struct_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/circuit_models/model_from_cccirc_m/","text":"model_from_cccirc.m \u00b6 Basic Information \u00b6 SYNTAX: model = model_from_cccirc(vacuum_objs,cccirc,vvcirc,vvgroup,Mmat,Rvec,iplcirc,verbose) PURPOSE: Create circuit model using cccirc input. INPUT: vacuum_objs = vacuum model objects (often called tok_data_struct) cccirc = coil conductor currents circuit description vvcirc = vacuum vessel conductors circuit description vvgroup = vacuum vessel element groupings Mmat = mutual inductances (matrix) for all conductors Rvec = resistances (vector) for all conductors iplcirc = if 1, include plasma circuit (in which case Mmat, Rvec must contain plasma elements), else 0 verbose = (optional) OUTPUT: data struct model containing: Pxx = Pcc = Mhat = Vhat = Rhat = RESTRICTIONS: Modeling with cccirc no longer supports use of Lckt_extra or Rckt_extra. Dependencies \u00b6 cccirc_to_netlist wait","title":"model_from_cccirc.m"},{"location":"function-guide/circuit_models/model_from_cccirc_m/#model_from_cccircm","text":"","title":"model_from_cccirc.m"},{"location":"function-guide/circuit_models/model_from_cccirc_m/#basic-information","text":"SYNTAX: model = model_from_cccirc(vacuum_objs,cccirc,vvcirc,vvgroup,Mmat,Rvec,iplcirc,verbose) PURPOSE: Create circuit model using cccirc input. INPUT: vacuum_objs = vacuum model objects (often called tok_data_struct) cccirc = coil conductor currents circuit description vvcirc = vacuum vessel conductors circuit description vvgroup = vacuum vessel element groupings Mmat = mutual inductances (matrix) for all conductors Rvec = resistances (vector) for all conductors iplcirc = if 1, include plasma circuit (in which case Mmat, Rvec must contain plasma elements), else 0 verbose = (optional) OUTPUT: data struct model containing: Pxx = Pcc = Mhat = Vhat = Rhat = RESTRICTIONS: Modeling with cccirc no longer supports use of Lckt_extra or Rckt_extra.","title":"Basic Information"},{"location":"function-guide/circuit_models/model_from_cccirc_m/#dependencies","text":"cccirc_to_netlist wait","title":"Dependencies"},{"location":"function-guide/circuit_models/model_from_netlist_m/","text":"model_from_netlist.m \u00b6 Basic Information \u00b6 SYNTAX: model = model_from_netlist(netlist,Mmat,Rvec,Iout,Vout,verbose) PURPOSE: Produces model that is generalization of that produced by the simpler tokamak/plasma modeling schemes, of the form: Mhat*dx/dt + Rhat*x = Vhat*u + What*du/dt y = Chat*x + Dhat*u + DWhat*du/dt where the generalized state and input vectors are: x = [i_inductors; v_capacitors], u = [Vsource; Isource] y = [current_outputs; voltage_outputs] INPUT: netlist = netlist specification of circuit connections Mmat = mutual inductance matrix for all \"M\" type elements in netlist Rvec = resistance vector for all \"M\" type elements in netlist (Values of netlist for \"M\" objects are indices into these objects.) Iout = array of strings defining branches for which to output currents (optional, default = no current outputs) Vout = n x 2 matrix, each row containing node numbers [N1 N2], with voltage output defined as V(N1)-V(N2) (optional, default = no voltage outputs) verbose = set to >0 to print model-building diagnostics to terminal (optional, default = 0) OUTPUT: (in structure \"model\") model = structure containing model objects; see descriptions field for description of contents of each field RESTRICTIONS: (1) Does not yet handle circuits containing capacitors or current sources. (2) Right now it can't handle outputs Vout if circuit is not specified as a connected graph (i.e. no floating potentials). METHOD: Described in: M.L.Walker, A General Purpose Circuit Modeling Code for Tokamak Plasma Magnetic Control, Engineering Physics Memo EPM070120a, January 20, 2007","title":"model_from_netlist.m"},{"location":"function-guide/circuit_models/model_from_netlist_m/#model_from_netlistm","text":"","title":"model_from_netlist.m"},{"location":"function-guide/circuit_models/model_from_netlist_m/#basic-information","text":"SYNTAX: model = model_from_netlist(netlist,Mmat,Rvec,Iout,Vout,verbose) PURPOSE: Produces model that is generalization of that produced by the simpler tokamak/plasma modeling schemes, of the form: Mhat*dx/dt + Rhat*x = Vhat*u + What*du/dt y = Chat*x + Dhat*u + DWhat*du/dt where the generalized state and input vectors are: x = [i_inductors; v_capacitors], u = [Vsource; Isource] y = [current_outputs; voltage_outputs] INPUT: netlist = netlist specification of circuit connections Mmat = mutual inductance matrix for all \"M\" type elements in netlist Rvec = resistance vector for all \"M\" type elements in netlist (Values of netlist for \"M\" objects are indices into these objects.) Iout = array of strings defining branches for which to output currents (optional, default = no current outputs) Vout = n x 2 matrix, each row containing node numbers [N1 N2], with voltage output defined as V(N1)-V(N2) (optional, default = no voltage outputs) verbose = set to >0 to print model-building diagnostics to terminal (optional, default = 0) OUTPUT: (in structure \"model\") model = structure containing model objects; see descriptions field for description of contents of each field RESTRICTIONS: (1) Does not yet handle circuits containing capacitors or current sources. (2) Right now it can't handle outputs Vout if circuit is not specified as a connected graph (i.e. no floating potentials). METHOD: Described in: M.L.Walker, A General Purpose Circuit Modeling Code for Tokamak Plasma Magnetic Control, Engineering Physics Memo EPM070120a, January 20, 2007","title":"Basic Information"},{"location":"function-guide/circuit_models/update_constraint_eqns_m/","text":"update_constraint_eqns.m \u00b6 Basic Information \u00b6 SYNTAX: update_constraint_eqns PURPOSE: Update the constraint equations in dynamic_equil.m. INPUT: LHS, RHS = matrices defining previous constraint equation (LHS*x=RHS) nvar = number of variables in optimization (size of x) addLHS, addRHS = additional rows to add to constraint equation (# columns in addLHS must be < = # columns in LHS) OUTPUT: LHS, RHS = matrices for updated constraint equations Dependencies \u00b6 wait","title":"update_constraint_eqns.m"},{"location":"function-guide/circuit_models/update_constraint_eqns_m/#update_constraint_eqnsm","text":"","title":"update_constraint_eqns.m"},{"location":"function-guide/circuit_models/update_constraint_eqns_m/#basic-information","text":"SYNTAX: update_constraint_eqns PURPOSE: Update the constraint equations in dynamic_equil.m. INPUT: LHS, RHS = matrices defining previous constraint equation (LHS*x=RHS) nvar = number of variables in optimization (size of x) addLHS, addRHS = additional rows to add to constraint equation (# columns in addLHS must be < = # columns in LHS) OUTPUT: LHS, RHS = matrices for updated constraint equations","title":"Basic Information"},{"location":"function-guide/circuit_models/update_constraint_eqns_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/circuit_models/write_netlist_file_m/","text":"write_netlist_file.m \u00b6 Basic Information \u00b6 SYNTAX: write_netlist_file(netlist,netlist_file) PURPOSE: Write out a formatted ascii netlist file from a netlist data structure in matlab. INPUT: netlist = netlist data structure variable netlist_file = name of netlist file to write OUTPUT: ascii file containing netlist Dependencies \u00b6","title":"write_netlist_file.m"},{"location":"function-guide/circuit_models/write_netlist_file_m/#write_netlist_filem","text":"","title":"write_netlist_file.m"},{"location":"function-guide/circuit_models/write_netlist_file_m/#basic-information","text":"SYNTAX: write_netlist_file(netlist,netlist_file) PURPOSE: Write out a formatted ascii netlist file from a netlist data structure in matlab. INPUT: netlist = netlist data structure variable netlist_file = name of netlist file to write OUTPUT: ascii file containing netlist","title":"Basic Information"},{"location":"function-guide/circuit_models/write_netlist_file_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/design/build_design_model_m/","text":"build_design_model.m \u00b6 Basic Information \u00b6 SYNTAX: design_model = build_design_model(design_model_in) PURPOSE: Builds single state-space model incorporating power supply system (optional),plasma system,and filter/delay system (optional). Connections between systems can be arbitrarily specified, and INPUTS: design_model_in = structure tokname = Tokamak name (e.g. 'D3D','NSTX','KSTAR') use_ps = Include power supply system (1:YES 0:NO) use_fiters = Include filter/delay system (1:YES 0:NO) use_disturb = Include distrubance inputs (1:YES 0:NO) psbuild_in = Struct of parameters for PS build macro sysbuild_in = Struct of parameters for tokamak system build macro control_in = Struct of parameters defining control output response filter_in = Struct of parameters defining filter/delay system sys_outputs = Names of outputs from combined system post_proc = Statements to evaluate at end of function (optional) OUTPUTS: design_model = LTI model Dependencies \u00b6 get_isoflux_grid_data build_isoflux_response get_isoflux_ref_data get_linest_from_ematrix get_isoflux_segment_data build_gap_response build_linest_response connect_design_systems build_filter_system","title":"build_design_model.m"},{"location":"function-guide/design/build_design_model_m/#build_design_modelm","text":"","title":"build_design_model.m"},{"location":"function-guide/design/build_design_model_m/#basic-information","text":"SYNTAX: design_model = build_design_model(design_model_in) PURPOSE: Builds single state-space model incorporating power supply system (optional),plasma system,and filter/delay system (optional). Connections between systems can be arbitrarily specified, and INPUTS: design_model_in = structure tokname = Tokamak name (e.g. 'D3D','NSTX','KSTAR') use_ps = Include power supply system (1:YES 0:NO) use_fiters = Include filter/delay system (1:YES 0:NO) use_disturb = Include distrubance inputs (1:YES 0:NO) psbuild_in = Struct of parameters for PS build macro sysbuild_in = Struct of parameters for tokamak system build macro control_in = Struct of parameters defining control output response filter_in = Struct of parameters defining filter/delay system sys_outputs = Names of outputs from combined system post_proc = Statements to evaluate at end of function (optional) OUTPUTS: design_model = LTI model","title":"Basic Information"},{"location":"function-guide/design/build_design_model_m/#dependencies","text":"get_isoflux_grid_data build_isoflux_response get_isoflux_ref_data get_linest_from_ematrix get_isoflux_segment_data build_gap_response build_linest_response connect_design_systems build_filter_system","title":"Dependencies"},{"location":"function-guide/design/build_gap_response_m/","text":"build_gap_response.m \u00b6 Basic Information \u00b6 SYNTAX: gap_response = build_gap_response(gap_in) PURPOSE: Build gap response for gaps defined in gap_in INPUT: gap_in = structure gapspec = [r z gr gz] for each gap (4 x ngap) (see calc_gap.m) gapnames = Names of gaps (optional) tok_data_struct = Toksys vacuum object (from make_tok_objects.m) resp = Plasma system response model (rzrig or gspert) equil_data = Equilibrium data structure post_proc = Statements to evaluate at end of function. OUTPUT: gap_response = structure gapresp = response structure with fields: dgapdis: gap response to conductors [m/A] dgapdip,*dli,*dbetap, etc: exogenous responses gaps: distances from boundary to wall through r,z along gr,gz [m] gapspec: New gap specification on form [r z gr gz] gapnames = Gap names METHOD: Dependencies \u00b6 calc_gaps","title":"build_gap_response.m"},{"location":"function-guide/design/build_gap_response_m/#build_gap_responsem","text":"","title":"build_gap_response.m"},{"location":"function-guide/design/build_gap_response_m/#basic-information","text":"SYNTAX: gap_response = build_gap_response(gap_in) PURPOSE: Build gap response for gaps defined in gap_in INPUT: gap_in = structure gapspec = [r z gr gz] for each gap (4 x ngap) (see calc_gap.m) gapnames = Names of gaps (optional) tok_data_struct = Toksys vacuum object (from make_tok_objects.m) resp = Plasma system response model (rzrig or gspert) equil_data = Equilibrium data structure post_proc = Statements to evaluate at end of function. OUTPUT: gap_response = structure gapresp = response structure with fields: dgapdis: gap response to conductors [m/A] dgapdip,*dli,*dbetap, etc: exogenous responses gaps: distances from boundary to wall through r,z along gr,gz [m] gapspec: New gap specification on form [r z gr gz] gapnames = Gap names METHOD:","title":"Basic Information"},{"location":"function-guide/design/build_gap_response_m/#dependencies","text":"calc_gaps","title":"Dependencies"},{"location":"function-guide/design/build_isoflux_response_m/","text":"build_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: isoflux_response = build_isoflux_response(isoflux_input) PURPOSE: Build isoflux response for elements listed in isoflux_input. Response objects include plasma response if vacuum_model=0 in iso_presp_in. INPUT: isoflux_input = (structure) tokname = Tokamak name segment_resp_flag = Cell array of flags determining how response on ctrl segments computed (see compress_isoflux_response.m) segment_alg = Segment algorithm (1:Flux 2:Br 3:Bz) segment_usage = Segment usage (0: Ignored, 1-4:with reference #N, 5:no ref) (returned by get_isoflux_segment_data) grid_resp_flag = Cell array of flags determining how response on grid computed (see compress_isoflux_response.m) grid_usage = Grid \" \" (returned by get_isoflux_grid_data) ref_flux_source = Sources for reference flux, maximum 4 elements. Sources specificed by an index number, where indices access the array: [segments[1:nseg] grids[1:ngrid]. iso_presp_in = Isoflux plasma response input structure (see calc_isoflux_plasma_response.m, excludes response_data and rtefit_def) use_pcs_isoflux = (WHAT DOES THIS DO??) default 0 Optional inputs: exe_dir = Path to compiled pcs executable directory (how does this get set?) segment_names = Cell array of isoflux segment names (defined by ?? if use_pcs_isoflux=1) grid_names = Cell array of isoflux grid names (defined by ?? if use_pcs_isoflux=1) post_proc = Statements to evaluate at end of function (not used if not set?). OUTPUT: isoflux_response = structure isoflux_input = Input structure (see above) rtefit_defns = rtEFIT definition structure (see define_rtefit_objects.m) nseg = # segments ngrid = # grids isodata = Array of response_data structures [nseg + ngrid] (see read_response.m) Gcntl = Response of flux at isoflux control points and field at Xpts to changes in conductor currents. Outputs = [nsegments fluxes(Wb),flux,Br,Bz at Xpt1(Wb,T), flux,Br,Bz at Xpt2(Wb,T)...] Inputs = currents conductors (E,F,vv,Ip) corresponding to conductors in iso_presp_in.vacuum_objs. Units = A. Gcntlbetap = Isoflux response to betap disturbance Gcntlli = \" \" \" li \" Gcntl_err = Gcntlbetap_err= Gcntlli_err = all_response = cell array of all PCS response structures processed during calculation METHOD: Dependencies \u00b6 calc_isoflux_plasma_response wait compress_isoflux_response mk_var","title":"build_isoflux_response.m"},{"location":"function-guide/design/build_isoflux_response_m/#build_isoflux_responsem","text":"","title":"build_isoflux_response.m"},{"location":"function-guide/design/build_isoflux_response_m/#basic-information","text":"SYNTAX: isoflux_response = build_isoflux_response(isoflux_input) PURPOSE: Build isoflux response for elements listed in isoflux_input. Response objects include plasma response if vacuum_model=0 in iso_presp_in. INPUT: isoflux_input = (structure) tokname = Tokamak name segment_resp_flag = Cell array of flags determining how response on ctrl segments computed (see compress_isoflux_response.m) segment_alg = Segment algorithm (1:Flux 2:Br 3:Bz) segment_usage = Segment usage (0: Ignored, 1-4:with reference #N, 5:no ref) (returned by get_isoflux_segment_data) grid_resp_flag = Cell array of flags determining how response on grid computed (see compress_isoflux_response.m) grid_usage = Grid \" \" (returned by get_isoflux_grid_data) ref_flux_source = Sources for reference flux, maximum 4 elements. Sources specificed by an index number, where indices access the array: [segments[1:nseg] grids[1:ngrid]. iso_presp_in = Isoflux plasma response input structure (see calc_isoflux_plasma_response.m, excludes response_data and rtefit_def) use_pcs_isoflux = (WHAT DOES THIS DO??) default 0 Optional inputs: exe_dir = Path to compiled pcs executable directory (how does this get set?) segment_names = Cell array of isoflux segment names (defined by ?? if use_pcs_isoflux=1) grid_names = Cell array of isoflux grid names (defined by ?? if use_pcs_isoflux=1) post_proc = Statements to evaluate at end of function (not used if not set?). OUTPUT: isoflux_response = structure isoflux_input = Input structure (see above) rtefit_defns = rtEFIT definition structure (see define_rtefit_objects.m) nseg = # segments ngrid = # grids isodata = Array of response_data structures [nseg + ngrid] (see read_response.m) Gcntl = Response of flux at isoflux control points and field at Xpts to changes in conductor currents. Outputs = [nsegments fluxes(Wb),flux,Br,Bz at Xpt1(Wb,T), flux,Br,Bz at Xpt2(Wb,T)...] Inputs = currents conductors (E,F,vv,Ip) corresponding to conductors in iso_presp_in.vacuum_objs. Units = A. Gcntlbetap = Isoflux response to betap disturbance Gcntlli = \" \" \" li \" Gcntl_err = Gcntlbetap_err= Gcntlli_err = all_response = cell array of all PCS response structures processed during calculation METHOD:","title":"Basic Information"},{"location":"function-guide/design/build_isoflux_response_m/#dependencies","text":"calc_isoflux_plasma_response wait compress_isoflux_response mk_var","title":"Dependencies"},{"location":"function-guide/design/build_linest_response_m/","text":"build_linest_response.m \u00b6 Basic Information \u00b6 SYNTAX: linest_response = build_linest_reponse(linest_in) PURPOSE: Connect design system components into a single system. INPUT: linest_in = structure linest_defs = structure array est_name = Name of linear estimator input_names = Cell array of inputs with non-zero coefficients coeff = Array of input coefficients pl_sys = Plasma system providing inputs (output of build_***_sys) post_proc = Statement strings to run at end of function OUTPUT: linest_response = structure outputs = Array of linear estimator names cmat, dmat, hmat = Response matrices to be appended to plasma system matrices RESTRICTIONS: Connection function will assume that all inputs are from plasma system. Using other inputs will lead to errors. Linest names must match pl_out elements (case insensitive). METHOD: Dependencies \u00b6","title":"build_linest_response.m"},{"location":"function-guide/design/build_linest_response_m/#build_linest_responsem","text":"","title":"build_linest_response.m"},{"location":"function-guide/design/build_linest_response_m/#basic-information","text":"SYNTAX: linest_response = build_linest_reponse(linest_in) PURPOSE: Connect design system components into a single system. INPUT: linest_in = structure linest_defs = structure array est_name = Name of linear estimator input_names = Cell array of inputs with non-zero coefficients coeff = Array of input coefficients pl_sys = Plasma system providing inputs (output of build_***_sys) post_proc = Statement strings to run at end of function OUTPUT: linest_response = structure outputs = Array of linear estimator names cmat, dmat, hmat = Response matrices to be appended to plasma system matrices RESTRICTIONS: Connection function will assume that all inputs are from plasma system. Using other inputs will lead to errors. Linest names must match pl_out elements (case insensitive). METHOD:","title":"Basic Information"},{"location":"function-guide/design/build_linest_response_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/design/compress_isoflux_response_m/","text":"compress_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: [compdata] = compress_isoflux_response(data,cntl_pts,isotype,resp_flag) PURPOSE: Compress isoflux response to a single row using specified method. Can also detect and handle stacked responses (e.g. flux, Br, Bz). INPUT: data = Segment/grid response data (size = ncntl_pts x nstates) cntl_pts = Segment/grid control point (r,z) locations (size = 2 x nctl_pts) isotype = 'G' or 'S' resp_flag = Response compression method flag depndent upon type: if scalar 0 = do not use this segment/grid 1 = use average over entire segment/grid 2 = use response at center of segment/grid if length=2: Use response at pt closest to [r,z] OUTPUT: compdata = Compressed response vectors METHOD: If mod(size(data,1),ncntl_pts)==0, assume multiple response vectors (e.g. flux, Br, Bz). Dependencies \u00b6","title":"compress_isoflux_response.m"},{"location":"function-guide/design/compress_isoflux_response_m/#compress_isoflux_responsem","text":"","title":"compress_isoflux_response.m"},{"location":"function-guide/design/compress_isoflux_response_m/#basic-information","text":"SYNTAX: [compdata] = compress_isoflux_response(data,cntl_pts,isotype,resp_flag) PURPOSE: Compress isoflux response to a single row using specified method. Can also detect and handle stacked responses (e.g. flux, Br, Bz). INPUT: data = Segment/grid response data (size = ncntl_pts x nstates) cntl_pts = Segment/grid control point (r,z) locations (size = 2 x nctl_pts) isotype = 'G' or 'S' resp_flag = Response compression method flag depndent upon type: if scalar 0 = do not use this segment/grid 1 = use average over entire segment/grid 2 = use response at center of segment/grid if length=2: Use response at pt closest to [r,z] OUTPUT: compdata = Compressed response vectors METHOD: If mod(size(data,1),ncntl_pts)==0, assume multiple response vectors (e.g. flux, Br, Bz).","title":"Basic Information"},{"location":"function-guide/design/compress_isoflux_response_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/design/connect_design_systems_m/","text":"connect_design_systems.m \u00b6 Basic Information \u00b6 SYNTAX: systot = connect_design_systems(connect_sys_in) PURPOSE: Connect individual design system components into a single system. INPUT: connect_sys_in = structure use_disturb = Disturbance input flag (1:Use 0:Do not use) tok_model = Model of tokamak system (output of build_XX_sys) plasma_sys = Tokamak syetem state-space model ps_sys = Power system state-space model (optional) filter_sys = Filter system state-sapce model (optional) outputs = Connected system output names (optional) [If not defined, all PS, plasma, & filter outputs passed] post_proc = Statements to evaluate at end of function (optional) OUTPUT: systot = State space model of combined system METHOD: Connections are determined using InputName and OutputName properties of the state-space models. Names must be a case insensitive match to each other to be properly connected. Duplicate output names in two systems will only match the first name in the order (PS,pl,filt), so avoid duplicate output names to remove any ambiguity, Dependencies \u00b6 sysconnect","title":"connect_design_systems.m"},{"location":"function-guide/design/connect_design_systems_m/#connect_design_systemsm","text":"","title":"connect_design_systems.m"},{"location":"function-guide/design/connect_design_systems_m/#basic-information","text":"SYNTAX: systot = connect_design_systems(connect_sys_in) PURPOSE: Connect individual design system components into a single system. INPUT: connect_sys_in = structure use_disturb = Disturbance input flag (1:Use 0:Do not use) tok_model = Model of tokamak system (output of build_XX_sys) plasma_sys = Tokamak syetem state-space model ps_sys = Power system state-space model (optional) filter_sys = Filter system state-sapce model (optional) outputs = Connected system output names (optional) [If not defined, all PS, plasma, & filter outputs passed] post_proc = Statements to evaluate at end of function (optional) OUTPUT: systot = State space model of combined system METHOD: Connections are determined using InputName and OutputName properties of the state-space models. Names must be a case insensitive match to each other to be properly connected. Duplicate output names in two systems will only match the first name in the order (PS,pl,filt), so avoid duplicate output names to remove any ambiguity,","title":"Basic Information"},{"location":"function-guide/design/connect_design_systems_m/#dependencies","text":"sysconnect","title":"Dependencies"},{"location":"function-guide/design/define_rtefit_objects_m/","text":"define_rtefit_objects.m \u00b6 Basic Information \u00b6 SYNTAX: rtefit_defns = define_rtefit_objects(exe_dir) PURPOSE: Get definitions and locations for objects used in rtefit. INPUT: exe_dir = Path to compiled pcs executable directory OUTPUT: rtefit_defns = structure containing rtefit definitions EF_NESUM = # E (ohmic) coils EF_NFCOIL = # F (poloidal field) coils EF_NVESSEL = # vessel segments EF_NW_MAX = # gridpoint in radial direction EF_NH_MAX = # gridpoint in vertical direction EF_NUM_GRIDPTS_FULLSET_INVESSEL = # gridpoints inside vessel EF_NUM_CURRENT_SOURCES_INVESSEL = # of all current sources EF_ICT_COILCOUNT =: 53 EF_ICT_COILCOUNT_4IZE: 3 EF_DATA_FILE_DIRECTORY = '/p/pcs/ops/data_nstx/rtefit_v7a/' nw = # gridpoint in radial direction nh = # gridpoints in verical direction keep = ??? keep_invessel = ??? keepw = R locations in keep set keeph = Z locations in keep set invessel_indices = indices of grid point within vessel r = R coordinates of keep set r_invessel = R coordinates of invessel grid points rinverse = 1./r rinverse_invessel: rinverse of invessel gridpoints z = Z corrdinates of keep set zero = ??? rgrid = R locations of grid zgrid = Z locations of grid descriptions RESTRICTIONS: METHOD: Dependencies \u00b6 parse_rtefitsizes wait","title":"define_rtefit_objects.m"},{"location":"function-guide/design/define_rtefit_objects_m/#define_rtefit_objectsm","text":"","title":"define_rtefit_objects.m"},{"location":"function-guide/design/define_rtefit_objects_m/#basic-information","text":"SYNTAX: rtefit_defns = define_rtefit_objects(exe_dir) PURPOSE: Get definitions and locations for objects used in rtefit. INPUT: exe_dir = Path to compiled pcs executable directory OUTPUT: rtefit_defns = structure containing rtefit definitions EF_NESUM = # E (ohmic) coils EF_NFCOIL = # F (poloidal field) coils EF_NVESSEL = # vessel segments EF_NW_MAX = # gridpoint in radial direction EF_NH_MAX = # gridpoint in vertical direction EF_NUM_GRIDPTS_FULLSET_INVESSEL = # gridpoints inside vessel EF_NUM_CURRENT_SOURCES_INVESSEL = # of all current sources EF_ICT_COILCOUNT =: 53 EF_ICT_COILCOUNT_4IZE: 3 EF_DATA_FILE_DIRECTORY = '/p/pcs/ops/data_nstx/rtefit_v7a/' nw = # gridpoint in radial direction nh = # gridpoints in verical direction keep = ??? keep_invessel = ??? keepw = R locations in keep set keeph = Z locations in keep set invessel_indices = indices of grid point within vessel r = R coordinates of keep set r_invessel = R coordinates of invessel grid points rinverse = 1./r rinverse_invessel: rinverse of invessel gridpoints z = Z corrdinates of keep set zero = ??? rgrid = R locations of grid zgrid = Z locations of grid descriptions RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/design/define_rtefit_objects_m/#dependencies","text":"parse_rtefitsizes wait","title":"Dependencies"},{"location":"function-guide/design/designeq_m/","text":"designeq.m \u00b6 Basic Information \u00b6 USAGE: [eq,eqx] = designeq(spec,tok,options,guiflag) PURPOSE: Design an equilibrium, designeq by itself opens a GUI for specification INPUTS: spec, structure with targets, weights, limits, locks, template tok, Toksys description of the tokamak options, settings and flags guiflag, flag to open the GUI (default 0 = no GUI) For deadstart: spec = 'circle' or 'ellipse' or 'lsn' or 'usn' or 'dn' spec may contain structures: targets, weights, limits, locks The solution is minimized deviation from weights*targets within limits. Implemented targets: cc, presr (pressure versus rho), jparar (j_parallel versus rho), rbbbs, zbbbs, rsurf, zsurf, aminor, kappa0, cpasma, betap, li, rcur, zcur, rx1, zx1, rx2, zx2, drsep, psibry, x1rleg, x1zleg, x2rleg, x2zleg (divertor leg coords), fun1, ..., fun9 (expressions, e.g. betap+li/2) Set spec.template = eq0 for same turnfc, fcid, cc format, etc. as eq0 spec.cccirc assigns a circuit (with sign) to each coil in cc For DIII-D do: PP_objs=get_PP_objs(shot), spec.buscode = [0 0 PP_objs.bus_code] options may contain fields: nkn, number of knots in splines for pres, fpol (default is 1) psikn, normalized flux values from 0 to 1 for knots (default equally spaced) idoplot, flag to plot progress of equilibrium design (default 1) maxiter, maximum iterations (25 by default) use_template_presr, use pressure vs rho of template equilibrium use_template_presr_normalized, use pressure vs rho of template equilibrium but scale magnitude depending on betap or similar targets use_template_jparar, use the j_parallel vs rho of template equilibrium use_template_jparar_normalized, use the j_parallel vs rho of template equilibrium but scale by: (kj1+kj2*linspace(1,0,nr)) depending on Ip, li, or similar targets iframe4movie, creates bitmap picture files of iteration progress OUTPUTS: eq, designed equilibrium eqx, extra information METHOD: Equilibrium fitted to weighted design objectives by Newton-Rhapson iterations Dependencies \u00b6 cc_efit_to_tok designeq_gui","title":"designeq.m"},{"location":"function-guide/design/designeq_m/#designeqm","text":"","title":"designeq.m"},{"location":"function-guide/design/designeq_m/#basic-information","text":"USAGE: [eq,eqx] = designeq(spec,tok,options,guiflag) PURPOSE: Design an equilibrium, designeq by itself opens a GUI for specification INPUTS: spec, structure with targets, weights, limits, locks, template tok, Toksys description of the tokamak options, settings and flags guiflag, flag to open the GUI (default 0 = no GUI) For deadstart: spec = 'circle' or 'ellipse' or 'lsn' or 'usn' or 'dn' spec may contain structures: targets, weights, limits, locks The solution is minimized deviation from weights*targets within limits. Implemented targets: cc, presr (pressure versus rho), jparar (j_parallel versus rho), rbbbs, zbbbs, rsurf, zsurf, aminor, kappa0, cpasma, betap, li, rcur, zcur, rx1, zx1, rx2, zx2, drsep, psibry, x1rleg, x1zleg, x2rleg, x2zleg (divertor leg coords), fun1, ..., fun9 (expressions, e.g. betap+li/2) Set spec.template = eq0 for same turnfc, fcid, cc format, etc. as eq0 spec.cccirc assigns a circuit (with sign) to each coil in cc For DIII-D do: PP_objs=get_PP_objs(shot), spec.buscode = [0 0 PP_objs.bus_code] options may contain fields: nkn, number of knots in splines for pres, fpol (default is 1) psikn, normalized flux values from 0 to 1 for knots (default equally spaced) idoplot, flag to plot progress of equilibrium design (default 1) maxiter, maximum iterations (25 by default) use_template_presr, use pressure vs rho of template equilibrium use_template_presr_normalized, use pressure vs rho of template equilibrium but scale magnitude depending on betap or similar targets use_template_jparar, use the j_parallel vs rho of template equilibrium use_template_jparar_normalized, use the j_parallel vs rho of template equilibrium but scale by: (kj1+kj2*linspace(1,0,nr)) depending on Ip, li, or similar targets iframe4movie, creates bitmap picture files of iteration progress OUTPUTS: eq, designed equilibrium eqx, extra information METHOD: Equilibrium fitted to weighted design objectives by Newton-Rhapson iterations","title":"Basic Information"},{"location":"function-guide/design/designeq_m/#dependencies","text":"cc_efit_to_tok designeq_gui","title":"Dependencies"},{"location":"function-guide/design/get_isoflux_filename_m/","text":"get_isoflux_filename.m \u00b6 Basic Information \u00b6 SYNTAX: filename = get_isoflux_filename(name,typeflag,rtefit_defns) PURPOSE: Get the unique filename for a given segment or grid INPUT: isoname = Base name of segment/grid (e.g. \"bot_3cm\") isotype = Designates object type: segment ('S') or grid ('G') rtefit_defns = structure (see define_rtefit_objects.m) OUTPUT: filename = Filename for given object, excluding prefixes & suffixes (e.g. grid \"bot_3cm\" returns \"bot_3cm_grid_00003\") ier = 0: file(s) found 1: No file found METHOD: Dependencies \u00b6","title":"get_isoflux_filename.m"},{"location":"function-guide/design/get_isoflux_filename_m/#get_isoflux_filenamem","text":"","title":"get_isoflux_filename.m"},{"location":"function-guide/design/get_isoflux_filename_m/#basic-information","text":"SYNTAX: filename = get_isoflux_filename(name,typeflag,rtefit_defns) PURPOSE: Get the unique filename for a given segment or grid INPUT: isoname = Base name of segment/grid (e.g. \"bot_3cm\") isotype = Designates object type: segment ('S') or grid ('G') rtefit_defns = structure (see define_rtefit_objects.m) OUTPUT: filename = Filename for given object, excluding prefixes & suffixes (e.g. grid \"bot_3cm\" returns \"bot_3cm_grid_00003\") ier = 0: file(s) found 1: No file found METHOD:","title":"Basic Information"},{"location":"function-guide/design/get_isoflux_filename_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/design/get_isoflux_grid_data_m/","text":"get_isoflux_grid_data.m \u00b6 Basic Information \u00b6 SYNTAX: [gridRZ,gridusage,gp,gd,gi,tp,td,ti] = get_isoflux_grid_data(shot,t0,datafunc,dt,algID) PURPOSE: Retrieves grid names, usage, and algorithms for a given shot & time INPUT: shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function dt = Interval around time to collect target data (s) [0.02] (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) algID = algorithm identifier, e.g., 'D' for isodnull, 'S' for isosnull (needed only if gains and tau values requested) OUTPUT: gridRZ = [R,Z] coordinates of segment control points at time t0 gridusage = Usage specification (0:Ignored, 1-4:Ref 1-4) RESTRICTIONS: Usage/alg targets must not change in interval [t0-dt,t0+dt] METHOD: Dependencies \u00b6 mk_var wait","title":"get_isoflux_grid_data.m"},{"location":"function-guide/design/get_isoflux_grid_data_m/#get_isoflux_grid_datam","text":"","title":"get_isoflux_grid_data.m"},{"location":"function-guide/design/get_isoflux_grid_data_m/#basic-information","text":"SYNTAX: [gridRZ,gridusage,gp,gd,gi,tp,td,ti] = get_isoflux_grid_data(shot,t0,datafunc,dt,algID) PURPOSE: Retrieves grid names, usage, and algorithms for a given shot & time INPUT: shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function dt = Interval around time to collect target data (s) [0.02] (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) algID = algorithm identifier, e.g., 'D' for isodnull, 'S' for isosnull (needed only if gains and tau values requested) OUTPUT: gridRZ = [R,Z] coordinates of segment control points at time t0 gridusage = Usage specification (0:Ignored, 1-4:Ref 1-4) RESTRICTIONS: Usage/alg targets must not change in interval [t0-dt,t0+dt] METHOD:","title":"Basic Information"},{"location":"function-guide/design/get_isoflux_grid_data_m/#dependencies","text":"mk_var wait","title":"Dependencies"},{"location":"function-guide/design/get_isoflux_ref_data_m/","text":"get_isoflux_ref_data.m \u00b6 Basic Information \u00b6 SYNTAX: ref_flux_src = get_isoflux_ref_data(shot,t0,datafunc,dt) PURPOSE: Retrieves reference flux sources for a given shot & time INPUT: [default] shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) dt = Interval around time to collect target data (s) [0.02] OUTPUT: ref_flux_src = Reference flux indices (length = 4). Indices #1-18 refer to segments 1-18. Indices 19 & 20 refer to grid1 & 2, respectively. RESTRICTIONS: Reference targets must not change in interval [t0-dt,t0+dt] Dependencies \u00b6 mk_var","title":"get_isoflux_ref_data.m"},{"location":"function-guide/design/get_isoflux_ref_data_m/#get_isoflux_ref_datam","text":"","title":"get_isoflux_ref_data.m"},{"location":"function-guide/design/get_isoflux_ref_data_m/#basic-information","text":"SYNTAX: ref_flux_src = get_isoflux_ref_data(shot,t0,datafunc,dt) PURPOSE: Retrieves reference flux sources for a given shot & time INPUT: [default] shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) dt = Interval around time to collect target data (s) [0.02] OUTPUT: ref_flux_src = Reference flux indices (length = 4). Indices #1-18 refer to segments 1-18. Indices 19 & 20 refer to grid1 & 2, respectively. RESTRICTIONS: Reference targets must not change in interval [t0-dt,t0+dt]","title":"Basic Information"},{"location":"function-guide/design/get_isoflux_ref_data_m/#dependencies","text":"mk_var","title":"Dependencies"},{"location":"function-guide/design/get_isoflux_segment_data_m/","text":"get_isoflux_segment_data.m \u00b6 Basic Information \u00b6 SYNTAX: [segRZ,segusage,segalg,gp,gd,gi,tp,td,ti] = get_isoflux_segment_data(shot,t0,datafunc,dt,nseg,algD) PURPOSE: Retrieves segment names, usage, and algorithms for a given shot & time INPUT: [default] shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function dt = Interval around time to collect target data (s) [0.02] (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) nseg = number of isoflux segments (optional, default=18) algID = algorithm identifier, e.g., 'D' for isodnull, 'S' for isosnull (needed only if gains and tau values requested) OUTPUT: segRZ = [R,Z] coordinates of segment control points at time t0 (m) segusage = Usage specification (0:Ignored, 1-4:Ref 1-4, 5:No Ref) segalg = Segment algorithm (1: Flux, 2: Br, 3: Bz 4: Locate touch point) (Note this is in build_design_model format and does not distinguish between \"at control point\" and \"at target\" at this time) gp,gd,gi = PID gains at the time t0 tp,td,di = PID tau values at the time t0 RESTRICTIONS: Usage/alg targets must not change in interval [t0-dt,t0+dt] METHOD: Dependencies \u00b6 mk_var wait","title":"get_isoflux_segment_data.m"},{"location":"function-guide/design/get_isoflux_segment_data_m/#get_isoflux_segment_datam","text":"","title":"get_isoflux_segment_data.m"},{"location":"function-guide/design/get_isoflux_segment_data_m/#basic-information","text":"SYNTAX: [segRZ,segusage,segalg,gp,gd,gi,tp,td,ti] = get_isoflux_segment_data(shot,t0,datafunc,dt,nseg,algD) PURPOSE: Retrieves segment names, usage, and algorithms for a given shot & time INPUT: [default] shot = Shot number t0 = Desired time for target (s) datafunc = Function handle to data collection function dt = Interval around time to collect target data (s) [0.02] (function must be of form [d,t,ier] = f(shot,signal,tmin,tmax)) nseg = number of isoflux segments (optional, default=18) algID = algorithm identifier, e.g., 'D' for isodnull, 'S' for isosnull (needed only if gains and tau values requested) OUTPUT: segRZ = [R,Z] coordinates of segment control points at time t0 (m) segusage = Usage specification (0:Ignored, 1-4:Ref 1-4, 5:No Ref) segalg = Segment algorithm (1: Flux, 2: Br, 3: Bz 4: Locate touch point) (Note this is in build_design_model format and does not distinguish between \"at control point\" and \"at target\" at this time) gp,gd,gi = PID gains at the time t0 tp,td,di = PID tau values at the time t0 RESTRICTIONS: Usage/alg targets must not change in interval [t0-dt,t0+dt] METHOD:","title":"Basic Information"},{"location":"function-guide/design/get_isoflux_segment_data_m/#dependencies","text":"mk_var wait","title":"Dependencies"},{"location":"function-guide/design/get_linest_from_ematrix_m/","text":"get_linest_from_ematrix.m \u00b6 Basic Information \u00b6 GET_LINEST_FROM_EMATRIX Returns inear estimator definitions from PCS Ematrix SYNTAX: linest_defs = get_linest_from_ematrix(shot,category,phase,matname) PURPOSE: Return linear estimator definitions from PCS Ematrix INPUT: shot = Shot number category = Category name phase = Isoflux phase name ematname = Ematrix name OUTPUT: linest_defs = ?? Dependencies \u00b6 get_pcssetup","title":"get_linest_from_ematrix.m"},{"location":"function-guide/design/get_linest_from_ematrix_m/#get_linest_from_ematrixm","text":"","title":"get_linest_from_ematrix.m"},{"location":"function-guide/design/get_linest_from_ematrix_m/#basic-information","text":"GET_LINEST_FROM_EMATRIX Returns inear estimator definitions from PCS Ematrix SYNTAX: linest_defs = get_linest_from_ematrix(shot,category,phase,matname) PURPOSE: Return linear estimator definitions from PCS Ematrix INPUT: shot = Shot number category = Category name phase = Isoflux phase name ematname = Ematrix name OUTPUT: linest_defs = ??","title":"Basic Information"},{"location":"function-guide/design/get_linest_from_ematrix_m/#dependencies","text":"get_pcssetup","title":"Dependencies"},{"location":"function-guide/design/parse_rtefitsizes_m/","text":"parse_rtefitsizes.m \u00b6 Basic Information \u00b6 SYNTAX: [rtefit_defns,ier] = parse_rtefitsizes(filename) PURPOSE: Returns rtEFIT variables (array sizes, directory names, etc...) contained within rtefitsizes.pro. This file is located with the PCS executable directory. INPUT: filename = Full path to valid rtefitsizes.pro file OUTPUT: rtefit_defns = Structure containing varname/value pairs from rtefitsizes.pro RESTRICTIONS: METHOD: Dependencies \u00b6","title":"parse_rtefitsizes.m"},{"location":"function-guide/design/parse_rtefitsizes_m/#parse_rtefitsizesm","text":"","title":"parse_rtefitsizes.m"},{"location":"function-guide/design/parse_rtefitsizes_m/#basic-information","text":"SYNTAX: [rtefit_defns,ier] = parse_rtefitsizes(filename) PURPOSE: Returns rtEFIT variables (array sizes, directory names, etc...) contained within rtefitsizes.pro. This file is located with the PCS executable directory. INPUT: filename = Full path to valid rtefitsizes.pro file OUTPUT: rtefit_defns = Structure containing varname/value pairs from rtefitsizes.pro RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/design/parse_rtefitsizes_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/design/read_response_m/","text":"read_response.m \u00b6 Basic Information \u00b6 SYNTAX: response_data = read_response(filename,rtefit_defns) PURPOSE: Read response info for control segment or grid. INPUT: filename = root name of file containing response data (doesn't include prefix \"ef_psi\", \"ef_br\", etc. or suffix \".dat\"). rtefit_defns = structure (see define_rtefit_objects.m) OUTPUT: response_data = structure isotype = String specifying grid (\"G\") or segment (\"S\") filename = Source file for raw response data cntl_pts= list of locations (r,z) of control points mutuals = mutual inductances between conductors and control points brg = greens function values from conductors to Br at control pts bzg = greens function values from conductors to Bz at control pts First coordinate in data objects mutuals, brgreens, bzgreens corresponds to conductors, in the following order: F-coils, next E-coils, next vessel elts, last nz x nr = grid elements. UNITS are Amp-turns, Wb/rad, and Tesla. (NOTE!! RTEFIT treats E-coils as having only 1 turn, so returned data assumes that also.) METHOD: Note that this function takes care of conversion from the rtefit convention, which uses a row-first indexing to the efit/matlab convention, which uses a column-first indexing. Dependencies \u00b6 read_util","title":"read_response.m"},{"location":"function-guide/design/read_response_m/#read_responsem","text":"","title":"read_response.m"},{"location":"function-guide/design/read_response_m/#basic-information","text":"SYNTAX: response_data = read_response(filename,rtefit_defns) PURPOSE: Read response info for control segment or grid. INPUT: filename = root name of file containing response data (doesn't include prefix \"ef_psi\", \"ef_br\", etc. or suffix \".dat\"). rtefit_defns = structure (see define_rtefit_objects.m) OUTPUT: response_data = structure isotype = String specifying grid (\"G\") or segment (\"S\") filename = Source file for raw response data cntl_pts= list of locations (r,z) of control points mutuals = mutual inductances between conductors and control points brg = greens function values from conductors to Br at control pts bzg = greens function values from conductors to Bz at control pts First coordinate in data objects mutuals, brgreens, bzgreens corresponds to conductors, in the following order: F-coils, next E-coils, next vessel elts, last nz x nr = grid elements. UNITS are Amp-turns, Wb/rad, and Tesla. (NOTE!! RTEFIT treats E-coils as having only 1 turn, so returned data assumes that also.) METHOD: Note that this function takes care of conversion from the rtefit convention, which uses a row-first indexing to the efit/matlab convention, which uses a column-first indexing.","title":"Basic Information"},{"location":"function-guide/design/read_response_m/#dependencies","text":"read_util","title":"Dependencies"},{"location":"function-guide/design/read_util_m/","text":"read_util.m \u00b6 Basic Information \u00b6 SYNTAX: [control_pts,response] = read_util(rtefit_defns,filename) PURPOSE: Read response info for control segments or grids INPUT: rtefit_defns = rtEFIT data definiton structure (see define_rtefit_objects.m) filename = File containing response data OUTPUT: cntrl_pts = list of locations (r,z) of control points response = brg,bzg,or mutuals between control point and current sources First coordinate in data objects mutuals, brgreens, bzgreens corresponds to conductors, in the following order: F-coils, E-coils, next vessel elts, last nz x nr = grid elements. UNITS are Amp-turns, Wb/rad, and Tesla METHOD: Note that this function takes care of conversion from the rtefit convention, which uses a row-first indexing to the efit/matlab convention, which uses a column-first indexing. Dependencies \u00b6","title":"read_util.m"},{"location":"function-guide/design/read_util_m/#read_utilm","text":"","title":"read_util.m"},{"location":"function-guide/design/read_util_m/#basic-information","text":"SYNTAX: [control_pts,response] = read_util(rtefit_defns,filename) PURPOSE: Read response info for control segments or grids INPUT: rtefit_defns = rtEFIT data definiton structure (see define_rtefit_objects.m) filename = File containing response data OUTPUT: cntrl_pts = list of locations (r,z) of control points response = brg,bzg,or mutuals between control point and current sources First coordinate in data objects mutuals, brgreens, bzgreens corresponds to conductors, in the following order: F-coils, E-coils, next vessel elts, last nz x nr = grid elements. UNITS are Amp-turns, Wb/rad, and Tesla METHOD: Note that this function takes care of conversion from the rtefit convention, which uses a row-first indexing to the efit/matlab convention, which uses a column-first indexing.","title":"Basic Information"},{"location":"function-guide/design/read_util_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/design/symmetrize_eq_m/","text":"symmetrize_eq.m \u00b6 Basic Information \u00b6 SYNTAX: [eq,eqx] = symmetrize_eq(eq0,vacObj,options) PURPOSE: Create up/down symmetric equlibrium structure from asymmetric source. INPUTS: eq0 = Original (asymmetric) equilbrium data structure vacObjs = Vacuum objects (e.g. tok_data_struct) options: mirrorBase = Basis for mirroring (-1:bottom 1:top) cccirc = cccirc to force symmetric coils idxExclude = Non-equilbrium coil states to exclude (e.g. IVC) OUTPUTS: eq = Symmeterized equilibrium eqx = Additional equilibrium data (see designeq.m) Dependencies \u00b6 designeq mk_var","title":"symmetrize_eq.m"},{"location":"function-guide/design/symmetrize_eq_m/#symmetrize_eqm","text":"","title":"symmetrize_eq.m"},{"location":"function-guide/design/symmetrize_eq_m/#basic-information","text":"SYNTAX: [eq,eqx] = symmetrize_eq(eq0,vacObj,options) PURPOSE: Create up/down symmetric equlibrium structure from asymmetric source. INPUTS: eq0 = Original (asymmetric) equilbrium data structure vacObjs = Vacuum objects (e.g. tok_data_struct) options: mirrorBase = Basis for mirroring (-1:bottom 1:top) cccirc = cccirc to force symmetric coils idxExclude = Non-equilbrium coil states to exclude (e.g. IVC) OUTPUTS: eq = Symmeterized equilibrium eqx = Additional equilibrium data (see designeq.m)","title":"Basic Information"},{"location":"function-guide/design/symmetrize_eq_m/#dependencies","text":"designeq mk_var","title":"Dependencies"},{"location":"function-guide/dmp/breakup_contour_matrix_m/","text":"breakup_contour_matrix.m \u00b6 Basic Information \u00b6 SYNTAX: breakup_contour_matrix(ContourMatrix) PURPOSE: Breakup a ContourMatrix of the type stored as the \".ContourMatrix\" property in contour graph objects in Matlab, and return the various lines that define the contours as a combination of X, Y, and Z points. INPUTS: ContourMatrix: The ContourMatrix from a Matlab contour chart object from which the X, Y and Z data of the contours is to be extracted. OUTPUTS: XData: The X-values of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. YData: The Y-values of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. ZData: The Z-values (levels) of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY: Dependencies \u00b6","title":"breakup_contour_matrix.m"},{"location":"function-guide/dmp/breakup_contour_matrix_m/#breakup_contour_matrixm","text":"","title":"breakup_contour_matrix.m"},{"location":"function-guide/dmp/breakup_contour_matrix_m/#basic-information","text":"SYNTAX: breakup_contour_matrix(ContourMatrix) PURPOSE: Breakup a ContourMatrix of the type stored as the \".ContourMatrix\" property in contour graph objects in Matlab, and return the various lines that define the contours as a combination of X, Y, and Z points. INPUTS: ContourMatrix: The ContourMatrix from a Matlab contour chart object from which the X, Y and Z data of the contours is to be extracted. OUTPUTS: XData: The X-values of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. YData: The Y-values of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. ZData: The Z-values (levels) of the lines that make up the contours in a contour chart object as a row vector. If more than one contour line exists on the graph, then each line is stored as a separate column in the array. NaN is added to fill unused rows. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/breakup_contour_matrix_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/dmp/bulk_save_fig_dmp_m/","text":"bulk_save_fig_dmp.m \u00b6 Basic Information \u00b6 SYNTAX: bulk_save_fig_dmp(dmp_fields,fig_paths) PURPOSE: Generate DIII-D DMP HDF5 files from matlab figures. INPUTS: *** If dmp_fields & fig_paths not provided, looks for a file in this directory called 'dmp_config.m' which defines them dmp_fields (optional): string path to matlab file defining structures dmp_fields and fig_paths as defined below. -or- dmp_fields (optional): a struct with these fields defined: dmp_fields.author_last [str]: Your last name dmp_fields.data_provider [str]: Name of data provider dmp_fields.publication_year [str]: Year of publication dmp_fields.journal [str]: Name of journal dmp_fields.doc_number [str]: DIII-D doc number for pubs tracker dmp_fields.citation [str]: Full citation fig_paths (optional): a cell-array of strings to map figures to .fig files: fig_paths{:,1} [str]: First column is figure numbers, a string like: '1', '2b', or '3abc' fig_paths{:,2} [str]: Second column is file paths to .fig file, like '~/figs/figure3.fig' ** Alternately, this column can be a cell array of multiple string file paths. In this case, it is assumed that the figure in the publication is a compound figure containing multiple .fig files. OUTPUTS: None in matlab - but will generate .hdf5 files in the current directory for each requested figure. RESTRICTIONS: Not all figure elements are currently support, but most are. See get_graph_data.m for the most up to date list of what is and what is not supported. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY: Dependencies \u00b6 save_dmp_hdf5 fancy_save fig2dmp","title":"bulk_save_fig_dmp.m"},{"location":"function-guide/dmp/bulk_save_fig_dmp_m/#bulk_save_fig_dmpm","text":"","title":"bulk_save_fig_dmp.m"},{"location":"function-guide/dmp/bulk_save_fig_dmp_m/#basic-information","text":"SYNTAX: bulk_save_fig_dmp(dmp_fields,fig_paths) PURPOSE: Generate DIII-D DMP HDF5 files from matlab figures. INPUTS: *** If dmp_fields & fig_paths not provided, looks for a file in this directory called 'dmp_config.m' which defines them dmp_fields (optional): string path to matlab file defining structures dmp_fields and fig_paths as defined below. -or- dmp_fields (optional): a struct with these fields defined: dmp_fields.author_last [str]: Your last name dmp_fields.data_provider [str]: Name of data provider dmp_fields.publication_year [str]: Year of publication dmp_fields.journal [str]: Name of journal dmp_fields.doc_number [str]: DIII-D doc number for pubs tracker dmp_fields.citation [str]: Full citation fig_paths (optional): a cell-array of strings to map figures to .fig files: fig_paths{:,1} [str]: First column is figure numbers, a string like: '1', '2b', or '3abc' fig_paths{:,2} [str]: Second column is file paths to .fig file, like '~/figs/figure3.fig' ** Alternately, this column can be a cell array of multiple string file paths. In this case, it is assumed that the figure in the publication is a compound figure containing multiple .fig files. OUTPUTS: None in matlab - but will generate .hdf5 files in the current directory for each requested figure. RESTRICTIONS: Not all figure elements are currently support, but most are. See get_graph_data.m for the most up to date list of what is and what is not supported. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/bulk_save_fig_dmp_m/#dependencies","text":"save_dmp_hdf5 fancy_save fig2dmp","title":"Dependencies"},{"location":"function-guide/dmp/check_dmphdf5_struct_m/","text":"check_dmphdf5_struct.m \u00b6 Basic Information \u00b6 SYNTAX: check_dmphdf5_struct(hdf5_struct) PURPOSE: Check a structure to see if it has the required fields and layout for the DIII-D DMP HDF5 file requirements. INPUTS: hdf5_struct: A structure to test OUTPUTS: warnings: A cell array of strings of warnings on missing fields or other problems with the structure. RESTRICTIONS: Additional checks may be done by the DIII-D DMP uploader. Also does not check if additional un-needed information is in the structure. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY: Dependencies \u00b6","title":"check_dmphdf5_struct.m"},{"location":"function-guide/dmp/check_dmphdf5_struct_m/#check_dmphdf5_structm","text":"","title":"check_dmphdf5_struct.m"},{"location":"function-guide/dmp/check_dmphdf5_struct_m/#basic-information","text":"SYNTAX: check_dmphdf5_struct(hdf5_struct) PURPOSE: Check a structure to see if it has the required fields and layout for the DIII-D DMP HDF5 file requirements. INPUTS: hdf5_struct: A structure to test OUTPUTS: warnings: A cell array of strings of warnings on missing fields or other problems with the structure. RESTRICTIONS: Additional checks may be done by the DIII-D DMP uploader. Also does not check if additional un-needed information is in the structure. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/check_dmphdf5_struct_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/dmp/dmphdf5_struct_m/","text":"dmphdf5_struct.m \u00b6 Basic Information \u00b6 SYNTAX: dmphdf5_struct(varargin) PURPOSE: Make a structure to hold data and plot information for exporting to the hdf5 format used for the DIII-D DMP. With no options the output structure has all of the required fields, but set to empty strings as an initialized template. INPUTS: varagin: Pairs of strings defining fields to define in the output structure in addition to the data incorporated from the figures. For example, to add info for the data provider these two added args would work: dmphdf5_struct('data_provider','John Doe') OUTPUTS: dmphdf5: The output structure for exporting to the DIII-D DMP hdf5 format. By default the fields are: -author_last: [string] The author's last name -journal: [string] the journal published in -publication_year: [string] the year of publication as a string -data_provider: [string] the name of the person person that provided the data in this graph -doc_number: [string] the DIII-D doc number for this article or document - it is assigned by the DIII-D publications tracker. -figure_number: [string] the figure number in the document. Ex: '1', '2b', '3abc' -citation: [string] a full citation for the publication that the figure appears in. -DATA: [struct] a structure in which the data from a figure is stored. Datasets from a figure are to be labeled DATA.dataset#, and should each have a corresponding DATA.dataheader# which has comma-separated header information defining each column of the data. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY: Dependencies \u00b6","title":"dmphdf5_struct.m"},{"location":"function-guide/dmp/dmphdf5_struct_m/#dmphdf5_structm","text":"","title":"dmphdf5_struct.m"},{"location":"function-guide/dmp/dmphdf5_struct_m/#basic-information","text":"SYNTAX: dmphdf5_struct(varargin) PURPOSE: Make a structure to hold data and plot information for exporting to the hdf5 format used for the DIII-D DMP. With no options the output structure has all of the required fields, but set to empty strings as an initialized template. INPUTS: varagin: Pairs of strings defining fields to define in the output structure in addition to the data incorporated from the figures. For example, to add info for the data provider these two added args would work: dmphdf5_struct('data_provider','John Doe') OUTPUTS: dmphdf5: The output structure for exporting to the DIII-D DMP hdf5 format. By default the fields are: -author_last: [string] The author's last name -journal: [string] the journal published in -publication_year: [string] the year of publication as a string -data_provider: [string] the name of the person person that provided the data in this graph -doc_number: [string] the DIII-D doc number for this article or document - it is assigned by the DIII-D publications tracker. -figure_number: [string] the figure number in the document. Ex: '1', '2b', '3abc' -citation: [string] a full citation for the publication that the figure appears in. -DATA: [struct] a structure in which the data from a figure is stored. Datasets from a figure are to be labeled DATA.dataset#, and should each have a corresponding DATA.dataheader# which has comma-separated header information defining each column of the data. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/dmphdf5_struct_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/dmp/fig2dmp_m/","text":"fig2dmp.m \u00b6 Basic Information \u00b6 SYNTAX: fig2dmp(figOrAxesHandles, contoursJustLevels, varargin) PURPOSE: Exteract the data from a figure, axes object, or combination of figure and axes objects, and store the data in a struture format that can be saved as an HDF5 in the DIII-D DMP format. INPUTS: figOrAxesHandles: Any number or combination of figure or axes objects. It will be assumed that all included figs/axes are a part of a final figure which should be included together in a single DMP hdf5 file. contoursJustLevels: (default=1) Option to just extract contour traces at the levels displayed in a figure, as opposed to all included data in the underlying matrix from which contours are displayed. For example: if an EFIT flux grid is in the figure, setting to 0 will include the entire flux grid in the output structure. Setting to 1 will just include the contours of flux displayed in the figure itself. varagin: Pairs of strings defining fields to define in the output structure in addition to the data incorporated from the figures. For example, to add info for the data provider these two added args would work: fig2dmp(fig_handles, 1, 'data_provider','John Doe') OUTPUTS: dmpstruct: A structure which can be exported to an hdf5 file in the format used for DIII-D DMP files. See dmphdf5_struct.m for more info on the format of the structure. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"fig2dmp.m"},{"location":"function-guide/dmp/fig2dmp_m/#fig2dmpm","text":"","title":"fig2dmp.m"},{"location":"function-guide/dmp/fig2dmp_m/#basic-information","text":"SYNTAX: fig2dmp(figOrAxesHandles, contoursJustLevels, varargin) PURPOSE: Exteract the data from a figure, axes object, or combination of figure and axes objects, and store the data in a struture format that can be saved as an HDF5 in the DIII-D DMP format. INPUTS: figOrAxesHandles: Any number or combination of figure or axes objects. It will be assumed that all included figs/axes are a part of a final figure which should be included together in a single DMP hdf5 file. contoursJustLevels: (default=1) Option to just extract contour traces at the levels displayed in a figure, as opposed to all included data in the underlying matrix from which contours are displayed. For example: if an EFIT flux grid is in the figure, setting to 0 will include the entire flux grid in the output structure. Setting to 1 will just include the contours of flux displayed in the figure itself. varagin: Pairs of strings defining fields to define in the output structure in addition to the data incorporated from the figures. For example, to add info for the data provider these two added args would work: fig2dmp(fig_handles, 1, 'data_provider','John Doe') OUTPUTS: dmpstruct: A structure which can be exported to an hdf5 file in the format used for DIII-D DMP files. See dmphdf5_struct.m for more info on the format of the structure. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/get_graph_data_m/","text":"get_graph_data.m \u00b6 Basic Information \u00b6 SYNTAX: get_graph_data(gObj, contoursJustLevels) PURPOSE: Exteract the data from a chart object in a figure. INPUTS: gObj: A chart object (like a line or surface) on a figure to extract the data from. See restrictions below for supported figure types. contoursJustLevels: (default=1) Option to just extract contour traces at the levels displayed in a figure, as opposed to all included data in the underlying matrix from which contours are displayed. For example: if an EFIT flux grid is in the figure, setting to 0 will include the entire flux grid in the output structure. Setting to 1 will just include the contours of flux displayed in the figure itself. OUTPUTS: ier: 0 if no failures to extract data, 1 if there was a problem (like the plot type is not supported, for example). DisplayName: The DisplayName of the chart object, if it was defined (usually defined by calling legend()). Type: The object type XData: The XData from the plotting object. If a polar plot, this corresponds to RData. If a lat-lot type plot, this corresponds to LongitudeData. YData: The YData from the plotting object. If a polar plot, this corresponds to ThetaData. If a lat-lot type plot, this corresponds to LattitudeData. ZData: The ZData from the plotting object, if it exists for this type of plot object. XNegativeDelta: For error-bars, the nagative X delta. XPositiveDelta: For error-bars, the positive X delta. YNegativeDelta: For error-bars, the nagative Y delta. YPositiveDelta: For error-bars, the positive Y delta. CData: For surface plots the color can be set to be data dependent, so it is stored if the user set the color to vary with the data. Exception: if the user set the color to just vary with the Z-data, then don't repeat this by just storing it again. RESTRICTIONS: Currently supported chart objects: -Area -Bar -Contour* -ErrorBar -Histogram/Histogram2: XData is BinEdges, YData is Values -Line -Scatter -Stair -Stem -Surface**: only type with CData & CDataMode * Contour plots only return data of displayed contours! (unless option \"contoursFullData\" is applied!) ** Only returns color data if CData & CDataMode are defined and CDataMode is set to 'manual' (aka user supplied data, not just a repeat of ZData) (future add option to force color?) *** If polar axes: XData contains RData values, YData contains ThetaData values. *** If lat/lon axes: XData contains LongitudeData values, YData contains LatitudeData values. **** Does NOT return symbol size or alpha data! Currently DOES NOT SUPPORT: -GeographicBubbleChart -Heatmap -Quiver -StackedAxes -StackedLineChart -WordCloudChart WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY: Dependencies \u00b6 breakup_contour_matrix","title":"get_graph_data.m"},{"location":"function-guide/dmp/get_graph_data_m/#get_graph_datam","text":"","title":"get_graph_data.m"},{"location":"function-guide/dmp/get_graph_data_m/#basic-information","text":"SYNTAX: get_graph_data(gObj, contoursJustLevels) PURPOSE: Exteract the data from a chart object in a figure. INPUTS: gObj: A chart object (like a line or surface) on a figure to extract the data from. See restrictions below for supported figure types. contoursJustLevels: (default=1) Option to just extract contour traces at the levels displayed in a figure, as opposed to all included data in the underlying matrix from which contours are displayed. For example: if an EFIT flux grid is in the figure, setting to 0 will include the entire flux grid in the output structure. Setting to 1 will just include the contours of flux displayed in the figure itself. OUTPUTS: ier: 0 if no failures to extract data, 1 if there was a problem (like the plot type is not supported, for example). DisplayName: The DisplayName of the chart object, if it was defined (usually defined by calling legend()). Type: The object type XData: The XData from the plotting object. If a polar plot, this corresponds to RData. If a lat-lot type plot, this corresponds to LongitudeData. YData: The YData from the plotting object. If a polar plot, this corresponds to ThetaData. If a lat-lot type plot, this corresponds to LattitudeData. ZData: The ZData from the plotting object, if it exists for this type of plot object. XNegativeDelta: For error-bars, the nagative X delta. XPositiveDelta: For error-bars, the positive X delta. YNegativeDelta: For error-bars, the nagative Y delta. YPositiveDelta: For error-bars, the positive Y delta. CData: For surface plots the color can be set to be data dependent, so it is stored if the user set the color to vary with the data. Exception: if the user set the color to just vary with the Z-data, then don't repeat this by just storing it again. RESTRICTIONS: Currently supported chart objects: -Area -Bar -Contour* -ErrorBar -Histogram/Histogram2: XData is BinEdges, YData is Values -Line -Scatter -Stair -Stem -Surface**: only type with CData & CDataMode * Contour plots only return data of displayed contours! (unless option \"contoursFullData\" is applied!) ** Only returns color data if CData & CDataMode are defined and CDataMode is set to 'manual' (aka user supplied data, not just a repeat of ZData) (future add option to force color?) *** If polar axes: XData contains RData values, YData contains ThetaData values. *** If lat/lon axes: XData contains LongitudeData values, YData contains LatitudeData values. **** Does NOT return symbol size or alpha data! Currently DOES NOT SUPPORT: -GeographicBubbleChart -Heatmap -Quiver -StackedAxes -StackedLineChart -WordCloudChart WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/get_graph_data_m/#dependencies","text":"breakup_contour_matrix","title":"Dependencies"},{"location":"function-guide/dmp/save_dmp_hdf5_m/","text":"save_dmp_hdf5.m \u00b6 Basic Information \u00b6 SYNTAX: save_dmp_hdf5(hdf5_struct, alt_name, append, verbose) PURPOSE: Save a structure of the type defined by dmphdf5_struct.m as an hdf5 file of the format for the DIII-D DMP hdf5 format. INPUTS: hdf5_struct: The struct containing publication informations and figure data of the format defined in dmphdf5_struct. alt_name: By default, the hdf5 file is named following a convention set by the DIII-D DMP. This allows a user to use a different filename if they should choose. The default which is used for DIII-D DMP is: DIII-D_[AuthorLastName]_[JournalName]_[PublicationYear]_Fig[figNumber].h5 append: [default = 0] Append new datasets and update information in a pre-existing hdf5 file with the same name. Default is 0, which will delete the previouds version of the hdf5 file before creating a new one. verbose: [default = 1] Print all warnings in addition to returning them. OUTPUTS: ier: 0 if no warnings after checking the structure before saving, otherwise 1. warnings: A cell array of strings of warnings on missing fields or other problems with the structure. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY: Dependencies \u00b6 check_dmphdf5_struct write_struct_to_hdf5","title":"save_dmp_hdf5.m"},{"location":"function-guide/dmp/save_dmp_hdf5_m/#save_dmp_hdf5m","text":"","title":"save_dmp_hdf5.m"},{"location":"function-guide/dmp/save_dmp_hdf5_m/#basic-information","text":"SYNTAX: save_dmp_hdf5(hdf5_struct, alt_name, append, verbose) PURPOSE: Save a structure of the type defined by dmphdf5_struct.m as an hdf5 file of the format for the DIII-D DMP hdf5 format. INPUTS: hdf5_struct: The struct containing publication informations and figure data of the format defined in dmphdf5_struct. alt_name: By default, the hdf5 file is named following a convention set by the DIII-D DMP. This allows a user to use a different filename if they should choose. The default which is used for DIII-D DMP is: DIII-D_[AuthorLastName]_[JournalName]_[PublicationYear]_Fig[figNumber].h5 append: [default = 0] Append new datasets and update information in a pre-existing hdf5 file with the same name. Default is 0, which will delete the previouds version of the hdf5 file before creating a new one. verbose: [default = 1] Print all warnings in addition to returning them. OUTPUTS: ier: 0 if no warnings after checking the structure before saving, otherwise 1. warnings: A cell array of strings of warnings on missing fields or other problems with the structure. RESTRICTIONS: WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/save_dmp_hdf5_m/#dependencies","text":"check_dmphdf5_struct write_struct_to_hdf5","title":"Dependencies"},{"location":"function-guide/dmp/write_struct_to_hdf5_m/","text":"write_struct_to_hdf5.m \u00b6 Basic Information \u00b6 SYNTAX: write_struct_to_hdf5(file_name,hdf5_struct,hdf5_path) PURPOSE: Write a structure to an hdf5 file. Note that the only elements that are supported are strings, arrays (up to 2-D), and sub-structures. Structures are used to define groups in the output hdf5 file. Strings are stored as variable length strings (not attributes). INPUTS: file_name: The filename to save the hdf5 file as. hdf5_struct: The structure to be exported to hdf5 format. hdf5_path: (optional - default='/') A path in the hdf5 file denoting the top-level group under which all data is to be stored under. This function is called recursively using this option to denote moving into a lower group. OUTPUTS: None RESTRICTIONS: Note that the only elements that are supported are strings, arrays (up to 2-D), and sub-structures. Structures are used to define groups in the output hdf5 file. Strings are stored as variable length strings (not attributes). Currently breaks if trying to update a previously existing hdf5 file and any elements overlap between the old and new data. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY: Dependencies \u00b6","title":"write_struct_to_hdf5.m"},{"location":"function-guide/dmp/write_struct_to_hdf5_m/#write_struct_to_hdf5m","text":"","title":"write_struct_to_hdf5.m"},{"location":"function-guide/dmp/write_struct_to_hdf5_m/#basic-information","text":"SYNTAX: write_struct_to_hdf5(file_name,hdf5_struct,hdf5_path) PURPOSE: Write a structure to an hdf5 file. Note that the only elements that are supported are strings, arrays (up to 2-D), and sub-structures. Structures are used to define groups in the output hdf5 file. Strings are stored as variable length strings (not attributes). INPUTS: file_name: The filename to save the hdf5 file as. hdf5_struct: The structure to be exported to hdf5 format. hdf5_path: (optional - default='/') A path in the hdf5 file denoting the top-level group under which all data is to be stored under. This function is called recursively using this option to denote moving into a lower group. OUTPUTS: None RESTRICTIONS: Note that the only elements that are supported are strings, arrays (up to 2-D), and sub-structures. Structures are used to define groups in the output hdf5 file. Strings are stored as variable length strings (not attributes). Currently breaks if trying to update a previously existing hdf5 file and any elements overlap between the old and new data. WRITTEN BY: Jayson Barr ON 10/11/18 MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/dmp/write_struct_to_hdf5_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/efit/cc_efit_to_tok_m/","text":"cc_efit_to_tok.m \u00b6 Basic Information \u00b6 SYNTAX: equil_I = cc_efit_to_tok(vac_objs,equil_data) PURPOSE: Convert equilibrium conductor currents in internal EFIT representation (contained in equil_data) into a representation compatible with toksys environment. INPUT: vac_objs = vacuum model data object structure equil_data = equilibrium data structure idx_efit_to_tok = optional map of efit pf coil indices to toksys indices, s.t. if I=currents in efit order, then ` I(idx_efit_to_tok)=currents in toksys order idxvv_efit_to_tok = \" vv indices \" \" \" OUTPUT: (units defined by imks, iterminal in vac_objs) equil_I = structure containing: cc0t = coil current equilibrium vector, toksys conductors cc0e = coil current equilibrium vector, EFIT conductors vc0t = vessel current equilibrium vector, toksys conductors vc0e = vessel current equilibrium vector, EFIT conductors cprojet = mapping: cc0t = cprojet*cc0e cprojte = mapping: cc0e = cprojte*cc0t vprojte = mapping: vc0e = vprojte*vc0t (Equilibrium vessel currents are usually all zero. In those cases, vc0e and vprojte are not produced.) Dependencies \u00b6 proj_turn wait","title":"cc_efit_to_tok.m"},{"location":"function-guide/efit/cc_efit_to_tok_m/#cc_efit_to_tokm","text":"","title":"cc_efit_to_tok.m"},{"location":"function-guide/efit/cc_efit_to_tok_m/#basic-information","text":"SYNTAX: equil_I = cc_efit_to_tok(vac_objs,equil_data) PURPOSE: Convert equilibrium conductor currents in internal EFIT representation (contained in equil_data) into a representation compatible with toksys environment. INPUT: vac_objs = vacuum model data object structure equil_data = equilibrium data structure idx_efit_to_tok = optional map of efit pf coil indices to toksys indices, s.t. if I=currents in efit order, then ` I(idx_efit_to_tok)=currents in toksys order idxvv_efit_to_tok = \" vv indices \" \" \" OUTPUT: (units defined by imks, iterminal in vac_objs) equil_I = structure containing: cc0t = coil current equilibrium vector, toksys conductors cc0e = coil current equilibrium vector, EFIT conductors vc0t = vessel current equilibrium vector, toksys conductors vc0e = vessel current equilibrium vector, EFIT conductors cprojet = mapping: cc0t = cprojet*cc0e cprojte = mapping: cc0e = cprojte*cc0t vprojte = mapping: vc0e = vprojte*vc0t (Equilibrium vessel currents are usually all zero. In those cases, vc0e and vprojte are not produced.)","title":"Basic Information"},{"location":"function-guide/efit/cc_efit_to_tok_m/#dependencies","text":"proj_turn wait","title":"Dependencies"},{"location":"function-guide/efit/efit_movie_m/","text":"efit_movie.m \u00b6 Basic Information \u00b6 USAGE: >>efit_movie PURPOSE: Script to display movie of EFIT flux patterns from set of EFITs. INPUTS: eqdir = string giving directory containing EFIT g-files (final character is '/', e.g. '/u/humphrys/efit/') shot = integer shot number t1ms = initial EFIT slice time (msec) t2ms = final EFIT slice time (msec) dtms = EFIT slices time interval (msec) OUTPUTS: EFIT movie displayed. RESTRICTIONS: EFIT g0-files identified by shot, t1ms, t2ms, dtms must exist in eqdir. Input variables must be defined; no defaults provided EXCEPT for eqdir, defaulted to './' (so uses default directory). METHOD: Dependencies \u00b6","title":"efit_movie.m"},{"location":"function-guide/efit/efit_movie_m/#efit_moviem","text":"","title":"efit_movie.m"},{"location":"function-guide/efit/efit_movie_m/#basic-information","text":"USAGE: >>efit_movie PURPOSE: Script to display movie of EFIT flux patterns from set of EFITs. INPUTS: eqdir = string giving directory containing EFIT g-files (final character is '/', e.g. '/u/humphrys/efit/') shot = integer shot number t1ms = initial EFIT slice time (msec) t2ms = final EFIT slice time (msec) dtms = EFIT slices time interval (msec) OUTPUTS: EFIT movie displayed. RESTRICTIONS: EFIT g0-files identified by shot, t1ms, t2ms, dtms must exist in eqdir. Input variables must be defined; no defaults provided EXCEPT for eqdir, defaulted to './' (so uses default directory). METHOD:","title":"Basic Information"},{"location":"function-guide/efit/efit_movie_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/efit/eq_mod_m/","text":"eq_mod.m \u00b6 Basic Information \u00b6 SYNTAX: eqmod= eq_mod(eq); PURPOSE: Puts time index as last index of each array. INPUT: <default> eq = structure from mds_eq OUTPUT: eqmod = structure containing EFIT eqdsk variables with time last entry Example: eq.BCENTR(255,1) => eqmod.BCENTER(1,255) see also mds_eq WRITTEN BY: Jim Leuer ON 6/11/03 ========================================================================== Defaults Dependencies \u00b6","title":"eq_mod.m"},{"location":"function-guide/efit/eq_mod_m/#eq_modm","text":"","title":"eq_mod.m"},{"location":"function-guide/efit/eq_mod_m/#basic-information","text":"SYNTAX: eqmod= eq_mod(eq); PURPOSE: Puts time index as last index of each array. INPUT: <default> eq = structure from mds_eq OUTPUT: eqmod = structure containing EFIT eqdsk variables with time last entry Example: eq.BCENTR(255,1) => eqmod.BCENTER(1,255) see also mds_eq WRITTEN BY: Jim Leuer ON 6/11/03 ========================================================================== Defaults","title":"Basic Information"},{"location":"function-guide/efit/eq_mod_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/efit/equil_to_gdata_m/","text":"equil_to_gdata.m \u00b6 Basic Information \u00b6 USAGE: [gdata,ireadok] = equil_to_gdata(equil, tms); USAGE: [gdata,ireadok] = equil_to_gdata(mds_string); calls read_mds_func PURPOSE: Convert equil data generated by read_mds_eq_func to read_gfile_func INPUTS: <default> equil= equilibrium data: equil=read_mds_eq_func(shot,tree,server); mds_string= optionally if equil is a string containing MDS+ tree information: format: <Server><.><tree>.shot.time Examples: 'D3D.EFIT09.g131498.02600' 'D3D.EFITRT1.131498.02600' '.g131498.02600' => 'D3D.EFIT01.g131498.02600' tms= time [ms] to use from equil data OUTPUTS: gdata = data structure containing EFIT G-file variables ireadok = flag to report good read of gfile (0=bad, 1=good) RESTRICTIONS: MDS EFIT Tree must exist for call with mds_string string convention NOTE TESTED WITH ANY MDS+ except D3D Dependencies \u00b6 shot_from_gfile read_gfile_func gfile_def","title":"equil_to_gdata.m"},{"location":"function-guide/efit/equil_to_gdata_m/#equil_to_gdatam","text":"","title":"equil_to_gdata.m"},{"location":"function-guide/efit/equil_to_gdata_m/#basic-information","text":"USAGE: [gdata,ireadok] = equil_to_gdata(equil, tms); USAGE: [gdata,ireadok] = equil_to_gdata(mds_string); calls read_mds_func PURPOSE: Convert equil data generated by read_mds_eq_func to read_gfile_func INPUTS: <default> equil= equilibrium data: equil=read_mds_eq_func(shot,tree,server); mds_string= optionally if equil is a string containing MDS+ tree information: format: <Server><.><tree>.shot.time Examples: 'D3D.EFIT09.g131498.02600' 'D3D.EFITRT1.131498.02600' '.g131498.02600' => 'D3D.EFIT01.g131498.02600' tms= time [ms] to use from equil data OUTPUTS: gdata = data structure containing EFIT G-file variables ireadok = flag to report good read of gfile (0=bad, 1=good) RESTRICTIONS: MDS EFIT Tree must exist for call with mds_string string convention NOTE TESTED WITH ANY MDS+ except D3D","title":"Basic Information"},{"location":"function-guide/efit/equil_to_gdata_m/#dependencies","text":"shot_from_gfile read_gfile_func gfile_def","title":"Dependencies"},{"location":"function-guide/efit/get_efit_data1_m/","text":"get_efit_data1.m \u00b6 Basic Information \u00b6 SYNTAX: get_efit_data PURPOSE: Script to extract many slices of EFIT data from set of a0-eqdsk files assumed present in default directory and plot selected data. INPUT: eqdir = directory for EFIT data files (default='./'); eqdir string must end in \"/\" (eg '/users/humphrys/matlab/') shot = shot number iplot = 1 if want to plot many frames on one plot (default) = 2 if want to plot Z,R,Ip(t) on different plots = 0 to skip plotting EFIT time slices are specified using EITHER of the following methods: tmiefit = 1st efit time slice (msec) dt = delta time (msec) nslices = # of efit slices OR: tefit = vector of efit times (msec) to read from a0 files. If tefit is specified, input variables tmiefit, dt, nslices are ignored. ipltref = present figure if want to start plotting after present fig (default=0) e.g. if ipltref=2, EFIT plots start at fig 3 Currently used only for iplot=1 OUTPUT: Extracts data from a0 files and plots things. Dependencies \u00b6 read_afile","title":"get_efit_data1.m"},{"location":"function-guide/efit/get_efit_data1_m/#get_efit_data1m","text":"","title":"get_efit_data1.m"},{"location":"function-guide/efit/get_efit_data1_m/#basic-information","text":"SYNTAX: get_efit_data PURPOSE: Script to extract many slices of EFIT data from set of a0-eqdsk files assumed present in default directory and plot selected data. INPUT: eqdir = directory for EFIT data files (default='./'); eqdir string must end in \"/\" (eg '/users/humphrys/matlab/') shot = shot number iplot = 1 if want to plot many frames on one plot (default) = 2 if want to plot Z,R,Ip(t) on different plots = 0 to skip plotting EFIT time slices are specified using EITHER of the following methods: tmiefit = 1st efit time slice (msec) dt = delta time (msec) nslices = # of efit slices OR: tefit = vector of efit times (msec) to read from a0 files. If tefit is specified, input variables tmiefit, dt, nslices are ignored. ipltref = present figure if want to start plotting after present fig (default=0) e.g. if ipltref=2, EFIT plots start at fig 3 Currently used only for iplot=1 OUTPUT: Extracts data from a0 files and plots things.","title":"Basic Information"},{"location":"function-guide/efit/get_efit_data1_m/#dependencies","text":"read_afile","title":"Dependencies"},{"location":"function-guide/efit/gfile_def_m/","text":"gfile_def.m \u00b6 Basic Information \u00b6 SYNTAX: gdef = gfile_def PURPOSE: Produces G-file variable definition structure for inclusion in gfile structure INPUT: (none) OUTPUT: gdef = data structure containing EFIT G-file variable definitions Dependencies \u00b6","title":"gfile_def.m"},{"location":"function-guide/efit/gfile_def_m/#gfile_defm","text":"","title":"gfile_def.m"},{"location":"function-guide/efit/gfile_def_m/#basic-information","text":"SYNTAX: gdef = gfile_def PURPOSE: Produces G-file variable definition structure for inclusion in gfile structure INPUT: (none) OUTPUT: gdef = data structure containing EFIT G-file variable definitions","title":"Basic Information"},{"location":"function-guide/efit/gfile_def_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/efit/inside_plasma_m/","text":"inside_plasma.m \u00b6 Basic Information \u00b6 inside_plasma sets matrix \"inside\" to 0's & 1's for outside & inside plasma SYNTAX: inside= inside_plasma(psizr, rgefit,zgefit, rbbbs,zbbbs,... psimag,psibnd, iplot,dofast); inside= inside_plasma(psirz, rgefit,zgefit, rbbbs,zbbbs); minimum input PURPOSE: set matrix \"inside\" with 0's or 1's depending if inside or outside plasma. Uses same input as typically generated by read_gfile INPUTS: <default> [optional] psizr= Flux on plasma grid in (nz,nr) array format (Wb) rgefit= Radius vector of plasma grid (m) zgefit= Z vector of plasma grid (m) rbbbs= Radius vector of closed polygon plasma boundary (m) zbbbs= Z vector of closed polygon plasma boundary (m) nbbbs= number of elements to use in rbbbs,zbbbs [psimag]= Flux on axis (Wb) <max(max(psizr))> [psibnd]= Flux on boundary (Wb) <average of psi on boundary> [iplot]= 1; plot results <0>, 2= outside plasma only [dofast]= 1; increases algorithm speed at risk of including some private flux in solution. Only extreme shapes like crescents and beans are expected to need dofast=0. Default is dofast=0 since speed is still very fast. <0> OUTPUTS: inside= Matrix of 1's & 0's for inside or outside plasma (nz,nr) RESTRICTIONS: rb,zb adjacent elements cant be identical. Not tested for coarse plasma boundary polygon mesh. METHOD: uses limits to do most screening and finally FE triangular formula Dependencies \u00b6","title":"inside_plasma.m"},{"location":"function-guide/efit/inside_plasma_m/#inside_plasmam","text":"","title":"inside_plasma.m"},{"location":"function-guide/efit/inside_plasma_m/#basic-information","text":"inside_plasma sets matrix \"inside\" to 0's & 1's for outside & inside plasma SYNTAX: inside= inside_plasma(psizr, rgefit,zgefit, rbbbs,zbbbs,... psimag,psibnd, iplot,dofast); inside= inside_plasma(psirz, rgefit,zgefit, rbbbs,zbbbs); minimum input PURPOSE: set matrix \"inside\" with 0's or 1's depending if inside or outside plasma. Uses same input as typically generated by read_gfile INPUTS: <default> [optional] psizr= Flux on plasma grid in (nz,nr) array format (Wb) rgefit= Radius vector of plasma grid (m) zgefit= Z vector of plasma grid (m) rbbbs= Radius vector of closed polygon plasma boundary (m) zbbbs= Z vector of closed polygon plasma boundary (m) nbbbs= number of elements to use in rbbbs,zbbbs [psimag]= Flux on axis (Wb) <max(max(psizr))> [psibnd]= Flux on boundary (Wb) <average of psi on boundary> [iplot]= 1; plot results <0>, 2= outside plasma only [dofast]= 1; increases algorithm speed at risk of including some private flux in solution. Only extreme shapes like crescents and beans are expected to need dofast=0. Default is dofast=0 since speed is still very fast. <0> OUTPUTS: inside= Matrix of 1's & 0's for inside or outside plasma (nz,nr) RESTRICTIONS: rb,zb adjacent elements cant be identical. Not tested for coarse plasma boundary polygon mesh. METHOD: uses limits to do most screening and finally FE triangular formula","title":"Basic Information"},{"location":"function-guide/efit/inside_plasma_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/efit/make_mhdindat_from_tds_m/","text":"make_mhdindat_from_tds.m \u00b6 Basic Information \u00b6 SYNTAX: make_mhdindat_from_tds(tok_data_struct,options) PURPOSE: Creates EFUND input file mhdin.dat from Toksys tok_data_struct INPUT: tok_data_struct options = structure fcid = Connections between fcoils (see cccirc in build_tokamak_system) [1:nc] use_vv = 1:Add VV elements as coils 0:Don't [0] vvid = VV element conenctions (see vvid in build_tokamamk_system) [1:nv] OUTPUT: mhdin.dat file RESTRICTIONS:","title":"make_mhdindat_from_tds.m"},{"location":"function-guide/efit/make_mhdindat_from_tds_m/#make_mhdindat_from_tdsm","text":"","title":"make_mhdindat_from_tds.m"},{"location":"function-guide/efit/make_mhdindat_from_tds_m/#basic-information","text":"SYNTAX: make_mhdindat_from_tds(tok_data_struct,options) PURPOSE: Creates EFUND input file mhdin.dat from Toksys tok_data_struct INPUT: tok_data_struct options = structure fcid = Connections between fcoils (see cccirc in build_tokamak_system) [1:nc] use_vv = 1:Add VV elements as coils 0:Don't [0] vvid = VV element conenctions (see vvid in build_tokamamk_system) [1:nv] OUTPUT: mhdin.dat file RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/efit/plasma_current_m/","text":"plasma_current.m \u00b6 Basic Information \u00b6 Function generates plasma current (pcurrt) from flux (psizr) SYNTAX: [pcur,jphi,cpasma]= plasma_current(psizr, pprime, ffprim,... psimag,psibnd,... rgefit,zgefit,... rbbbs,zbbbs,nbbbs,... iplot,dofast) PURPOSE: Generate plasma current from flux and current profile information Input is same as read_gfile input or mds_eq => eq_ga_env pcur is almost identical to that obtained using iecurr=2 in EFIT (error <~ 0.2 and max near boundary) INPUTS: [default] <optional> psizr= true flux on grid (Wb) pprime= p' vector (pprime from read_gfile) (nt/m^2)/(Vs/rad) ffprim= ff' vector (ffprim in read_gfile) (mT)^2/(Vs/rad) psimag= Flux on axis (Wb) [max(max(psizr))] psibnd= Flux on boundary (Wb) [average of flux on boundary] rgefit= Radius vector of grid (m) zgefit= Z vector of grid (m) rbbbs= Radius vector of boundary (m) zbbbs= Z vector of boundary (m) nbbbs= number of elements in rbbbs zbbbs [length(rbbbs] iplot= 2; 1= plot boundary, 2= contour jphi; 3= clabel [0] dofast= 1; increases algorithm speed at risk of including some private flux in solution. Only extreme shapes like crescents and beans are expected to need dofast=0. Default is dofast=0 since speed is still very fast. [0] <cpasma>= Plasma Current (A) OUTPUTS: pcur = plasma current on nr,nz grid [A] jphi= plasma current density on nr,nz grid [MA/m^2] cpasma= plasma current = sum(sum(pcur)) Warning messages displayed if sum(sum(pcur)) and existing cpasma are widely different. cpasma then overwritten. NOTE: ALL UNITS ARE MKS (except jphi is MA/m^2) CAUTION: Overwrites pcur, jphi & cpasma if read_gfile read from gfile RESTRICTIONS: SEE ALSO: inside_plasma Dependencies \u00b6 read_gfile inside_plasma","title":"plasma_current.m"},{"location":"function-guide/efit/plasma_current_m/#plasma_currentm","text":"","title":"plasma_current.m"},{"location":"function-guide/efit/plasma_current_m/#basic-information","text":"Function generates plasma current (pcurrt) from flux (psizr) SYNTAX: [pcur,jphi,cpasma]= plasma_current(psizr, pprime, ffprim,... psimag,psibnd,... rgefit,zgefit,... rbbbs,zbbbs,nbbbs,... iplot,dofast) PURPOSE: Generate plasma current from flux and current profile information Input is same as read_gfile input or mds_eq => eq_ga_env pcur is almost identical to that obtained using iecurr=2 in EFIT (error <~ 0.2 and max near boundary) INPUTS: [default] <optional> psizr= true flux on grid (Wb) pprime= p' vector (pprime from read_gfile) (nt/m^2)/(Vs/rad) ffprim= ff' vector (ffprim in read_gfile) (mT)^2/(Vs/rad) psimag= Flux on axis (Wb) [max(max(psizr))] psibnd= Flux on boundary (Wb) [average of flux on boundary] rgefit= Radius vector of grid (m) zgefit= Z vector of grid (m) rbbbs= Radius vector of boundary (m) zbbbs= Z vector of boundary (m) nbbbs= number of elements in rbbbs zbbbs [length(rbbbs] iplot= 2; 1= plot boundary, 2= contour jphi; 3= clabel [0] dofast= 1; increases algorithm speed at risk of including some private flux in solution. Only extreme shapes like crescents and beans are expected to need dofast=0. Default is dofast=0 since speed is still very fast. [0] <cpasma>= Plasma Current (A) OUTPUTS: pcur = plasma current on nr,nz grid [A] jphi= plasma current density on nr,nz grid [MA/m^2] cpasma= plasma current = sum(sum(pcur)) Warning messages displayed if sum(sum(pcur)) and existing cpasma are widely different. cpasma then overwritten. NOTE: ALL UNITS ARE MKS (except jphi is MA/m^2) CAUTION: Overwrites pcur, jphi & cpasma if read_gfile read from gfile RESTRICTIONS: SEE ALSO: inside_plasma","title":"Basic Information"},{"location":"function-guide/efit/plasma_current_m/#dependencies","text":"read_gfile inside_plasma","title":"Dependencies"},{"location":"function-guide/efit/read_afile_func_m/","text":"read_afile_func.m \u00b6 Basic Information \u00b6 USAGE: [adata,ireadok] = read_afile_func(filename,nfcoil,nesum,old_efit) PURPOSE: Read efit a-file INPUTS: <default> filename = a-file filename. Ex. 'a085352.03000' nsilop = Number of Psi loops. Default = 41 magpri = Number of mag probes. Default = 60 nfcoil = Number of fcoils. Default = 18 nesum = Number of e-coil circuits. Default = 6 OUTPUTS: adata = data structure containing EFIT A-file variables (all variables in a file with names based on EFIT convention) aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx ireadok = flag to report good read of afile (0=bad, 1=good) RESTRICTIONS: METHOD: WRITTEN BY: Luke Stagner (9/16/2020) Dependencies \u00b6","title":"read_afile_func.m"},{"location":"function-guide/efit/read_afile_func_m/#read_afile_funcm","text":"","title":"read_afile_func.m"},{"location":"function-guide/efit/read_afile_func_m/#basic-information","text":"USAGE: [adata,ireadok] = read_afile_func(filename,nfcoil,nesum,old_efit) PURPOSE: Read efit a-file INPUTS: <default> filename = a-file filename. Ex. 'a085352.03000' nsilop = Number of Psi loops. Default = 41 magpri = Number of mag probes. Default = 60 nfcoil = Number of fcoils. Default = 18 nesum = Number of e-coil circuits. Default = 6 OUTPUTS: adata = data structure containing EFIT A-file variables (all variables in a file with names based on EFIT convention) aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx ireadok = flag to report good read of afile (0=bad, 1=good) RESTRICTIONS: METHOD: WRITTEN BY: Luke Stagner (9/16/2020)","title":"Basic Information"},{"location":"function-guide/efit/read_afile_func_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/efit/read_eq_m/","text":"read_eq.m \u00b6 Basic Information \u00b6 USAGE: eq = read_eq(shot,times,source,tokamak) PURPOSE: Read equilibrium data from many possible sources and make structure according to toksys convention. Implemented sources are: 1. mds 2. A directory with efit g-files 3. A directory with corsica flat files INPUTS: shot is the shot number (no surprise there) times: times to fetch [sec] If empty or 'all' then all equilibria are fetched If single time specified, closest available time fetched If two times are specified they are tmin and tmax If >2 times are specified, only those exact times are fetched source: mds tree or directory with g files or directory with corsica flatfiles If source begins with a '/' it is a directory name, otherwise mds tree If server is 'corsica', source should contain flatfiles by create_corsica_flat_files tokamak: name of the tokamak, default 'DIII-D' server: optional mds server name. Default is standard mds server for tokamak. Use 'local' for data from GA test server (currently soas). OUTPUTS: eq = equilibrium data on toksys form, that can be used with cc_efit_to_tok and build_tokamak_system neq = number of equilibria returned eqraw = 'raw' eq data on original form before conversion to toksys convention RESTRICTIONS: Needs modification to work with Corsica files for tokamaks other than ITER METHOD: Dependencies \u00b6 read_corsica_flat_files read_gfile_tok read_mds_eqdsk","title":"read_eq.m"},{"location":"function-guide/efit/read_eq_m/#read_eqm","text":"","title":"read_eq.m"},{"location":"function-guide/efit/read_eq_m/#basic-information","text":"USAGE: eq = read_eq(shot,times,source,tokamak) PURPOSE: Read equilibrium data from many possible sources and make structure according to toksys convention. Implemented sources are: 1. mds 2. A directory with efit g-files 3. A directory with corsica flat files INPUTS: shot is the shot number (no surprise there) times: times to fetch [sec] If empty or 'all' then all equilibria are fetched If single time specified, closest available time fetched If two times are specified they are tmin and tmax If >2 times are specified, only those exact times are fetched source: mds tree or directory with g files or directory with corsica flatfiles If source begins with a '/' it is a directory name, otherwise mds tree If server is 'corsica', source should contain flatfiles by create_corsica_flat_files tokamak: name of the tokamak, default 'DIII-D' server: optional mds server name. Default is standard mds server for tokamak. Use 'local' for data from GA test server (currently soas). OUTPUTS: eq = equilibrium data on toksys form, that can be used with cc_efit_to_tok and build_tokamak_system neq = number of equilibria returned eqraw = 'raw' eq data on original form before conversion to toksys convention RESTRICTIONS: Needs modification to work with Corsica files for tokamaks other than ITER METHOD:","title":"Basic Information"},{"location":"function-guide/efit/read_eq_m/#dependencies","text":"read_corsica_flat_files read_gfile_tok read_mds_eqdsk","title":"Dependencies"},{"location":"function-guide/efit/read_gfile_func_m/","text":"read_gfile_func.m \u00b6 Basic Information \u00b6 USAGE: [gdata,ireadok] = read_gfile_func(filename,nfcoil,nesum,old_efit) [gdata,ireadok] = read_gfile_func(mds_string, ...); NEW MDS+ OPTION PURPOSE: Read efit ASCII g-eqdsk file w/ flag iecurr=2 set INPUTS: <default> filename = gfile filename [Ex: '/u/leuer/efit/diiid/s87977/g087977.02620'] nfcoil = number of F-coils <18 for DIII-D> nesum = number of E-coils <6 for DIII-D> old_efit= For iecurr=2 several different flavors of efit output exists. <Optional, default=0> For old versions of efit (e.g. NSTX) use old_efit=1 since it uses older efit version. NEW MDS READ OPTION: If directory of filename not found then looks in mds mds_string= string: Server.tree.shot.time [ex: 'D3D.EFIT01.g131498.02600'] OUTPUTS: gdata = data structure containing EFIT G-file variables ireadok = flag to report good read of gfile (0=bad, 1=good) RESTRICTIONS: gfile must be produced by EFIT run with flag iecurr=2 in order to write current density distribution on plasma grid & coil currents. (NEW versions of EFIT use iplcout=2 instead of iecurr) Dependencies \u00b6 equil_to_gdata wait gfile_def plasma_current","title":"read_gfile_func.m"},{"location":"function-guide/efit/read_gfile_func_m/#read_gfile_funcm","text":"","title":"read_gfile_func.m"},{"location":"function-guide/efit/read_gfile_func_m/#basic-information","text":"USAGE: [gdata,ireadok] = read_gfile_func(filename,nfcoil,nesum,old_efit) [gdata,ireadok] = read_gfile_func(mds_string, ...); NEW MDS+ OPTION PURPOSE: Read efit ASCII g-eqdsk file w/ flag iecurr=2 set INPUTS: <default> filename = gfile filename [Ex: '/u/leuer/efit/diiid/s87977/g087977.02620'] nfcoil = number of F-coils <18 for DIII-D> nesum = number of E-coils <6 for DIII-D> old_efit= For iecurr=2 several different flavors of efit output exists. <Optional, default=0> For old versions of efit (e.g. NSTX) use old_efit=1 since it uses older efit version. NEW MDS READ OPTION: If directory of filename not found then looks in mds mds_string= string: Server.tree.shot.time [ex: 'D3D.EFIT01.g131498.02600'] OUTPUTS: gdata = data structure containing EFIT G-file variables ireadok = flag to report good read of gfile (0=bad, 1=good) RESTRICTIONS: gfile must be produced by EFIT run with flag iecurr=2 in order to write current density distribution on plasma grid & coil currents. (NEW versions of EFIT use iplcout=2 instead of iecurr)","title":"Basic Information"},{"location":"function-guide/efit/read_gfile_func_m/#dependencies","text":"equil_to_gdata wait gfile_def plasma_current","title":"Dependencies"},{"location":"function-guide/efit/read_gfile_m/","text":"read_gfile.m \u00b6 Basic Information \u00b6 USAGE: >>read_gfile PURPOSE: Script to read efit ASCII g-eqdsk file w/ flag iecurr=2 set INPUTS: [default] filename = ['g083750.04838']; g0-eqdsk filename - Can contain directory nfcoil = [18]; # of F-coils; must be specified for non-D3D (Optional) defaults to D3D values of nfcoil=18 nesum = [6]; # of E-coils; must be specified for non-D3D (Optional) defaults to D3D value of nesum=6 (for > 6seg case) old_efit=[0]; For iecurr=2 several different flavors of efit output exists. (Optional) For old versions of efit (i.e. NSTX) you want old_efit=1 since they use older efit version. OUTPUTS: (Produces large set of data objects from g0-file in Matlab environment.) ireadok = flag to report good read of gfile (0=bad, 1=good) jphi=current density on grid MA/m^2 psizr = true total flux on grid in Wb psimag = axis flux in true Wb psibnd = boundary flux in true Wb (psibry also defined same) cc = E/F coil currents in MA-turns cc2 = E/F coil currents in MA-turns (for 2-segment E-coil) CAUTION: cc2 has min(2,nesum) E-coil elements (could be 1 vs std: 2) RESTRICTIONS: g0 file must be produced by EFIT run with flag iecurr=2 in order to write current density distribution on grid. Must set nesum to correct number of e-coil segments at top of file. May overwrite some data objects in D3D environment from load_d3denv. METHOD: Follows write/read format of EFIT file weqdskx.for, reads usual g-file data, reads coil current and jphi data (if iecurr was set =2 in EFIT run), defines some flux variables and converts some variables to D3D Matlab data environment standards. Dependencies \u00b6","title":"read_gfile.m"},{"location":"function-guide/efit/read_gfile_m/#read_gfilem","text":"","title":"read_gfile.m"},{"location":"function-guide/efit/read_gfile_m/#basic-information","text":"USAGE: >>read_gfile PURPOSE: Script to read efit ASCII g-eqdsk file w/ flag iecurr=2 set INPUTS: [default] filename = ['g083750.04838']; g0-eqdsk filename - Can contain directory nfcoil = [18]; # of F-coils; must be specified for non-D3D (Optional) defaults to D3D values of nfcoil=18 nesum = [6]; # of E-coils; must be specified for non-D3D (Optional) defaults to D3D value of nesum=6 (for > 6seg case) old_efit=[0]; For iecurr=2 several different flavors of efit output exists. (Optional) For old versions of efit (i.e. NSTX) you want old_efit=1 since they use older efit version. OUTPUTS: (Produces large set of data objects from g0-file in Matlab environment.) ireadok = flag to report good read of gfile (0=bad, 1=good) jphi=current density on grid MA/m^2 psizr = true total flux on grid in Wb psimag = axis flux in true Wb psibnd = boundary flux in true Wb (psibry also defined same) cc = E/F coil currents in MA-turns cc2 = E/F coil currents in MA-turns (for 2-segment E-coil) CAUTION: cc2 has min(2,nesum) E-coil elements (could be 1 vs std: 2) RESTRICTIONS: g0 file must be produced by EFIT run with flag iecurr=2 in order to write current density distribution on grid. Must set nesum to correct number of e-coil segments at top of file. May overwrite some data objects in D3D environment from load_d3denv. METHOD: Follows write/read format of EFIT file weqdskx.for, reads usual g-file data, reads coil current and jphi data (if iecurr was set =2 in EFIT run), defines some flux variables and converts some variables to D3D Matlab data environment standards.","title":"Basic Information"},{"location":"function-guide/efit/read_gfile_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/efit/read_gfile_tok_m/","text":"read_gfile_tok.m \u00b6 Basic Information \u00b6 USAGE: gfile_data = ... read_gfile_tok(filename,tokamak,nfcoil,nesum,nves,old_efit,cc_file) gfile_data = read_gfile_tok(filename); default DIII-D read PURPOSE: Read efit ASCII g-eqdsk file for specific tokamak. INPUTS: <default> filename= g0-eqdsk filename (printed with iecurr=2 or iplcout=1) Note: filename= gShot.Time name is parced to get shot number tokamak = one of 'DIII-D','d3d','NSTX','EAST','KSTAR','ITER','CTF' PEGASUS, (Not CASE sensitive so DIII-D <=> diii-d) if not one of above then need nfcoil,nesum,... <'DIII-D'>) nfcoil = number of F-coils <default specific to each machine - below> nesum = number of E-coils <default specific to each machine - below> nves = number of vessel elements included in efit data <defaults below> old_efit= For iecurr=2 several different flavors of efit output exists. (Optional, default=0) For old versions of efit (e.g. NSTX) use old_efit=1 since it uses older efit version. cc_file= coil current file name [cc=load(cc_file)] or coil current vector use when coil currents not available from efit (or to override) (units = MA-turns) Current Machine Defaults: (Default tokamak is DIII-D) Tokamak nfcoil nesum nves old_efit Size(cc) Note DIII-D 18 6 0 0 18+6=24 6-seg E-coil NSTX 11 1 30 1 41+1=42 1E+11F+30VV after shot 115265, April 2 2005 set old_efit=0 or shot#>=115265 NSTX 17 1 35 1 1+17+35=42 1E+17F+35VV NSTX internally switches on shot # determined from gfile name ex: /g120423.00533 => shot= 120423 => old_efit=0 KSTAR 14 1 0 0 14+4=18 no E; 4IC's sab10 14 1 60+24 0 14+4=18 12 VV Groups rtefit 18 1 60+10 0 18 ic included 33x33 14VCefit EAST 12 1 0 0 14 no E; IC's? CTF 14 1 24 0 14 NO E; FDF 14 0 24 0 14 NO E; FDF2009? 22 0 24 0 22 FDF2011 PEGASUS 17 1 0 0 17 ITER 12 1 113 0 12 NO E HL2M 16 1 24 0 16 1E other nfcoil nesum 0 0 nfcoil+nesum need coil #'s Note: Including nfcoil, nesum ... in argument list with a particular machine overrides the machine default numbers Note: filename= \"..../gShot.Time\" format is parced to get shot number if needed to differentiate between machine configurations (i.e. NSTX) OUTPUTS: gfile_data = structure containing data read directly from g-file and variables derived from this original data. RESTRICTIONS: g0 file must be produced by EFIT run with flag iecurr=2 or iplcout=1 in order to write current density distribution on grid and coil cc's Dependencies \u00b6 diff_mat shot_from_gfile std_efit_units wait read_gfile_func","title":"read_gfile_tok.m"},{"location":"function-guide/efit/read_gfile_tok_m/#read_gfile_tokm","text":"","title":"read_gfile_tok.m"},{"location":"function-guide/efit/read_gfile_tok_m/#basic-information","text":"USAGE: gfile_data = ... read_gfile_tok(filename,tokamak,nfcoil,nesum,nves,old_efit,cc_file) gfile_data = read_gfile_tok(filename); default DIII-D read PURPOSE: Read efit ASCII g-eqdsk file for specific tokamak. INPUTS: <default> filename= g0-eqdsk filename (printed with iecurr=2 or iplcout=1) Note: filename= gShot.Time name is parced to get shot number tokamak = one of 'DIII-D','d3d','NSTX','EAST','KSTAR','ITER','CTF' PEGASUS, (Not CASE sensitive so DIII-D <=> diii-d) if not one of above then need nfcoil,nesum,... <'DIII-D'>) nfcoil = number of F-coils <default specific to each machine - below> nesum = number of E-coils <default specific to each machine - below> nves = number of vessel elements included in efit data <defaults below> old_efit= For iecurr=2 several different flavors of efit output exists. (Optional, default=0) For old versions of efit (e.g. NSTX) use old_efit=1 since it uses older efit version. cc_file= coil current file name [cc=load(cc_file)] or coil current vector use when coil currents not available from efit (or to override) (units = MA-turns) Current Machine Defaults: (Default tokamak is DIII-D) Tokamak nfcoil nesum nves old_efit Size(cc) Note DIII-D 18 6 0 0 18+6=24 6-seg E-coil NSTX 11 1 30 1 41+1=42 1E+11F+30VV after shot 115265, April 2 2005 set old_efit=0 or shot#>=115265 NSTX 17 1 35 1 1+17+35=42 1E+17F+35VV NSTX internally switches on shot # determined from gfile name ex: /g120423.00533 => shot= 120423 => old_efit=0 KSTAR 14 1 0 0 14+4=18 no E; 4IC's sab10 14 1 60+24 0 14+4=18 12 VV Groups rtefit 18 1 60+10 0 18 ic included 33x33 14VCefit EAST 12 1 0 0 14 no E; IC's? CTF 14 1 24 0 14 NO E; FDF 14 0 24 0 14 NO E; FDF2009? 22 0 24 0 22 FDF2011 PEGASUS 17 1 0 0 17 ITER 12 1 113 0 12 NO E HL2M 16 1 24 0 16 1E other nfcoil nesum 0 0 nfcoil+nesum need coil #'s Note: Including nfcoil, nesum ... in argument list with a particular machine overrides the machine default numbers Note: filename= \"..../gShot.Time\" format is parced to get shot number if needed to differentiate between machine configurations (i.e. NSTX) OUTPUTS: gfile_data = structure containing data read directly from g-file and variables derived from this original data. RESTRICTIONS: g0 file must be produced by EFIT run with flag iecurr=2 or iplcout=1 in order to write current density distribution on grid and coil cc's","title":"Basic Information"},{"location":"function-guide/efit/read_gfile_tok_m/#dependencies","text":"diff_mat shot_from_gfile std_efit_units wait read_gfile_func","title":"Dependencies"},{"location":"function-guide/efit/read_mds_eq_func_m/","text":"read_mds_eq_func.m \u00b6 Basic Information \u00b6 SYNTAX: [equil,neq,eq,ier] = read_mds_eq_func(shotnum,tree,server) PURPOSE: Generic read of geqdsk and aeqdsk data, returning data in approximately the same form as read_gfile_func.m. (data needed from aeqdsk not well-defined yet) INPUT: <default> shotnum = shot number tree = mdsplus tree containing efit data server = mdsplus server name verbose= 1; print out progressive info. during MDS READ, 0=no print <[]> OUTPUT: equil = structure containing: gdef = text description of variables shotnum = shot number of equilibria time = array of times of equilibria gdata = array of structures containing geqdsk data (same data produced by read_equil_func) adata = array of structureus containing aeqdsk data neq = number of equilibria found eq = equilibrium structure returned by get_mds_tree ier = error code RESTRICTIONS: The bzero and ecase entries of equil.gdata are empty. Dependencies \u00b6 wait gfile_def plasma_current get_mds_tree","title":"read_mds_eq_func.m"},{"location":"function-guide/efit/read_mds_eq_func_m/#read_mds_eq_funcm","text":"","title":"read_mds_eq_func.m"},{"location":"function-guide/efit/read_mds_eq_func_m/#basic-information","text":"SYNTAX: [equil,neq,eq,ier] = read_mds_eq_func(shotnum,tree,server) PURPOSE: Generic read of geqdsk and aeqdsk data, returning data in approximately the same form as read_gfile_func.m. (data needed from aeqdsk not well-defined yet) INPUT: <default> shotnum = shot number tree = mdsplus tree containing efit data server = mdsplus server name verbose= 1; print out progressive info. during MDS READ, 0=no print <[]> OUTPUT: equil = structure containing: gdef = text description of variables shotnum = shot number of equilibria time = array of times of equilibria gdata = array of structures containing geqdsk data (same data produced by read_equil_func) adata = array of structureus containing aeqdsk data neq = number of equilibria found eq = equilibrium structure returned by get_mds_tree ier = error code RESTRICTIONS: The bzero and ecase entries of equil.gdata are empty.","title":"Basic Information"},{"location":"function-guide/efit/read_mds_eq_func_m/#dependencies","text":"wait gfile_def plasma_current get_mds_tree","title":"Dependencies"},{"location":"function-guide/efit/read_mds_eqdsk_m/","text":"read_mds_eqdsk.m \u00b6 Basic Information \u00b6 SYNTAX: [eqdata,neq,eq,ier] = read_mds_eqdsk(shotnum,times,efit_source,tokamak,server) PURPOSE: Read geqdsk and aeqdsk data from mdsplus, return data like read_gfile_tok.m. (data needed from aeqdsk not well-defined yet) INPUT: <default> shotnum = shot number times = equilibrium time(s), one of: if single float#: closest time available in mds (s) if pair [t1,t2]: times between t1 and t2 (s) if 'all': return all times in tree <'ALL'> efit_source = source tree for EFIT (e.g. <'EFIT01'>, 'EFITRT1') tokamak = tokamak name. <DIII-D> server = optional server name. Default is to use standard mds server for tokamak. Use 'local' to get data from the GA test server (currently vidar). OUTPUT: eqdata = array of structures, each containing info from 1 eqdsk (single time causes structure returned to be like read_gfile_tok; others return extended structures) neq = number of eqdsk's returned eq = entire tree containing efit equilibrium data ier = error code RESTRICTIONS: Only handles D3D, EAST, KSTAR, and NSTX(EFITRT only) right now. Need to add code for the other devices supported by read_gfile_tok.m. Dependencies \u00b6 read_mds_eq_func wait std_efit_units","title":"read_mds_eqdsk.m"},{"location":"function-guide/efit/read_mds_eqdsk_m/#read_mds_eqdskm","text":"","title":"read_mds_eqdsk.m"},{"location":"function-guide/efit/read_mds_eqdsk_m/#basic-information","text":"SYNTAX: [eqdata,neq,eq,ier] = read_mds_eqdsk(shotnum,times,efit_source,tokamak,server) PURPOSE: Read geqdsk and aeqdsk data from mdsplus, return data like read_gfile_tok.m. (data needed from aeqdsk not well-defined yet) INPUT: <default> shotnum = shot number times = equilibrium time(s), one of: if single float#: closest time available in mds (s) if pair [t1,t2]: times between t1 and t2 (s) if 'all': return all times in tree <'ALL'> efit_source = source tree for EFIT (e.g. <'EFIT01'>, 'EFITRT1') tokamak = tokamak name. <DIII-D> server = optional server name. Default is to use standard mds server for tokamak. Use 'local' to get data from the GA test server (currently vidar). OUTPUT: eqdata = array of structures, each containing info from 1 eqdsk (single time causes structure returned to be like read_gfile_tok; others return extended structures) neq = number of eqdsk's returned eq = entire tree containing efit equilibrium data ier = error code RESTRICTIONS: Only handles D3D, EAST, KSTAR, and NSTX(EFITRT only) right now. Need to add code for the other devices supported by read_gfile_tok.m.","title":"Basic Information"},{"location":"function-guide/efit/read_mds_eqdsk_m/#dependencies","text":"read_mds_eq_func wait std_efit_units","title":"Dependencies"},{"location":"function-guide/efit/read_mds_g_func_m/","text":"read_mds_g_func.m \u00b6 Basic Information \u00b6 SYNTAX: [gfile,neq,eq] = read_mds_g_func(shotnum,tree,server) PURPOSE: Read geqdsk generic function, returning data in approximately the same form as read_gfile_func.m. INPUT: shotnum = shot number tree = mdsplus tree containing efit data server = mdsplus server name OUTPUT: gfile = structure containing: gdef = text description of variables shotnum = shot number of equilibria time = array of times of equilibria data = array of structures containing data (same data produced by read_gfile_func) neq = number of equilibria found eq = equilibrium structure returned by eq_mds RESTRICTIONS: The bzero and ecase entries of gfile.data are empty. Dependencies \u00b6 gfile_def plasma_current wait","title":"read_mds_g_func.m"},{"location":"function-guide/efit/read_mds_g_func_m/#read_mds_g_funcm","text":"","title":"read_mds_g_func.m"},{"location":"function-guide/efit/read_mds_g_func_m/#basic-information","text":"SYNTAX: [gfile,neq,eq] = read_mds_g_func(shotnum,tree,server) PURPOSE: Read geqdsk generic function, returning data in approximately the same form as read_gfile_func.m. INPUT: shotnum = shot number tree = mdsplus tree containing efit data server = mdsplus server name OUTPUT: gfile = structure containing: gdef = text description of variables shotnum = shot number of equilibria time = array of times of equilibria data = array of structures containing data (same data produced by read_gfile_func) neq = number of equilibria found eq = equilibrium structure returned by eq_mds RESTRICTIONS: The bzero and ecase entries of gfile.data are empty.","title":"Basic Information"},{"location":"function-guide/efit/read_mds_g_func_m/#dependencies","text":"gfile_def plasma_current wait","title":"Dependencies"},{"location":"function-guide/efit/read_mhdin_m/","text":"read_mhdin.m \u00b6 Basic Information \u00b6 USAGE: >>read_mhdin PURPOSE: reads efit file mhdin.dat. All variables are added in UPPER CASE INPUTS: [default] filename = ['mhdin.dat']; EFIT mhdin.dat file name Can contain directory Note: below dimensions are needed only if geometry is read below namelist defaults for D3D nfcoil = [18]; # of F-coils; must be specified for non-D3D (Opt.) defaults to D3D values of nfcoil=18 necoil = [122]; # number of E-coils elements specify for non-D3D (Opt.) defaults to D3D value of nesum=6 nsilop = [41]; # flux loops, needed if not read in namelist (opt.) nvesel = [24]; # vessels, needed if not read in namelist (opt.) OUTPUTS: all name list items: IGRID, RLEFT, RRIGHT, ... FCID, FCTURN, ... PF coil geometry if nfcoil>0, E-coil geometry if nesum>0 ireadok = flag to report good read of gfile (0=bad, 1=good) CAUTION: Namelist is read with to_upper=+1 which makes all variables UPPER CASE. New read_namelist in /thor/leuer/matlab/util/read_namelist.m allows change of case. We want to read and make all variables UC To change UPPER CASE to lower case use: mhdin_list= mk_uc_lc_var; makes all lower case variables (nothing to UPCASE) mhdin_list= mk_uc_lc_var('-remove_upper','*'); remove upper case Dependencies \u00b6 fix_undscr plot_box read_mhdin read_namelist","title":"read_mhdin.m"},{"location":"function-guide/efit/read_mhdin_m/#read_mhdinm","text":"","title":"read_mhdin.m"},{"location":"function-guide/efit/read_mhdin_m/#basic-information","text":"USAGE: >>read_mhdin PURPOSE: reads efit file mhdin.dat. All variables are added in UPPER CASE INPUTS: [default] filename = ['mhdin.dat']; EFIT mhdin.dat file name Can contain directory Note: below dimensions are needed only if geometry is read below namelist defaults for D3D nfcoil = [18]; # of F-coils; must be specified for non-D3D (Opt.) defaults to D3D values of nfcoil=18 necoil = [122]; # number of E-coils elements specify for non-D3D (Opt.) defaults to D3D value of nesum=6 nsilop = [41]; # flux loops, needed if not read in namelist (opt.) nvesel = [24]; # vessels, needed if not read in namelist (opt.) OUTPUTS: all name list items: IGRID, RLEFT, RRIGHT, ... FCID, FCTURN, ... PF coil geometry if nfcoil>0, E-coil geometry if nesum>0 ireadok = flag to report good read of gfile (0=bad, 1=good) CAUTION: Namelist is read with to_upper=+1 which makes all variables UPPER CASE. New read_namelist in /thor/leuer/matlab/util/read_namelist.m allows change of case. We want to read and make all variables UC To change UPPER CASE to lower case use: mhdin_list= mk_uc_lc_var; makes all lower case variables (nothing to UPCASE) mhdin_list= mk_uc_lc_var('-remove_upper','*'); remove upper case","title":"Basic Information"},{"location":"function-guide/efit/read_mhdin_m/#dependencies","text":"fix_undscr plot_box read_mhdin read_namelist","title":"Dependencies"},{"location":"function-guide/efit/run_efit_m/","text":"run_efit.m \u00b6 Basic Information \u00b6 SYNTAX: run_efit(shot,tims,dtms,nslices,snap,snapidx,efitver,efitdir) PURPOSE: Run EFIT from inside Matlab: uses basic input format just as in standard invokation from command line (so will perform many slices as usual with starting time, delta time, nslices). INPUTS: shot = shot number tims = starting time (in ms) at which to calculate EFIT dtms = delta time (in ms) between each slice nslices = # of slices to calculate snap = (optional) string specifying: if snapidx=2: data file to read input data from if snapidx=3: use snap file in default directory (or in /link) if snapidx=7: snap file extension (eg 'jta_t') snapidx = (optional) EFIT input mode (2=input file, 3=snap file) Default=3 (used if nargin<6). Note if snapidx=2, the shot, tims,dtms,nslices inputs are ignored, and snap specifies the input file to use. efitver = (optional) string specifying EFIT version (eg 'efitd65yd' or 'efitd6565d') efitdir = (optional) string specifying directory in which EFIT version is to be found (default = /link/efit/ or /d/linux/efit/) OUTPUTS: None RESTRICTIONS: METHOD: Uses Matlab unix() command to execute command string built in this function for desired inputs. Dependencies \u00b6","title":"run_efit.m"},{"location":"function-guide/efit/run_efit_m/#run_efitm","text":"","title":"run_efit.m"},{"location":"function-guide/efit/run_efit_m/#basic-information","text":"SYNTAX: run_efit(shot,tims,dtms,nslices,snap,snapidx,efitver,efitdir) PURPOSE: Run EFIT from inside Matlab: uses basic input format just as in standard invokation from command line (so will perform many slices as usual with starting time, delta time, nslices). INPUTS: shot = shot number tims = starting time (in ms) at which to calculate EFIT dtms = delta time (in ms) between each slice nslices = # of slices to calculate snap = (optional) string specifying: if snapidx=2: data file to read input data from if snapidx=3: use snap file in default directory (or in /link) if snapidx=7: snap file extension (eg 'jta_t') snapidx = (optional) EFIT input mode (2=input file, 3=snap file) Default=3 (used if nargin<6). Note if snapidx=2, the shot, tims,dtms,nslices inputs are ignored, and snap specifies the input file to use. efitver = (optional) string specifying EFIT version (eg 'efitd65yd' or 'efitd6565d') efitdir = (optional) string specifying directory in which EFIT version is to be found (default = /link/efit/ or /d/linux/efit/) OUTPUTS: None RESTRICTIONS: METHOD: Uses Matlab unix() command to execute command string built in this function for desired inputs.","title":"Basic Information"},{"location":"function-guide/efit/run_efit_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/efit/shot_from_gfile_m/","text":"shot_from_gfile.m \u00b6 Basic Information \u00b6 SYNTAX: [shot,tms,dr] = shot_from_gfile(gfile) pointer to file [shot,tms,tree,server] = shot_from_gfile(gfile) pointer to MDS+ tree PURPOSE: look at string in gfile name and extract shot, tms, etc INPUT: <default> gfile = string contining gfile name or \"dot\" pointer to MDS tree ex: '/u/leuer/efit/d3d/shot131498/g131498.02000' file pointer 'D3D.EFITRT1.g131498.02000' MDS+ pointer OUTPUT: <default> shot = shot number tms = shot time [ms] dr = directory if pointer to gfile tree = EFIT Tree if pointer to MDS tree <'EFIT01'> server= MDS server for efit data <'D3D'> Dependencies \u00b6 parse_filename","title":"shot_from_gfile.m"},{"location":"function-guide/efit/shot_from_gfile_m/#shot_from_gfilem","text":"","title":"shot_from_gfile.m"},{"location":"function-guide/efit/shot_from_gfile_m/#basic-information","text":"SYNTAX: [shot,tms,dr] = shot_from_gfile(gfile) pointer to file [shot,tms,tree,server] = shot_from_gfile(gfile) pointer to MDS+ tree PURPOSE: look at string in gfile name and extract shot, tms, etc INPUT: <default> gfile = string contining gfile name or \"dot\" pointer to MDS tree ex: '/u/leuer/efit/d3d/shot131498/g131498.02000' file pointer 'D3D.EFITRT1.g131498.02000' MDS+ pointer OUTPUT: <default> shot = shot number tms = shot time [ms] dr = directory if pointer to gfile tree = EFIT Tree if pointer to MDS tree <'EFIT01'> server= MDS server for efit data <'D3D'>","title":"Basic Information"},{"location":"function-guide/efit/shot_from_gfile_m/#dependencies","text":"parse_filename","title":"Dependencies"},{"location":"function-guide/efit/std_efit_units_m/","text":"std_efit_units.m \u00b6 Basic Information \u00b6 SYNTAX: gfile_data = std_efit_units(gdata,tokamak) PURPOSE: Do device-dependent conversions of eqdsk data to a common set of units and conventions. INPUT: gdata = structure containing g eqdsk data tokamak = name of device options = parameters needed to customize logic for a particular device OUTPUT: gfile_data = structure containing g eqdsk data with standard units (i.e., MA-turns) Dependencies \u00b6 proj_turn wait","title":"std_efit_units.m"},{"location":"function-guide/efit/std_efit_units_m/#std_efit_unitsm","text":"","title":"std_efit_units.m"},{"location":"function-guide/efit/std_efit_units_m/#basic-information","text":"SYNTAX: gfile_data = std_efit_units(gdata,tokamak) PURPOSE: Do device-dependent conversions of eqdsk data to a common set of units and conventions. INPUT: gdata = structure containing g eqdsk data tokamak = name of device options = parameters needed to customize logic for a particular device OUTPUT: gfile_data = structure containing g eqdsk data with standard units (i.e., MA-turns)","title":"Basic Information"},{"location":"function-guide/efit/std_efit_units_m/#dependencies","text":"proj_turn wait","title":"Dependencies"},{"location":"function-guide/efit/trace_boundary_m/","text":"trace_boundary.m \u00b6 Basic Information \u00b6 USAGE: [rb,zb,rx,zx,ra,za,r0,z0,ilimited,psimag,psibry]=trace_boundary(psizr,rg,zg,limdata) PURPOSE: Find boundary INPUTS: psizr OUTPUTS: Coordinates of boundary: rb, zb Coordinates of x or touch point: r0,z0 Coordinates of axis: ra, za RESTRICTIONS: METHOD: Dependencies \u00b6","title":"trace_boundary.m"},{"location":"function-guide/efit/trace_boundary_m/#trace_boundarym","text":"","title":"trace_boundary.m"},{"location":"function-guide/efit/trace_boundary_m/#basic-information","text":"USAGE: [rb,zb,rx,zx,ra,za,r0,z0,ilimited,psimag,psibry]=trace_boundary(psizr,rg,zg,limdata) PURPOSE: Find boundary INPUTS: psizr OUTPUTS: Coordinates of boundary: rb, zb Coordinates of x or touch point: r0,z0 Coordinates of axis: ra, za RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/efit/trace_boundary_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/efit/write_afile_m/","text":"write_afile.m \u00b6 Basic Information \u00b6 USAGE: write_afile(equil,eqversion,aday) PURPOSE: write afiles INPUTS: equil: equilibrium on the toksys format (that is returned by read_mds_eqdsk) eqversion: (optional) source of equilibrium (default is TOKSYS) aday: (optional) the date the equilibrium was created OUTPUTS: afiles to disk A-EQDSK File Variables aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx RESTRICTIONS: VERSION @(#)write_afile.m 1.3 10/09/14 WRITTEN BY: Anders Welander ON 6/1/11 MODIFICATION HISTORY: Luke Stagner ON 9/28/2020","title":"write_afile.m"},{"location":"function-guide/efit/write_afile_m/#write_afilem","text":"","title":"write_afile.m"},{"location":"function-guide/efit/write_afile_m/#basic-information","text":"USAGE: write_afile(equil,eqversion,aday) PURPOSE: write afiles INPUTS: equil: equilibrium on the toksys format (that is returned by read_mds_eqdsk) eqversion: (optional) source of equilibrium (default is TOKSYS) aday: (optional) the date the equilibrium was created OUTPUTS: afiles to disk A-EQDSK File Variables aaq1 eccurt pasmat taudia aaq2 filename pbinj taumhd aaq3 elongm psiref tavem ali eout qmflag terror alpha fluxx qout time aout header qpsib tsaisq areao ishot qqmagx uday bcentr jflag qsta vertn betap ktime rcencm vloopt betapd lflag rco2r vout betat limloc rco2v vsurfa betatd magpri rcurrt wbdot bpolav mco2r rmagx wpdot btaxp mco2v rout wplasm btaxv mfver1 rseps1 wplasmd ccbrsp mfver2 rseps2 xndnt cdflux nesum rttt xxx chipre nfcoil rvsin xxxxx cmerci nsilop rvsout xxxxxx cmpr2 obots s1 zcurrt cpasma obott s2 zmagx csilop olefs s3 zout dco2r oleft sepexp zseps1 dco2v orighs seplim zseps2 diamag oright shearb zvsin doutl otop sibdry zvsout doutu otops simagx RESTRICTIONS: VERSION @(#)write_afile.m 1.3 10/09/14 WRITTEN BY: Anders Welander ON 6/1/11 MODIFICATION HISTORY: Luke Stagner ON 9/28/2020","title":"Basic Information"},{"location":"function-guide/efit/write_cc_file_m/","text":"write_cc_file.m \u00b6 Basic Information \u00b6 USAGE: [cc_filename,ier] = write_cc_file(equilibria); PURPOSE: return absolute path to newly generated cc_file INPUTS: filename:name of geqdsk file OUTPUTS: cc_filename: string containing name of cc_file RESTRICTIONS: METHOD: cc_file= coil current file name [cc=load(cc_file)] or coil current vector use when coil currents not available from efit (or to override) ohmic coil current is first, then poloidal shaping currents (units = MA-turns) WRITTEN BY: Matthew J. Lanctot Dependencies \u00b6 dlmwrite","title":"write_cc_file.m"},{"location":"function-guide/efit/write_cc_file_m/#write_cc_filem","text":"","title":"write_cc_file.m"},{"location":"function-guide/efit/write_cc_file_m/#basic-information","text":"USAGE: [cc_filename,ier] = write_cc_file(equilibria); PURPOSE: return absolute path to newly generated cc_file INPUTS: filename:name of geqdsk file OUTPUTS: cc_filename: string containing name of cc_file RESTRICTIONS: METHOD: cc_file= coil current file name [cc=load(cc_file)] or coil current vector use when coil currents not available from efit (or to override) ohmic coil current is first, then poloidal shaping currents (units = MA-turns) WRITTEN BY: Matthew J. Lanctot","title":"Basic Information"},{"location":"function-guide/efit/write_cc_file_m/#dependencies","text":"dlmwrite","title":"Dependencies"},{"location":"function-guide/efit/write_eqdsk_m/","text":"write_eqdsk.m \u00b6 Basic Information \u00b6 USAGE: [equilibria, neq, eqraw] = write_eqdsk(shotnum,tefit,efit_source,tokamak,write_cc) PURPOSE: Retrieves eqdsk data from MDS and saves g,a files to dir INPUTS: shotnum: Shotnumber for equilibrium eg. 146970 tefit: time of efit, can be two element array specifying time range as in read_eq efit_source: EFIT source eg. 'EFIT01' tokamak: device name eg. 'd3d' OUTPUTS: eq = equilibrium data on toksys form, that can be used with cc_efit_to_tok and build_tokamak_system neq = number of equilibria returned eqraw = 'raw' eq data on original form before conversion to toksys convention RESTRICTIONS: METHOD: WRITTEN BY: Matthew J. Lanctot MODIFICATION HISTORY: Dependencies \u00b6 write_cc_file write_gfile read_eq","title":"write_eqdsk.m"},{"location":"function-guide/efit/write_eqdsk_m/#write_eqdskm","text":"","title":"write_eqdsk.m"},{"location":"function-guide/efit/write_eqdsk_m/#basic-information","text":"USAGE: [equilibria, neq, eqraw] = write_eqdsk(shotnum,tefit,efit_source,tokamak,write_cc) PURPOSE: Retrieves eqdsk data from MDS and saves g,a files to dir INPUTS: shotnum: Shotnumber for equilibrium eg. 146970 tefit: time of efit, can be two element array specifying time range as in read_eq efit_source: EFIT source eg. 'EFIT01' tokamak: device name eg. 'd3d' OUTPUTS: eq = equilibrium data on toksys form, that can be used with cc_efit_to_tok and build_tokamak_system neq = number of equilibria returned eqraw = 'raw' eq data on original form before conversion to toksys convention RESTRICTIONS: METHOD: WRITTEN BY: Matthew J. Lanctot MODIFICATION HISTORY:","title":"Basic Information"},{"location":"function-guide/efit/write_eqdsk_m/#dependencies","text":"write_cc_file write_gfile read_eq","title":"Dependencies"},{"location":"function-guide/efit/write_gfile_m/","text":"write_gfile.m \u00b6 Basic Information \u00b6 USAGE: write_gfile(eq) PURPOSE: write gfiles INPUTS: eq: equilibrium on the toksys format (that is returned by read_mds_eqdsk) OUTPUTS: gfiles to disk RESTRICTIONS: Dependencies \u00b6","title":"write_gfile.m"},{"location":"function-guide/efit/write_gfile_m/#write_gfilem","text":"","title":"write_gfile.m"},{"location":"function-guide/efit/write_gfile_m/#basic-information","text":"USAGE: write_gfile(eq) PURPOSE: write gfiles INPUTS: eq: equilibrium on the toksys format (that is returned by read_mds_eqdsk) OUTPUTS: gfiles to disk RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/efit/write_gfile_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/equil/calc_li_m/","text":"calc_li.m \u00b6 Basic Information \u00b6 SYNTAX: [li,li_vec,output_struct] = calc_li(input_struct); PURPOSE: Calculate li value(s) from an equilibrum current distribution, flux on the grid, and grid geometry. INPUTS: input_struct = structure (like gfile_data) containing: jphi = current density on grid (nz x nr or nz*nr vec) [A/m^2] psizr = flux on grid (nz x nr or nz*nr vec) [Wb] rg = major radius vector for grid (nr x 1) [m] zg = vertical position vector for grid (nz x 1) [m] rmaxis = major radius of mag axis [m] (optional; need for li(2)) OUTPUTS: li = actual internal inductance li == <Bp^2>_V/<Bp>_C^2 li_vec = vector of [li(1); li(2); li(3)] RESTRICTIONS: METHOD: Notation: V denotes plasma volume, C denotes contour of plasma boundary, <X>_V means volume-averaged X, <X>_C means line-averaged X along contour of plasma boundary. Bp is total poloidal field. K is kappa at plasma boundary. R is geometrical major radius of plasma boundary. Raxis is major radius of magnetic axis. li == <Bp^2>_V/<Bp>_C^2 = volume-avg of square of poloidal field over plasma volume divided by line-avg poloidal field squared. li(1) == (2*V*<Bp^2>_V/(R*(mu0*I)^2)) * 0.5*(1+K^2)/K li(2) = (2*V*<Bp^2>_V/(Raxis*(mu0*I)^2)) li(3) == (2*V*<Bp^2>_V/(R*(mu0*I)^2)) Dependencies \u00b6","title":"calc_li.m"},{"location":"function-guide/equil/calc_li_m/#calc_lim","text":"","title":"calc_li.m"},{"location":"function-guide/equil/calc_li_m/#basic-information","text":"SYNTAX: [li,li_vec,output_struct] = calc_li(input_struct); PURPOSE: Calculate li value(s) from an equilibrum current distribution, flux on the grid, and grid geometry. INPUTS: input_struct = structure (like gfile_data) containing: jphi = current density on grid (nz x nr or nz*nr vec) [A/m^2] psizr = flux on grid (nz x nr or nz*nr vec) [Wb] rg = major radius vector for grid (nr x 1) [m] zg = vertical position vector for grid (nz x 1) [m] rmaxis = major radius of mag axis [m] (optional; need for li(2)) OUTPUTS: li = actual internal inductance li == <Bp^2>_V/<Bp>_C^2 li_vec = vector of [li(1); li(2); li(3)] RESTRICTIONS: METHOD: Notation: V denotes plasma volume, C denotes contour of plasma boundary, <X>_V means volume-averaged X, <X>_C means line-averaged X along contour of plasma boundary. Bp is total poloidal field. K is kappa at plasma boundary. R is geometrical major radius of plasma boundary. Raxis is major radius of magnetic axis. li == <Bp^2>_V/<Bp>_C^2 = volume-avg of square of poloidal field over plasma volume divided by line-avg poloidal field squared. li(1) == (2*V*<Bp^2>_V/(R*(mu0*I)^2)) * 0.5*(1+K^2)/K li(2) = (2*V*<Bp^2>_V/(Raxis*(mu0*I)^2)) li(3) == (2*V*<Bp^2>_V/(R*(mu0*I)^2))","title":"Basic Information"},{"location":"function-guide/equil/calc_li_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/area_quad_m/","text":"area_quad.m \u00b6 Basic Information \u00b6 SYNTAX: area = area_quad(center,corners,rotate_angle) PURPOSE: calculate area of quadrilateral INPUT: center = center of mass of quadrilateral corners = 2 x 4 matrix of quadrilateral corners ([x,y] x 4) rotate_angle = angle of centerline of quad from positive x-axis, to be used to rotate onto x-axis OUTPUT: area = approximate area of quadrilateral RESTRICTIONS: Requires rotation to \"center\" the quad on x-axis. METHOD: Rotates quad to put 2 vertices each above and below axis. Area is approximated by using trapezoid area formula on shape above and below axis. Dependencies \u00b6 wait","title":"area_quad.m"},{"location":"function-guide/geom/area_quad_m/#area_quadm","text":"","title":"area_quad.m"},{"location":"function-guide/geom/area_quad_m/#basic-information","text":"SYNTAX: area = area_quad(center,corners,rotate_angle) PURPOSE: calculate area of quadrilateral INPUT: center = center of mass of quadrilateral corners = 2 x 4 matrix of quadrilateral corners ([x,y] x 4) rotate_angle = angle of centerline of quad from positive x-axis, to be used to rotate onto x-axis OUTPUT: area = approximate area of quadrilateral RESTRICTIONS: Requires rotation to \"center\" the quad on x-axis. METHOD: Rotates quad to put 2 vertices each above and below axis. Area is approximated by using trapezoid area formula on shape above and below axis.","title":"Basic Information"},{"location":"function-guide/geom/area_quad_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/geom/brpz_to_bxyz_m/","text":"brpz_to_bxyz.m \u00b6 Basic Information \u00b6 PURPOSE: convert a vector of fields brpz to rectangular coordinates bxyz brpz = [Br, Bphi, Bz] to xyz points: xpt = [x, y, z]. SYNTAX: bxyz= brpz_to_bxyz(rpz,brpz); INPUT: rpz = toroidal coordinates of each point 3 columns: [r,phi(radians),z] NOTE THIS IS IN CORRECT RIGHT HAND ROTATION (Not rzp) brpz = Field in each direction [Br, Bphi, Bz] NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D has Phi clockwise) OUTPUT: bxyz = Field in rectangular coordinates in 3-space. [Bx,By,Bz] SEE ALSO: rzp_to_pts rzpn_to_pts pts_to_fil ptsn_to_fil Dependencies \u00b6 rzp_to_pts","title":"brpz_to_bxyz.m"},{"location":"function-guide/geom/brpz_to_bxyz_m/#brpz_to_bxyzm","text":"","title":"brpz_to_bxyz.m"},{"location":"function-guide/geom/brpz_to_bxyz_m/#basic-information","text":"PURPOSE: convert a vector of fields brpz to rectangular coordinates bxyz brpz = [Br, Bphi, Bz] to xyz points: xpt = [x, y, z]. SYNTAX: bxyz= brpz_to_bxyz(rpz,brpz); INPUT: rpz = toroidal coordinates of each point 3 columns: [r,phi(radians),z] NOTE THIS IS IN CORRECT RIGHT HAND ROTATION (Not rzp) brpz = Field in each direction [Br, Bphi, Bz] NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D has Phi clockwise) OUTPUT: bxyz = Field in rectangular coordinates in 3-space. [Bx,By,Bz] SEE ALSO: rzp_to_pts rzpn_to_pts pts_to_fil ptsn_to_fil","title":"Basic Information"},{"location":"function-guide/geom/brpz_to_bxyz_m/#dependencies","text":"rzp_to_pts","title":"Dependencies"},{"location":"function-guide/geom/calc_dimensions_m/","text":"calc_dimensions.m \u00b6 Basic Information \u00b6 SYNTAX: [xy_phys] = calc_dimensions(xy_pairs,scale_orig,scale) PURPOSE: compute dimensions from units in scale drawing INPUT: xy_pairs = coordinates in scaled drawing (2 x npairs) scale_orig = coords of point in scaled drawing corresp. to phys origin scale = x/y multipliers of scaled drawing to give physical dimensions OUTPUT: xy_phys = coordinates of actual device Dependencies \u00b6","title":"calc_dimensions.m"},{"location":"function-guide/geom/calc_dimensions_m/#calc_dimensionsm","text":"","title":"calc_dimensions.m"},{"location":"function-guide/geom/calc_dimensions_m/#basic-information","text":"SYNTAX: [xy_phys] = calc_dimensions(xy_pairs,scale_orig,scale) PURPOSE: compute dimensions from units in scale drawing INPUT: xy_pairs = coordinates in scaled drawing (2 x npairs) scale_orig = coords of point in scaled drawing corresp. to phys origin scale = x/y multipliers of scaled drawing to give physical dimensions OUTPUT: xy_phys = coordinates of actual device","title":"Basic Information"},{"location":"function-guide/geom/calc_dimensions_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/dircos_m/","text":"dircos.m \u00b6 Basic Information \u00b6 SYNTAX: dir_cos= dircos(x,y,z,origin); PURPOSE: Generate direction cosines from line segment defined by [x,y,z] - origin INPUT: x,y,z= end points of line segment origin= vector [3] defining start of line segment Note: if not present assumes [0,0,0] OUTPUT dir_cos= row vectors of length 3 which contains the direction cosine for each entry in x,y,z NOTE: x,y,z can be matrix but output is matrix [n,3] where n=prod(size(x)) Dependencies \u00b6","title":"dircos.m"},{"location":"function-guide/geom/dircos_m/#dircosm","text":"","title":"dircos.m"},{"location":"function-guide/geom/dircos_m/#basic-information","text":"SYNTAX: dir_cos= dircos(x,y,z,origin); PURPOSE: Generate direction cosines from line segment defined by [x,y,z] - origin INPUT: x,y,z= end points of line segment origin= vector [3] defining start of line segment Note: if not present assumes [0,0,0] OUTPUT dir_cos= row vectors of length 3 which contains the direction cosine for each entry in x,y,z NOTE: x,y,z can be matrix but output is matrix [n,3] where n=prod(size(x))","title":"Basic Information"},{"location":"function-guide/geom/dircos_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/dist2bdry_m/","text":"dist2bdry.m \u00b6 Basic Information \u00b6 SYNTAX: [distance,nearest_pt] = dist2bdry(bdry,point,closed) PURPOSE: Compute (min) distance from a point to a boundary. Boundary is assumed be defined by the vertices specified in bdry and by linear interpolation between these points, in the order specified. INPUT: bdry = n x 2 array specifying x,y pairs which define boundary point = [x,y] data point closed = set to 1 if first and last vertex in bdry list should be connected to form a closed boundary(optional,default=0) OUTPUT: distance = minimum distance from point to boundary nearest_pt = [x,y] point on boundary nearest to point specified RESTRICTIONS: (1) Works for \"normal\" cases where you can locate the closest boundary point by first finding the first vertex on boundary. Won't work for \"pathological\" cases where boundary closest to the point is defined by two vertices far away from the point. (2) Not well tested yet. (Not at all for closed boundaries.) Dependencies \u00b6 wait","title":"dist2bdry.m"},{"location":"function-guide/geom/dist2bdry_m/#dist2bdrym","text":"","title":"dist2bdry.m"},{"location":"function-guide/geom/dist2bdry_m/#basic-information","text":"SYNTAX: [distance,nearest_pt] = dist2bdry(bdry,point,closed) PURPOSE: Compute (min) distance from a point to a boundary. Boundary is assumed be defined by the vertices specified in bdry and by linear interpolation between these points, in the order specified. INPUT: bdry = n x 2 array specifying x,y pairs which define boundary point = [x,y] data point closed = set to 1 if first and last vertex in bdry list should be connected to form a closed boundary(optional,default=0) OUTPUT: distance = minimum distance from point to boundary nearest_pt = [x,y] point on boundary nearest to point specified RESTRICTIONS: (1) Works for \"normal\" cases where you can locate the closest boundary point by first finding the first vertex on boundary. Won't work for \"pathological\" cases where boundary closest to the point is defined by two vertices far away from the point. (2) Not well tested yet. (Not at all for closed boundaries.)","title":"Basic Information"},{"location":"function-guide/geom/dist2bdry_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/geom/drawgrid_m/","text":"drawgrid.m \u00b6 Basic Information \u00b6 USAGE: drawgrid(rg,zg) drawgrid(c) c is struct with fields rg, zg [h1, h2, h3] = drawgrid(rg,zg) PURPOSE: draw grid rg,zg in current figure window INPUTS: rg, zg or c.rg, c.zg = grid coordinates OUTPUTS: h1 = handle to lines plotted along grid lines h2 = handle to lines plotted half-way between grid lines h3 = handle to points plotted at grid points Dependencies \u00b6","title":"drawgrid.m"},{"location":"function-guide/geom/drawgrid_m/#drawgridm","text":"","title":"drawgrid.m"},{"location":"function-guide/geom/drawgrid_m/#basic-information","text":"USAGE: drawgrid(rg,zg) drawgrid(c) c is struct with fields rg, zg [h1, h2, h3] = drawgrid(rg,zg) PURPOSE: draw grid rg,zg in current figure window INPUTS: rg, zg or c.rg, c.zg = grid coordinates OUTPUTS: h1 = handle to lines plotted along grid lines h2 = handle to lines plotted half-way between grid lines h3 = handle to points plotted at grid points","title":"Basic Information"},{"location":"function-guide/geom/drawgrid_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/fil_plot_arrow_m/","text":"fil_plot_arrow.m \u00b6 Basic Information \u00b6 PURPOSE: plots a set of vectors: xfil = [x1,y1,z1,x2,y2,z2] using arrows SYNTAX: hdl= fil_plot_arrow(xfil,s,cl,lw) INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end s= scale factor s=0 no scale, s=-1 matlab scale, s>0 actual scale cl= line color (optional)['r'] lw= line width (optional) [1] OUTPUT: hdl= handle to all graphics elements produced NOTE: can use hdl and rotations to rotate object Dependencies \u00b6 pts_to_fil fil_plot","title":"fil_plot_arrow.m"},{"location":"function-guide/geom/fil_plot_arrow_m/#fil_plot_arrowm","text":"","title":"fil_plot_arrow.m"},{"location":"function-guide/geom/fil_plot_arrow_m/#basic-information","text":"PURPOSE: plots a set of vectors: xfil = [x1,y1,z1,x2,y2,z2] using arrows SYNTAX: hdl= fil_plot_arrow(xfil,s,cl,lw) INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end s= scale factor s=0 no scale, s=-1 matlab scale, s>0 actual scale cl= line color (optional)['r'] lw= line width (optional) [1] OUTPUT: hdl= handle to all graphics elements produced NOTE: can use hdl and rotations to rotate object","title":"Basic Information"},{"location":"function-guide/geom/fil_plot_arrow_m/#dependencies","text":"pts_to_fil fil_plot","title":"Dependencies"},{"location":"function-guide/geom/fil_plot_m/","text":"fil_plot.m \u00b6 Basic Information \u00b6 PURPOSE: plots a set of filaments: xfil = [x1,y1,z1,x2,y2,z2] SYNTAX: hdl= fil_plot(xfil,cl,lw) INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end cl= line color (optional)['r'] lw= line width (optional) [1] OUTPUT: hdl= handle to all graphics elements produced NOTE: can use hdl and rotations to rotate object Dependencies \u00b6 pts_to_fil","title":"fil_plot.m"},{"location":"function-guide/geom/fil_plot_m/#fil_plotm","text":"","title":"fil_plot.m"},{"location":"function-guide/geom/fil_plot_m/#basic-information","text":"PURPOSE: plots a set of filaments: xfil = [x1,y1,z1,x2,y2,z2] SYNTAX: hdl= fil_plot(xfil,cl,lw) INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end cl= line color (optional)['r'] lw= line width (optional) [1] OUTPUT: hdl= handle to all graphics elements produced NOTE: can use hdl and rotations to rotate object","title":"Basic Information"},{"location":"function-guide/geom/fil_plot_m/#dependencies","text":"pts_to_fil","title":"Dependencies"},{"location":"function-guide/geom/fil_regrid_m/","text":"fil_regrid.m \u00b6 Basic Information \u00b6 PURPOSE: Increases the number of filaments n times. The filament matrix is composed of start to end points: xfil = [x1,y1,z1,x2,y2,z2] The output matrix has n times more rows SYNTAX: xnfil= fil_regrid(xfil,n) INPUT: xfilc= filament coordinates start to end [x1,y1,z1,x2,y2,z2] n = number of filaments split each filament into SCALAR OUTPUT: xnfil= filament matrix increased by nfil times [x1,y1,z1,x2,y2,z2] NOTE: See filc_to_fil for conversion from center to end filaments Dependencies \u00b6 pts_to_fil","title":"fil_regrid.m"},{"location":"function-guide/geom/fil_regrid_m/#fil_regridm","text":"","title":"fil_regrid.m"},{"location":"function-guide/geom/fil_regrid_m/#basic-information","text":"PURPOSE: Increases the number of filaments n times. The filament matrix is composed of start to end points: xfil = [x1,y1,z1,x2,y2,z2] The output matrix has n times more rows SYNTAX: xnfil= fil_regrid(xfil,n) INPUT: xfilc= filament coordinates start to end [x1,y1,z1,x2,y2,z2] n = number of filaments split each filament into SCALAR OUTPUT: xnfil= filament matrix increased by nfil times [x1,y1,z1,x2,y2,z2] NOTE: See filc_to_fil for conversion from center to end filaments","title":"Basic Information"},{"location":"function-guide/geom/fil_regrid_m/#dependencies","text":"pts_to_fil","title":"Dependencies"},{"location":"function-guide/geom/fil_to_filc_m/","text":"fil_to_filc.m \u00b6 Basic Information \u00b6 PURPOSE: convert end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] to center xc= [xc,yc,zc] and delta= [dx,dy,dz] SYNTAX: [xfilc]= fil_to_filc(xfil) INPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end OUTPUT: xfilc= filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] NOTE: See fil_to_filcdc for output of center, direction cos, & line length","title":"fil_to_filc.m"},{"location":"function-guide/geom/fil_to_filc_m/#fil_to_filcm","text":"","title":"fil_to_filc.m"},{"location":"function-guide/geom/fil_to_filc_m/#basic-information","text":"PURPOSE: convert end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] to center xc= [xc,yc,zc] and delta= [dx,dy,dz] SYNTAX: [xfilc]= fil_to_filc(xfil) INPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end OUTPUT: xfilc= filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] NOTE: See fil_to_filcdc for output of center, direction cos, & line length","title":"Basic Information"},{"location":"function-guide/geom/fil_to_filcdc_m/","text":"fil_to_filcdc.m \u00b6 Basic Information \u00b6 PURPOSE: convert end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] to center & direction cosines xcdc= [xc,yc,zc,dcx,dcy,dcz] also outputs filament length ll SYNTAX: [xcdc,ll]= fil_to_filcdc(xfil) INPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end OUTPUT: xcdc = filament center & direciton cosines: [xc,yc,zc,dcx,dcy,dcz] ll = filament length Dependencies \u00b6","title":"fil_to_filcdc.m"},{"location":"function-guide/geom/fil_to_filcdc_m/#fil_to_filcdcm","text":"","title":"fil_to_filcdc.m"},{"location":"function-guide/geom/fil_to_filcdc_m/#basic-information","text":"PURPOSE: convert end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] to center & direction cosines xcdc= [xc,yc,zc,dcx,dcy,dcz] also outputs filament length ll SYNTAX: [xcdc,ll]= fil_to_filcdc(xfil) INPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end OUTPUT: xcdc = filament center & direciton cosines: [xc,yc,zc,dcx,dcy,dcz] ll = filament length","title":"Basic Information"},{"location":"function-guide/geom/fil_to_filcdc_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/filc_to_fil_m/","text":"filc_to_fil.m \u00b6 Basic Information \u00b6 PURPOSE: convert center/delta description of filament xfilc=[xc,yc,zc,dx,dx,dy] to end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] SYNTAX: xfil= fil_to_filc(xfilc) INPUT: xfilc= filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] OUTPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end NOTE: See fil_to_filc for reverse transform See fil_to_filcdc for output of center, direction cos, & line length","title":"filc_to_fil.m"},{"location":"function-guide/geom/filc_to_fil_m/#filc_to_film","text":"","title":"filc_to_fil.m"},{"location":"function-guide/geom/filc_to_fil_m/#basic-information","text":"PURPOSE: convert center/delta description of filament xfilc=[xc,yc,zc,dx,dx,dy] to end point description of filaments xfil = [x1,y1,z1,x2,y2,z2] SYNTAX: xfil= fil_to_filc(xfilc) INPUT: xfilc= filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] OUTPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end NOTE: See fil_to_filc for reverse transform See fil_to_filcdc for output of center, direction cos, & line length","title":"Basic Information"},{"location":"function-guide/geom/fils2filcs_m/","text":"fils2filcs.m \u00b6 Basic Information \u00b6 PURPOSE: Convert end point description of filaments fils = [x1,y1,z1,x2,y2,z2] to center xc= [xc,yc,zc] and delta= [dx,dy,dz] SYNTAX: filcs = fils2filcs(fils) INPUT: fils = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end Alternatively fils can be a CELL with several filament matrices OUTPUT: filcs = filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] if fils is a cell then so is filcs NOTE: Dependencies \u00b6","title":"fils2filcs.m"},{"location":"function-guide/geom/fils2filcs_m/#fils2filcsm","text":"","title":"fils2filcs.m"},{"location":"function-guide/geom/fils2filcs_m/#basic-information","text":"PURPOSE: Convert end point description of filaments fils = [x1,y1,z1,x2,y2,z2] to center xc= [xc,yc,zc] and delta= [dx,dy,dz] SYNTAX: filcs = fils2filcs(fils) INPUT: fils = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end Alternatively fils can be a CELL with several filament matrices OUTPUT: filcs = filament center and delta: 6 column matrix [xc,yc,zc,dx,dy,dz] if fils is a cell then so is filcs NOTE:","title":"Basic Information"},{"location":"function-guide/geom/fils2filcs_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/lim2vv_m/","text":"lim2vv.m \u00b6 Basic Information \u00b6 SYNTAX: [vvdata,dirnu,iacnu,fracnu]=lim2vv(limdata,dperp,dw,idir,frac,iac); PURPOSE: Calculate vessel elements from limiter specification given by limdata = set of vertices in limiter, between which will be located vessel elements. INPUTS: limdata = set of vertices in limiter, between which will be located vessel elements. limdata has format [[r1 z1];[r2 z2]...] dperp = amount vessel elements are displaced from limiter dw = width of vessel elements idir = (optional) direction indices corr to each vessel element (nvv = nlim - 1). Default corresponds to +1; reverses direction of wall displacement if set element of idir to -1. frac = (optional) fraction by which to scale each VVelement iac = (optional) indices telling if AC or AC2 type element. Default = all AC (index 1) elements. Note that automatically sets vertical or horizontal elements to type 0... OUTPUTS: vvdata = vvdata array with standard format idirnu = new idir vector (actually used) iacnu = new iac vector (which was used in specifying actual vvdata) fracnu = new frac vector (actually used) plots of corresponding geometry RESTRICTIONS: METHOD: Dependencies \u00b6 plot_box","title":"lim2vv.m"},{"location":"function-guide/geom/lim2vv_m/#lim2vvm","text":"","title":"lim2vv.m"},{"location":"function-guide/geom/lim2vv_m/#basic-information","text":"SYNTAX: [vvdata,dirnu,iacnu,fracnu]=lim2vv(limdata,dperp,dw,idir,frac,iac); PURPOSE: Calculate vessel elements from limiter specification given by limdata = set of vertices in limiter, between which will be located vessel elements. INPUTS: limdata = set of vertices in limiter, between which will be located vessel elements. limdata has format [[r1 z1];[r2 z2]...] dperp = amount vessel elements are displaced from limiter dw = width of vessel elements idir = (optional) direction indices corr to each vessel element (nvv = nlim - 1). Default corresponds to +1; reverses direction of wall displacement if set element of idir to -1. frac = (optional) fraction by which to scale each VVelement iac = (optional) indices telling if AC or AC2 type element. Default = all AC (index 1) elements. Note that automatically sets vertical or horizontal elements to type 0... OUTPUTS: vvdata = vvdata array with standard format idirnu = new idir vector (actually used) iacnu = new iac vector (which was used in specifying actual vvdata) fracnu = new frac vector (actually used) plots of corresponding geometry RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/geom/lim2vv_m/#dependencies","text":"plot_box","title":"Dependencies"},{"location":"function-guide/geom/make_rect2_m/","text":"make_rect2.m \u00b6 Basic Information \u00b6 SYNTAX: corners = make_rect2(corner1, corner2, width, scale, direction) PURPOSE: Make rectangle from 2 corners and a width INPUT: corner1, corner2 = 2 corners in form [x;y] (drawing units) width = width of rectangle to grow from these 2 corners (physical units) direction = set to +1 to grow rectangle in positive x direction, -1 to grow in negative x direction OUTPUT: corners = corners defining rectangle ([x1;y1] [x2;y2] [x3;y3] [x4;y4]) Dependencies \u00b6","title":"make_rect2.m"},{"location":"function-guide/geom/make_rect2_m/#make_rect2m","text":"","title":"make_rect2.m"},{"location":"function-guide/geom/make_rect2_m/#basic-information","text":"SYNTAX: corners = make_rect2(corner1, corner2, width, scale, direction) PURPOSE: Make rectangle from 2 corners and a width INPUT: corner1, corner2 = 2 corners in form [x;y] (drawing units) width = width of rectangle to grow from these 2 corners (physical units) direction = set to +1 to grow rectangle in positive x direction, -1 to grow in negative x direction OUTPUT: corners = corners defining rectangle ([x1;y1] [x2;y2] [x3;y3] [x4;y4])","title":"Basic Information"},{"location":"function-guide/geom/make_rect2_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/make_ves_elt_m/","text":"make_ves_elt.m \u00b6 Basic Information \u00b6 SYNTAX: elt = make_ves_elt(type,corners,scale,scale_orig) PURPOSE: make vessel element from coordinates in scaled drawing INPUT: type = element type: 0 = angles AC=AC2=0 1 = 0<AC<90 deg., AC2 = 0 2 = AC = 0, 0<AC2<90 deg. -1 = AC>90 deg. , AC2 = 0 -2 = AC = 0, AC2>90 deg. corners = [[R1;Z1] [R2;Z2] [R3;Z3] [R4;Z4]] scale = 2x1 vector (r,z) which scales drawing to physical units scale_orig = coordinates of physical origin (r=z=0) in scale drawing OUTPUT: elt = [Z;R;dZ;dR;AC;AC2] Dependencies \u00b6 area_quad calc_dimensions","title":"make_ves_elt.m"},{"location":"function-guide/geom/make_ves_elt_m/#make_ves_eltm","text":"","title":"make_ves_elt.m"},{"location":"function-guide/geom/make_ves_elt_m/#basic-information","text":"SYNTAX: elt = make_ves_elt(type,corners,scale,scale_orig) PURPOSE: make vessel element from coordinates in scaled drawing INPUT: type = element type: 0 = angles AC=AC2=0 1 = 0<AC<90 deg., AC2 = 0 2 = AC = 0, 0<AC2<90 deg. -1 = AC>90 deg. , AC2 = 0 -2 = AC = 0, AC2>90 deg. corners = [[R1;Z1] [R2;Z2] [R3;Z3] [R4;Z4]] scale = 2x1 vector (r,z) which scales drawing to physical units scale_orig = coordinates of physical origin (r=z=0) in scale drawing OUTPUT: elt = [Z;R;dZ;dR;AC;AC2]","title":"Basic Information"},{"location":"function-guide/geom/make_ves_elt_m/#dependencies","text":"area_quad calc_dimensions","title":"Dependencies"},{"location":"function-guide/geom/perp2lim_m/","text":"perp2lim.m \u00b6 Basic Information \u00b6 SYNTAX: [rz_out]= perp2lim(rz_in,dperp); PURPOSE: Generates 2-D (r,z) perpendicular boundary displaced dperp from rz_in . INPUTS: rz_in = r,z index of input boundary rz_in= [r,z] or [r;z] dperp = Perpendicular distance (+ outward, - inward) scaler or size(r) iplot = 1 => plot new rz_out, -1 plot _in & _out geometry <0>= no plot OUTPUTS: rz_out = output data with dperp perpendicular displacement from rz_in RESTRICTIONS: rz_in must have at least 2 points if rz_in has only 2 points direction of vector is taken from r=0,z=0 for negative (inward displacement) watch out for crossing of center METHOD: uses mean of r and z to determine centroid r0, z0 and displaces dperp along radial from r0,z0 to ri,zi, based on dperp drperp= + displace away from center = - displace toward center Dependencies \u00b6","title":"perp2lim.m"},{"location":"function-guide/geom/perp2lim_m/#perp2limm","text":"","title":"perp2lim.m"},{"location":"function-guide/geom/perp2lim_m/#basic-information","text":"SYNTAX: [rz_out]= perp2lim(rz_in,dperp); PURPOSE: Generates 2-D (r,z) perpendicular boundary displaced dperp from rz_in . INPUTS: rz_in = r,z index of input boundary rz_in= [r,z] or [r;z] dperp = Perpendicular distance (+ outward, - inward) scaler or size(r) iplot = 1 => plot new rz_out, -1 plot _in & _out geometry <0>= no plot OUTPUTS: rz_out = output data with dperp perpendicular displacement from rz_in RESTRICTIONS: rz_in must have at least 2 points if rz_in has only 2 points direction of vector is taken from r=0,z=0 for negative (inward displacement) watch out for crossing of center METHOD: uses mean of r and z to determine centroid r0, z0 and displaces dperp along radial from r0,z0 to ri,zi, based on dperp drperp= + displace away from center = - displace toward center","title":"Basic Information"},{"location":"function-guide/geom/perp2lim_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/prlgrm_pts_m/","text":"prlgrm_pts.m \u00b6 Basic Information \u00b6 SYNTAX: prlgrm = prlgrm_pts(rz_end,t); PURPOSE: make efit type parallegram from rz end points and thickness INPUT: rz_end= array of [r,z] end points to construct parallegram t = thickness (array) same size as rz_end or scaler OUTPUT: prlgrm = [Z;R;dZ;dR;AC;AC2] (see figure 6-4 GA-A14490) note size(plgrm,1) = size(rz_end)-1 Note: This routine automatically uses Type 1 parallograms for angles <=45 and Type 2 parallograms for angles >45 Dependencies \u00b6","title":"prlgrm_pts.m"},{"location":"function-guide/geom/prlgrm_pts_m/#prlgrm_ptsm","text":"","title":"prlgrm_pts.m"},{"location":"function-guide/geom/prlgrm_pts_m/#basic-information","text":"SYNTAX: prlgrm = prlgrm_pts(rz_end,t); PURPOSE: make efit type parallegram from rz end points and thickness INPUT: rz_end= array of [r,z] end points to construct parallegram t = thickness (array) same size as rz_end or scaler OUTPUT: prlgrm = [Z;R;dZ;dR;AC;AC2] (see figure 6-4 GA-A14490) note size(plgrm,1) = size(rz_end)-1 Note: This routine automatically uses Type 1 parallograms for angles <=45 and Type 2 parallograms for angles >45","title":"Basic Information"},{"location":"function-guide/geom/prlgrm_pts_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/pts_to_fil_m/","text":"pts_to_fil.m \u00b6 Basic Information \u00b6 PURPOSE: convert a vector of points defined by xpt = [xpt,ypt,zpt] to filaments xfil [x1,y1,z1,x2,y2,z2] from point to point. This creats one less filament than the number of points SYNTAX: xfil= pts_to_fil(xpt) INPUT: xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] OUTPUT: xfil = filament constructed beteen points contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end Dependencies \u00b6","title":"pts_to_fil.m"},{"location":"function-guide/geom/pts_to_fil_m/#pts_to_film","text":"","title":"pts_to_fil.m"},{"location":"function-guide/geom/pts_to_fil_m/#basic-information","text":"PURPOSE: convert a vector of points defined by xpt = [xpt,ypt,zpt] to filaments xfil [x1,y1,z1,x2,y2,z2] from point to point. This creats one less filament than the number of points SYNTAX: xfil= pts_to_fil(xpt) INPUT: xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] OUTPUT: xfil = filament constructed beteen points contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end","title":"Basic Information"},{"location":"function-guide/geom/pts_to_fil_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/ptsn_to_fil_m/","text":"ptsn_to_fil.m \u00b6 Basic Information \u00b6 PURPOSE: convert a vector of points defined by xpt = [xpt,ypt,zpt] to filaments xfil [x1,y1,z1,x2,y2,z2] from point to point. this interpolates between points to to add n filaments for each point This creats one less filament than the number of points SYNTAX: xfil= ptsn_to_fil(xpt,n) INPUT: [default] xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] n = number of filaments per point [ones(length(xpt),1)] scalar or column vector same length as xpt OUTPUT: xfil = filament constructed beteen points contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end Dependencies \u00b6 pts_to_fil fil_plot","title":"ptsn_to_fil.m"},{"location":"function-guide/geom/ptsn_to_fil_m/#ptsn_to_film","text":"","title":"ptsn_to_fil.m"},{"location":"function-guide/geom/ptsn_to_fil_m/#basic-information","text":"PURPOSE: convert a vector of points defined by xpt = [xpt,ypt,zpt] to filaments xfil [x1,y1,z1,x2,y2,z2] from point to point. this interpolates between points to to add n filaments for each point This creats one less filament than the number of points SYNTAX: xfil= ptsn_to_fil(xpt,n) INPUT: [default] xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] n = number of filaments per point [ones(length(xpt),1)] scalar or column vector same length as xpt OUTPUT: xfil = filament constructed beteen points contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end","title":"Basic Information"},{"location":"function-guide/geom/ptsn_to_fil_m/#dependencies","text":"pts_to_fil fil_plot","title":"Dependencies"},{"location":"function-guide/geom/read_dxf_file_m/","text":"read_dxf_file.m \u00b6 Basic Information \u00b6 PURPOSE: Crude read of Autocad DXF files SYNTAX: [xyz,type]= read_dxf_file(filename,two_d); INPUT: [default] filename= ['dfx_file.dxf']; dxf file name two_d= 1; dont read and load any 3rd Z components [0] OUTPUT: xyz = point matrix defined by end points of lines contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of line and 2 is end type = type of entity, 1=point(vertex), 2=line, 3=arc NOTE: ONLY SET UP FOR LINE'S easily can be set up to read other components using LINE example Dependencies \u00b6","title":"read_dxf_file.m"},{"location":"function-guide/geom/read_dxf_file_m/#read_dxf_filem","text":"","title":"read_dxf_file.m"},{"location":"function-guide/geom/read_dxf_file_m/#basic-information","text":"PURPOSE: Crude read of Autocad DXF files SYNTAX: [xyz,type]= read_dxf_file(filename,two_d); INPUT: [default] filename= ['dfx_file.dxf']; dxf file name two_d= 1; dont read and load any 3rd Z components [0] OUTPUT: xyz = point matrix defined by end points of lines contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of line and 2 is end type = type of entity, 1=point(vertex), 2=line, 3=arc NOTE: ONLY SET UP FOR LINE'S easily can be set up to read other components using LINE example","title":"Basic Information"},{"location":"function-guide/geom/read_dxf_file_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/read_fil_file_m/","text":"read_fil_file.m \u00b6 Basic Information \u00b6 PURPOSE: Read filament geometry and current from file note can also be read using general read_lines.m SYNTAX: [xfil,ifil]= read_fil_file(filename); INPUT: [default] filename= filename, [filament.dat] OUTPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end ifil = current in each filament, one row for each filament in xfil Dependencies \u00b6 read_lines","title":"read_fil_file.m"},{"location":"function-guide/geom/read_fil_file_m/#read_fil_filem","text":"","title":"read_fil_file.m"},{"location":"function-guide/geom/read_fil_file_m/#basic-information","text":"PURPOSE: Read filament geometry and current from file note can also be read using general read_lines.m SYNTAX: [xfil,ifil]= read_fil_file(filename); INPUT: [default] filename= filename, [filament.dat] OUTPUT: xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end ifil = current in each filament, one row for each filament in xfil","title":"Basic Information"},{"location":"function-guide/geom/read_fil_file_m/#dependencies","text":"read_lines","title":"Dependencies"},{"location":"function-guide/geom/rot_3angles_m/","text":"rot_3angles.m \u00b6 Basic Information \u00b6 SYNTAX: [rot]= rot_3angles(alp,bet,gam); PURPOSE: Generate rotation tansfer function from 3 rotations: 1) rotate alp about Z axis => X Y Z => X' Y' Z' 2) rotate bet about X' axis => X' Y' Z' => X\" Y\" Z\" 3) rotate gam about Z\" axis => X\" Y\" Z\" => X\"' Y\"' Z\"' The rotation matrix is the transform between X Y Z and the X\"' Y\"' Z\"' The transform from global to local coordinates is: [X\"' Y\"' Z\"'] = [rot] * [X Y Z]' INPUT: alp,bet,gam= angles in degrees for rotations OUTPUT: rot= Coordinate transform matrix [3x3] [X' Y' Z']= [rot]*[X Y Z] NOTE: the transpose of rot is the reverse transform Dependencies \u00b6","title":"rot_3angles.m"},{"location":"function-guide/geom/rot_3angles_m/#rot_3anglesm","text":"","title":"rot_3angles.m"},{"location":"function-guide/geom/rot_3angles_m/#basic-information","text":"SYNTAX: [rot]= rot_3angles(alp,bet,gam); PURPOSE: Generate rotation tansfer function from 3 rotations: 1) rotate alp about Z axis => X Y Z => X' Y' Z' 2) rotate bet about X' axis => X' Y' Z' => X\" Y\" Z\" 3) rotate gam about Z\" axis => X\" Y\" Z\" => X\"' Y\"' Z\"' The rotation matrix is the transform between X Y Z and the X\"' Y\"' Z\"' The transform from global to local coordinates is: [X\"' Y\"' Z\"'] = [rot] * [X Y Z]' INPUT: alp,bet,gam= angles in degrees for rotations OUTPUT: rot= Coordinate transform matrix [3x3] [X' Y' Z']= [rot]*[X Y Z] NOTE: the transpose of rot is the reverse transform","title":"Basic Information"},{"location":"function-guide/geom/rot_3angles_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/rot_obj_m/","text":"rot_obj.m \u00b6 Basic Information \u00b6 SYNTAX: [x,y,z]= rot_obj(x,y,z,dir_cos,alpha,origin); PURPOSE: Rotation of an object described by [x,y,z] coordinates in 3-D Euclidean space, {X,Y,Z}, about a line described by direction cosines (dir_cos) [3x1] and passing thru origin [3x1] thru angle (alpha) {degrees}. INPUT: x,y,z= x,y,z coordinates of object, {vector or matrix allowed} note: x,y,z must all be the same size dir_cos= Row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] Note: rotation is about + direction of line alpha= Angle in degrees to rotate using the right hand rule origin= Vector [3] containing the origin about which to rotate Note: if origin is not present it assumes [0,0,0] OUTPUT: x,y,z= new coordinates of object following rotation Dependencies \u00b6 rotation","title":"rot_obj.m"},{"location":"function-guide/geom/rot_obj_m/#rot_objm","text":"","title":"rot_obj.m"},{"location":"function-guide/geom/rot_obj_m/#basic-information","text":"SYNTAX: [x,y,z]= rot_obj(x,y,z,dir_cos,alpha,origin); PURPOSE: Rotation of an object described by [x,y,z] coordinates in 3-D Euclidean space, {X,Y,Z}, about a line described by direction cosines (dir_cos) [3x1] and passing thru origin [3x1] thru angle (alpha) {degrees}. INPUT: x,y,z= x,y,z coordinates of object, {vector or matrix allowed} note: x,y,z must all be the same size dir_cos= Row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] Note: rotation is about + direction of line alpha= Angle in degrees to rotate using the right hand rule origin= Vector [3] containing the origin about which to rotate Note: if origin is not present it assumes [0,0,0] OUTPUT: x,y,z= new coordinates of object following rotation","title":"Basic Information"},{"location":"function-guide/geom/rot_obj_m/#dependencies","text":"rotation","title":"Dependencies"},{"location":"function-guide/geom/rotation_m/","text":"rotation.m \u00b6 Basic Information \u00b6 SYNTAX: [rot]= rotation(dir_cos,alpha); PURPOSE: Generate rotation matrix (rot) [3x3] in 3-D Euclidean space {X,Y,Z} for rotation of [x,y,z] objects about line described by direction cosines (dir_cos) [3x1] thru angle (alpha) {degrees}. Use of rotational transform is: [X_new,Y_new,Z_new] = [X, Y, Z] * a INPUT: dir_cos= row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] note: rotation is about + direction of line alpha= angle in degrees to rotate using the right hand rule OUTPUT: rot= Rotational transform matrix [3x3] NOTE: This rotates the coordinate system. To rotate object use -alpha Dependencies \u00b6","title":"rotation.m"},{"location":"function-guide/geom/rotation_m/#rotationm","text":"","title":"rotation.m"},{"location":"function-guide/geom/rotation_m/#basic-information","text":"SYNTAX: [rot]= rotation(dir_cos,alpha); PURPOSE: Generate rotation matrix (rot) [3x3] in 3-D Euclidean space {X,Y,Z} for rotation of [x,y,z] objects about line described by direction cosines (dir_cos) [3x1] thru angle (alpha) {degrees}. Use of rotational transform is: [X_new,Y_new,Z_new] = [X, Y, Z] * a INPUT: dir_cos= row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] note: rotation is about + direction of line alpha= angle in degrees to rotate using the right hand rule OUTPUT: rot= Rotational transform matrix [3x3] NOTE: This rotates the coordinate system. To rotate object use -alpha","title":"Basic Information"},{"location":"function-guide/geom/rotation_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/rpz_to_xyz_m/","text":"rpz_to_xyz.m \u00b6 Basic Information \u00b6 PURPOSE: convert a cylindrical vector rpz = [R,Phi,Z] to rectangular coordinates xyz = [X, Y, Z] SYNTAX: xyz= rpz_to_xyz(rpz); INPUT: rpz = cylindrical coordinates in 3 columns: [r,phi(radians),z] NOTE THIS IS IN CORRECT RIGHT HAND ROTATION (Not rzp) NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D has Phi clockwise) OUTPUT: xyz = rectangular coordinates in 3-space. [X,Y,Z] SEE ALSO: rzp_to_pts brpz_to_bxyz rzp_to_pts rzpn_to_pts pts_to_fil ptsn_to_fil Dependencies \u00b6","title":"rpz_to_xyz.m"},{"location":"function-guide/geom/rpz_to_xyz_m/#rpz_to_xyzm","text":"","title":"rpz_to_xyz.m"},{"location":"function-guide/geom/rpz_to_xyz_m/#basic-information","text":"PURPOSE: convert a cylindrical vector rpz = [R,Phi,Z] to rectangular coordinates xyz = [X, Y, Z] SYNTAX: xyz= rpz_to_xyz(rpz); INPUT: rpz = cylindrical coordinates in 3 columns: [r,phi(radians),z] NOTE THIS IS IN CORRECT RIGHT HAND ROTATION (Not rzp) NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D has Phi clockwise) OUTPUT: xyz = rectangular coordinates in 3-space. [X,Y,Z] SEE ALSO: rzp_to_pts brpz_to_bxyz rzp_to_pts rzpn_to_pts pts_to_fil ptsn_to_fil","title":"Basic Information"},{"location":"function-guide/geom/rpz_to_xyz_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/rzp_to_pts_m/","text":"rzp_to_pts.m \u00b6 Basic Information \u00b6 PURPOSE: convert a vector of points defined in toroidal geometry as: rzp = [r,z,phi] to xyz points: xpt = [x, y, z]. SYNTAX: xpt= rzp_to_pts(rzp) INPUT: rzp = toroidal coordinates of each point 3 columns: [r,z,phi(radians)] NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D hase Phi clockwise) NOTE: You should use Right Hand R,Phi,Z order rather than R,Z,Phi (left hand) OUTPUT: xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] SEE ALSO: rpz_to_xyz rzpn_to_pts pts_to_fil ptsn_to_fil Dependencies \u00b6","title":"rzp_to_pts.m"},{"location":"function-guide/geom/rzp_to_pts_m/#rzp_to_ptsm","text":"","title":"rzp_to_pts.m"},{"location":"function-guide/geom/rzp_to_pts_m/#basic-information","text":"PURPOSE: convert a vector of points defined in toroidal geometry as: rzp = [r,z,phi] to xyz points: xpt = [x, y, z]. SYNTAX: xpt= rzp_to_pts(rzp) INPUT: rzp = toroidal coordinates of each point 3 columns: [r,z,phi(radians)] NOTE: phi is zero along x-axis and increased toward +y. This is counter- clockwise when viewed from top. (DIII-D hase Phi clockwise) NOTE: You should use Right Hand R,Phi,Z order rather than R,Z,Phi (left hand) OUTPUT: xpt = coordinates of each point in 3-space. Contains 3 columns: [x,y,z] SEE ALSO: rpz_to_xyz rzpn_to_pts pts_to_fil ptsn_to_fil","title":"Basic Information"},{"location":"function-guide/geom/rzp_to_pts_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/shape_create_m/","text":"shape_create.m \u00b6 Basic Information \u00b6 USAGE: [r,z] = shape_create(s) PURPOSE: Create a plasma shape INPUTS: s, structure with the extreme points on the shape: rout, zout, rtop, ztop, rinn, zinn, rbot, zbot Squareness params can also be included: squo, squi, sqli, sqlo (defaults = 0) OUTPUTS: r,z, boundary coordinates NOTE: Special call: official ITER boundary, limiter, and full separatrix [r,z,Rlim,Zlim,rsep,zsep] = shape_create('ITER'); See also SHAPE_PARAMS, SHAPE_EDIT Dependencies \u00b6 shape_edit","title":"shape_create.m"},{"location":"function-guide/geom/shape_create_m/#shape_createm","text":"","title":"shape_create.m"},{"location":"function-guide/geom/shape_create_m/#basic-information","text":"USAGE: [r,z] = shape_create(s) PURPOSE: Create a plasma shape INPUTS: s, structure with the extreme points on the shape: rout, zout, rtop, ztop, rinn, zinn, rbot, zbot Squareness params can also be included: squo, squi, sqli, sqlo (defaults = 0) OUTPUTS: r,z, boundary coordinates NOTE: Special call: official ITER boundary, limiter, and full separatrix [r,z,Rlim,Zlim,rsep,zsep] = shape_create('ITER'); See also SHAPE_PARAMS, SHAPE_EDIT","title":"Basic Information"},{"location":"function-guide/geom/shape_create_m/#dependencies","text":"shape_edit","title":"Dependencies"},{"location":"function-guide/geom/shape_edit_m/","text":"shape_edit.m \u00b6 Basic Information \u00b6 USAGE: [r,z] = shape_edit(r0,z0,s) PURPOSE: Edit a plasma shape by specifying new shape parameters Original shape parameters can be found with s0 = shape_params(r0,z0) INPUTS: s, structure with new shape parameters, these can be edited: rsurf, zsurf, aminor, bminor, elong, triu, tril, squo, squi, sqli, sqlo Omit fields or set value to nan for parameters to be ignored One of aminor, bminor, elong must be ignored (default bminor) OUTPUTS: r,z, modified boundary coordinates See also SHAPE_CREATE, SHAPE_PARAMS","title":"shape_edit.m"},{"location":"function-guide/geom/shape_edit_m/#shape_editm","text":"","title":"shape_edit.m"},{"location":"function-guide/geom/shape_edit_m/#basic-information","text":"USAGE: [r,z] = shape_edit(r0,z0,s) PURPOSE: Edit a plasma shape by specifying new shape parameters Original shape parameters can be found with s0 = shape_params(r0,z0) INPUTS: s, structure with new shape parameters, these can be edited: rsurf, zsurf, aminor, bminor, elong, triu, tril, squo, squi, sqli, sqlo Omit fields or set value to nan for parameters to be ignored One of aminor, bminor, elong must be ignored (default bminor) OUTPUTS: r,z, modified boundary coordinates See also SHAPE_CREATE, SHAPE_PARAMS","title":"Basic Information"},{"location":"function-guide/geom/shape_params_m/","text":"shape_params.m \u00b6 Basic Information \u00b6 USAGE: s = shape_params(r,z) PURPOSE: Return shape parameters for a boundary INPUTS: r, z, boundary coordinates OUTPUTS: s, structure with shape parameters See also SHAPE_CREATE, SHAPE_EDIT Dependencies \u00b6","title":"shape_params.m"},{"location":"function-guide/geom/shape_params_m/#shape_paramsm","text":"","title":"shape_params.m"},{"location":"function-guide/geom/shape_params_m/#basic-information","text":"USAGE: s = shape_params(r,z) PURPOSE: Return shape parameters for a boundary INPUTS: r, z, boundary coordinates OUTPUTS: s, structure with shape parameters See also SHAPE_CREATE, SHAPE_EDIT","title":"Basic Information"},{"location":"function-guide/geom/shape_params_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/write_fil_file_m/","text":"write_fil_file.m \u00b6 Basic Information \u00b6 PURPOSE: output filament geometry and current to file for read in with read_lines.m SYNTAX: num= write_fil_file(xfil,ifil,filename); INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end ifil = current in each filament, one row for each filament in xfil filename= filename, [filament.dat] OUTPUT: num = number of filaments written to file Dependencies \u00b6","title":"write_fil_file.m"},{"location":"function-guide/geom/write_fil_file_m/#write_fil_filem","text":"","title":"write_fil_file.m"},{"location":"function-guide/geom/write_fil_file_m/#basic-information","text":"PURPOSE: output filament geometry and current to file for read in with read_lines.m SYNTAX: num= write_fil_file(xfil,ifil,filename); INPUT: [default] xfil = filament matrix defined by end points of filament contining 6 columns [x1,y1,z1,x2,y2,z2] where 1 is start of filament and 2 is end ifil = current in each filament, one row for each filament in xfil filename= filename, [filament.dat] OUTPUT: num = number of filaments written to file","title":"Basic Information"},{"location":"function-guide/geom/write_fil_file_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/geom/z_dircos_m/","text":"z_dircos.m \u00b6 Basic Information \u00b6 SYNTAX: rot= z_dircos(dir_cos); PURPOSE: Find the direction cosines of an axis system (X', Y', Z') with Z' axis direction cosines input and the X' axis lying in the X, Y plane in the global (X,Y,Z) coordinate system INPUT: dir_cos= row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] OUTPUT: rot= Coordinate transform matrix [3x3] [X' Y' Z']= [rot]*[X Y Z] CAUTION: input of dir_cos=[0,0,1] is \"gimbal lock\" condition and the first transform angle (alpha) cannot be determined - rot set to eye(3) Jim Leuer 1-13-97; Ref: Korn&Korn 1968 & Escibal'65 Pg 77 Dependencies \u00b6","title":"z_dircos.m"},{"location":"function-guide/geom/z_dircos_m/#z_dircosm","text":"","title":"z_dircos.m"},{"location":"function-guide/geom/z_dircos_m/#basic-information","text":"SYNTAX: rot= z_dircos(dir_cos); PURPOSE: Find the direction cosines of an axis system (X', Y', Z') with Z' axis direction cosines input and the X' axis lying in the X, Y plane in the global (X,Y,Z) coordinate system INPUT: dir_cos= row or column vector of length 3 which contains the direction vector or direction cosine of line to rotate about. The direction vector is [dx,dy,dz] along line or [x,y,z] OUTPUT: rot= Coordinate transform matrix [3x3] [X' Y' Z']= [rot]*[X Y Z] CAUTION: input of dir_cos=[0,0,1] is \"gimbal lock\" condition and the first transform angle (alpha) cannot be determined - rot set to eye(3) Jim Leuer 1-13-97; Ref: Korn&Korn 1968 & Escibal'65 Pg 77","title":"Basic Information"},{"location":"function-guide/geom/z_dircos_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/jfit/findlcfs_m/","text":"findlcfs.m \u00b6 Basic Information \u00b6 USAGE: >> [psilc,isclosed] = findlcfs(rg,zg,xlim,ylim,psig) PURPOSE: Function to find last closed flux surface inside limiter on grid INPUTS: rg,zg = grid geometry xlim,ylim = limiter R,Z psig = flux matrix on zg,rg grid (nz x nr) OUTPUTS: psilc = flux on LCFS (if found; otherwise last surface found) isclosed = flag to identify if psilc corr to closed surface RESTRICTIONS: METHOD: If fails to find closed contour, psilc = max of flux on limiter Dependencies \u00b6 findclosedDH","title":"findlcfs.m"},{"location":"function-guide/jfit/findlcfs_m/#findlcfsm","text":"","title":"findlcfs.m"},{"location":"function-guide/jfit/findlcfs_m/#basic-information","text":"USAGE: >> [psilc,isclosed] = findlcfs(rg,zg,xlim,ylim,psig) PURPOSE: Function to find last closed flux surface inside limiter on grid INPUTS: rg,zg = grid geometry xlim,ylim = limiter R,Z psig = flux matrix on zg,rg grid (nz x nr) OUTPUTS: psilc = flux on LCFS (if found; otherwise last surface found) isclosed = flag to identify if psilc corr to closed surface RESTRICTIONS: METHOD: If fails to find closed contour, psilc = max of flux on limiter","title":"Basic Information"},{"location":"function-guide/jfit/findlcfs_m/#dependencies","text":"findclosedDH","title":"Dependencies"},{"location":"function-guide/jfit/plot_jfit_slice_m/","text":"plot_jfit_slice.m \u00b6 Basic Information \u00b6 USAGE: >> plot_jfit_slice PURPOSE: Script to plot JFIT single slice INPUTS: In Matlab environment: jfit_file = JFIT data file written by jfit_fun tok_dat_struct (object structure file: must match JFIT calc) input_time (opt) = 1 to select to input time at prompt (def=1) OUTPUTS: Plots RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD: Dependencies \u00b6 findsep plot_tok_geo findlcfs","title":"plot_jfit_slice.m"},{"location":"function-guide/jfit/plot_jfit_slice_m/#plot_jfit_slicem","text":"","title":"plot_jfit_slice.m"},{"location":"function-guide/jfit/plot_jfit_slice_m/#basic-information","text":"USAGE: >> plot_jfit_slice PURPOSE: Script to plot JFIT single slice INPUTS: In Matlab environment: jfit_file = JFIT data file written by jfit_fun tok_dat_struct (object structure file: must match JFIT calc) input_time (opt) = 1 to select to input time at prompt (def=1) OUTPUTS: Plots RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD:","title":"Basic Information"},{"location":"function-guide/jfit/plot_jfit_slice_m/#dependencies","text":"findsep plot_tok_geo findlcfs","title":"Dependencies"},{"location":"function-guide/jfit/plot_jfit_slices_m/","text":"plot_jfit_slices.m \u00b6 Basic Information \u00b6 USAGE: >> plot_jfit_slices PURPOSE: Script to plot JFIT many slices on one figure INPUTS: In Matlab environment: jfit_file = JFIT data file written by jfit_fun tok_dat_struct (object structure file: must match JFIT calc) OUTPUTS: Plots RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD: Dependencies \u00b6 findsep plot_tok_geo find_near findlcfs","title":"plot_jfit_slices.m"},{"location":"function-guide/jfit/plot_jfit_slices_m/#plot_jfit_slicesm","text":"","title":"plot_jfit_slices.m"},{"location":"function-guide/jfit/plot_jfit_slices_m/#basic-information","text":"USAGE: >> plot_jfit_slices PURPOSE: Script to plot JFIT many slices on one figure INPUTS: In Matlab environment: jfit_file = JFIT data file written by jfit_fun tok_dat_struct (object structure file: must match JFIT calc) OUTPUTS: Plots RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD:","title":"Basic Information"},{"location":"function-guide/jfit/plot_jfit_slices_m/#dependencies","text":"findsep plot_tok_geo find_near findlcfs","title":"Dependencies"},{"location":"function-guide/jfit/postpr_jfit_dev_m/","text":"postpr_jfit_dev.m \u00b6 Basic Information \u00b6 USAGE: >> postpr_jfit_dev PURPOSE: Script to post-process JFIT results to get q, Ihalo, etc... (replaces old jfit_postpr script; updated for 2009 JFIT) INPUTS: jfit_file = JFIT data file written by jfit_fun tipsit = time for plotting of equilibrium flux/field [s] (tipsit takes precedence over ipsit if exists) ipsit = (optional) index for time to plot eq flux/field if tipsit doesn't exist... ilcfs=flag to select LCFS finding algorithm. 1=anglebased, 2=line segment intersection alg., 0=omit lcfs calc (psi only; AlHyatt flag) idopsit = flag to accumulate psi_grid(t) in Wb/rad (1=do, 0=skip) savetype = (optional) 'MAT' for standard (present Matlab version) format, or (e.g.) 'V13' for R13 format isave = save postpr*.mat file qelim = max plot limit for qa, qe (def=20) Defined in jfit_file data: jfit_obj_file = file containing tok_dat_struct (must match JFIT calc) OUTPUTS: Save file \"postpr_tmp_<shot>.mat\" and plots... RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD: Dependencies \u00b6 findsep plot_tok_geo smoothdt deriv paper_position findlcfs gridit","title":"postpr_jfit_dev.m"},{"location":"function-guide/jfit/postpr_jfit_dev_m/#postpr_jfit_devm","text":"","title":"postpr_jfit_dev.m"},{"location":"function-guide/jfit/postpr_jfit_dev_m/#basic-information","text":"USAGE: >> postpr_jfit_dev PURPOSE: Script to post-process JFIT results to get q, Ihalo, etc... (replaces old jfit_postpr script; updated for 2009 JFIT) INPUTS: jfit_file = JFIT data file written by jfit_fun tipsit = time for plotting of equilibrium flux/field [s] (tipsit takes precedence over ipsit if exists) ipsit = (optional) index for time to plot eq flux/field if tipsit doesn't exist... ilcfs=flag to select LCFS finding algorithm. 1=anglebased, 2=line segment intersection alg., 0=omit lcfs calc (psi only; AlHyatt flag) idopsit = flag to accumulate psi_grid(t) in Wb/rad (1=do, 0=skip) savetype = (optional) 'MAT' for standard (present Matlab version) format, or (e.g.) 'V13' for R13 format isave = save postpr*.mat file qelim = max plot limit for qa, qe (def=20) Defined in jfit_file data: jfit_obj_file = file containing tok_dat_struct (must match JFIT calc) OUTPUTS: Save file \"postpr_tmp_<shot>.mat\" and plots... RESTRICTIONS: Object file must match objects used in JFIT calculation. METHOD:","title":"Basic Information"},{"location":"function-guide/jfit/postpr_jfit_dev_m/#dependencies","text":"findsep plot_tok_geo smoothdt deriv paper_position findlcfs gridit","title":"Dependencies"},{"location":"function-guide/mag/bgreens_conway_m/","text":"bgreens_conway.m \u00b6 Basic Information \u00b6 SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_fine(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. This version of code is based on low level calculation using fine.m. Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bpdata(1:5,:)=[Z;R;Ang;length(m);Ip coeff] (5th row is ignored, so 4 x number probes also works) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation. Dependencies \u00b6 wait bld_subelements","title":"bgreens_conway.m"},{"location":"function-guide/mag/bgreens_conway_m/#bgreens_conwaym","text":"","title":"bgreens_conway.m"},{"location":"function-guide/mag/bgreens_conway_m/#basic-information","text":"SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_fine(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. This version of code is based on low level calculation using fine.m. Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bpdata(1:5,:)=[Z;R;Ang;length(m);Ip coeff] (5th row is ignored, so 4 x number probes also works) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/bgreens_conway_m/#dependencies","text":"wait bld_subelements","title":"Dependencies"},{"location":"function-guide/mag/bgreens_distrib_m/","text":"bgreens_distrib.m \u00b6 Basic Information \u00b6 SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_distrib(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. (Use mutind_distrib with bcoil_data = filaments to compute Greens functions for flux.) Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bpdata(1:5,:)=[Z;R;Ang;length(m);Ip coeff] (5th row is ignored, so 4 x number probes also works) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation. Dependencies \u00b6 calc_bgreens wait green_near bld_subelements","title":"bgreens_distrib.m"},{"location":"function-guide/mag/bgreens_distrib_m/#bgreens_distribm","text":"","title":"bgreens_distrib.m"},{"location":"function-guide/mag/bgreens_distrib_m/#basic-information","text":"SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_distrib(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. (Use mutind_distrib with bcoil_data = filaments to compute Greens functions for flux.) Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bpdata(1:5,:)=[Z;R;Ang;length(m);Ip coeff] (5th row is ignored, so 4 x number probes also works) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/bgreens_distrib_m/#dependencies","text":"calc_bgreens wait green_near bld_subelements","title":"Dependencies"},{"location":"function-guide/mag/bgreens_fine_m/","text":"bgreens_fine.m \u00b6 Basic Information \u00b6 @(#)bgreens_fine.m 1.4 02/11/08 SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_fine(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. This version of code is based on low level calculation using fine.m. Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bprobe_data(1:6,:)=[Z;R;Ang;length(m);Ip coeff;width(m)] (abs(4th row) specifies width if < 0) (5th row is ignored, so 4 x number probes also works) (6th row is optional, assumed 0.02m if not provided) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: If probe width is specified in 6 row bprobe_data AND there is length<0 in row 4, the row 4 specified length prevails. Probe will be treated as flat if width specified in row 4 (6 row convention allows l & w) METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation. WRITTEN BY: Mike Walker ON 7/26/99 10/03/03 JAL1 remove one line commented below 10/30/07 NWE length=0 \"saddle probes\" treated as single point 02/08/08 NWE applies probe cross section width if specified in bprobe_data(6,:) or length<0 in bprobe_data(4,:). Dependencies \u00b6 wait bld_subelements","title":"bgreens_fine.m"},{"location":"function-guide/mag/bgreens_fine_m/#bgreens_finem","text":"","title":"bgreens_fine.m"},{"location":"function-guide/mag/bgreens_fine_m/#basic-information","text":"@(#)bgreens_fine.m 1.4 02/11/08 SYNTAX: [brgreens,bzgreens,bpgreens] = ... bgreens_fine(coil_data,bprobe_data,nrect,verbose) PURPOSE: Compute Greens functions from axisymmetric current carrying conductors, each of whose cross-section is a parallelogram, to Br, Bz, and angled probe measurement at a set of specified points. This version of code is based on low level calculation using fine.m. Can be used to compute Br,Bz Greens functions for arbitrary points in space. INPUT: coil_data = data describing geometry of coil set Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| bprobe_data = Bprobe data, 5 x number of probes (or any msmnt pts): bprobe_data(1:6,:)=[Z;R;Ang;length(m);Ip coeff;width(m)] (abs(4th row) specifies width if < 0) (5th row is ignored, so 4 x number probes also works) (6th row is optional, assumed 0.02m if not provided) nrect = rectangle partitioning for conductor set (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: brgreens = Br Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bzgreens = Bz Greens function matrix, with rows corresponding to probes, columns to conductors (Tesla/MA) bpgreens = Greens function matrix to field measured by bprobes, with rows corresponding to probes, columns to conductors (Tesla/MA) RESTRICTIONS: If probe width is specified in 6 row bprobe_data AND there is length<0 in row 4, the row 4 specified length prevails. Probe will be treated as flat if width specified in row 4 (6 row convention allows l & w) METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All bgreens are computed for these rectangles, then combined at the end. Calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation. WRITTEN BY: Mike Walker ON 7/26/99 10/03/03 JAL1 remove one line commented below 10/30/07 NWE length=0 \"saddle probes\" treated as single point 02/08/08 NWE applies probe cross section width if specified in bprobe_data(6,:) or length<0 in bprobe_data(4,:).","title":"Basic Information"},{"location":"function-guide/mag/bgreens_fine_m/#dependencies","text":"wait bld_subelements","title":"Dependencies"},{"location":"function-guide/mag/bld_subelements_m/","text":"bld_subelements.m \u00b6 Basic Information \u00b6 SYNTAX: [geometry,lnrect,snrect] = ... bld_subelements(cond_data,nrect,allow_filaments) PURPOSE: Split conductors into rectangular subelements. INPUT: cond_data = data describing geometry of conductor Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrect = number of rectangles to partition conductors. Interpretation depends on size of this object: scalar: nrect = number of rectangles across largest of conductor minimum dimensions (thickest conductor). All partitioning automatically computed from this. (Gives roughly constant subrectangle size over all conductors.) length vector == 2: nrect specifies FIXED nshort x nlong partitioning, nshort refers to min(dR,dZ) 2 x nconductors or nconductors x 2: nrect specifies FIXED values of (nshort, nlong) for each conductor nconductors length vector: nrect specifies fixed nshort for each conductor, nlong computed by dR/dZ scaling allow_filaments = set to 1 to allow filament (dR=dZ=0) coils, otherwise an error message will be printed if this is detected OUTPUT: geometry = 7 x n matrix describing all subelements of all conductors Each column has the following information: [z of current element; r of current element; conductor number; dz of subelement; dr of subelement; row number of element within conductor; column number of element within conductor] lnrect = number of rectangles in longer dimension, for each conductor Dependencies \u00b6 plot_box wait","title":"bld_subelements.m"},{"location":"function-guide/mag/bld_subelements_m/#bld_subelementsm","text":"","title":"bld_subelements.m"},{"location":"function-guide/mag/bld_subelements_m/#basic-information","text":"SYNTAX: [geometry,lnrect,snrect] = ... bld_subelements(cond_data,nrect,allow_filaments) PURPOSE: Split conductors into rectangular subelements. INPUT: cond_data = data describing geometry of conductor Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrect = number of rectangles to partition conductors. Interpretation depends on size of this object: scalar: nrect = number of rectangles across largest of conductor minimum dimensions (thickest conductor). All partitioning automatically computed from this. (Gives roughly constant subrectangle size over all conductors.) length vector == 2: nrect specifies FIXED nshort x nlong partitioning, nshort refers to min(dR,dZ) 2 x nconductors or nconductors x 2: nrect specifies FIXED values of (nshort, nlong) for each conductor nconductors length vector: nrect specifies fixed nshort for each conductor, nlong computed by dR/dZ scaling allow_filaments = set to 1 to allow filament (dR=dZ=0) coils, otherwise an error message will be printed if this is detected OUTPUT: geometry = 7 x n matrix describing all subelements of all conductors Each column has the following information: [z of current element; r of current element; conductor number; dz of subelement; dr of subelement; row number of element within conductor; column number of element within conductor] lnrect = number of rectangles in longer dimension, for each conductor","title":"Basic Information"},{"location":"function-guide/mag/bld_subelements_m/#dependencies","text":"plot_box wait","title":"Dependencies"},{"location":"function-guide/mag/calc_bgreens_m/","text":"calc_bgreens.m \u00b6 Basic Information \u00b6 SYNTAX: [Br,Bz,dBrdr,dBrdz,dBzdr,dBzdz] = calc_bgreens(ra,rb,za,zb,k,Ek,Kk) PURPOSE: Calculate Br, Bz green functions with the option of using already computed elliptic integrals. [Kk,Ek]=ellipke(m) k=sqrt(m); where m=((rb+ra).^2 - (rb-ra).^2)./((rb+ra).^2 + (za-zb).^2); INPUT: ra = radius of source element (m) rb = radius of measurement point (m) za = z position of source element (m) zb = z position of measurement point (m) k = parameter that is argument to elliptic integrals (optional) Ek = calculated value of elliptic integral E(k) (optional) Kk = calculated value of elliptic integral K(k) (optional) All inputs must be same size (scalars, vectors, or matrices). If k,Ek,Kk not specified, they are computed here. OUTPUT: Br = radial field at measurement point due to current in filament at source location Bz = vertical field at measurement point due to current in filament at source location dBrdr = derivative of Br w.r.t. rb at measurement point dBrdz = derivative of Br w.r.t. zb at measurement point dBzdr = derivative of Bz w.r.t. rb at measurement point dBzdz = derivative of Bz w.r.t. zb at measurement point RESTRICTIONS: This is a \"filament-to-filament\" calculation and is not correct for distributed current sources. The filament calculation is singular for \"point b\" equal to \"point a\". Dependencies \u00b6","title":"calc_bgreens.m"},{"location":"function-guide/mag/calc_bgreens_m/#calc_bgreensm","text":"","title":"calc_bgreens.m"},{"location":"function-guide/mag/calc_bgreens_m/#basic-information","text":"SYNTAX: [Br,Bz,dBrdr,dBrdz,dBzdr,dBzdz] = calc_bgreens(ra,rb,za,zb,k,Ek,Kk) PURPOSE: Calculate Br, Bz green functions with the option of using already computed elliptic integrals. [Kk,Ek]=ellipke(m) k=sqrt(m); where m=((rb+ra).^2 - (rb-ra).^2)./((rb+ra).^2 + (za-zb).^2); INPUT: ra = radius of source element (m) rb = radius of measurement point (m) za = z position of source element (m) zb = z position of measurement point (m) k = parameter that is argument to elliptic integrals (optional) Ek = calculated value of elliptic integral E(k) (optional) Kk = calculated value of elliptic integral K(k) (optional) All inputs must be same size (scalars, vectors, or matrices). If k,Ek,Kk not specified, they are computed here. OUTPUT: Br = radial field at measurement point due to current in filament at source location Bz = vertical field at measurement point due to current in filament at source location dBrdr = derivative of Br w.r.t. rb at measurement point dBrdz = derivative of Br w.r.t. zb at measurement point dBzdr = derivative of Bz w.r.t. rb at measurement point dBzdz = derivative of Bz w.r.t. zb at measurement point RESTRICTIONS: This is a \"filament-to-filament\" calculation and is not correct for distributed current sources. The filament calculation is singular for \"point b\" equal to \"point a\".","title":"Basic Information"},{"location":"function-guide/mag/calc_bgreens_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mag/calc_eddy_flux_m/","text":"calc_eddy_flux.m \u00b6 Basic Information \u00b6 SYNTAX: [flux,B,Br,Bz,ivv,t_ivv,imc]= calc_eddy_flux(shotnum,tok_data_struct,rtimes,t,Icoils,... psidata,probedata,options,plasma) PURPOSE: Compute flux/field in vacuum region for multiple rtimes using a fit to measured diagnostics, then compute approximate loop voltage. Fit may optionally use eigenmode approximation of vessel or do full integration of VV eddy currents for fitting vessel effects, include axisymmetric magnetic materials, and/or include Ip effects. INPUT: [default] shotnum = number of shot to reconstruct rtimes = time steps at which to reconstruct vacuum flux/field t = time vector for data signals Icoils = PF coil current data psidata = flux loop data probedata = magnetic probe data options cccirc = PF coils circuit connection mapping Pcc = mapping from coil states to all PF coils (only one of cccirc or Pcc should be provided) clevels = # levels on contour plots [10] idxbp = indices of B-probes to fit [all=1:nbp] idxfl = indices of flux loops to fit [all=1:nfl] idxvv = indices of VV elements to use [all=1:nv] ieddy = 0: Use eigenmode expansion of VV to fit vv currents 1: Use integrated VV eddy currents for fitting navg = # time points over which measurements are averaged [3] neig = # eigenmods to reating if ieddy=0 [10] pause_it = pause after plots for inspection (1=yes 0=no) [0] plotb = plot magnetic fields (1=yes 0=no) [1] plotfl = plot magnetic flux (1=yes 0=no) [1] (SEE calc_vv_eddy for further options) plasma (see calc_vv_eddy) NOTE: To reproduce results of calc_vac_flux simply put ieddy=0. OUTPUT: flux = magnetic flux at plasma grid points for each time step B,Br,Bz = magnetic field \"\"\"\" ivv = calculated vessel currents (if ieddy = 1) t_ivv = time vector for calculated vessel currents imc = magnetization currents Plots: 1. contour plots of magnetic flux and field over the kstar x-section RESTRICTIONS: 1. Assumes that all data is uniformly sampled & in same time intervals WRITTEN BY: Jim Leuer ON 9/22/06 Optimization part taken from M. Walkers calc_vac_flux and modified. also different plot features @(#)calc_eddy_flux.m 1.7 02/02/10","title":"calc_eddy_flux.m"},{"location":"function-guide/mag/calc_eddy_flux_m/#calc_eddy_fluxm","text":"","title":"calc_eddy_flux.m"},{"location":"function-guide/mag/calc_eddy_flux_m/#basic-information","text":"SYNTAX: [flux,B,Br,Bz,ivv,t_ivv,imc]= calc_eddy_flux(shotnum,tok_data_struct,rtimes,t,Icoils,... psidata,probedata,options,plasma) PURPOSE: Compute flux/field in vacuum region for multiple rtimes using a fit to measured diagnostics, then compute approximate loop voltage. Fit may optionally use eigenmode approximation of vessel or do full integration of VV eddy currents for fitting vessel effects, include axisymmetric magnetic materials, and/or include Ip effects. INPUT: [default] shotnum = number of shot to reconstruct rtimes = time steps at which to reconstruct vacuum flux/field t = time vector for data signals Icoils = PF coil current data psidata = flux loop data probedata = magnetic probe data options cccirc = PF coils circuit connection mapping Pcc = mapping from coil states to all PF coils (only one of cccirc or Pcc should be provided) clevels = # levels on contour plots [10] idxbp = indices of B-probes to fit [all=1:nbp] idxfl = indices of flux loops to fit [all=1:nfl] idxvv = indices of VV elements to use [all=1:nv] ieddy = 0: Use eigenmode expansion of VV to fit vv currents 1: Use integrated VV eddy currents for fitting navg = # time points over which measurements are averaged [3] neig = # eigenmods to reating if ieddy=0 [10] pause_it = pause after plots for inspection (1=yes 0=no) [0] plotb = plot magnetic fields (1=yes 0=no) [1] plotfl = plot magnetic flux (1=yes 0=no) [1] (SEE calc_vv_eddy for further options) plasma (see calc_vv_eddy) NOTE: To reproduce results of calc_vac_flux simply put ieddy=0. OUTPUT: flux = magnetic flux at plasma grid points for each time step B,Br,Bz = magnetic field \"\"\"\" ivv = calculated vessel currents (if ieddy = 1) t_ivv = time vector for calculated vessel currents imc = magnetization currents Plots: 1. contour plots of magnetic flux and field over the kstar x-section RESTRICTIONS: 1. Assumes that all data is uniformly sampled & in same time intervals WRITTEN BY: Jim Leuer ON 9/22/06 Optimization part taken from M. Walkers calc_vac_flux and modified. also different plot features @(#)calc_eddy_flux.m 1.7 02/02/10","title":"Basic Information"},{"location":"function-guide/mag/calc_mpp_m/","text":"calc_mpp.m \u00b6 Basic Information \u00b6 SYNTAX: [mpp,gbr2p,gbz2p] = calc_mpp(rgg,zgg,dr,dz,nz,nr) PURPOSE: calculate mutuals between all plasma gridpoints INPUT: rgg = r coords of all grids zgg = z coords of all grids dr = r width of all grid \"current elements\" dz = z width of all grid \"current elements\" nz = number of grids in z direction nr = number of grids in r direction OUTPUT: mpp = mutuals between all plasma gridpoints (uH) gbr2p = Br greens functions from plasma grid to itself (T/MA) gbz2p = Bz greens functions from plasma grid to itself (T/MA) !!NOTE!!: This data is stored in a compressed format using the fact that it is only the difference in z coordinates which enters the mutual and Greens' function calculations: All output matrices are of size (nz*nr) by nr, where columns represent different values of radial coordinate. To extract a mutual inductance or Green's function value for the kth grid point (measurement point) versus the jth grid point (current source), do the following: (1) calculate the number of grids n that grid point k is above the jth grid point in z direction (negative value n if kth is below jth) (2) calculate the column number m (m=1,...,nr) that grid point k is in. (3) mutual inductance = mpp((m-1)*nz+|n|+1,j) (4) Br greens function = sign(n) * gbr2p((m-1)*nz+|n|+1,j) where sign(n) = 1, if n>=0 = -1, if n<0. (5) Bz greens function = gbz2p((m-1)*nz+|n|+1,j) Note that it is only important to distinguish between the source and measurement point for Br Green's function values. This \"uncompress\" procedure is implemented in get_plasma_greens.m. Dependencies \u00b6 mindbf_gen","title":"calc_mpp.m"},{"location":"function-guide/mag/calc_mpp_m/#calc_mppm","text":"","title":"calc_mpp.m"},{"location":"function-guide/mag/calc_mpp_m/#basic-information","text":"SYNTAX: [mpp,gbr2p,gbz2p] = calc_mpp(rgg,zgg,dr,dz,nz,nr) PURPOSE: calculate mutuals between all plasma gridpoints INPUT: rgg = r coords of all grids zgg = z coords of all grids dr = r width of all grid \"current elements\" dz = z width of all grid \"current elements\" nz = number of grids in z direction nr = number of grids in r direction OUTPUT: mpp = mutuals between all plasma gridpoints (uH) gbr2p = Br greens functions from plasma grid to itself (T/MA) gbz2p = Bz greens functions from plasma grid to itself (T/MA) !!NOTE!!: This data is stored in a compressed format using the fact that it is only the difference in z coordinates which enters the mutual and Greens' function calculations: All output matrices are of size (nz*nr) by nr, where columns represent different values of radial coordinate. To extract a mutual inductance or Green's function value for the kth grid point (measurement point) versus the jth grid point (current source), do the following: (1) calculate the number of grids n that grid point k is above the jth grid point in z direction (negative value n if kth is below jth) (2) calculate the column number m (m=1,...,nr) that grid point k is in. (3) mutual inductance = mpp((m-1)*nz+|n|+1,j) (4) Br greens function = sign(n) * gbr2p((m-1)*nz+|n|+1,j) where sign(n) = 1, if n>=0 = -1, if n<0. (5) Bz greens function = gbz2p((m-1)*nz+|n|+1,j) Note that it is only important to distinguish between the source and measurement point for Br Green's function values. This \"uncompress\" procedure is implemented in get_plasma_greens.m.","title":"Basic Information"},{"location":"function-guide/mag/calc_mpp_m/#dependencies","text":"mindbf_gen","title":"Dependencies"},{"location":"function-guide/mag/calc_ohmic_res_m/","text":"calc_ohmic_res.m \u00b6 Basic Information \u00b6 PURPOSE: Calculates Best Coil resistances to produce constant flux decay USAGE: rcc= calc_ohmic_res(mcc,icc); INPUTS: [default] mcc= coil mutual inductance matrix icc= Optimum initial magnetization current vector OUTPUTS: rcc = optimum resistance matrix METHOD: [I]^-1 is diaganal matrix made up of 1/I_i currents R/gamma = [I]^-1 [M] I LIMITATIONS: Assumes the initial current distrubution is Ohmic (i.e. produces constant flux plateau in plasma region. icc is typically generated using ohmic_dist see also ohmic_dist.m Dependencies \u00b6 ohmic_dist plot_box dee","title":"calc_ohmic_res.m"},{"location":"function-guide/mag/calc_ohmic_res_m/#calc_ohmic_resm","text":"","title":"calc_ohmic_res.m"},{"location":"function-guide/mag/calc_ohmic_res_m/#basic-information","text":"PURPOSE: Calculates Best Coil resistances to produce constant flux decay USAGE: rcc= calc_ohmic_res(mcc,icc); INPUTS: [default] mcc= coil mutual inductance matrix icc= Optimum initial magnetization current vector OUTPUTS: rcc = optimum resistance matrix METHOD: [I]^-1 is diaganal matrix made up of 1/I_i currents R/gamma = [I]^-1 [M] I LIMITATIONS: Assumes the initial current distrubution is Ohmic (i.e. produces constant flux plateau in plasma region. icc is typically generated using ohmic_dist see also ohmic_dist.m","title":"Basic Information"},{"location":"function-guide/mag/calc_ohmic_res_m/#dependencies","text":"ohmic_dist plot_box dee","title":"Dependencies"},{"location":"function-guide/mag/calc_vv_eddy_m/","text":"calc_vv_eddy.m \u00b6 Basic Information \u00b6 @(#)calc_vv_eddy.m 1.3 04/21/08 SYNTAX: [ivv,t_ivv] ... = calc_vv_eddy(shotnum,tok_data_struct,t,icoils,options,plasma) PURPOSE: Calculates VV eddy currents from PF coil ramps, with plasma effects optionally included. INPUT: [default] shotnum = shot number tok_data_struct = TokSys vacuum object t = time vector for current waveforms icoils = coil current matrix (A) (dim = [ntimes,ncoils] options cutoff = Cutoff frequency for filtering I_dot (Hz) [100Hz] cor_offdrf = dI/dt data correction (0=none 1=offset 2=drift) [0] idxvv = indices of VV elements to use in calculation [1:nv] inc_pl = include Ip effects (1=yes 0=no) [0] (requires plasma structure if 1) ivv0 = initial vv currents (size = length(idxvv)) (A) [0] n_offdrf = # points to use for offset or drift correction [100] pause_it = pause after plots for inspection (1=yes 0=no) [0] ploted = plot eddy current analysis (1=yes 0=no) [1] resv_fac = multiplication factor for VV resistance [1] t0 = starting time for VV current integration (s) [0] plasma ip = plasma current vector (A) r_pl = plasma major radius (m) a_pl = plasma minor radius (m) k_pl = plasma elongations [1.0] d_pl = plasma triangularity [0] n_pl = # pts defining plasma edge [100] z_pl = plasma vertical positions (m) [0] OUTPUT: ivv = VV eddy current vectors (size = [nt,nv]); t_ivv = VV eddy current time vector (size = nt) RESTRICTIONS: 1. Assumes that all data is uniformly sampled & in same time intervals METHOD: WRITTEN BY: Jim Leuer ON 9/28/06 taken from calc_eddy_flux MODIFICATIONS: 2008-03-03 NWE generalized to use with any tokamak, removed data retrieval ============================================================================= Dependencies \u00b6 eigsort subplot_ga wait rm_x_label correct_drift dee fft_filter","title":"calc_vv_eddy.m"},{"location":"function-guide/mag/calc_vv_eddy_m/#calc_vv_eddym","text":"","title":"calc_vv_eddy.m"},{"location":"function-guide/mag/calc_vv_eddy_m/#basic-information","text":"@(#)calc_vv_eddy.m 1.3 04/21/08 SYNTAX: [ivv,t_ivv] ... = calc_vv_eddy(shotnum,tok_data_struct,t,icoils,options,plasma) PURPOSE: Calculates VV eddy currents from PF coil ramps, with plasma effects optionally included. INPUT: [default] shotnum = shot number tok_data_struct = TokSys vacuum object t = time vector for current waveforms icoils = coil current matrix (A) (dim = [ntimes,ncoils] options cutoff = Cutoff frequency for filtering I_dot (Hz) [100Hz] cor_offdrf = dI/dt data correction (0=none 1=offset 2=drift) [0] idxvv = indices of VV elements to use in calculation [1:nv] inc_pl = include Ip effects (1=yes 0=no) [0] (requires plasma structure if 1) ivv0 = initial vv currents (size = length(idxvv)) (A) [0] n_offdrf = # points to use for offset or drift correction [100] pause_it = pause after plots for inspection (1=yes 0=no) [0] ploted = plot eddy current analysis (1=yes 0=no) [1] resv_fac = multiplication factor for VV resistance [1] t0 = starting time for VV current integration (s) [0] plasma ip = plasma current vector (A) r_pl = plasma major radius (m) a_pl = plasma minor radius (m) k_pl = plasma elongations [1.0] d_pl = plasma triangularity [0] n_pl = # pts defining plasma edge [100] z_pl = plasma vertical positions (m) [0] OUTPUT: ivv = VV eddy current vectors (size = [nt,nv]); t_ivv = VV eddy current time vector (size = nt) RESTRICTIONS: 1. Assumes that all data is uniformly sampled & in same time intervals METHOD: WRITTEN BY: Jim Leuer ON 9/28/06 taken from calc_eddy_flux MODIFICATIONS: 2008-03-03 NWE generalized to use with any tokamak, removed data retrieval =============================================================================","title":"Basic Information"},{"location":"function-guide/mag/calc_vv_eddy_m/#dependencies","text":"eigsort subplot_ga wait rm_x_label correct_drift dee fft_filter","title":"Dependencies"},{"location":"function-guide/mag/cfil_3d_b_m/","text":"cfil_3d_b.m \u00b6 Basic Information \u00b6 PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] produced by a circular filament with radius a located with center at 0,0,0 and center line in +Z direction. Unit current (1A) in counter clockwise The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= cfil_3d_b(x,y,z,a) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [a] == vector of filament radius one filament per row Note: If x,y,z & a are matrix or vectors they must be same size. Any of the components can be a scalar. OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use cfilr_3b_b if [X] is inside the filament Dependencies \u00b6 fine","title":"cfil_3d_b.m"},{"location":"function-guide/mag/cfil_3d_b_m/#cfil_3d_bm","text":"","title":"cfil_3d_b.m"},{"location":"function-guide/mag/cfil_3d_b_m/#basic-information","text":"PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] produced by a circular filament with radius a located with center at 0,0,0 and center line in +Z direction. Unit current (1A) in counter clockwise The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= cfil_3d_b(x,y,z,a) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [a] == vector of filament radius one filament per row Note: If x,y,z & a are matrix or vectors they must be same size. Any of the components can be a scalar. OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use cfilr_3b_b if [X] is inside the filament","title":"Basic Information"},{"location":"function-guide/mag/cfil_3d_b_m/#dependencies","text":"fine","title":"Dependencies"},{"location":"function-guide/mag/crect2bprobe_m/","text":"crect2bprobe.m \u00b6 Basic Information \u00b6 PURPOSE: Generated B-field at magnetic probe located at rp,zp with angle theta and length l from circular coil locatd at rc,zc with rectanular width and height dr and dz and carrying current cur. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [b]= crect2bprobe(rc,zc,dr,dz,i,r,z,theta,leng) INPUT: rc,zc= coordinates of center of rectangular coil dr,dz= width and height of coil cur= current in coil (+=counter clockwise) rp,zp= coordinates of the center of the probe angle= Angle of the coil with the horozontal (deg) leng= length of the probe in the theta direction OUTPUT: [b] == B field at probes CAUTION: Present version does not use leng. It computes field only at center NOTE: uses magnetics routing fine.m which is single precision Dependencies \u00b6 fine","title":"crect2bprobe.m"},{"location":"function-guide/mag/crect2bprobe_m/#crect2bprobem","text":"","title":"crect2bprobe.m"},{"location":"function-guide/mag/crect2bprobe_m/#basic-information","text":"PURPOSE: Generated B-field at magnetic probe located at rp,zp with angle theta and length l from circular coil locatd at rc,zc with rectanular width and height dr and dz and carrying current cur. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [b]= crect2bprobe(rc,zc,dr,dz,i,r,z,theta,leng) INPUT: rc,zc= coordinates of center of rectangular coil dr,dz= width and height of coil cur= current in coil (+=counter clockwise) rp,zp= coordinates of the center of the probe angle= Angle of the coil with the horozontal (deg) leng= length of the probe in the theta direction OUTPUT: [b] == B field at probes CAUTION: Present version does not use leng. It computes field only at center NOTE: uses magnetics routing fine.m which is single precision","title":"Basic Information"},{"location":"function-guide/mag/crect2bprobe_m/#dependencies","text":"fine","title":"Dependencies"},{"location":"function-guide/mag/fil_3d_b_m/","text":"fil_3d_b.m \u00b6 Basic Information \u00b6 PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] produced by a straight filament with length [c] in the z direction carrying Unit current (I=1A) in the +z direction The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= fil_3d_b(x,y,z,c) INPUT: [x,y,z] == [X] coordinates of field point for calculation of B [c] == length of filament (scalar or same size as X) Note: x,y,z or c can be a scalar or matrix but all matricies must be same size. Any of the components can be a scalar. Caution: if x and y are both zero answer is NAN (use fil_3d_b_rad) OUTPUT: [bx,by,bz] == [B] B-field at point X NOTE: see filr_3d_b for filaments with finite radius computation inside rad. Dependencies \u00b6","title":"fil_3d_b.m"},{"location":"function-guide/mag/fil_3d_b_m/#fil_3d_bm","text":"","title":"fil_3d_b.m"},{"location":"function-guide/mag/fil_3d_b_m/#basic-information","text":"PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] produced by a straight filament with length [c] in the z direction carrying Unit current (I=1A) in the +z direction The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= fil_3d_b(x,y,z,c) INPUT: [x,y,z] == [X] coordinates of field point for calculation of B [c] == length of filament (scalar or same size as X) Note: x,y,z or c can be a scalar or matrix but all matricies must be same size. Any of the components can be a scalar. Caution: if x and y are both zero answer is NAN (use fil_3d_b_rad) OUTPUT: [bx,by,bz] == [B] B-field at point X NOTE: see filr_3d_b for filaments with finite radius computation inside rad.","title":"Basic Information"},{"location":"function-guide/mag/fil_3d_b_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mag/fil_a_m/","text":"fil_a.m \u00b6 Basic Information \u00b6 PURPOSE: Generates the Z directed vector potential Az from by a straight filament centered at the origin [0,0,0] carrying Unit current (1A) in the +Z direction Filament limits are z=-c/2 to z=+c/2 Only component is Az, All other components are zero (Ax, Ay == 0) Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: az= fil_a(x,y,z,c) INPUT: x,y,z = coordinates of field point for calculation of Az [m] c = length of filament (scalar or same length as x) [m] Note: x,y,z or c can be a scalar or matrix but all matricies must be same size. Any of the components can be a scalar. OUTPUT: az == Vector Potential, Az, at point x,y,z [Web/m] Caution: On filament (x=y=0) solution is infinite between -a/2<=z<=a/2 solution gives INF. On axis (r=0), above and below the filament the solution is finite and correctly calculated DO NOT USE FOR SELF INDUCT. Dependencies \u00b6 fil_3d_b","title":"fil_a.m"},{"location":"function-guide/mag/fil_a_m/#fil_am","text":"","title":"fil_a.m"},{"location":"function-guide/mag/fil_a_m/#basic-information","text":"PURPOSE: Generates the Z directed vector potential Az from by a straight filament centered at the origin [0,0,0] carrying Unit current (1A) in the +Z direction Filament limits are z=-c/2 to z=+c/2 Only component is Az, All other components are zero (Ax, Ay == 0) Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: az= fil_a(x,y,z,c) INPUT: x,y,z = coordinates of field point for calculation of Az [m] c = length of filament (scalar or same length as x) [m] Note: x,y,z or c can be a scalar or matrix but all matricies must be same size. Any of the components can be a scalar. OUTPUT: az == Vector Potential, Az, at point x,y,z [Web/m] Caution: On filament (x=y=0) solution is infinite between -a/2<=z<=a/2 solution gives INF. On axis (r=0), above and below the filament the solution is finite and correctly calculated DO NOT USE FOR SELF INDUCT.","title":"Basic Information"},{"location":"function-guide/mag/fil_a_m/#dependencies","text":"fil_3d_b","title":"Dependencies"},{"location":"function-guide/mag/filr_3d_b_m/","text":"filr_3d_b.m \u00b6 Basic Information \u00b6 PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] from straight filament Filament has finite radius [d] and length [c] in z direction. Inside r<d the field is proportional to r rather than 1/r for filament. Filament has uniform current density and carries unit current (I=1A) in the +z direction. The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= filr_3d_b(x,y,z,c,d) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [c] == vector of filament lengths one filament per row [d] == vector of filament radius one filament per row Note: If x,y,z & c,d are matrix or vectors they must be same size. Any of the components can be a scalar. OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use fil_3b_b if [X] is outside filament for faster execution Dependencies \u00b6 fil_3d_b","title":"filr_3d_b.m"},{"location":"function-guide/mag/filr_3d_b_m/#filr_3d_bm","text":"","title":"filr_3d_b.m"},{"location":"function-guide/mag/filr_3d_b_m/#basic-information","text":"PURPOSE: Generates B-field in carthesian 3-space [X] == [x,y,z] from straight filament Filament has finite radius [d] and length [c] in z direction. Inside r<d the field is proportional to r rather than 1/r for filament. Filament has uniform current density and carries unit current (I=1A) in the +z direction. The coordinate system is centered about the geometric center of filament. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= filr_3d_b(x,y,z,c,d) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [c] == vector of filament lengths one filament per row [d] == vector of filament radius one filament per row Note: If x,y,z & c,d are matrix or vectors they must be same size. Any of the components can be a scalar. OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point X NOTE: use fil_3b_b if [X] is outside filament for faster execution","title":"Basic Information"},{"location":"function-guide/mag/filr_3d_b_m/#dependencies","text":"fil_3d_b","title":"Dependencies"},{"location":"function-guide/mag/green_near_m/","text":"green_near.m \u00b6 Basic Information \u00b6 SYNTAX: [br,bz,dbrdr,dbrdz,dbzdr,dbzdz] = ... green_near(rcurr,zcurr,rdim,zdim,rb,zb,nsplit) PURPOSE: Calculate green function from current flowing in a loop of rectangular cross-section to a filamentary loop which is nearby. This function is meant to handle carefully the evaluation of green functions for loops which are very close to one another. INPUT: rcurr= radius of centroid of current source (m) zcurr= z-dimension (height) of centroid of current source (m) rb = radius of point at which induced field will be measured (m) zb = z-dimension (height) of point where induced field is measured (m) rdim = r dimension of rectangle in which current flows (m) zdim = z dimension of rectangle in which current flows (m) nsplit = number of pieces to split each coordinate (z,r) of current source into for calculation (option, default=[8,8]) Variables rcurr,zcurr, rb, and zb must be same size (scalar or vector). Variables rdim, zdim must be scalar. OUTPUT: br = calculated green function for br (Tesla/Amp) bz = calculated green function for bz (Tesla/Amp) RESTRICTIONS: METHOD: Break up rectangle into small pieces. Use standard method to calculate values for pieces not containing measurement point. Use some other approximation (what?) for piece containing measurement point. Add up all values and divide by number of pieces (i.e. divvy up current evenly into the small pieces). Dependencies \u00b6 calc_bgreens","title":"green_near.m"},{"location":"function-guide/mag/green_near_m/#green_nearm","text":"","title":"green_near.m"},{"location":"function-guide/mag/green_near_m/#basic-information","text":"SYNTAX: [br,bz,dbrdr,dbrdz,dbzdr,dbzdz] = ... green_near(rcurr,zcurr,rdim,zdim,rb,zb,nsplit) PURPOSE: Calculate green function from current flowing in a loop of rectangular cross-section to a filamentary loop which is nearby. This function is meant to handle carefully the evaluation of green functions for loops which are very close to one another. INPUT: rcurr= radius of centroid of current source (m) zcurr= z-dimension (height) of centroid of current source (m) rb = radius of point at which induced field will be measured (m) zb = z-dimension (height) of point where induced field is measured (m) rdim = r dimension of rectangle in which current flows (m) zdim = z dimension of rectangle in which current flows (m) nsplit = number of pieces to split each coordinate (z,r) of current source into for calculation (option, default=[8,8]) Variables rcurr,zcurr, rb, and zb must be same size (scalar or vector). Variables rdim, zdim must be scalar. OUTPUT: br = calculated green function for br (Tesla/Amp) bz = calculated green function for bz (Tesla/Amp) RESTRICTIONS: METHOD: Break up rectangle into small pieces. Use standard method to calculate values for pieces not containing measurement point. Use some other approximation (what?) for piece containing measurement point. Add up all values and divide by number of pieces (i.e. divvy up current evenly into the small pieces).","title":"Basic Information"},{"location":"function-guide/mag/green_near_m/#dependencies","text":"calc_bgreens","title":"Dependencies"},{"location":"function-guide/mag/induc_rect_m/","text":"induc_rect.m \u00b6 Basic Information \u00b6 SYNTAXX: ind= induc_rect(a,b,r) PURPOSE: Calculate one-turn, self inductance of plane rectangle made from a circular cross section wire of radius r. The rectangle dimensions are a by b INPUT: a,b = dimensions of rectangle, (vector) [m] r = radius or wire cross (vector) [m] OUTPUT: ind = one turn, self inductance of coil [Henries] Multiply by N^2 if coil has N turns RESTRICTIONS: All input vectors must be the same length (or a scalar) Dependencies \u00b6","title":"induc_rect.m"},{"location":"function-guide/mag/induc_rect_m/#induc_rectm","text":"","title":"induc_rect.m"},{"location":"function-guide/mag/induc_rect_m/#basic-information","text":"SYNTAXX: ind= induc_rect(a,b,r) PURPOSE: Calculate one-turn, self inductance of plane rectangle made from a circular cross section wire of radius r. The rectangle dimensions are a by b INPUT: a,b = dimensions of rectangle, (vector) [m] r = radius or wire cross (vector) [m] OUTPUT: ind = one turn, self inductance of coil [Henries] Multiply by N^2 if coil has N turns RESTRICTIONS: All input vectors must be the same length (or a scalar)","title":"Basic Information"},{"location":"function-guide/mag/induc_rect_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mag/mcircle2point_m/","text":"mcircle2point.m \u00b6 Basic Information \u00b6 USAGE: M = mcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma (or other axisymmetric conductor) carrying a uniform current density INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mfcircle2point, mpcircle2point Dependencies \u00b6 mutinds","title":"mcircle2point.m"},{"location":"function-guide/mag/mcircle2point_m/#mcircle2pointm","text":"","title":"mcircle2point.m"},{"location":"function-guide/mag/mcircle2point_m/#basic-information","text":"USAGE: M = mcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma (or other axisymmetric conductor) carrying a uniform current density INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mfcircle2point, mpcircle2point","title":"Basic Information"},{"location":"function-guide/mag/mcircle2point_m/#dependencies","text":"mutinds","title":"Dependencies"},{"location":"function-guide/mag/mfcircle2point_m/","text":"mfcircle2point.m \u00b6 Basic Information \u00b6 USAGE: M = mfcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma where current density is proportional to 1/R (as it is for ffprim) INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mcircle2point, mpcircle2point Dependencies \u00b6 mutinds","title":"mfcircle2point.m"},{"location":"function-guide/mag/mfcircle2point_m/#mfcircle2pointm","text":"","title":"mfcircle2point.m"},{"location":"function-guide/mag/mfcircle2point_m/#basic-information","text":"USAGE: M = mfcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma where current density is proportional to 1/R (as it is for ffprim) INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mcircle2point, mpcircle2point","title":"Basic Information"},{"location":"function-guide/mag/mfcircle2point_m/#dependencies","text":"mutinds","title":"Dependencies"},{"location":"function-guide/mag/mindbf_gen_m/","text":"mindbf_gen.m \u00b6 Basic Information \u00b6 SYNTAX: [mut,br,bz,badindex] = mindbf_gen(ra,rb,za,zb,rdim,zdim,ndist,nsplit) PURPOSE: Calculate mutual inductance, B_r, and B_z from a current source \"a\" which is a coil carrying distributed current to a measurement point \"b\". Note that the fields are calculated at point b due to current at point a. Green functions are Henries and Tesla/Amp. This routine is a generalized version of Dave Humphreys' mindbf.pro which handles carefully all the problems that I could think of having to do with a distributed current source and with points a and b close together. INPUT: ra,za = r and z coordinates of current source(s) (meters) rb,zb = r and z coordinates of \"measurement point(s)\" (meters) rdim = r dimension of rectangular distributed current element source(s) (m) zdim = z dimension of rectangular distributed current element source(s) (m) ndist = number of multiples of rdim in r dimension and zdim in z dimension away from current element that a measurement point point should be in order to use simple filament-to-filament approximation (optional, default=3) nsplit = number of pieces to split each coordinate (z,r) of current source into for \"near\" calculation (optional, default=[8,8]) (Allows input of vectors of ra,za,rb,zb if size of a and b objects equal or one is scalar.) OUTPUT: mut = mutual inductance between 2 loops at locations (ra,za), (rb,zb) (Henries) br = multiplier of current at pt(s) a to produce radial field at pt(s) b (Tesla/Amp) bz = multiplier of current at pt(s) a to produce vertical field at pt(s) b (Tesla/Amp) badindex = if >= 0, index in input vector(s) for which elliptic integral calculator could not give good value. This means values of mut(badindex), br(badindex), and bz(badindex) are NOT VALID. Note: I think I've fixed it so that a bad value is never returned, but I want to leave this in for awhile so I can check if it's ever >=0. RESTRICTIONS: NOTE that this ASSUMES there will be AT MOST ONE instance of points from the a and b vectors which are too close together to calculate responses correctly. If vector input, all vectors ra, rb, za, and zb must be same size. In this case, output corresponds to pairings of elements in sets a and b. For example, mut is calculated between (ra(k),za(k)) and (rb(k),zb(k)), but not between (ra(k),za(k)) and (rb(j),zb(j)) for j different from k. NOTE: A number of \"divide by 0\" messages may be generated on first pass of some calculations. These are fixed later on by recomputation of data for \"too close\" points. Dependencies \u00b6 mutind_near calc_bgreens rectl","title":"mindbf_gen.m"},{"location":"function-guide/mag/mindbf_gen_m/#mindbf_genm","text":"","title":"mindbf_gen.m"},{"location":"function-guide/mag/mindbf_gen_m/#basic-information","text":"SYNTAX: [mut,br,bz,badindex] = mindbf_gen(ra,rb,za,zb,rdim,zdim,ndist,nsplit) PURPOSE: Calculate mutual inductance, B_r, and B_z from a current source \"a\" which is a coil carrying distributed current to a measurement point \"b\". Note that the fields are calculated at point b due to current at point a. Green functions are Henries and Tesla/Amp. This routine is a generalized version of Dave Humphreys' mindbf.pro which handles carefully all the problems that I could think of having to do with a distributed current source and with points a and b close together. INPUT: ra,za = r and z coordinates of current source(s) (meters) rb,zb = r and z coordinates of \"measurement point(s)\" (meters) rdim = r dimension of rectangular distributed current element source(s) (m) zdim = z dimension of rectangular distributed current element source(s) (m) ndist = number of multiples of rdim in r dimension and zdim in z dimension away from current element that a measurement point point should be in order to use simple filament-to-filament approximation (optional, default=3) nsplit = number of pieces to split each coordinate (z,r) of current source into for \"near\" calculation (optional, default=[8,8]) (Allows input of vectors of ra,za,rb,zb if size of a and b objects equal or one is scalar.) OUTPUT: mut = mutual inductance between 2 loops at locations (ra,za), (rb,zb) (Henries) br = multiplier of current at pt(s) a to produce radial field at pt(s) b (Tesla/Amp) bz = multiplier of current at pt(s) a to produce vertical field at pt(s) b (Tesla/Amp) badindex = if >= 0, index in input vector(s) for which elliptic integral calculator could not give good value. This means values of mut(badindex), br(badindex), and bz(badindex) are NOT VALID. Note: I think I've fixed it so that a bad value is never returned, but I want to leave this in for awhile so I can check if it's ever >=0. RESTRICTIONS: NOTE that this ASSUMES there will be AT MOST ONE instance of points from the a and b vectors which are too close together to calculate responses correctly. If vector input, all vectors ra, rb, za, and zb must be same size. In this case, output corresponds to pairings of elements in sets a and b. For example, mut is calculated between (ra(k),za(k)) and (rb(k),zb(k)), but not between (ra(k),za(k)) and (rb(j),zb(j)) for j different from k. NOTE: A number of \"divide by 0\" messages may be generated on first pass of some calculations. These are fixed later on by recomputation of data for \"too close\" points.","title":"Basic Information"},{"location":"function-guide/mag/mindbf_gen_m/#dependencies","text":"mutind_near calc_bgreens rectl","title":"Dependencies"},{"location":"function-guide/mag/mindbf_m/","text":"mindbf.m \u00b6 Basic Information \u00b6 SYNTAX: [mut,br,bz]=mindbf(ra,za,rb,zb) PURPOSE: Calculate mutual inductances and B-field Green functions in Matlab. Fields are calculated at point b due to current at point a. INPUT: ra,za = (meters) rb,zb = (meters) Allows input of vectors of ra,za,rb,zb. OUTPUT: mut = mutual inductance between 2 loops at locations (ra,za), (rb,zb) (Henries) br = multiplier of current at pt(s) a to produce radial field at pt(s) b (Tesla/Amp) bz = multiplier of current at pt(s) a to produce vertical field at pt(s) b (Tesla/Amp) RESTRICTIONS: If vector input, output corresponds to pairings of elements in sets a and b. For example, mut is calculated between (ra(k),za(k)) and (rb(k),zb(k)), but not between (ra(k),za(k)) and (rb(j),zb(j)) for j different from k. Dependencies \u00b6","title":"mindbf.m"},{"location":"function-guide/mag/mindbf_m/#mindbfm","text":"","title":"mindbf.m"},{"location":"function-guide/mag/mindbf_m/#basic-information","text":"SYNTAX: [mut,br,bz]=mindbf(ra,za,rb,zb) PURPOSE: Calculate mutual inductances and B-field Green functions in Matlab. Fields are calculated at point b due to current at point a. INPUT: ra,za = (meters) rb,zb = (meters) Allows input of vectors of ra,za,rb,zb. OUTPUT: mut = mutual inductance between 2 loops at locations (ra,za), (rb,zb) (Henries) br = multiplier of current at pt(s) a to produce radial field at pt(s) b (Tesla/Amp) bz = multiplier of current at pt(s) a to produce vertical field at pt(s) b (Tesla/Amp) RESTRICTIONS: If vector input, output corresponds to pairings of elements in sets a and b. For example, mut is calculated between (ra(k),za(k)) and (rb(k),zb(k)), but not between (ra(k),za(k)) and (rb(j),zb(j)) for j different from k.","title":"Basic Information"},{"location":"function-guide/mag/mindbf_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mag/mpcircle2point_m/","text":"mpcircle2point.m \u00b6 Basic Information \u00b6 USAGE: M = mpcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma where current density is proportional to R (as it is for pprime) INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mcircle2point, mfcircle2point Dependencies \u00b6 mutinds","title":"mpcircle2point.m"},{"location":"function-guide/mag/mpcircle2point_m/#mpcircle2pointm","text":"","title":"mpcircle2point.m"},{"location":"function-guide/mag/mpcircle2point_m/#basic-information","text":"USAGE: M = mpcircle2point(r,z,rp,zp,a); PURPOSE: Return poloidal flux from circular plasma where current density is proportional to R (as it is for pprime) INPUTS: r,z major radius and height of field point rp,zp major radius and height of plasma center a, minor radius of plasma OUTPUTS: M, flux for 1-A of current, a.k.a. as mutual inductance METHOD: Flux is found in look-up table. Relative error always < 1e-6 See also mcircle2point, mfcircle2point","title":"Basic Information"},{"location":"function-guide/mag/mpcircle2point_m/#dependencies","text":"mutinds","title":"Dependencies"},{"location":"function-guide/mag/mpolygon2point_m/","text":"mpolygon2point.m \u00b6 Basic Information \u00b6 SYNTAX: [M, Mr, Mz] = mpolygon2point(rpolygon, zpolygon, r, z, D) PURPOSE: Calculate mutual inductances between coaxial loops First loop has cross section described by rpolygon, zpolygon which contain coordinates for the corners Cross section of second loop is a point (thin wire) at r, z INPUTS: rpolygon, zpolygon = coordinates of first current loop [meters] r, z = major radius, height of second loop [meters] D, choice of derivatives in Mr, Mz, see below OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives w.r.t. r, z if D = 1, derivatives are w.r.t. rigid shifts of rp, zp if D = 2, derivatives are w.r.t. r, z RESTRICTIONS: The mutual M is for uniform current density across polygon Dependencies \u00b6 mutinds","title":"mpolygon2point.m"},{"location":"function-guide/mag/mpolygon2point_m/#mpolygon2pointm","text":"","title":"mpolygon2point.m"},{"location":"function-guide/mag/mpolygon2point_m/#basic-information","text":"SYNTAX: [M, Mr, Mz] = mpolygon2point(rpolygon, zpolygon, r, z, D) PURPOSE: Calculate mutual inductances between coaxial loops First loop has cross section described by rpolygon, zpolygon which contain coordinates for the corners Cross section of second loop is a point (thin wire) at r, z INPUTS: rpolygon, zpolygon = coordinates of first current loop [meters] r, z = major radius, height of second loop [meters] D, choice of derivatives in Mr, Mz, see below OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives w.r.t. r, z if D = 1, derivatives are w.r.t. rigid shifts of rp, zp if D = 2, derivatives are w.r.t. r, z RESTRICTIONS: The mutual M is for uniform current density across polygon","title":"Basic Information"},{"location":"function-guide/mag/mpolygon2point_m/#dependencies","text":"mutinds","title":"Dependencies"},{"location":"function-guide/mag/mpolygon2polygon_m/","text":"mpolygon2polygon.m \u00b6 Basic Information \u00b6 SYNTAX: [M, Mr, Mz] = mpolygon2polygon(ra, za, rb, zb) PURPOSE: Calculate mutual inductances between coaxial loops A & B The cross sections of the loops are polygons INPUTS: ra, za = coordinates for the corners of polygon A [m] rb, zb = coordinates for the corners of polygon B [m] OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives of M w.r.t. rigid shifts of ra and za RESTRICTIONS: Assumes uniform current distribution across both polygons Dependencies \u00b6 mpolygon2point","title":"mpolygon2polygon.m"},{"location":"function-guide/mag/mpolygon2polygon_m/#mpolygon2polygonm","text":"","title":"mpolygon2polygon.m"},{"location":"function-guide/mag/mpolygon2polygon_m/#basic-information","text":"SYNTAX: [M, Mr, Mz] = mpolygon2polygon(ra, za, rb, zb) PURPOSE: Calculate mutual inductances between coaxial loops A & B The cross sections of the loops are polygons INPUTS: ra, za = coordinates for the corners of polygon A [m] rb, zb = coordinates for the corners of polygon B [m] OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives of M w.r.t. rigid shifts of ra and za RESTRICTIONS: Assumes uniform current distribution across both polygons","title":"Basic Information"},{"location":"function-guide/mag/mpolygon2polygon_m/#dependencies","text":"mpolygon2point","title":"Dependencies"},{"location":"function-guide/mag/mrectangle2point_m/","text":"mrectangle2point.m \u00b6 Basic Information \u00b6 SYNTAX: [M, Mr, Mz] = mrectangle2point(ri, ro, zl, zu, r, z) PURPOSE: Calculate mutual inductances between coaxial loops First loop has rectangular cross section with edges ri,ro,zl,zu Second loop is a thin wire at r, z To return only Mr or Mz, indicate which with 'r' or 'z' like this Mz = mrectangle2point(ri,ro,zl,zu,r,z,'z') Typical relative error is 1e-12, for more info type: mrectangle2point info Slow very accurate calculation can be made with: [M, Mr, Mz] = mrectangle2point('integral2',ri,ro,zl,zu,r,z) INPUTS: ri, ro = inner and outer radius of rectangles [meters] zl, zu = lower and upper height of rectangles [meters] r, z = major radius, height of thin wire [meters] Size mixing allowed, outputs are sized like ri+ro+zl+zu+r+z OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives of M with respect to r, z","title":"mrectangle2point.m"},{"location":"function-guide/mag/mrectangle2point_m/#mrectangle2pointm","text":"","title":"mrectangle2point.m"},{"location":"function-guide/mag/mrectangle2point_m/#basic-information","text":"SYNTAX: [M, Mr, Mz] = mrectangle2point(ri, ro, zl, zu, r, z) PURPOSE: Calculate mutual inductances between coaxial loops First loop has rectangular cross section with edges ri,ro,zl,zu Second loop is a thin wire at r, z To return only Mr or Mz, indicate which with 'r' or 'z' like this Mz = mrectangle2point(ri,ro,zl,zu,r,z,'z') Typical relative error is 1e-12, for more info type: mrectangle2point info Slow very accurate calculation can be made with: [M, Mr, Mz] = mrectangle2point('integral2',ri,ro,zl,zu,r,z) INPUTS: ri, ro = inner and outer radius of rectangles [meters] zl, zu = lower and upper height of rectangles [meters] r, z = major radius, height of thin wire [meters] Size mixing allowed, outputs are sized like ri+ro+zl+zu+r+z OUTPUTS: M = mutual inductance between loops [H] Mr, Mz, derivatives of M with respect to r, z","title":"Basic Information"},{"location":"function-guide/mag/mut_coil_set_m/","text":"mut_coil_set.m \u00b6 Basic Information \u00b6 SYNTAXX: mut= mut_coil_set(rc,zc,dr,dz) PURPOSE: Generate the mutual inductance between all coils in a set Coils are coaxial and axisymmetric, have rectangular cross-section and carry uniform current density INPUT: rc = Radial center of coil [m] zc = Axial center of coil [m] dr = Radial width of coil [m] dz = Axial height of coil [m] OUTPUT: mut = [n,n] matrix of mutual inductance of coils [Henries] RESTRICTIONS: See rectl for Self Inductance Restriction: err<1 for delz/(2*delr) < 1 Coils with aspect ratio approaching 1 are problematic Dependencies \u00b6 fine rectl","title":"mut_coil_set.m"},{"location":"function-guide/mag/mut_coil_set_m/#mut_coil_setm","text":"","title":"mut_coil_set.m"},{"location":"function-guide/mag/mut_coil_set_m/#basic-information","text":"SYNTAXX: mut= mut_coil_set(rc,zc,dr,dz) PURPOSE: Generate the mutual inductance between all coils in a set Coils are coaxial and axisymmetric, have rectangular cross-section and carry uniform current density INPUT: rc = Radial center of coil [m] zc = Axial center of coil [m] dr = Radial width of coil [m] dz = Axial height of coil [m] OUTPUT: mut = [n,n] matrix of mutual inductance of coils [Henries] RESTRICTIONS: See rectl for Self Inductance Restriction: err<1 for delz/(2*delr) < 1 Coils with aspect ratio approaching 1 are problematic","title":"Basic Information"},{"location":"function-guide/mag/mut_coil_set_m/#dependencies","text":"fine rectl","title":"Dependencies"},{"location":"function-guide/mag/mut_fil_fil_m/","text":"mut_fil_fil.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the mutual inductance between two sets of filaments A & B. Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. Sending filament set is \"A\", receiving filament set is \"B\" Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: mut_fil_fil(xa,xb,fa,fb) INPUT: (a= sending filament, b= receiving filament) xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] xb = same for receiving filaments [xb,yb,zb,dxb,dyb,dzb] fa,fb= Optional: fraction of current in filament for parallel filaments OUTPUT: m == mutual inductance between filament sets A to B [H] CAUTION: Will not work for filaments on top of each other (ie self inductance) Dependencies \u00b6 fil_regrid fil_a z_dircos fil_to_filc pts_to_fil","title":"mut_fil_fil.m"},{"location":"function-guide/mag/mut_fil_fil_m/#mut_fil_film","text":"","title":"mut_fil_fil.m"},{"location":"function-guide/mag/mut_fil_fil_m/#basic-information","text":"PURPOSE: Calculate the mutual inductance between two sets of filaments A & B. Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. Sending filament set is \"A\", receiving filament set is \"B\" Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: mut_fil_fil(xa,xb,fa,fb) INPUT: (a= sending filament, b= receiving filament) xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] xb = same for receiving filaments [xb,yb,zb,dxb,dyb,dzb] fa,fb= Optional: fraction of current in filament for parallel filaments OUTPUT: m == mutual inductance between filament sets A to B [H] CAUTION: Will not work for filaments on top of each other (ie self inductance)","title":"Basic Information"},{"location":"function-guide/mag/mut_fil_fil_m/#dependencies","text":"fil_regrid fil_a z_dircos fil_to_filc pts_to_fil","title":"Dependencies"},{"location":"function-guide/mag/mut_ladder_m/","text":"mut_ladder.m \u00b6 Basic Information \u00b6 SYNTAXX: mut= mut_ladder(a,b,r,n) PURPOSE: Generate the mutual inductance between cells in a ladder shaped component made of n cells in the a direction. Each cell has dimensions in the x by y direction of a by b Cells are replicated in the x direction resulting in a ladder structure of length n*a in the x direction and width b in y. Each cell is adjacent to the next cell in the x direction and the rung is common to the left and right cells INPUT: a = side dimension of one cell in the length ladder direction, [m] b = sied dimension of one cell in the width direction, [m] r = radius or wire cross (vector) [m] n = number of rectangular cells OUTPUT: mut = [n,n] matrix of mutual inductance of cells in ladder [Henries] (Order is 1st cell on left to last cell on right) RESTRICTIONS: At present all cells are same size; but could be modified to do variable cell size in x direction by changing vector x internally Dependencies \u00b6 induc_rect","title":"mut_ladder.m"},{"location":"function-guide/mag/mut_ladder_m/#mut_ladderm","text":"","title":"mut_ladder.m"},{"location":"function-guide/mag/mut_ladder_m/#basic-information","text":"SYNTAXX: mut= mut_ladder(a,b,r,n) PURPOSE: Generate the mutual inductance between cells in a ladder shaped component made of n cells in the a direction. Each cell has dimensions in the x by y direction of a by b Cells are replicated in the x direction resulting in a ladder structure of length n*a in the x direction and width b in y. Each cell is adjacent to the next cell in the x direction and the rung is common to the left and right cells INPUT: a = side dimension of one cell in the length ladder direction, [m] b = sied dimension of one cell in the width direction, [m] r = radius or wire cross (vector) [m] n = number of rectangular cells OUTPUT: mut = [n,n] matrix of mutual inductance of cells in ladder [Henries] (Order is 1st cell on left to last cell on right) RESTRICTIONS: At present all cells are same size; but could be modified to do variable cell size in x direction by changing vector x internally","title":"Basic Information"},{"location":"function-guide/mag/mut_ladder_m/#dependencies","text":"induc_rect","title":"Dependencies"},{"location":"function-guide/mag/mutind_conway_m/","text":"mutind_conway.m \u00b6 Basic Information \u00b6 SYNTAX: mutuals=mutind_fine(acoil_data,bcoil_data, ... nrecta,nrectb,verbose) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation. Dependencies \u00b6 bld_subelements","title":"mutind_conway.m"},{"location":"function-guide/mag/mutind_conway_m/#mutind_conwaym","text":"","title":"mutind_conway.m"},{"location":"function-guide/mag/mutind_conway_m/#basic-information","text":"SYNTAX: mutuals=mutind_fine(acoil_data,bcoil_data, ... nrecta,nrectb,verbose) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/mutind_conway_m/#dependencies","text":"bld_subelements","title":"Dependencies"},{"location":"function-guide/mag/mutind_distrib_m/","text":"mutind_distrib.m \u00b6 Basic Information \u00b6 SYNTAX: mutuals=mutind_distrib(acoil_data,bcoil_data, ... nrecta,nrectb,make_plot) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) make_plot = set to 1 to plot conductors' cross-sections OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation. Dependencies \u00b6 mutind_near mutind bld_subelements","title":"mutind_distrib.m"},{"location":"function-guide/mag/mutind_distrib_m/#mutind_distribm","text":"","title":"mutind_distrib.m"},{"location":"function-guide/mag/mutind_distrib_m/#basic-information","text":"SYNTAX: mutuals=mutind_distrib(acoil_data,bcoil_data, ... nrecta,nrectb,make_plot) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) make_plot = set to 1 to plot conductors' cross-sections OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/mutind_distrib_m/#dependencies","text":"mutind_near mutind bld_subelements","title":"Dependencies"},{"location":"function-guide/mag/mutind_fine_m/","text":"mutind_fine.m \u00b6 Basic Information \u00b6 SYNTAX: mutuals=mutind_fine(acoil_data,bcoil_data, ... nrecta,nrectb,verbose) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation. Dependencies \u00b6 bld_subelements","title":"mutind_fine.m"},{"location":"function-guide/mag/mutind_fine_m/#mutind_finem","text":"","title":"mutind_fine.m"},{"location":"function-guide/mag/mutind_fine_m/#basic-information","text":"SYNTAX: mutuals=mutind_fine(acoil_data,bcoil_data, ... nrecta,nrectb,verbose) PURPOSE: Compute mutual inductance between 2 sets of axisymmetric conductors, each of whose cross-section is a parallelogram. Filament conductors (identified by setting dR=dZ=0 in bcoil_data) are allowed for conductor set B. INPUT: acoil_data = data describing geometry of coil set A bcoil_data = data describing geometry of coil set B Format of this data has each column = [Z;R;dZ;dR;AC;AC2], where: Z = z centroids of conductors (m) R = r centroids of conductors (m) dZ = height of conductors (m) dR = width of conductors (m) AC = angle between coil and horizontal (degrees) AC2 = angle between coil and horizontal (degrees) At most one of AC, AC2 is nonzero and indicates type of parallelogram: xxxx xxxx x xxxx x xxxx x --- xxxxxxxxxxxxx xxxx x | xx xx --- xxxx x | xx xx | x X xxxx dZ xx xx | x (R,Z) xxxx | xx X xx dZ x xxxx | xx (R,Z) xx | x xxxx | xx xx | x xxxx | xx xx _|_ xxxx ^ --- xxxxxxxxxxxxx ^ AC ) AC2 ) |----------dR----------| |---dR------| nrecta = rectangle partitioning for conductor set A (see header documentation for bld_subelements.m) nrectb = rectangle partitioning for conductor set B (see header documentation for bld_subelements.m) verbose = print/display verbose info. 0 = no print/display. Numbers>0 give increasingly more information/displays. OUTPUT: mutuals = mutual inductance matrix, with rows corresponding to coil set A, columns to coil set B (micro-Henries) RESTRICTIONS: METHOD: Each conductor is partitioned into a bunch of tiny rectangles. All mutuals are computed for these rectangles, then combined at the end. Mutuals calculation is done in 2 steps: (1) use filament to filament calculation for all subelements (2) replace those subelement calculations which would have inaccurate results, based on geometric information, with more accurate calculation.","title":"Basic Information"},{"location":"function-guide/mag/mutind_fine_m/#dependencies","text":"bld_subelements","title":"Dependencies"},{"location":"function-guide/mag/mutind_m/","text":"mutind.m \u00b6 Basic Information \u00b6 SYNTAX: mut=mutind(ra,za,rb,zb) PURPOSE: Calculate mutual inductances between loops centered at r=0. INPUT: ra,za = vectors of (r,z) coordinates (meters) of first current loops rb,zb = vectors of (r,z) coordinates (meters) of 2nd current loops Note arguments have different ordering convention than IDL function. OUTPUT: mut = vector of mutual inductances between current loops (in micro-Henries), mut(k) = mutual from loop at (ra(k),za(k)) to loop at (rb(k),zb(k)). RESTRICTIONS: Coordinates (r,z) must represent concentric current loops. All input vectors must be the same length. Dependencies \u00b6","title":"mutind.m"},{"location":"function-guide/mag/mutind_m/#mutindm","text":"","title":"mutind.m"},{"location":"function-guide/mag/mutind_m/#basic-information","text":"SYNTAX: mut=mutind(ra,za,rb,zb) PURPOSE: Calculate mutual inductances between loops centered at r=0. INPUT: ra,za = vectors of (r,z) coordinates (meters) of first current loops rb,zb = vectors of (r,z) coordinates (meters) of 2nd current loops Note arguments have different ordering convention than IDL function. OUTPUT: mut = vector of mutual inductances between current loops (in micro-Henries), mut(k) = mutual from loop at (ra(k),za(k)) to loop at (rb(k),zb(k)). RESTRICTIONS: Coordinates (r,z) must represent concentric current loops. All input vectors must be the same length.","title":"Basic Information"},{"location":"function-guide/mag/mutind_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mag/mutind_near_m/","text":"mutind_near.m \u00b6 Basic Information \u00b6 SYNTAX: mutual = mutind_near(rcurr,zcurr,rdim,zdim,rpsi,zpsi) PURPOSE: Calculate mutual inductance from current flowing in a loop of rectangular cross-section to a filamentary loop which is nearby. This function is meant to handle carefully the evaluation of mutual inductances for loops which are very close to one another. INPUT: rcurr= radius of centroid of current source (m) zcurr= z-dimension (height) of centroid of current source (m) rpsi = radius of point at which induced flux will be measured (m) zpsi = z-dimension (height) of point where induced flux is measured (m) rdim = r dimension of rectangle in which current flows (m) zdim = z dimension of rectangle in which current flows (m) nsplit = number of pieces to split each coordinate (z,r) of current source into for calculation (optional, default=[8,8]) Variables rcurr,zcurr, rpsi, and zpsi must be same size (scalar or vector). Variables rdim, zdim must be scalar or same size as rcurr. OUTPUT: mut = calculated mutual inductance (Henries) from the current source at each (rcurr(i),zcurr(i)) to measurement at (rpsi(i),zpsi(i)) Dependencies \u00b6 mutind rectl","title":"mutind_near.m"},{"location":"function-guide/mag/mutind_near_m/#mutind_nearm","text":"","title":"mutind_near.m"},{"location":"function-guide/mag/mutind_near_m/#basic-information","text":"SYNTAX: mutual = mutind_near(rcurr,zcurr,rdim,zdim,rpsi,zpsi) PURPOSE: Calculate mutual inductance from current flowing in a loop of rectangular cross-section to a filamentary loop which is nearby. This function is meant to handle carefully the evaluation of mutual inductances for loops which are very close to one another. INPUT: rcurr= radius of centroid of current source (m) zcurr= z-dimension (height) of centroid of current source (m) rpsi = radius of point at which induced flux will be measured (m) zpsi = z-dimension (height) of point where induced flux is measured (m) rdim = r dimension of rectangle in which current flows (m) zdim = z dimension of rectangle in which current flows (m) nsplit = number of pieces to split each coordinate (z,r) of current source into for calculation (optional, default=[8,8]) Variables rcurr,zcurr, rpsi, and zpsi must be same size (scalar or vector). Variables rdim, zdim must be scalar or same size as rcurr. OUTPUT: mut = calculated mutual inductance (Henries) from the current source at each (rcurr(i),zcurr(i)) to measurement at (rpsi(i),zpsi(i))","title":"Basic Information"},{"location":"function-guide/mag/mutind_near_m/#dependencies","text":"mutind rectl","title":"Dependencies"},{"location":"function-guide/mag/mutinds_m/","text":"mutinds.m \u00b6 Basic Information \u00b6 SYNTAX: M = mutinds(ra,za,rb,zb) [M,Mr,Mz,Mrr,Mrz,Mzz,Mrrr,Mrrz,Mrzz,Mzzz] = mutinds(ra,za,rb,zb) Mzz = mutinds(ra,za,rb,zb,'zz'), returns a specific derivative S = mutinds(ra,za,rb,zb,3), returns struct matrix of derivatives S(i,j).f is the (i-1)th z, (j-1)th r derivative of M For small distances d = sqrt((rb-ra)^2+(zb-za)^2) < 1e-6*ra the relative error for mutinds(1,0,1+d,0) is 3e-18/d, but M = mutinds((ra+rb)/2,d,[],[]) can be used to get full accuracy PURPOSE: Calculate mutual inductance between coaxial loops INPUTS: ra,za = coordinates of first current loop [meters] rb,zb = coordinates of second current loop [meters] sizes can be mixed, outputs have same size as ra+za+rb+zb flag to request a specific derivative or matrix of derivatives allowed strings: 'r','z','rr','rz','zz','rrr', etc up to 'zzzzzz' allowed integers: 0,1,2,3 OUTPUTS: M = mutual inductance between loops a and b [H] Mr, Mz, Mrr, Mrz, ..., Mzzzzzz = derivatives w.r.t. rb and zb Dependencies \u00b6","title":"mutinds.m"},{"location":"function-guide/mag/mutinds_m/#mutindsm","text":"","title":"mutinds.m"},{"location":"function-guide/mag/mutinds_m/#basic-information","text":"SYNTAX: M = mutinds(ra,za,rb,zb) [M,Mr,Mz,Mrr,Mrz,Mzz,Mrrr,Mrrz,Mrzz,Mzzz] = mutinds(ra,za,rb,zb) Mzz = mutinds(ra,za,rb,zb,'zz'), returns a specific derivative S = mutinds(ra,za,rb,zb,3), returns struct matrix of derivatives S(i,j).f is the (i-1)th z, (j-1)th r derivative of M For small distances d = sqrt((rb-ra)^2+(zb-za)^2) < 1e-6*ra the relative error for mutinds(1,0,1+d,0) is 3e-18/d, but M = mutinds((ra+rb)/2,d,[],[]) can be used to get full accuracy PURPOSE: Calculate mutual inductance between coaxial loops INPUTS: ra,za = coordinates of first current loop [meters] rb,zb = coordinates of second current loop [meters] sizes can be mixed, outputs have same size as ra+za+rb+zb flag to request a specific derivative or matrix of derivatives allowed strings: 'r','z','rr','rz','zz','rrr', etc up to 'zzzzzz' allowed integers: 0,1,2,3 OUTPUTS: M = mutual inductance between loops a and b [H] Mr, Mz, Mrr, Mrz, ..., Mzzzzzz = derivatives w.r.t. rb and zb","title":"Basic Information"},{"location":"function-guide/mag/mutinds_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mag/ohmic_dist_m/","text":"ohmic_dist.m \u00b6 Basic Information \u00b6 USAGE: [i_ohmic,fl,br,bz,rbs,zbs,err] = ... ohmic_dist(rbs,zbs,rcc,zcc,drcc,dzcc,mk_bs_uniform,minimize_i) Also can be called as script: ohmic_dist PURPOSE: Calculates the Best Ohmic current distribution for a set of F coils to a plasma boundary to generate 1Vs in boundary INPUTS: [default] rbs, zbs= R,Z Plasma boundary Points (m) rcc,zcc,drcc,dzcc= Rectangular Coil center and widths (m) (e.g. use the 2nd, 1st, 4th, and 3rd rows of standard fcdata object) mk_bs_uniform= Makes rbs, zbs a uniform poloidal grid scale [1] if >1 then makes mk_bs_uniform number of points if =1 then makes length(rbs) number of uniform points minimize_i = =0.1; Includes currents in opts. to reduce +-I [0] The value of minimize_i weights how much I smooting Value of 0.1 reasonably balances I. err~ 0.25 OUTPUTS: i_ohmic = Optimum Ohmic Current Dist. for 1Vs on Boundary (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rbs zbs = R,Z boundary points used in analysis (m) NOTE: rbs,zbs changed to uniform version of input err = Average Error in booundary flux value (Delta_Vs/Vs) RESTRICTIONS: uses square coil for all d3d type trapazoidal coils (small effect) Produces Amp-Turns. Use c_ohmic./fcnturn to convert to coil terminal Amp METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary Dependencies \u00b6 read_gfile ot_script in_script","title":"ohmic_dist.m"},{"location":"function-guide/mag/ohmic_dist_m/#ohmic_distm","text":"","title":"ohmic_dist.m"},{"location":"function-guide/mag/ohmic_dist_m/#basic-information","text":"USAGE: [i_ohmic,fl,br,bz,rbs,zbs,err] = ... ohmic_dist(rbs,zbs,rcc,zcc,drcc,dzcc,mk_bs_uniform,minimize_i) Also can be called as script: ohmic_dist PURPOSE: Calculates the Best Ohmic current distribution for a set of F coils to a plasma boundary to generate 1Vs in boundary INPUTS: [default] rbs, zbs= R,Z Plasma boundary Points (m) rcc,zcc,drcc,dzcc= Rectangular Coil center and widths (m) (e.g. use the 2nd, 1st, 4th, and 3rd rows of standard fcdata object) mk_bs_uniform= Makes rbs, zbs a uniform poloidal grid scale [1] if >1 then makes mk_bs_uniform number of points if =1 then makes length(rbs) number of uniform points minimize_i = =0.1; Includes currents in opts. to reduce +-I [0] The value of minimize_i weights how much I smooting Value of 0.1 reasonably balances I. err~ 0.25 OUTPUTS: i_ohmic = Optimum Ohmic Current Dist. for 1Vs on Boundary (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rbs zbs = R,Z boundary points used in analysis (m) NOTE: rbs,zbs changed to uniform version of input err = Average Error in booundary flux value (Delta_Vs/Vs) RESTRICTIONS: uses square coil for all d3d type trapazoidal coils (small effect) Produces Amp-Turns. Use c_ohmic./fcnturn to convert to coil terminal Amp METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary","title":"Basic Information"},{"location":"function-guide/mag/ohmic_dist_m/#dependencies","text":"read_gfile ot_script in_script","title":"Dependencies"},{"location":"function-guide/mag/rect_3d_b_m/","text":"rect_3d_b.m \u00b6 Basic Information \u00b6 PURPOSE: This function generates B-field in carthesian 3-space [X] == [x,y,z] produced by a uniform current density rectangle of dimensions [A] == [a,b,c] contining uniform current in the +Z direction and carrying unit current I=1A. The coordinate system is centered about the geometric center of rectangle. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= rect_3d_b.m(x,y,z,a,b,c) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [a,b,c] == [A] vectors of rectangle dimensions, one rectangle per row Note: X and a should be the same size. If A is a single row its rows are expanded to the rows of x If X is a single row its rows are expanded to the rows of a OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point corresponding to x & a NOTE: Vectorized so can handle vectors of same length and scalers NOTE: Produces double precision solution every where except eps from edges CAUTION: Needs additional Validations at edge discontinuities (Part II) Dependencies \u00b6","title":"rect_3d_b.m"},{"location":"function-guide/mag/rect_3d_b_m/#rect_3d_bm","text":"","title":"rect_3d_b.m"},{"location":"function-guide/mag/rect_3d_b_m/#basic-information","text":"PURPOSE: This function generates B-field in carthesian 3-space [X] == [x,y,z] produced by a uniform current density rectangle of dimensions [A] == [a,b,c] contining uniform current in the +Z direction and carrying unit current I=1A. The coordinate system is centered about the geometric center of rectangle. Note: All Units are MKS (meters, Amps, Tesla) SYNTAX: [bx,by,bz]= rect_3d_b.m(x,y,z,a,b,c) INPUT: [x,y,z] == [X] vectors of coordinates, one point per row [a,b,c] == [A] vectors of rectangle dimensions, one rectangle per row Note: X and a should be the same size. If A is a single row its rows are expanded to the rows of x If X is a single row its rows are expanded to the rows of a OUTPUT: [bx,by,bz] == [B] vectors of B-fields at point corresponding to x & a NOTE: Vectorized so can handle vectors of same length and scalers NOTE: Produces double precision solution every where except eps from edges CAUTION: Needs additional Validations at edge discontinuities (Part II)","title":"Basic Information"},{"location":"function-guide/mag/rect_3d_b_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mag/rectl_m/","text":"rectl.m \u00b6 Basic Information \u00b6 SYNTAX: selfind = rectl(rc,delz,delr) PURPOSE: Calculate self inductance of rectangular coil. INPUT: rc = mean radius of the coil (meters) delz = axial height of the coil (meters) delr = radial width of the coil (meters) OUTPUT: selfind = self inductance (in uH) RESTRICTIONS: Accuracy of calculated self inductance will be better than 1 for delz/(2*delr) < 1.0. This is not guaranteed for delz/(2*delr) > 1.0. Dependencies \u00b6","title":"rectl.m"},{"location":"function-guide/mag/rectl_m/#rectlm","text":"","title":"rectl.m"},{"location":"function-guide/mag/rectl_m/#basic-information","text":"SYNTAX: selfind = rectl(rc,delz,delr) PURPOSE: Calculate self inductance of rectangular coil. INPUT: rc = mean radius of the coil (meters) delz = axial height of the coil (meters) delr = radial width of the coil (meters) OUTPUT: selfind = self inductance (in uH) RESTRICTIONS: Accuracy of calculated self inductance will be better than 1 for delz/(2*delr) < 1.0. This is not guaranteed for delz/(2*delr) > 1.0.","title":"Basic Information"},{"location":"function-guide/mag/rectl_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mag/self_fil_m/","text":"self_fil.m \u00b6 Basic Information \u00b6 PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero Dependencies \u00b6 fil_regrid mut_fil_fil fil_a z_dircos fil_to_filc pts_to_fil","title":"self_fil.m"},{"location":"function-guide/mag/self_fil_m/#self_film","text":"","title":"self_fil.m"},{"location":"function-guide/mag/self_fil_m/#basic-information","text":"PURPOSE: Calculate the self inductance of a set of filaments A Filament is defined by center and deltas x= [xc,yc,zc,dx,dy,dz]. The filament radius, aa is needed to compute self inductance This is complementary to mut_fil_fil which computes mutual between two filament sets A & B. Note: All Units are MKS (meters, Amps, Tesla, Henries ...) SYNTAX: self_fil(xa,fa) INPUT: (a= sending filament & receiving filament) [default] xa = center coordinates. & delta lengths [xa,ya,za,dxa,dya,dza] aa = Radius of filament for self inductance (vector or scalor) fa = Optional: fraction of current in filament for parallel currents [1] full= 0=does only half matrix (assume symmetry) =1 does full matrix [0] OUTPUT: l == self inductance of filament A sets [H] CAUTION: Filament radius aa cannot be zero","title":"Basic Information"},{"location":"function-guide/mag/self_fil_m/#dependencies","text":"fil_regrid mut_fil_fil fil_a z_dircos fil_to_filc pts_to_fil","title":"Dependencies"},{"location":"function-guide/mag/selfind_m/","text":"selfind.m \u00b6 Basic Information \u00b6 SYNTAX: inductance=selfind(rc,radc,kappa) PURPOSE: Self-inductance expression for an axisymmetric coil of major radius RC and minor radius RADC (in uH). INPUT: rc = major radius [m] radc = minor radius [m] kappa = elongation (optional, default=1) OUTPUT: inductance = self inductance of coil Dependencies \u00b6","title":"selfind.m"},{"location":"function-guide/mag/selfind_m/#selfindm","text":"","title":"selfind.m"},{"location":"function-guide/mag/selfind_m/#basic-information","text":"SYNTAX: inductance=selfind(rc,radc,kappa) PURPOSE: Self-inductance expression for an axisymmetric coil of major radius RC and minor radius RADC (in uH). INPUT: rc = major radius [m] radc = minor radius [m] kappa = elongation (optional, default=1) OUTPUT: inductance = self inductance of coil","title":"Basic Information"},{"location":"function-guide/mag/selfind_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/math/cubicroots_m/","text":"cubicroots.m \u00b6 Basic Information \u00b6 USAGE: [x1, x2, x3] = cubicroots(a, b, c, d) PURPOSE: Find the roots to the cubic equation: a*x^3 + b*x^2 + c*x + d = 0 Can also be used with a = 0 and/or b = 0 INPUTS: a, b, c, d - may be 1 arbitrary size in a mix with scalars OUTPUTS: The roots such that: (x-x1)*(x-x2)*(x-x3) = x^3 + b/a*x^2 + c/a*x + d/a If a == 0 then x3 is nan since polynomial is 2:nd degree If also b == 0 then x2 will also be nan If also c == 0 then x1 will also be nan NOTES: Faster than the function roots, in particular when several equations solved at once. Also more accurate than roots Solutions are in the same order as from function roots If a ~= 0, x1 is always real cubicroots(a,b,c,d,n) iterates n times to reduce tiny errors Dependencies \u00b6","title":"cubicroots.m"},{"location":"function-guide/math/cubicroots_m/#cubicrootsm","text":"","title":"cubicroots.m"},{"location":"function-guide/math/cubicroots_m/#basic-information","text":"USAGE: [x1, x2, x3] = cubicroots(a, b, c, d) PURPOSE: Find the roots to the cubic equation: a*x^3 + b*x^2 + c*x + d = 0 Can also be used with a = 0 and/or b = 0 INPUTS: a, b, c, d - may be 1 arbitrary size in a mix with scalars OUTPUTS: The roots such that: (x-x1)*(x-x2)*(x-x3) = x^3 + b/a*x^2 + c/a*x + d/a If a == 0 then x3 is nan since polynomial is 2:nd degree If also b == 0 then x2 will also be nan If also c == 0 then x1 will also be nan NOTES: Faster than the function roots, in particular when several equations solved at once. Also more accurate than roots Solutions are in the same order as from function roots If a ~= 0, x1 is always real cubicroots(a,b,c,d,n) iterates n times to reduce tiny errors","title":"Basic Information"},{"location":"function-guide/math/cubicroots_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/math/deriv2_m/","text":"deriv2.m \u00b6 Basic Information \u00b6 SYNTAX: D = deriv2(x,y,f,n) PURPOSE: Calculate derivatives of f w.r.t. x and y INPUTS: x, y = coordinates (need not be equidistant) f = matrix of size(ny,nx) with values on grid x,y n = number of adjacent points to use (default 2) OUTPUTS: D = struct matrix with derivatives up to order n D(i,j).f is (j-1):th x, (i-1):th y derivative Dependencies \u00b6","title":"deriv2.m"},{"location":"function-guide/math/deriv2_m/#deriv2m","text":"","title":"deriv2.m"},{"location":"function-guide/math/deriv2_m/#basic-information","text":"SYNTAX: D = deriv2(x,y,f,n) PURPOSE: Calculate derivatives of f w.r.t. x and y INPUTS: x, y = coordinates (need not be equidistant) f = matrix of size(ny,nx) with values on grid x,y n = number of adjacent points to use (default 2) OUTPUTS: D = struct matrix with derivatives up to order n D(i,j).f is (j-1):th x, (i-1):th y derivative","title":"Basic Information"},{"location":"function-guide/math/deriv2_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/math/deriv_m/","text":"deriv.m \u00b6 Basic Information \u00b6 SYNTAX: [xderiv,tderiv] = deriv(x,t,method) PURPOSE: Calculate approximate derivative of vector or matrix. INPUT: x = column vector or matrix to differentiate t = times corresponding to x data (column vector), or time between samples (scalar) method = differentiation method (optional, default=1) 1 = forward difference 2 = backward difference 3 = average of forward and backward difference 4 = produces correct derivative for times BETWEEN input samples (Strictly speaking, derivative is undefined at sample points for piecewise linear signal) OUTPUT: xderiv = approximate derivative vector = dx/dt, at input times if method<4, at constructed time vector tderiv if method=4. tderiv = input t if method<4. Strictly contains t if method=4. If x is a matrix, each column must represent data sampled at times given by vector t. RESTRICTIONS: (1) Time t must column vector with values in ascending order. Dependencies \u00b6","title":"deriv.m"},{"location":"function-guide/math/deriv_m/#derivm","text":"","title":"deriv.m"},{"location":"function-guide/math/deriv_m/#basic-information","text":"SYNTAX: [xderiv,tderiv] = deriv(x,t,method) PURPOSE: Calculate approximate derivative of vector or matrix. INPUT: x = column vector or matrix to differentiate t = times corresponding to x data (column vector), or time between samples (scalar) method = differentiation method (optional, default=1) 1 = forward difference 2 = backward difference 3 = average of forward and backward difference 4 = produces correct derivative for times BETWEEN input samples (Strictly speaking, derivative is undefined at sample points for piecewise linear signal) OUTPUT: xderiv = approximate derivative vector = dx/dt, at input times if method<4, at constructed time vector tderiv if method=4. tderiv = input t if method<4. Strictly contains t if method=4. If x is a matrix, each column must represent data sampled at times given by vector t. RESTRICTIONS: (1) Time t must column vector with values in ascending order.","title":"Basic Information"},{"location":"function-guide/math/deriv_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/math/eigsort_m/","text":"eigsort.m \u00b6 Basic Information \u00b6 SYNTAX: eigsort(A), d = eigsort(A), OR [V,d] = eigsort(A) PURPOSE: Calculate eigenvectors V and vector of eigenvalues d, sorted by real part. Works the same as eig.m, except eigenvectors are always returned as a vector (eig returns sometimes as a vector, sometimes as a diagonal matrix) and eigenvalues are sorted. INPUT: A = matrix to calculate eigenvalues for OUTPUT: (see eig.m) V = eigenvectors of A d = eigenvalues of A, i'th eigenvector corresponds to V(:,i) Dependencies \u00b6","title":"eigsort.m"},{"location":"function-guide/math/eigsort_m/#eigsortm","text":"","title":"eigsort.m"},{"location":"function-guide/math/eigsort_m/#basic-information","text":"SYNTAX: eigsort(A), d = eigsort(A), OR [V,d] = eigsort(A) PURPOSE: Calculate eigenvectors V and vector of eigenvalues d, sorted by real part. Works the same as eig.m, except eigenvectors are always returned as a vector (eig returns sometimes as a vector, sometimes as a diagonal matrix) and eigenvalues are sorted. INPUT: A = matrix to calculate eigenvalues for OUTPUT: (see eig.m) V = eigenvectors of A d = eigenvalues of A, i'th eigenvector corresponds to V(:,i)","title":"Basic Information"},{"location":"function-guide/math/eigsort_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/math/gauleg_m/","text":"gauleg.m \u00b6 Basic Information \u00b6 SYNTAX: [x, w] = gauleg(n,x1,x2) PURPOSE: Compute the Gauss-Legendre quadrature abscissas and weights of n internal points for the integration range [x1, x2] INPUTS: n = number of points x1, x2 = lower and upper bound for the integral, defaults -1, +1 OUTPUTS: x = points to evaluate the function at w = weights for each of the points EXAMPLE: [x, w] = gauleg(32, -1, +1); fx = @(x)sin(x).^2; Igl = w*fx(x) Ii = integral(fx, -1, +1) compare Igl and Ii","title":"gauleg.m"},{"location":"function-guide/math/gauleg_m/#gaulegm","text":"","title":"gauleg.m"},{"location":"function-guide/math/gauleg_m/#basic-information","text":"SYNTAX: [x, w] = gauleg(n,x1,x2) PURPOSE: Compute the Gauss-Legendre quadrature abscissas and weights of n internal points for the integration range [x1, x2] INPUTS: n = number of points x1, x2 = lower and upper bound for the integral, defaults -1, +1 OUTPUTS: x = points to evaluate the function at w = weights for each of the points EXAMPLE: [x, w] = gauleg(32, -1, +1); fx = @(x)sin(x).^2; Igl = w*fx(x) Ii = integral(fx, -1, +1) compare Igl and Ii","title":"Basic Information"},{"location":"function-guide/math/isinpoly_m/","text":"isinpoly.m \u00b6 Basic Information \u00b6 USAGE: ft = isinpoly(rt,zt,rp,zp) ft = isinpoly(rt,zt) Second call uses latest supplied polygon and executes faster PURPOSE: Test if point(s) rt, zt are inside polygon rp, zp INPUTS: rt, zt, coordinates of test points rp, zp, coordinates of polygon corners OUTPUTS: ft, flag(s): 0 = outside, 1 = inside Dependencies \u00b6","title":"isinpoly.m"},{"location":"function-guide/math/isinpoly_m/#isinpolym","text":"","title":"isinpoly.m"},{"location":"function-guide/math/isinpoly_m/#basic-information","text":"USAGE: ft = isinpoly(rt,zt,rp,zp) ft = isinpoly(rt,zt) Second call uses latest supplied polygon and executes faster PURPOSE: Test if point(s) rt, zt are inside polygon rp, zp INPUTS: rt, zt, coordinates of test points rp, zp, coordinates of polygon corners OUTPUTS: ft, flag(s): 0 = outside, 1 = inside","title":"Basic Information"},{"location":"function-guide/math/isinpoly_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/math/line_intersection_m/","text":"line_intersection.m \u00b6 Basic Information \u00b6 USAGE: [x, y, f, tA, tB] = line_intersection(xA, yA, xB, yB); PURPOSE: Return point of intersection between lines A and B INPUTS: xA, yA = x, y for two points on line A, sizes [1,2] xB, yB = x, y for two points on line B, sizes [1,2] If called with multiple line-pairs (n), sizes are [n,2] For this case any input can still be size [1,2] OUTPUTS: x, y = point where lines A and B intersect f = flag regarding segment between specified points 0 = A & B are parallel and never intersect 1 = A & B are the same line but the segments have no overlap 2 = A & B intersect but not between specified points 3 = Line A intersected between specified points 4 = Line B intersected between specified points 5 = Both lines intersect between specified points 6 = A & B are the same line and segments partly overlap (not yet implemented) 7 = Points xA, yA are the same as xB, yB (not yet implemented) tA, fraction given by: x = xA(:,1) + tA.*(xA(:,2)-xA(:,1)) tB, fraction given by: x = xB(:,1) + tB.*(xB(:,2)-xB(:,1)) Dependencies \u00b6","title":"line_intersection.m"},{"location":"function-guide/math/line_intersection_m/#line_intersectionm","text":"","title":"line_intersection.m"},{"location":"function-guide/math/line_intersection_m/#basic-information","text":"USAGE: [x, y, f, tA, tB] = line_intersection(xA, yA, xB, yB); PURPOSE: Return point of intersection between lines A and B INPUTS: xA, yA = x, y for two points on line A, sizes [1,2] xB, yB = x, y for two points on line B, sizes [1,2] If called with multiple line-pairs (n), sizes are [n,2] For this case any input can still be size [1,2] OUTPUTS: x, y = point where lines A and B intersect f = flag regarding segment between specified points 0 = A & B are parallel and never intersect 1 = A & B are the same line but the segments have no overlap 2 = A & B intersect but not between specified points 3 = Line A intersected between specified points 4 = Line B intersected between specified points 5 = Both lines intersect between specified points 6 = A & B are the same line and segments partly overlap (not yet implemented) 7 = Points xA, yA are the same as xB, yB (not yet implemented) tA, fraction given by: x = xA(:,1) + tA.*(xA(:,2)-xA(:,1)) tB, fraction given by: x = xB(:,1) + tB.*(xB(:,2)-xB(:,1))","title":"Basic Information"},{"location":"function-guide/math/line_intersection_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/math/minvert_m/","text":"minvert.m \u00b6 Basic Information \u00b6 SYNTAX: [matinv,minsig,numsig] = minvert(mat,tol,figure_num) PURPOSE: Perform SVD generalized inverse of non-square or square matrix. INPUTS: mat = matrix to invert (can be square or non-square) tol = tolerance for inversion (retains singular values st sv/sv_max>tol) If tol>1, then interprets as # of singular values to keep,, and returns sig(tol)/max(sig) figure_num = specifies figure number of plotting desired (default=no plot) OUTPUTS: matinv = SVD generalized inverse of mat. minsig = minimum singular value retained divided by max singular value numsig = number of singular values retained RESTRICTIONS: None. METHOD: SVD generalized inverse. Adapted from IDL function minvert.pro. Dependencies \u00b6","title":"minvert.m"},{"location":"function-guide/math/minvert_m/#minvertm","text":"","title":"minvert.m"},{"location":"function-guide/math/minvert_m/#basic-information","text":"SYNTAX: [matinv,minsig,numsig] = minvert(mat,tol,figure_num) PURPOSE: Perform SVD generalized inverse of non-square or square matrix. INPUTS: mat = matrix to invert (can be square or non-square) tol = tolerance for inversion (retains singular values st sv/sv_max>tol) If tol>1, then interprets as # of singular values to keep,, and returns sig(tol)/max(sig) figure_num = specifies figure number of plotting desired (default=no plot) OUTPUTS: matinv = SVD generalized inverse of mat. minsig = minimum singular value retained divided by max singular value numsig = number of singular values retained RESTRICTIONS: None. METHOD: SVD generalized inverse. Adapted from IDL function minvert.pro.","title":"Basic Information"},{"location":"function-guide/math/minvert_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/math/pdipmqpneq2_m/","text":"pdipmqpneq2.m \u00b6 Basic Information \u00b6 USAGE: rep = pdipmqpneq2(H,h,E,f,kmax,epstop,eta) PURPOSE: Solve the particular quadratic program (no equality constraint) min_z (0.5*x'*H*x+h'*x), s.t. E*x<=f (QP/neq) INPUTS: H, Hessian term nx-by-nx (decision variable x is nx-by-1) h, linear term nx-by-1 E, inequality constraint matrix nz-by-nx (nz is # constraints) f, inequality constraint rhs data nz-by-1 kmax, maximum number of iterations, range 1 to 200 epstop, relative tolerance, range 1e-12 to 1e-3 (def. 1e-9) eta, dampening factor, 0<eta<1 (default 0.95) Any/all of kmax=[],epstop=[],eta=[] is allowed and sets the parameter to the default; but this generates a message that warns about defaulting behavior. OUTPUTS: rep, structure with solution and other parameters rep.descriptions details the contents of rep METHOD: Uses a primal-dual interior point method based on the standard predictor-corrector technique. The initial point is automatically set. All constraints must be present. This code uses a relative norm stop condition. Dependencies \u00b6","title":"pdipmqpneq2.m"},{"location":"function-guide/math/pdipmqpneq2_m/#pdipmqpneq2m","text":"","title":"pdipmqpneq2.m"},{"location":"function-guide/math/pdipmqpneq2_m/#basic-information","text":"USAGE: rep = pdipmqpneq2(H,h,E,f,kmax,epstop,eta) PURPOSE: Solve the particular quadratic program (no equality constraint) min_z (0.5*x'*H*x+h'*x), s.t. E*x<=f (QP/neq) INPUTS: H, Hessian term nx-by-nx (decision variable x is nx-by-1) h, linear term nx-by-1 E, inequality constraint matrix nz-by-nx (nz is # constraints) f, inequality constraint rhs data nz-by-1 kmax, maximum number of iterations, range 1 to 200 epstop, relative tolerance, range 1e-12 to 1e-3 (def. 1e-9) eta, dampening factor, 0<eta<1 (default 0.95) Any/all of kmax=[],epstop=[],eta=[] is allowed and sets the parameter to the default; but this generates a message that warns about defaulting behavior. OUTPUTS: rep, structure with solution and other parameters rep.descriptions details the contents of rep METHOD: Uses a primal-dual interior point method based on the standard predictor-corrector technique. The initial point is automatically set. All constraints must be present. This code uses a relative norm stop condition.","title":"Basic Information"},{"location":"function-guide/math/pdipmqpneq2_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/math/polycellint_m/","text":"polycellint.m \u00b6 Basic Information \u00b6 USAGE: [Acell, RAcell, ARcell] = polycellint(rg,zg,rp,zp) PURPOSE: Calculate how much area of each cell in grid rg, zg is inside the polygon rp, zp INPUTS: rg, zg, coordinates for centers of rectangles rp, zp, coordinates defining a polygon OUTPUTS: Acell, area of cells that are inside the polygon RAcell, surface integral of R over inside area ARcell, surface integral of 1/R over inside area All output sizes are [length(zg),length(rg)] Dependencies \u00b6","title":"polycellint.m"},{"location":"function-guide/math/polycellint_m/#polycellintm","text":"","title":"polycellint.m"},{"location":"function-guide/math/polycellint_m/#basic-information","text":"USAGE: [Acell, RAcell, ARcell] = polycellint(rg,zg,rp,zp) PURPOSE: Calculate how much area of each cell in grid rg, zg is inside the polygon rp, zp INPUTS: rg, zg, coordinates for centers of rectangles rp, zp, coordinates defining a polygon OUTPUTS: Acell, area of cells that are inside the polygon RAcell, surface integral of R over inside area ARcell, surface integral of 1/R over inside area All output sizes are [length(zg),length(rg)]","title":"Basic Information"},{"location":"function-guide/math/polycellint_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mdsplus/get_mds_tree_m/","text":"get_mds_tree.m \u00b6 Basic Information \u00b6 SYNTAX: data= get_mds_tree(shot, tree, server, toupper,verbose); full call data= get_mds_tree(shot); defaults to DIII-D data= get_mds_tree(shot, 'EFIT01', 'NSTX'); for NSTX data= get_mds_tree(shot, 'NB', 'DIII-D'); example other tree PURPOSE: Get entire selected mds tree from mdsplus database. INPUT: <default> shot = shot number tree = tree to use <'EFIT01'> server = MDS+ database to use: 'DIII-D'(default),'NSTX','EAST', 'THOR', 'OPEN'(assumes mdsconnect already called). Other inputs invoke mdsconnect(server) to connect to server. toupper = 1= all variables made upper case, =-1 all var. made lower case [0]= no change, variables made depending on mds case (typical UC) verbose = set to 1 to get diagnostic prints during execution <1> server= 'NSTX' or 'EAST'; (since can take some time to get) <0> server= 'DIII-D' & all others; OUTPUT: data = structure containing all data in MDS+ tree, with same tree structure except that 'TOP' replaced by 'tree' See: data.allnames for list of all variables in full structure Some Extra items added to structure (all lower case) data.id = sting array of important data identifyer enf data.shot = shot number data.server= MDS+ server data.allnames= list of variables in structure with path relative to \"TOP\" data.mdsnames= list of variables in structure with full mds path ier = error code WRITTEN BY: Jim Leuer ON 3/1/05 (original name get_mds_tree) taken from get_mds_tree.m uses sub-structure to store USES: eq_mod To see MDS structure on HYDRA run traverser tested on DIII-D and NSTX data and should work for JET data but not tested CHANGE LOG: SMF 20140923 - Changed getnci call to use nid_numbers due to fullpath not accepting wildcards. ========================================================================== Dependencies \u00b6 read_gfile mdsconnect mdsopen mdsdisconnect mdsvalue mds_sub_tree","title":"get_mds_tree.m"},{"location":"function-guide/mdsplus/get_mds_tree_m/#get_mds_treem","text":"","title":"get_mds_tree.m"},{"location":"function-guide/mdsplus/get_mds_tree_m/#basic-information","text":"SYNTAX: data= get_mds_tree(shot, tree, server, toupper,verbose); full call data= get_mds_tree(shot); defaults to DIII-D data= get_mds_tree(shot, 'EFIT01', 'NSTX'); for NSTX data= get_mds_tree(shot, 'NB', 'DIII-D'); example other tree PURPOSE: Get entire selected mds tree from mdsplus database. INPUT: <default> shot = shot number tree = tree to use <'EFIT01'> server = MDS+ database to use: 'DIII-D'(default),'NSTX','EAST', 'THOR', 'OPEN'(assumes mdsconnect already called). Other inputs invoke mdsconnect(server) to connect to server. toupper = 1= all variables made upper case, =-1 all var. made lower case [0]= no change, variables made depending on mds case (typical UC) verbose = set to 1 to get diagnostic prints during execution <1> server= 'NSTX' or 'EAST'; (since can take some time to get) <0> server= 'DIII-D' & all others; OUTPUT: data = structure containing all data in MDS+ tree, with same tree structure except that 'TOP' replaced by 'tree' See: data.allnames for list of all variables in full structure Some Extra items added to structure (all lower case) data.id = sting array of important data identifyer enf data.shot = shot number data.server= MDS+ server data.allnames= list of variables in structure with path relative to \"TOP\" data.mdsnames= list of variables in structure with full mds path ier = error code WRITTEN BY: Jim Leuer ON 3/1/05 (original name get_mds_tree) taken from get_mds_tree.m uses sub-structure to store USES: eq_mod To see MDS structure on HYDRA run traverser tested on DIII-D and NSTX data and should work for JET data but not tested CHANGE LOG: SMF 20140923 - Changed getnci call to use nid_numbers due to fullpath not accepting wildcards. ==========================================================================","title":"Basic Information"},{"location":"function-guide/mdsplus/get_mds_tree_m/#dependencies","text":"read_gfile mdsconnect mdsopen mdsdisconnect mdsvalue mds_sub_tree","title":"Dependencies"},{"location":"function-guide/mdsplus/getmdata_m/","text":"getmdata.m \u00b6 Basic Information \u00b6 SYNTAX OPTIONS: [data_vals,time_vals,ier,units] = getmdata(shotnum, ptname, treename, connOrTokamak, getxdata) PURPOSE: Get mdsplus or ptdata data with reusable connections through mdsPlus library. INPUT: shotnum = shot number ptname = name of data - must be in single quotes treename = which tree to use for mdsplus data, or 'ptdata' (optional) Default Options depend on the server: Server: Default treename: 'D3D' -> 'ptdata' 'JET' -> 'PPF' 'NSTX' -> 'wf' 'KSTAR' -> 'pcs_kstar' 'EAST' -> 'pcs_east' 'EAST@GA' -> 'pcs_east' connOrTokamak = tokamak name, server, or reusable mdsplus library connection object. (optional, default = 'd3d') -mdsplus library objects can be made with getmdsconn -Server address can be input as a string -Tokamak name will lookup default server addresses: Options: (default = 'd3d') 'D3D' -> 'atlas.gat.com' 'JET' -> 'mdsplus.jet.efda.org' 'NSTX' -> 'birch.pppl.gov:8501' 'KSTAR' -> '203.230.126.212:8005' 'EAST' -> '202.127.204.12:8000' 'EAST@GA' -> 'eastdata.gat.com' OUTPUT: data_vals = Data for ptname defined by input (complete data record) time_vals = Time values ier = error code = 0 if OK, else > 0 units = Units string for ptname if defined in the MDSplus DB. EXAMPLES getmdata(176991, 'ip', 'ptdata', 'd3d') getmdata(57035, 'MAGN/IPLA', 'PPF', 'jet') getmdata(57035,'MAGN/IPLA','PPF','JET') getmdata(109070,'ip','wf','NSTX') getmdata(999991,'PCIP','PCS_KSTAR','kstar') getmdata(73502,'pcrl01','pcs_east','east') getmdata(73502,'pcrl01','pcs_east','east') EXAMPLE re-using MDSplus connection: [connObj, ier] = getmdsconn('d3d'); [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ip', 'ptdata', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ipmeas', 'efit01', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'li', 'efitrt1', connObj) or: [ data_vals, time_vals, ier, units, connObj ] = getmdata(176991, 'ip', 'ptdata', 'd3d') [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ipmeas', 'efit01', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'li', 'efitrt1', connObj) RESTRICTIONS: (1) Only works for 1-D and 2-D data right now WRITTEN BY: Jayson Barr ON 8/16/18 Dependencies \u00b6 getmdsconn ptname_find_mdstree get_defaults_for_tok","title":"getmdata.m"},{"location":"function-guide/mdsplus/getmdata_m/#getmdatam","text":"","title":"getmdata.m"},{"location":"function-guide/mdsplus/getmdata_m/#basic-information","text":"SYNTAX OPTIONS: [data_vals,time_vals,ier,units] = getmdata(shotnum, ptname, treename, connOrTokamak, getxdata) PURPOSE: Get mdsplus or ptdata data with reusable connections through mdsPlus library. INPUT: shotnum = shot number ptname = name of data - must be in single quotes treename = which tree to use for mdsplus data, or 'ptdata' (optional) Default Options depend on the server: Server: Default treename: 'D3D' -> 'ptdata' 'JET' -> 'PPF' 'NSTX' -> 'wf' 'KSTAR' -> 'pcs_kstar' 'EAST' -> 'pcs_east' 'EAST@GA' -> 'pcs_east' connOrTokamak = tokamak name, server, or reusable mdsplus library connection object. (optional, default = 'd3d') -mdsplus library objects can be made with getmdsconn -Server address can be input as a string -Tokamak name will lookup default server addresses: Options: (default = 'd3d') 'D3D' -> 'atlas.gat.com' 'JET' -> 'mdsplus.jet.efda.org' 'NSTX' -> 'birch.pppl.gov:8501' 'KSTAR' -> '203.230.126.212:8005' 'EAST' -> '202.127.204.12:8000' 'EAST@GA' -> 'eastdata.gat.com' OUTPUT: data_vals = Data for ptname defined by input (complete data record) time_vals = Time values ier = error code = 0 if OK, else > 0 units = Units string for ptname if defined in the MDSplus DB. EXAMPLES getmdata(176991, 'ip', 'ptdata', 'd3d') getmdata(57035, 'MAGN/IPLA', 'PPF', 'jet') getmdata(57035,'MAGN/IPLA','PPF','JET') getmdata(109070,'ip','wf','NSTX') getmdata(999991,'PCIP','PCS_KSTAR','kstar') getmdata(73502,'pcrl01','pcs_east','east') getmdata(73502,'pcrl01','pcs_east','east') EXAMPLE re-using MDSplus connection: [connObj, ier] = getmdsconn('d3d'); [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ip', 'ptdata', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ipmeas', 'efit01', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'li', 'efitrt1', connObj) or: [ data_vals, time_vals, ier, units, connObj ] = getmdata(176991, 'ip', 'ptdata', 'd3d') [ data_vals, time_vals, ier, units ] = getmdata(176991, 'ipmeas', 'efit01', connObj) [ data_vals, time_vals, ier, units ] = getmdata(176991, 'li', 'efitrt1', connObj) RESTRICTIONS: (1) Only works for 1-D and 2-D data right now WRITTEN BY: Jayson Barr ON 8/16/18","title":"Basic Information"},{"location":"function-guide/mdsplus/getmdata_m/#dependencies","text":"getmdsconn ptname_find_mdstree get_defaults_for_tok","title":"Dependencies"},{"location":"function-guide/mdsplus/getmds_m/","text":"getmds.m \u00b6 Basic Information \u00b6 SYNTAX OPTIONS: [data,tvec,ier] = getmds(shot,name,range_min,range_max,tree,server,ical) [data,xvec,tvec,ier] = getmds(shot,name,range_min,range_max,tree,server,ical) PURPOSE: Get mdsplus data from the MDS database. INPUT: shot = shot number name = name of data - must be in single quotes range_min = minimum value of independent variable(s) - use NaN to specify no limit: if scalar, this is min time (s) if vector, last entry is min time (s), other entries are minima for other independent variables range_max = maximum value of independent variable(s) - use NaN to specify no limit: if scalar, this is max time (s) if vector, last entry is max time (s), other entries are maxima for other independent variables tree = which tree to use (optional, default = 'EFIT01') server = which server to use (optional). Options: 'DIII-D'(default), 'JET', 'NSTX', 'THOR' ical = return data in units of digitizer counts (ical=0), volts into digitizer (ical=2), or physics units (ical=1). Only used for data from 'THOR', 'data-server3' (EAST), and 'pcs_kstar' (KSTAR) OUTPUT: data = data for name defined by input (dimensions correspond to dimensions specified in range_min) (xvec..tvec) = variable number of arguments containing vectors of independent variables specified in range_min and range_max ier = error code = 0 if OK, else > 0 EXAMPLES getmds(106649,'rmaxis',1.5,5,'EFIT01','DIII-D') getmds(57035,'MAGN/IPLA',1.0,3.0,'PPF','JET') getmds(109070,'ip',1.0,3.0,'wf','NSTX') getmds(999991,'PCIP',0.0,8.0,'PCS_KSTAR','THOR'); NEED 3D examples RESTRICTIONS: (1) Only works for range_min/max up to length 2 at the moment (make a request for more). (2) Use the lower level routines starting with \"mds\" to manipulate the MDS data directly.","title":"getmds.m"},{"location":"function-guide/mdsplus/getmds_m/#getmdsm","text":"","title":"getmds.m"},{"location":"function-guide/mdsplus/getmds_m/#basic-information","text":"SYNTAX OPTIONS: [data,tvec,ier] = getmds(shot,name,range_min,range_max,tree,server,ical) [data,xvec,tvec,ier] = getmds(shot,name,range_min,range_max,tree,server,ical) PURPOSE: Get mdsplus data from the MDS database. INPUT: shot = shot number name = name of data - must be in single quotes range_min = minimum value of independent variable(s) - use NaN to specify no limit: if scalar, this is min time (s) if vector, last entry is min time (s), other entries are minima for other independent variables range_max = maximum value of independent variable(s) - use NaN to specify no limit: if scalar, this is max time (s) if vector, last entry is max time (s), other entries are maxima for other independent variables tree = which tree to use (optional, default = 'EFIT01') server = which server to use (optional). Options: 'DIII-D'(default), 'JET', 'NSTX', 'THOR' ical = return data in units of digitizer counts (ical=0), volts into digitizer (ical=2), or physics units (ical=1). Only used for data from 'THOR', 'data-server3' (EAST), and 'pcs_kstar' (KSTAR) OUTPUT: data = data for name defined by input (dimensions correspond to dimensions specified in range_min) (xvec..tvec) = variable number of arguments containing vectors of independent variables specified in range_min and range_max ier = error code = 0 if OK, else > 0 EXAMPLES getmds(106649,'rmaxis',1.5,5,'EFIT01','DIII-D') getmds(57035,'MAGN/IPLA',1.0,3.0,'PPF','JET') getmds(109070,'ip',1.0,3.0,'wf','NSTX') getmds(999991,'PCIP',0.0,8.0,'PCS_KSTAR','THOR'); NEED 3D examples RESTRICTIONS: (1) Only works for range_min/max up to length 2 at the moment (make a request for more). (2) Use the lower level routines starting with \"mds\" to manipulate the MDS data directly.","title":"Basic Information"},{"location":"function-guide/mdsplus/getmdsconn_m/","text":"getmdsconn.m \u00b6 Basic Information \u00b6 SYNTAX OPTIONS: [connObj, ier] = getmdsconn(serverTok) PURPOSE: Establish a connection to an MDSplus server, return a connection object. INPUT: serverTok = Either a hostname or a tokamak shortname: 'DIII-D', 'D3D' -> 'atlas.gat.com' 'JET' -> 'mdsplus.jet.efda.org' 'NSTX' -> 'birch.pppl.gov:8501' 'KSTAR'-> '203.230.126.212:8005' 'EAST' -> '202.127.204.12:8000' 'EAST@GA' -> 'eastdata.gat.com' OUTPUT: connObj = connection object used for getting data ier = error code = 0 if OK, else > 0 EXAMPLES: [connObj, ier] = getmdsconn('d3d') [connObj, ier] = getmdsconn('NSTX') [connObj, ier] = getmdsconn('east@ga') RESTRICTIONS: (1) METHOD: WRITTEN BY: Jayson Barr ON 2/14/18 Dependencies \u00b6","title":"getmdsconn.m"},{"location":"function-guide/mdsplus/getmdsconn_m/#getmdsconnm","text":"","title":"getmdsconn.m"},{"location":"function-guide/mdsplus/getmdsconn_m/#basic-information","text":"SYNTAX OPTIONS: [connObj, ier] = getmdsconn(serverTok) PURPOSE: Establish a connection to an MDSplus server, return a connection object. INPUT: serverTok = Either a hostname or a tokamak shortname: 'DIII-D', 'D3D' -> 'atlas.gat.com' 'JET' -> 'mdsplus.jet.efda.org' 'NSTX' -> 'birch.pppl.gov:8501' 'KSTAR'-> '203.230.126.212:8005' 'EAST' -> '202.127.204.12:8000' 'EAST@GA' -> 'eastdata.gat.com' OUTPUT: connObj = connection object used for getting data ier = error code = 0 if OK, else > 0 EXAMPLES: [connObj, ier] = getmdsconn('d3d') [connObj, ier] = getmdsconn('NSTX') [connObj, ier] = getmdsconn('east@ga') RESTRICTIONS: (1) METHOD: WRITTEN BY: Jayson Barr ON 2/14/18","title":"Basic Information"},{"location":"function-guide/mdsplus/getmdsconn_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mdsplus/mds_eq_m/","text":"mds_eq.m \u00b6 Basic Information \u00b6 SYNTAX: eq= mds_eq(shot, tree, gam, mk_var); defaults to DIII-D server mds_eq(shot, 'EFIT01, 'gam', 1, 'NSTX'); makes vars in workspace PURPOSE: Get EFIT equilibrium (GEQDSK AEQDSK MEQDSK) from mdsplus database. INPUT: <default> shot = shot number tree = which efit tree to use <'EFIT01'> gam = ['g']; get only g file, a= only a file, m= mfile, <gam> mk_var = [1]; Will make efit variables in calling workspace, <0> makes none 2 will make lower case, 3 will make upper case variable note default variables in MDS are upper case NOTE: see eq_to_env for way to make tstart<=t<tend arrays server = which data base to use: defaults to [DIII-D] also NSTX OUTPUT: eq = structure containing EFIT eqdsk variables See: eq.gnames .anames .mnames for g,a,m file names All EFIT variables are as in MDSPLUS => Upper Case Ex: eq.BCENTR, eq.BDRY, eq.PSIRZ, Use: plot(eq.GTIME, eq.CPASMA), contour(eq.R, eq.Z, eq.PSIRZ(:,:,round(length(eq.GTIME)/2))') Extra items added to structure (all lower case) eq.id = sting array of important data identifyer enf eq.gnames= sting array of all gfile names collected (eq to see all) eq.anames= sting array of all afile names collected (eq to see all) eq.mnames= sting array of all mfile names collected (eq to see all) eq.shot = shot number eq.tree = mds tree used to get data (ex. EFIT01 EFIT02 (=MSD)); if mk_var>0 it makes variables in base workspace BCENTR, BDRY, CPASMA, PSIRZ, ... NOTE: 1)Function returns all TIME data for shot in large arrays. Example: eq.BCENTER(255,1) eq.GTIME(255,1); Time data vector for all .GNAME arrays 255 times eq.ATIME(251,1); Time data vector for all .ANAME arrays 251 times eq.MTIME or eq.TIME Note old \"m\" uses TIME new \"m\" uses MTIME eq.PPRIME(65,255),PSIRZ(65,65,225) Similar arrays (without eq. strucutre) are generated in workspace if mk_var>=1 : BCENTER(255,1), GTIME(255,1) or LC if mk_var==2 2) Time is in vector eq.GTIME and is in ms. All other units are as they come from EFIT. psi(Vs/r) I(A) R(m) ... CAUTION: All time vectors are last index of vector of array. CAUTION: GTIME ATIME & (MTIME or TIME) are not necesaarly the same. CAUTION: Current Bad Variable in d3dMDSPLUS ARE: CASE, HEADER, ZGRID (use Z) CAUTION: THIS ROUTINE GETS ALL MDS EQDSK DATA FOR SHOT AND EQ CAN BE HUGE CAUTION: Afile read 1st then Gfile: variables in common: BCENTR, CPASMA, ... SEE ALSO: eq_time_lim eq_ga_env Dependencies \u00b6 read_gfile mdsconnect mdsopen wait eq_mod mdsdisconnect mdsvalue","title":"mds_eq.m"},{"location":"function-guide/mdsplus/mds_eq_m/#mds_eqm","text":"","title":"mds_eq.m"},{"location":"function-guide/mdsplus/mds_eq_m/#basic-information","text":"SYNTAX: eq= mds_eq(shot, tree, gam, mk_var); defaults to DIII-D server mds_eq(shot, 'EFIT01, 'gam', 1, 'NSTX'); makes vars in workspace PURPOSE: Get EFIT equilibrium (GEQDSK AEQDSK MEQDSK) from mdsplus database. INPUT: <default> shot = shot number tree = which efit tree to use <'EFIT01'> gam = ['g']; get only g file, a= only a file, m= mfile, <gam> mk_var = [1]; Will make efit variables in calling workspace, <0> makes none 2 will make lower case, 3 will make upper case variable note default variables in MDS are upper case NOTE: see eq_to_env for way to make tstart<=t<tend arrays server = which data base to use: defaults to [DIII-D] also NSTX OUTPUT: eq = structure containing EFIT eqdsk variables See: eq.gnames .anames .mnames for g,a,m file names All EFIT variables are as in MDSPLUS => Upper Case Ex: eq.BCENTR, eq.BDRY, eq.PSIRZ, Use: plot(eq.GTIME, eq.CPASMA), contour(eq.R, eq.Z, eq.PSIRZ(:,:,round(length(eq.GTIME)/2))') Extra items added to structure (all lower case) eq.id = sting array of important data identifyer enf eq.gnames= sting array of all gfile names collected (eq to see all) eq.anames= sting array of all afile names collected (eq to see all) eq.mnames= sting array of all mfile names collected (eq to see all) eq.shot = shot number eq.tree = mds tree used to get data (ex. EFIT01 EFIT02 (=MSD)); if mk_var>0 it makes variables in base workspace BCENTR, BDRY, CPASMA, PSIRZ, ... NOTE: 1)Function returns all TIME data for shot in large arrays. Example: eq.BCENTER(255,1) eq.GTIME(255,1); Time data vector for all .GNAME arrays 255 times eq.ATIME(251,1); Time data vector for all .ANAME arrays 251 times eq.MTIME or eq.TIME Note old \"m\" uses TIME new \"m\" uses MTIME eq.PPRIME(65,255),PSIRZ(65,65,225) Similar arrays (without eq. strucutre) are generated in workspace if mk_var>=1 : BCENTER(255,1), GTIME(255,1) or LC if mk_var==2 2) Time is in vector eq.GTIME and is in ms. All other units are as they come from EFIT. psi(Vs/r) I(A) R(m) ... CAUTION: All time vectors are last index of vector of array. CAUTION: GTIME ATIME & (MTIME or TIME) are not necesaarly the same. CAUTION: Current Bad Variable in d3dMDSPLUS ARE: CASE, HEADER, ZGRID (use Z) CAUTION: THIS ROUTINE GETS ALL MDS EQDSK DATA FOR SHOT AND EQ CAN BE HUGE CAUTION: Afile read 1st then Gfile: variables in common: BCENTR, CPASMA, ... SEE ALSO: eq_time_lim eq_ga_env","title":"Basic Information"},{"location":"function-guide/mdsplus/mds_eq_m/#dependencies","text":"read_gfile mdsconnect mdsopen wait eq_mod mdsdisconnect mdsvalue","title":"Dependencies"},{"location":"function-guide/mdsplus/mds_sub_tree_m/","text":"mds_sub_tree.m \u00b6 Basic Information \u00b6 SYNTAX: mds_ot= mds_sub_tree(mds_in) PURPOSE:gets mds subtrees for next level down. INPUT: <default> mds_in = Input mds tree OUTPUT: mds_ot = Output mds subtree names WRITTEN BY: Jim Leuer ON 3/3/05 CHANGE LOG: SMF 20140923 - Changed getnci call to use nid_numbers due to fullpath not accepting wildcards. ========================================================================== @(#)mds_sub_tree.m 1.3 07/09/09 Dependencies \u00b6 mdsvalue","title":"mds_sub_tree.m"},{"location":"function-guide/mdsplus/mds_sub_tree_m/#mds_sub_treem","text":"","title":"mds_sub_tree.m"},{"location":"function-guide/mdsplus/mds_sub_tree_m/#basic-information","text":"SYNTAX: mds_ot= mds_sub_tree(mds_in) PURPOSE:gets mds subtrees for next level down. INPUT: <default> mds_in = Input mds tree OUTPUT: mds_ot = Output mds subtree names WRITTEN BY: Jim Leuer ON 3/3/05 CHANGE LOG: SMF 20140923 - Changed getnci call to use nid_numbers due to fullpath not accepting wildcards. ========================================================================== @(#)mds_sub_tree.m 1.3 07/09/09","title":"Basic Information"},{"location":"function-guide/mdsplus/mds_sub_tree_m/#dependencies","text":"mdsvalue","title":"Dependencies"},{"location":"function-guide/mdsplus/mdsclose_m/","text":"mdsclose.m \u00b6 Basic Information \u00b6 SYNTAX: status = mdsclose(para) PURPOSE: function to mdsclose on remote server INPUT: para = ?? (optional) (if para ~= 0, perform a disconnect of remote server) OUTPUT: status Dependencies \u00b6 mdsdisconnect","title":"mdsclose.m"},{"location":"function-guide/mdsplus/mdsclose_m/#mdsclosem","text":"","title":"mdsclose.m"},{"location":"function-guide/mdsplus/mdsclose_m/#basic-information","text":"SYNTAX: status = mdsclose(para) PURPOSE: function to mdsclose on remote server INPUT: para = ?? (optional) (if para ~= 0, perform a disconnect of remote server) OUTPUT: status","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsclose_m/#dependencies","text":"mdsdisconnect","title":"Dependencies"},{"location":"function-guide/mdsplus/mdsdisconnect_m/","text":"mdsdisconnect.m \u00b6 Basic Information \u00b6 SYNTAX: status = mdsdisconnect PURPOSE: function to close communication with remote mds server INPUT: none OUTPUT: status Dependencies \u00b6","title":"mdsdisconnect.m"},{"location":"function-guide/mdsplus/mdsdisconnect_m/#mdsdisconnectm","text":"","title":"mdsdisconnect.m"},{"location":"function-guide/mdsplus/mdsdisconnect_m/#basic-information","text":"SYNTAX: status = mdsdisconnect PURPOSE: function to close communication with remote mds server INPUT: none OUTPUT: status","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsdisconnect_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mdsplus/mdsopen_m/","text":"mdsopen.m \u00b6 Basic Information \u00b6 SYNTAX: [shoto,status] = mdsopen(server, shot) PURPOSE: function to open remote server server INPUT: server = string defining server and tree to access Example: 'atlas.gat.com::EFIT01' (server is optional, defaults to atlas.gat.com; If first parameter is not a string, will open 'EFIT01' tree.) shot = shot number OUTPUT: shoto = the shot number which was opened, if successful status = return status, odd=good, even=bad Dependencies \u00b6 wait","title":"mdsopen.m"},{"location":"function-guide/mdsplus/mdsopen_m/#mdsopenm","text":"","title":"mdsopen.m"},{"location":"function-guide/mdsplus/mdsopen_m/#basic-information","text":"SYNTAX: [shoto,status] = mdsopen(server, shot) PURPOSE: function to open remote server server INPUT: server = string defining server and tree to access Example: 'atlas.gat.com::EFIT01' (server is optional, defaults to atlas.gat.com; If first parameter is not a string, will open 'EFIT01' tree.) shot = shot number OUTPUT: shoto = the shot number which was opened, if successful status = return status, odd=good, even=bad","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsopen_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/mdsplus/mdsput_m/","text":"mdsput.m \u00b6 Basic Information \u00b6 SYNTAX: status = mdsput(node,expr,varargin) PURPOSE: puts data in MDS data base INPUT: node expr varargin OUTPUT: status Dependencies \u00b6","title":"mdsput.m"},{"location":"function-guide/mdsplus/mdsput_m/#mdsputm","text":"","title":"mdsput.m"},{"location":"function-guide/mdsplus/mdsput_m/#basic-information","text":"SYNTAX: status = mdsput(node,expr,varargin) PURPOSE: puts data in MDS data base INPUT: node expr varargin OUTPUT: status","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsput_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mdsplus/mdsvalue_m/","text":"mdsvalue.m \u00b6 Basic Information \u00b6 SYNTAX: [reply,status] = mdsvalue(str,varargin) PURPOSE: function to open server remotely eg : mdsvalue('2+3'); INPUT: str = string defining data to get (e.g. '\\betap') varargin= ?? OUTPUT: reply = requested information status = return status, odd=good, even=bad Dependencies \u00b6","title":"mdsvalue.m"},{"location":"function-guide/mdsplus/mdsvalue_m/#mdsvaluem","text":"","title":"mdsvalue.m"},{"location":"function-guide/mdsplus/mdsvalue_m/#basic-information","text":"SYNTAX: [reply,status] = mdsvalue(str,varargin) PURPOSE: function to open server remotely eg : mdsvalue('2+3'); INPUT: str = string defining data to get (e.g. '\\betap') varargin= ?? OUTPUT: reply = requested information status = return status, odd=good, even=bad","title":"Basic Information"},{"location":"function-guide/mdsplus/mdsvalue_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/mdsplus/recurse_mds_tree_m/","text":"recurse_mds_tree.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: The code in get_mds_tree defines the tree structure down to the first node that is delimited by a colon (i.e., all paths up to *:node). This function recurses down from there (when needed to actually populate the metadata in the tree. INPUT: mds_nam = node name to recurse from (or evaluate if it is a leaf node) metadata = full metadata that will be returned to user, with content filled up to this call mds_nam0 = Top tree name toupper = user selection (see get_mds_tree.m) verbose = user selection (see get_mds_tree.m) top_num = length of mds_nam0 string OUTPUT: metadata = updated full metadata object","title":"recurse_mds_tree.m"},{"location":"function-guide/mdsplus/recurse_mds_tree_m/#recurse_mds_treem","text":"","title":"recurse_mds_tree.m"},{"location":"function-guide/mdsplus/recurse_mds_tree_m/#basic-information","text":"SYNTAX: PURPOSE: The code in get_mds_tree defines the tree structure down to the first node that is delimited by a colon (i.e., all paths up to *:node). This function recurses down from there (when needed to actually populate the metadata in the tree. INPUT: mds_nam = node name to recurse from (or evaluate if it is a leaf node) metadata = full metadata that will be returned to user, with content filled up to this call mds_nam0 = Top tree name toupper = user selection (see get_mds_tree.m) verbose = user selection (see get_mds_tree.m) top_num = length of mds_nam0 string OUTPUT: metadata = updated full metadata object","title":"Basic Information"},{"location":"function-guide/ntm/K1fun_m/","text":"K1fun.m \u00b6 Basic Information \u00b6 USAGE: K1 = K1fun(w,fwhm_eccd,misalignment,toroidal_angle) PURPOSE: Calculate effectiveness parameter for replacing bootstrap current in NTM INPUTS: w, width of the NTM fwhm_eccd, Full Width at Half Maximum of ECCD misalignment, offset between current drive and resonant surface (default 0) (All of the above measured at same poloidal angle with same units) toroidal_angle, toroidal angle where CD is deposited from 0=O to 180=X, if omitted an average is calculated corresponding to continuous ECCD if == 'O' calculation is for O-point modulation with 50 duty cycle if == 'X' calculation is for X-point modulation with 50 duty cycle OUTPUTS: K1, effectiveness parameter for replacing missing bootstrap current in NTM METHOD: Based on equations derived by Francis Perkins. Expanded by Anders Welander to work for arbitrary toroidal angles and include effect of radial misalignment. See epmasw060404b-mrePhase.doc which also includes Perkins' work as an appendix. Dependencies \u00b6","title":"K1fun.m"},{"location":"function-guide/ntm/K1fun_m/#k1funm","text":"","title":"K1fun.m"},{"location":"function-guide/ntm/K1fun_m/#basic-information","text":"USAGE: K1 = K1fun(w,fwhm_eccd,misalignment,toroidal_angle) PURPOSE: Calculate effectiveness parameter for replacing bootstrap current in NTM INPUTS: w, width of the NTM fwhm_eccd, Full Width at Half Maximum of ECCD misalignment, offset between current drive and resonant surface (default 0) (All of the above measured at same poloidal angle with same units) toroidal_angle, toroidal angle where CD is deposited from 0=O to 180=X, if omitted an average is calculated corresponding to continuous ECCD if == 'O' calculation is for O-point modulation with 50 duty cycle if == 'X' calculation is for X-point modulation with 50 duty cycle OUTPUTS: K1, effectiveness parameter for replacing missing bootstrap current in NTM METHOD: Based on equations derived by Francis Perkins. Expanded by Anders Welander to work for arbitrary toroidal angles and include effect of radial misalignment. See epmasw060404b-mrePhase.doc which also includes Perkins' work as an appendix.","title":"Basic Information"},{"location":"function-guide/ntm/K1fun_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/ntm/MREfun_m/","text":"MREfun.m \u00b6 Basic Information \u00b6 USAGE: dwdt = MREfun(eq2d,w,j_eccd,fwhm_eccd,misalignment,toroidal_angle) PURPOSE: Calculate dw/dt from Modified Rutherford Equation INPUTS: eq2d, structure with 2-D equilibrium inputs: q, safety factor at NTM-resonant surface (e.g. 2/1 or 3/2) dqdR, dq/dR at q-surface delta_prime0, delta_prime at q-surface before ECCD is applied tau_R, resistive time at q-surface [sec] j_tot, total current density at q-surface j_boot, bootstrap current density at q-surface wmarg, marginal island size (2*ion banana width) Rqmin, minimum major radius of q-surface Rqmax, maximum major radius of q-surface w, full width of NTM j_eccd, peak ECCD density (Gaussian profile) fwhm_eccd, Full Width at Half Maximum of ECCD misalignment, offset between ECCD peak and q-surface (default 0) toroidal_angle, toroidal angle where ECCD is deposited from 0=O to 180=X, if omitted an average dw/dt is calculated for continuous ECCD on rotating NTM if == 'O' then O-point modulation with 50 duty cycle is used if == 'X' then X-point modulation with 50 duty cycle is used j_tot, j_boot, j_eccd must all be same units (j_tot=1 is an example) All lengths including 1/delta_prime0 and 1/dqdR in same units [m] Inputs can be any mix of *one* size [n1,n2] and size [1,1] eq2d must be size [1,1] but its fields can be size [n1,n2] or [1,1] OUTPUTS: dw/dt, rate of change of island width [m/s] METHOD: MRE from Nucl Fusion 49, (2009) 045005, Prospects for.. Dependencies \u00b6 K1fun","title":"MREfun.m"},{"location":"function-guide/ntm/MREfun_m/#mrefunm","text":"","title":"MREfun.m"},{"location":"function-guide/ntm/MREfun_m/#basic-information","text":"USAGE: dwdt = MREfun(eq2d,w,j_eccd,fwhm_eccd,misalignment,toroidal_angle) PURPOSE: Calculate dw/dt from Modified Rutherford Equation INPUTS: eq2d, structure with 2-D equilibrium inputs: q, safety factor at NTM-resonant surface (e.g. 2/1 or 3/2) dqdR, dq/dR at q-surface delta_prime0, delta_prime at q-surface before ECCD is applied tau_R, resistive time at q-surface [sec] j_tot, total current density at q-surface j_boot, bootstrap current density at q-surface wmarg, marginal island size (2*ion banana width) Rqmin, minimum major radius of q-surface Rqmax, maximum major radius of q-surface w, full width of NTM j_eccd, peak ECCD density (Gaussian profile) fwhm_eccd, Full Width at Half Maximum of ECCD misalignment, offset between ECCD peak and q-surface (default 0) toroidal_angle, toroidal angle where ECCD is deposited from 0=O to 180=X, if omitted an average dw/dt is calculated for continuous ECCD on rotating NTM if == 'O' then O-point modulation with 50 duty cycle is used if == 'X' then X-point modulation with 50 duty cycle is used j_tot, j_boot, j_eccd must all be same units (j_tot=1 is an example) All lengths including 1/delta_prime0 and 1/dqdR in same units [m] Inputs can be any mix of *one* size [n1,n2] and size [1,1] eq2d must be size [1,1] but its fields can be size [n1,n2] or [1,1] OUTPUTS: dw/dt, rate of change of island width [m/s] METHOD: MRE from Nucl Fusion 49, (2009) 045005, Prospects for..","title":"Basic Information"},{"location":"function-guide/ntm/MREfun_m/#dependencies","text":"K1fun","title":"Dependencies"},{"location":"function-guide/ntm/ntm_field_m/","text":"ntm_field.m \u00b6 Basic Information \u00b6 SYNTAX: [g, dgdphi, phi, rq, zq] = ntm_field(equ, q, tok, dphid, iplot) PURPOSE: Calculate fields from NTM measured by magnetic probes For examples of use cases type >> ntm_field INPUTS: equ, structure with TokSys equilibrium q, safety factor of surface (should be rational value!) tok, TokSys description of tokamak or just bpdata(1:5,1:nbp) dphid, toroidal degrees between contour points On first call default = 5, then previously used value iplot, plot geometry of filament and probes (default = 0) OUTPUTS: g(i,j) = field at probe i, when rq(j), zq(j) is at phi = 0 dgdphi = derivative of g w.r.t. phi rq, zq, phi-phi(j) = toroidal coordinates for current path #j RESTRICTIONS: The effect of the NTM is modeled as a 1-A current filament running along a field line on the rational surface. If I_deficit [A] is current missing because of NTM then magnetic probe signals = -sign(jphi)*g*I_deficit [T] Dependencies \u00b6 qcontour","title":"ntm_field.m"},{"location":"function-guide/ntm/ntm_field_m/#ntm_fieldm","text":"","title":"ntm_field.m"},{"location":"function-guide/ntm/ntm_field_m/#basic-information","text":"SYNTAX: [g, dgdphi, phi, rq, zq] = ntm_field(equ, q, tok, dphid, iplot) PURPOSE: Calculate fields from NTM measured by magnetic probes For examples of use cases type >> ntm_field INPUTS: equ, structure with TokSys equilibrium q, safety factor of surface (should be rational value!) tok, TokSys description of tokamak or just bpdata(1:5,1:nbp) dphid, toroidal degrees between contour points On first call default = 5, then previously used value iplot, plot geometry of filament and probes (default = 0) OUTPUTS: g(i,j) = field at probe i, when rq(j), zq(j) is at phi = 0 dgdphi = derivative of g w.r.t. phi rq, zq, phi-phi(j) = toroidal coordinates for current path #j RESTRICTIONS: The effect of the NTM is modeled as a 1-A current filament running along a field line on the rational surface. If I_deficit [A] is current missing because of NTM then magnetic probe signals = -sign(jphi)*g*I_deficit [T]","title":"Basic Information"},{"location":"function-guide/ntm/ntm_field_m/#dependencies","text":"qcontour","title":"Dependencies"},{"location":"function-guide/ntm/qcontour_m/","text":"qcontour.m \u00b6 Basic Information \u00b6 SYNTAX: [rq, zq, psiq, rq2, zq2, psiq2] = qcontour(equ, q) h = qcontour(equ, q) for plot PURPOSE: Return contour where the safety factor equals q If nargout < 2, the contour is plotted INPUTS: equ, structure with TokSys equilibrium required fields are rg, zg, psizr, psibry, psimag, jphi q, safety factor OUTPUTS: rq, zq, coordinates for the q-surface [m] psiq, poloidal flux at the q-surface [Wb] rq2, zq2, psiq2, ditto for any extra q-surface inside first h, handles to plots of limiter, boundary, and q-surface EXAMPLE: equ = read_mds_eqdsk(149713,3,'EFIT02','D3D'); qcontour(equ, 3/2) plot q=3/2-surface (and boundary and limiter) Dependencies \u00b6","title":"qcontour.m"},{"location":"function-guide/ntm/qcontour_m/#qcontourm","text":"","title":"qcontour.m"},{"location":"function-guide/ntm/qcontour_m/#basic-information","text":"SYNTAX: [rq, zq, psiq, rq2, zq2, psiq2] = qcontour(equ, q) h = qcontour(equ, q) for plot PURPOSE: Return contour where the safety factor equals q If nargout < 2, the contour is plotted INPUTS: equ, structure with TokSys equilibrium required fields are rg, zg, psizr, psibry, psimag, jphi q, safety factor OUTPUTS: rq, zq, coordinates for the q-surface [m] psiq, poloidal flux at the q-surface [Wb] rq2, zq2, psiq2, ditto for any extra q-surface inside first h, handles to plots of limiter, boundary, and q-surface EXAMPLE: equ = read_mds_eqdsk(149713,3,'EFIT02','D3D'); qcontour(equ, 3/2) plot q=3/2-surface (and boundary and limiter)","title":"Basic Information"},{"location":"function-guide/ntm/qcontour_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/ntm/test_K1fun_m/","text":"test_K1fun.m \u00b6 Basic Information \u00b6 USAGE: test_K1fun PURPOSE: Template for testing and getting started with K1fun INPUTS: OUTPUTS: Graphs identical to figures 4 and 5 in report by Francis Perkins Also found in epmasw060404b-mrePhase.doc Dependencies \u00b6 K1fun","title":"test_K1fun.m"},{"location":"function-guide/ntm/test_K1fun_m/#test_k1funm","text":"","title":"test_K1fun.m"},{"location":"function-guide/ntm/test_K1fun_m/#basic-information","text":"USAGE: test_K1fun PURPOSE: Template for testing and getting started with K1fun INPUTS: OUTPUTS: Graphs identical to figures 4 and 5 in report by Francis Perkins Also found in epmasw060404b-mrePhase.doc","title":"Basic Information"},{"location":"function-guide/ntm/test_K1fun_m/#dependencies","text":"K1fun","title":"Dependencies"},{"location":"function-guide/ntm/test_MREfun_m/","text":"test_MREfun.m \u00b6 Basic Information \u00b6 USAGE: test_MREfun PURPOSE: Calculate dw/dt versus w & misalignment for many cases using MREfun INPUTS: ITER equilibrium is from 2010, corsica/v3.3/sob User selects (WITHIN THIS SCRIPT): delta_prime0, delta_prime if no ECCD tau_R, resistive diffusion time at q-surface delta_eccd, FWHM in meters j_boot_frac = j_boot/j_tot j_eccd_frac = j_eccd/j_boot wmarg, marginal island size in meters wmin, minimum island size for dwdt calculation wmax, maximum island size for dwdt calculation q, q at surface of interest (typically 2/1 or 3/2) OUTPUTS: Figures identical to published material by LaHaye RESTRICTIONS: METHOD: Dependencies \u00b6 MREfun read_corsica_flat_files K1fun plot_tok_geo","title":"test_MREfun.m"},{"location":"function-guide/ntm/test_MREfun_m/#test_mrefunm","text":"","title":"test_MREfun.m"},{"location":"function-guide/ntm/test_MREfun_m/#basic-information","text":"USAGE: test_MREfun PURPOSE: Calculate dw/dt versus w & misalignment for many cases using MREfun INPUTS: ITER equilibrium is from 2010, corsica/v3.3/sob User selects (WITHIN THIS SCRIPT): delta_prime0, delta_prime if no ECCD tau_R, resistive diffusion time at q-surface delta_eccd, FWHM in meters j_boot_frac = j_boot/j_tot j_eccd_frac = j_eccd/j_boot wmarg, marginal island size in meters wmin, minimum island size for dwdt calculation wmax, maximum island size for dwdt calculation q, q at surface of interest (typically 2/1 or 3/2) OUTPUTS: Figures identical to published material by LaHaye RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/ntm/test_MREfun_m/#dependencies","text":"MREfun read_corsica_flat_files K1fun plot_tok_geo","title":"Dependencies"},{"location":"function-guide/plasma_models/bootstrap_m/","text":"bootstrap.m \u00b6 Basic Information \u00b6 USAGE: cb = bootstrap(p, Te, ne, Zeff, Zi, Ti) PURPOSE: Calculate bootstrap current and related quantities INPUTS: p, profile information (see gsprofiles), must contain fields: psip, poloidal flux on flux surfaces [Wb] rsurf, radial center of flux surfaces [m] aminor, minor radius of flux surfaces [m] fpol, fpol = 2e-7*enclosed poloidal current [Wb] pres, pressure [Pa] q, safety factor ft, fraction trapped particles in collisionless limit Babs, Surface-averaged B field magnitude Te, electron temperature [eV] (default 1e3) ne, electron density [m-3] (default 1e19) Zeff, Effective ion charge (default 1) Zi, main ion charge (default 1) Ti, ion temperature (default Ti=Te) [eV] For all inputs size(*,2) must equal number of flux surfaces or 1 OUTPUTS: cb contains fields: sigma: 'Conductivity = cneo.*sigma_Sptz' cneo: 'Neoclassical correction' sigma_Sptz: 'Spitzer conductivity' nuestar: 'Electron collisionality' nuistar: 'Main ion collisionality' jB: 'Flux-surface average <jbs*B>' jboot: '<jbs*B>/<B>' Calculations are done with formulas found in: Neoclassical conductivity and bootstrap current formulas for general axisymmetric equilibria and arbitrary collisionality regime, Sauter et al, Physics of Plasmas 6, 2834 (1999) & erratum 9, 5140 (2002) Recreate figures in the paper by running bootstrap without arguments RESTRICTIONS: Potato orbits near axis are not considered Approximate treatment for multiple ion species","title":"bootstrap.m"},{"location":"function-guide/plasma_models/bootstrap_m/#bootstrapm","text":"","title":"bootstrap.m"},{"location":"function-guide/plasma_models/bootstrap_m/#basic-information","text":"USAGE: cb = bootstrap(p, Te, ne, Zeff, Zi, Ti) PURPOSE: Calculate bootstrap current and related quantities INPUTS: p, profile information (see gsprofiles), must contain fields: psip, poloidal flux on flux surfaces [Wb] rsurf, radial center of flux surfaces [m] aminor, minor radius of flux surfaces [m] fpol, fpol = 2e-7*enclosed poloidal current [Wb] pres, pressure [Pa] q, safety factor ft, fraction trapped particles in collisionless limit Babs, Surface-averaged B field magnitude Te, electron temperature [eV] (default 1e3) ne, electron density [m-3] (default 1e19) Zeff, Effective ion charge (default 1) Zi, main ion charge (default 1) Ti, ion temperature (default Ti=Te) [eV] For all inputs size(*,2) must equal number of flux surfaces or 1 OUTPUTS: cb contains fields: sigma: 'Conductivity = cneo.*sigma_Sptz' cneo: 'Neoclassical correction' sigma_Sptz: 'Spitzer conductivity' nuestar: 'Electron collisionality' nuistar: 'Main ion collisionality' jB: 'Flux-surface average <jbs*B>' jboot: '<jbs*B>/<B>' Calculations are done with formulas found in: Neoclassical conductivity and bootstrap current formulas for general axisymmetric equilibria and arbitrary collisionality regime, Sauter et al, Physics of Plasmas 6, 2834 (1999) & erratum 9, 5140 (2002) Recreate figures in the paper by running bootstrap without arguments RESTRICTIONS: Potato orbits near axis are not considered Approximate treatment for multiple ion species","title":"Basic Information"},{"location":"function-guide/plasma_models/calc_centroid_m/","text":"calc_centroid.m \u00b6 Basic Information \u00b6 SYNTAX: [centroid_r,centroid_z] = calc_centroid(shot_or_eq,time) PURPOSE: Compute current centroid from equilibrium data for shot. INPUT: shot_or_eq = one of the following: - shot number to fetch geqdsk data from 'EFIT01' - mdsplus data structure containing g-eqdsk info for multiple times - standard toksys equilibrium data structure time = time (s) to find centroid (required if g-eqdsk is from mdsplus or is mds data structure) - can be scalar or vector OUTPUT: centroid_r,centroid_z = centroid location (m) RESTRICTIONS: This was built for D3D, but should be extendable to other devices (might work now, but not tested.) Dependencies \u00b6 read_mds_eqdsk plasma_current wait","title":"calc_centroid.m"},{"location":"function-guide/plasma_models/calc_centroid_m/#calc_centroidm","text":"","title":"calc_centroid.m"},{"location":"function-guide/plasma_models/calc_centroid_m/#basic-information","text":"SYNTAX: [centroid_r,centroid_z] = calc_centroid(shot_or_eq,time) PURPOSE: Compute current centroid from equilibrium data for shot. INPUT: shot_or_eq = one of the following: - shot number to fetch geqdsk data from 'EFIT01' - mdsplus data structure containing g-eqdsk info for multiple times - standard toksys equilibrium data structure time = time (s) to find centroid (required if g-eqdsk is from mdsplus or is mds data structure) - can be scalar or vector OUTPUT: centroid_r,centroid_z = centroid location (m) RESTRICTIONS: This was built for D3D, but should be extendable to other devices (might work now, but not tested.)","title":"Basic Information"},{"location":"function-guide/plasma_models/calc_centroid_m/#dependencies","text":"read_mds_eqdsk plasma_current wait","title":"Dependencies"},{"location":"function-guide/plasma_models/setup_disturbances_m/","text":"setup_disturbances.m \u00b6 Basic Information \u00b6 SYNTAX: output_struct = setup_disturbances(disturbance_struct) PURPOSE: Set up the disturbance inputs to system model. INPUT: disturbance_struct = structure containing inputs defining disturbances, or string: enter 'help' to display available default disturbances, then enter string specifying one of these default disturbances to produce disturbance model in output structure - can use this self-documented structure as a starting point to customize input OUTPUT: output_struct = structure containing: - disturbance model if input is disturbance structure - disturbance structure corresponding to default disturbance if one of those specified as input (a field=NaN => value is not specified by disturbance model); RESTRICTIONS: METHOD: Default disturbances described in: [1] Leuer, et al, ELM Disturbances in DIII-D ITER Scenario 2 Demo Discharges, EPMjal100805iter_d3d_elm_dist Date: 5 Aug. 2010 [2] Leuer, et al, Interpretation of EFDA ITER Plasma Disturbances, EPMjal100830iter_ dist_efda, 24 Sept. 2010 Dependencies \u00b6 wait deriv resamplev","title":"setup_disturbances.m"},{"location":"function-guide/plasma_models/setup_disturbances_m/#setup_disturbancesm","text":"","title":"setup_disturbances.m"},{"location":"function-guide/plasma_models/setup_disturbances_m/#basic-information","text":"SYNTAX: output_struct = setup_disturbances(disturbance_struct) PURPOSE: Set up the disturbance inputs to system model. INPUT: disturbance_struct = structure containing inputs defining disturbances, or string: enter 'help' to display available default disturbances, then enter string specifying one of these default disturbances to produce disturbance model in output structure - can use this self-documented structure as a starting point to customize input OUTPUT: output_struct = structure containing: - disturbance model if input is disturbance structure - disturbance structure corresponding to default disturbance if one of those specified as input (a field=NaN => value is not specified by disturbance model); RESTRICTIONS: METHOD: Default disturbances described in: [1] Leuer, et al, ELM Disturbances in DIII-D ITER Scenario 2 Demo Discharges, EPMjal100805iter_d3d_elm_dist Date: 5 Aug. 2010 [2] Leuer, et al, Interpretation of EFDA ITER Plasma Disturbances, EPMjal100830iter_ dist_efda, 24 Sept. 2010","title":"Basic Information"},{"location":"function-guide/plasma_models/setup_disturbances_m/#dependencies","text":"wait deriv resamplev","title":"Dependencies"},{"location":"function-guide/plresp/calc_LR_m/","text":"calc_LR.m \u00b6 Basic Information \u00b6 SYNTAX: [tau,Lp,Res,eta,Lp0] = calc_LR(R0,a,kappa,li,Te,Zeff,lnlam,ne) PURPOSE: Calculate decay time for plasma INPUTS: R0 = major radius [m] a = minor radius [m] kappa = elongation li = (optional) internal inductance (default = 0.85) Te = electron temperature [eV] Zeff = (optional) effective charge state (default=1) lnlam = (optional) Coulomb logarithm ln(Lambda) (default=15) ne = (optional) electron density [m^-3] (if present, calculates lnlam from lnlam = 31 - ln(sqrt(ne)/Te) and ignores input lnlam) OUTPUTS: tau = resistive decay L/R time constant [s] Lp = plasma self inductance (calculated with sind.m) [H] Res = plasma resistance [Ohm] eta = resistivity [Ohm-m] Lp0 = Shafranov expression with kappa correction RESTRICTIONS: All quantities scalars now. METHOD: From Chen, p. 183: eta = 5.2e-5*Zeff*lnlam/(Te^1.5); Pl.restvty ohm-m Spitzer From Hutchinson, p. 19: lnlam = 31 - log(sqrt(ne)/Te); valid for Te>10 eV Dependencies \u00b6 selfind","title":"calc_LR.m"},{"location":"function-guide/plresp/calc_LR_m/#calc_lrm","text":"","title":"calc_LR.m"},{"location":"function-guide/plresp/calc_LR_m/#basic-information","text":"SYNTAX: [tau,Lp,Res,eta,Lp0] = calc_LR(R0,a,kappa,li,Te,Zeff,lnlam,ne) PURPOSE: Calculate decay time for plasma INPUTS: R0 = major radius [m] a = minor radius [m] kappa = elongation li = (optional) internal inductance (default = 0.85) Te = electron temperature [eV] Zeff = (optional) effective charge state (default=1) lnlam = (optional) Coulomb logarithm ln(Lambda) (default=15) ne = (optional) electron density [m^-3] (if present, calculates lnlam from lnlam = 31 - ln(sqrt(ne)/Te) and ignores input lnlam) OUTPUTS: tau = resistive decay L/R time constant [s] Lp = plasma self inductance (calculated with sind.m) [H] Res = plasma resistance [Ohm] eta = resistivity [Ohm-m] Lp0 = Shafranov expression with kappa correction RESTRICTIONS: All quantities scalars now. METHOD: From Chen, p. 183: eta = 5.2e-5*Zeff*lnlam/(Te^1.5); Pl.restvty ohm-m Spitzer From Hutchinson, p. 19: lnlam = 31 - log(sqrt(ne)/Te); valid for Te>10 eV","title":"Basic Information"},{"location":"function-guide/plresp/calc_LR_m/#dependencies","text":"selfind","title":"Dependencies"},{"location":"function-guide/simserver/build_shape_simserver_m/","text":"build_shape_simserver.m \u00b6 Basic Information \u00b6 USAGE: build_shape_simserver.m PURPOSE: Validate Simulink simserver simulation and generate executable version. INPUTS: Set on the command line: tokamak = string defining name of tokamak extension = string defining input script to execute (defining the input file input_bld_<tokamak>_sim_<extension>.m that will be executed. All other variables are set in that script.) Define in the input file: mdl = Simulink model name eg.'d3d_sim' shot = Shotnumber for equilibrium eg. 146970 read_shot_data = equil_time = Equilibrium time in sec. eg. 2.4 tval = interval [tmin,tmax] in which to do validation of constructed simserver efit_source = EFIT source eg. 'EFIT01' mds_server = noise_option = See help for setup_bld_d3d_sim disturbance_option = See help for setup_bld_d3d_sim ivalidate = See help for setup_bld_d3d_sim ichannelmap = See help for setup_bld_d3d_sim iconvergeq = See help for setup_bld_d3d_sim iverbose = See help for setup_bld_d3d_sim rtwcompile = set to 1 (default) to compile the executable simserver, else 0 (if the RTW license is available) master_cpu_cycle_time = PCS master cpu cycle time in us eg. 50 dt_simulink = Simulink cycle time in sec. 5.0e-6 avoids discontinuous derivatives; s state_shot = state_time = init_sim_time = patch_source = If 'shot' use the F-coil patch panel used in experiment, otherwise use this file. Rp_ext = Plasma resistance (ohms). If set, overrides Rp value that will make predicted flux induction agree with resistive flux consumption. Otherwise, do not define default_init_filename = name of file that will contain designeq currents can be generated using get_sim_initial_currents.m objdir = obj_file = pcs_dir = Directory containing infra and INTEL_DIR directories intel_dir = ncpus = master_cpu_num = cpu_order = cycle_times = (us) calc_delay_times= (us) cmd_delay_times = (us) use_fpcom = OUTPUTS: all variables needed to set up the simserver plant model and, if rtwcompile=1, an executable version of the simserver RESTRICTIONS: Requires executing the PCS in closed loop with the plant simulation as part of the build process. Dependencies \u00b6 setup_io_PCS_Sfn","title":"build_shape_simserver.m"},{"location":"function-guide/simserver/build_shape_simserver_m/#build_shape_simserverm","text":"","title":"build_shape_simserver.m"},{"location":"function-guide/simserver/build_shape_simserver_m/#basic-information","text":"USAGE: build_shape_simserver.m PURPOSE: Validate Simulink simserver simulation and generate executable version. INPUTS: Set on the command line: tokamak = string defining name of tokamak extension = string defining input script to execute (defining the input file input_bld_<tokamak>_sim_<extension>.m that will be executed. All other variables are set in that script.) Define in the input file: mdl = Simulink model name eg.'d3d_sim' shot = Shotnumber for equilibrium eg. 146970 read_shot_data = equil_time = Equilibrium time in sec. eg. 2.4 tval = interval [tmin,tmax] in which to do validation of constructed simserver efit_source = EFIT source eg. 'EFIT01' mds_server = noise_option = See help for setup_bld_d3d_sim disturbance_option = See help for setup_bld_d3d_sim ivalidate = See help for setup_bld_d3d_sim ichannelmap = See help for setup_bld_d3d_sim iconvergeq = See help for setup_bld_d3d_sim iverbose = See help for setup_bld_d3d_sim rtwcompile = set to 1 (default) to compile the executable simserver, else 0 (if the RTW license is available) master_cpu_cycle_time = PCS master cpu cycle time in us eg. 50 dt_simulink = Simulink cycle time in sec. 5.0e-6 avoids discontinuous derivatives; s state_shot = state_time = init_sim_time = patch_source = If 'shot' use the F-coil patch panel used in experiment, otherwise use this file. Rp_ext = Plasma resistance (ohms). If set, overrides Rp value that will make predicted flux induction agree with resistive flux consumption. Otherwise, do not define default_init_filename = name of file that will contain designeq currents can be generated using get_sim_initial_currents.m objdir = obj_file = pcs_dir = Directory containing infra and INTEL_DIR directories intel_dir = ncpus = master_cpu_num = cpu_order = cycle_times = (us) calc_delay_times= (us) cmd_delay_times = (us) use_fpcom = OUTPUTS: all variables needed to set up the simserver plant model and, if rtwcompile=1, an executable version of the simserver RESTRICTIONS: Requires executing the PCS in closed loop with the plant simulation as part of the build process.","title":"Basic Information"},{"location":"function-guide/simserver/build_shape_simserver_m/#dependencies","text":"setup_io_PCS_Sfn","title":"Dependencies"},{"location":"function-guide/simserver/calc_Ip_gains_m/","text":"calc_Ip_gains.m \u00b6 Basic Information \u00b6 SYNTAX: Ip_gains = calc_Ip_gains(tok_system,vacuum_objs,cccirc, ... pfcoils,IPCS_to_Istates,figure_num) PURPOSE: Calculate \"ohmic distribution\" of coil currents to use as gains to drive Ip in PCS control. INPUT: tok_system = model of tokamak system produced by build_tokamak_system.m vacuum_objs= vacuum model objects for this tokamak cccirc = connection vector pfcoils = subset of PF coils to use in ohmic calculation IPCS_to_Istates = mapping from coil indices in PCS to corresp. states in models contained in tok_system (examples: for KSTAR it's [1:7], for EAST it's [1 7 2 8 3 9 4 10 5 11 6 12]) figure_num = figure number to start plotting from (default = no plots) OUTPUT: Ip_gains = gains to enter into M-matrix in PCS RESTRICTIONS: Dependencies \u00b6 ohmic_dist","title":"calc_Ip_gains.m"},{"location":"function-guide/simserver/calc_Ip_gains_m/#calc_ip_gainsm","text":"","title":"calc_Ip_gains.m"},{"location":"function-guide/simserver/calc_Ip_gains_m/#basic-information","text":"SYNTAX: Ip_gains = calc_Ip_gains(tok_system,vacuum_objs,cccirc, ... pfcoils,IPCS_to_Istates,figure_num) PURPOSE: Calculate \"ohmic distribution\" of coil currents to use as gains to drive Ip in PCS control. INPUT: tok_system = model of tokamak system produced by build_tokamak_system.m vacuum_objs= vacuum model objects for this tokamak cccirc = connection vector pfcoils = subset of PF coils to use in ohmic calculation IPCS_to_Istates = mapping from coil indices in PCS to corresp. states in models contained in tok_system (examples: for KSTAR it's [1:7], for EAST it's [1 7 2 8 3 9 4 10 5 11 6 12]) figure_num = figure number to start plotting from (default = no plots) OUTPUT: Ip_gains = gains to enter into M-matrix in PCS RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/simserver/calc_Ip_gains_m/#dependencies","text":"ohmic_dist","title":"Dependencies"},{"location":"function-guide/simserver/calc_equil_diags_m/","text":"calc_equil_diags.m \u00b6 Basic Information \u00b6 SYNTAX:[coils,psi_loops,B_probes,rogloops,Ip] = ... calc_equil_diags(tok_system,vacuum_objs) PURPOSE: Compute magnetic diagnostics associated with a plasma equilibrium. INPUT: tok_system = structure containing system model vacuum_objs = structure containing green functions to magnetic diagnostics (mpl, gpb, mlc, gbc) OUTPUT: coils = current in coils (A; in order of internal states, uncollapsed) psi_loops = flux at flux loops (Wb) B_probes = field at magnetic probes (T) rogloops = current measured by Rogowski loops (Amps) Ip = plasma current (Amps) RESTRICTIONS: Note that this function doesn't produce equilibrium values for loop voltages or for \"nonstandard\" outputs. Dependencies \u00b6 plasma_current","title":"calc_equil_diags.m"},{"location":"function-guide/simserver/calc_equil_diags_m/#calc_equil_diagsm","text":"","title":"calc_equil_diags.m"},{"location":"function-guide/simserver/calc_equil_diags_m/#basic-information","text":"SYNTAX:[coils,psi_loops,B_probes,rogloops,Ip] = ... calc_equil_diags(tok_system,vacuum_objs) PURPOSE: Compute magnetic diagnostics associated with a plasma equilibrium. INPUT: tok_system = structure containing system model vacuum_objs = structure containing green functions to magnetic diagnostics (mpl, gpb, mlc, gbc) OUTPUT: coils = current in coils (A; in order of internal states, uncollapsed) psi_loops = flux at flux loops (Wb) B_probes = field at magnetic probes (T) rogloops = current measured by Rogowski loops (Amps) Ip = plasma current (Amps) RESTRICTIONS: Note that this function doesn't produce equilibrium values for loop voltages or for \"nonstandard\" outputs.","title":"Basic Information"},{"location":"function-guide/simserver/calc_equil_diags_m/#dependencies","text":"plasma_current","title":"Dependencies"},{"location":"function-guide/simserver/get_sim_initial_currents_m/","text":"get_sim_initial_currents.m \u00b6 Basic Information \u00b6 USAGE: [nc, i_init, i_ip] = get_sim_initial_currents(tokamak,shot,time,source,servers) PURPOSE: Retrieve initial currents and write simserver initialization file INPUTS: tokamak: tokamak string shot: shotnumber integer time: array of times esource: efit tree server: mdsplus server fsource: F-coil data source 'efit' or 'exp' OUTPUTS: RESTRICTIONS: Only setup for D3D tokamak (will generalize as necessary) Dependencies \u00b6 write_simserver_init_file cc_efit_to_tok get_signals read_eq","title":"get_sim_initial_currents.m"},{"location":"function-guide/simserver/get_sim_initial_currents_m/#get_sim_initial_currentsm","text":"","title":"get_sim_initial_currents.m"},{"location":"function-guide/simserver/get_sim_initial_currents_m/#basic-information","text":"USAGE: [nc, i_init, i_ip] = get_sim_initial_currents(tokamak,shot,time,source,servers) PURPOSE: Retrieve initial currents and write simserver initialization file INPUTS: tokamak: tokamak string shot: shotnumber integer time: array of times esource: efit tree server: mdsplus server fsource: F-coil data source 'efit' or 'exp' OUTPUTS: RESTRICTIONS: Only setup for D3D tokamak (will generalize as necessary)","title":"Basic Information"},{"location":"function-guide/simserver/get_sim_initial_currents_m/#dependencies","text":"write_simserver_init_file cc_efit_to_tok get_signals read_eq","title":"Dependencies"},{"location":"function-guide/simserver/make_PCS_V_trajectory_m/","text":"make_PCS_V_trajectory.m \u00b6 Basic Information \u00b6 SYNTAX: Vtraj= ... make_PCS_V_trajectory(Ictraj,Iptraj,xtraj,Vlimits,diag_objects) PURPOSE: Make voltage trajectory from user-defined current trajectories for SC coils - prototype for implementation in PCS. This version uses polynomials to represent sections between vertices in PCS waveforms. INPUT: Ictraj = current trajectories specified by user, each column represents a different coil - PF [1,2,3,4,5,6,7,8,11,12,13,14] Iptraj = plasma current trajectory xtraj = x values of waveform vertices for coil trajectories Vlimits = nx2 matrix = [Vmin, Vmax], voltage limits for coil circuits diag_objects = structure, contains mutual inductances Mcc,Mcp,Mcv,Mvp with rows/cols corresponding to Ictraj,Ivtraj currents OUTPUT: Vtraj = voltage trajectories in same (PCS) order RESTRICTIONS: Assumes coils are superconducting, so coil resistance is not accounted for in voltage trajectory calculation. Dependencies \u00b6 resamplev wait","title":"make_PCS_V_trajectory.m"},{"location":"function-guide/simserver/make_PCS_V_trajectory_m/#make_pcs_v_trajectorym","text":"","title":"make_PCS_V_trajectory.m"},{"location":"function-guide/simserver/make_PCS_V_trajectory_m/#basic-information","text":"SYNTAX: Vtraj= ... make_PCS_V_trajectory(Ictraj,Iptraj,xtraj,Vlimits,diag_objects) PURPOSE: Make voltage trajectory from user-defined current trajectories for SC coils - prototype for implementation in PCS. This version uses polynomials to represent sections between vertices in PCS waveforms. INPUT: Ictraj = current trajectories specified by user, each column represents a different coil - PF [1,2,3,4,5,6,7,8,11,12,13,14] Iptraj = plasma current trajectory xtraj = x values of waveform vertices for coil trajectories Vlimits = nx2 matrix = [Vmin, Vmax], voltage limits for coil circuits diag_objects = structure, contains mutual inductances Mcc,Mcp,Mcv,Mvp with rows/cols corresponding to Ictraj,Ivtraj currents OUTPUT: Vtraj = voltage trajectories in same (PCS) order RESTRICTIONS: Assumes coils are superconducting, so coil resistance is not accounted for in voltage trajectory calculation.","title":"Basic Information"},{"location":"function-guide/simserver/make_PCS_V_trajectory_m/#dependencies","text":"resamplev wait","title":"Dependencies"},{"location":"function-guide/simserver/make_pf_trajectory_m/","text":"make_pf_trajectory.m \u00b6 Basic Information \u00b6 SYNTAX: [Ictraj,Vtraj,tItraj]=make_pf_trajectory(tok_system,vacuum_objs,... pfcoils_oh,PFmax,Ipref,PF_init,figure_num) PURPOSE: Construct PF coil current and voltage trajectories. INPUT: tok_system = model of tokamak system produced by build_tokamak_system.m vacuum_objs= vacuum model objects for this tokamak pfcoils_oh = indices from PF coils [1:ncc] to use for Ip (\"ohmic\") drive PFmax = maximum current allowed in PF coils, must correspond to order of currents represented by tok_system.cc0 Ipref = 2 column matrix, 1st col=time(s), 2nd = Ip reference (amps) PF_init = approximate PF coil initial conditions (length ncc) figure_num = figure number to start plotting from (default = no plots) OUTPUT: Ictraj = trajectory of all coil currents Vtraj = trajectory of voltages to produce those currents tItraj = time values corresponding to data in Ictraj, Vtraj RESTRICTIONS: Code computes initial condition closest to PF_init and compatible with trajectory. METHOD: See M.L.Walker, Calculation of Feedforward Current and Voltage Trajectories for Shape and Plasma Current Control, Engineering Physics Memo, EPM??? Dependencies \u00b6 ohmic_dist1 wait resamplev","title":"make_pf_trajectory.m"},{"location":"function-guide/simserver/make_pf_trajectory_m/#make_pf_trajectorym","text":"","title":"make_pf_trajectory.m"},{"location":"function-guide/simserver/make_pf_trajectory_m/#basic-information","text":"SYNTAX: [Ictraj,Vtraj,tItraj]=make_pf_trajectory(tok_system,vacuum_objs,... pfcoils_oh,PFmax,Ipref,PF_init,figure_num) PURPOSE: Construct PF coil current and voltage trajectories. INPUT: tok_system = model of tokamak system produced by build_tokamak_system.m vacuum_objs= vacuum model objects for this tokamak pfcoils_oh = indices from PF coils [1:ncc] to use for Ip (\"ohmic\") drive PFmax = maximum current allowed in PF coils, must correspond to order of currents represented by tok_system.cc0 Ipref = 2 column matrix, 1st col=time(s), 2nd = Ip reference (amps) PF_init = approximate PF coil initial conditions (length ncc) figure_num = figure number to start plotting from (default = no plots) OUTPUT: Ictraj = trajectory of all coil currents Vtraj = trajectory of voltages to produce those currents tItraj = time values corresponding to data in Ictraj, Vtraj RESTRICTIONS: Code computes initial condition closest to PF_init and compatible with trajectory. METHOD: See M.L.Walker, Calculation of Feedforward Current and Voltage Trajectories for Shape and Plasma Current Control, Engineering Physics Memo, EPM???","title":"Basic Information"},{"location":"function-guide/simserver/make_pf_trajectory_m/#dependencies","text":"ohmic_dist1 wait resamplev","title":"Dependencies"},{"location":"function-guide/simserver/make_scenario_m/","text":"make_scenario.m \u00b6 Basic Information \u00b6 SYNTAX: [Ictraj_PCS,Vtraj_PCS] = make_scenario(scenario_data,debug) PURPOSE: Make the input files needed by PCS and simserver to run a particular plasma scenario simulation. (Only works for EAST and KSTAR right now.) INPUT: in scenario_data structure: scenario_name = name(string) of scenario to build setup files for tok_system = tokamak (and plasma) model structure vacuum_objs = tokamak basic geometry objects structure IPCS_to_Istates = index vector mapping coils in PCS order to states of the linearized model, IPCS_to_Istates(i) = k, where i is the number of the PF coil, and k is the corresponding state index (include only coils intended to have nonzero equil. current) Istates_to_IPCS = index vector mapping coil current states to coils in PCS, Istates_to_IPCS(i) = k, where i is the index of the state, and k is the number of the PF coil Ipref = trajectory for plasma current (1st column=time, 2nd=Ip) Icref = trajectory for coil currents, 1st col.=time, remaining columns are PF currents in PCS order (required for vacuum, else not used) PF_state_names_PCS = names of PF current states, in PCS order PFmax = vector maximum currents allowed in PF coils iplcirc = set equal to 1 to include plasma circuit eqn in model cccirc = coil connection definitions pfcoils = subset of PF coils to compute trajectories for = either indices into vacuum_objs.fcnames or names in vacuum_objs.fcnames vacuum_model = flag, 0=vacuum model in tok_system, 1=plasma model ip_init = initial value for Ip dt_rz = time step for R and Z feedback control Gp_z,Gd_z,Gi_z = gains for Z control taup_z,taud_z,taui_z = time constants for Z control full_system = set to 1 to get full set of outputs, else 0 Vlimits = upper and lower bounds on coil voltages idx_vcntl_ckts = indices of vert. cntrl coils, after circuits connected debug = set to 1 to get debug plots of trajectories OUTPUT: Ictraj_PCS Vctraj_PCS FILES (all with scenario_name in place of #): #.log = log showing what is produced and how to use #_PF*_Itraj.dat = PF and Ip trajectories (consistent with Ip trajectory) #_Ip_traj.dat = Ip trajectory #_Vtraj.dat = voltage trajectories #_PCS_mutuals.dat = matrices needed by PCS to compute V trajs #_I_init.dat = file to use to initialize simserver currents at other than default (equilibrium) values RESTRICTIONS: (1) Assumes that first 3 sets of diagnostics are: coils, flux loops, probes (2) Works only when ohmic distribution currents all the same sign right now. Dependencies \u00b6 make_pf_trajectory calc_PCS_PID_response make_simserver_dat sysinfo wait make_PCS_V_trajectory resamplev","title":"make_scenario.m"},{"location":"function-guide/simserver/make_scenario_m/#make_scenariom","text":"","title":"make_scenario.m"},{"location":"function-guide/simserver/make_scenario_m/#basic-information","text":"SYNTAX: [Ictraj_PCS,Vtraj_PCS] = make_scenario(scenario_data,debug) PURPOSE: Make the input files needed by PCS and simserver to run a particular plasma scenario simulation. (Only works for EAST and KSTAR right now.) INPUT: in scenario_data structure: scenario_name = name(string) of scenario to build setup files for tok_system = tokamak (and plasma) model structure vacuum_objs = tokamak basic geometry objects structure IPCS_to_Istates = index vector mapping coils in PCS order to states of the linearized model, IPCS_to_Istates(i) = k, where i is the number of the PF coil, and k is the corresponding state index (include only coils intended to have nonzero equil. current) Istates_to_IPCS = index vector mapping coil current states to coils in PCS, Istates_to_IPCS(i) = k, where i is the index of the state, and k is the number of the PF coil Ipref = trajectory for plasma current (1st column=time, 2nd=Ip) Icref = trajectory for coil currents, 1st col.=time, remaining columns are PF currents in PCS order (required for vacuum, else not used) PF_state_names_PCS = names of PF current states, in PCS order PFmax = vector maximum currents allowed in PF coils iplcirc = set equal to 1 to include plasma circuit eqn in model cccirc = coil connection definitions pfcoils = subset of PF coils to compute trajectories for = either indices into vacuum_objs.fcnames or names in vacuum_objs.fcnames vacuum_model = flag, 0=vacuum model in tok_system, 1=plasma model ip_init = initial value for Ip dt_rz = time step for R and Z feedback control Gp_z,Gd_z,Gi_z = gains for Z control taup_z,taud_z,taui_z = time constants for Z control full_system = set to 1 to get full set of outputs, else 0 Vlimits = upper and lower bounds on coil voltages idx_vcntl_ckts = indices of vert. cntrl coils, after circuits connected debug = set to 1 to get debug plots of trajectories OUTPUT: Ictraj_PCS Vctraj_PCS FILES (all with scenario_name in place of #): #.log = log showing what is produced and how to use #_PF*_Itraj.dat = PF and Ip trajectories (consistent with Ip trajectory) #_Ip_traj.dat = Ip trajectory #_Vtraj.dat = voltage trajectories #_PCS_mutuals.dat = matrices needed by PCS to compute V trajs #_I_init.dat = file to use to initialize simserver currents at other than default (equilibrium) values RESTRICTIONS: (1) Assumes that first 3 sets of diagnostics are: coils, flux loops, probes (2) Works only when ohmic distribution currents all the same sign right now.","title":"Basic Information"},{"location":"function-guide/simserver/make_scenario_m/#dependencies","text":"make_pf_trajectory calc_PCS_PID_response make_simserver_dat sysinfo wait make_PCS_V_trajectory resamplev","title":"Dependencies"},{"location":"function-guide/simserver/make_simserver_dat_m/","text":"make_simserver_dat.m \u00b6 Basic Information \u00b6 SYNTAX: make_simserver_dat(init_file,Icoil0,Ip0) PURPOSE: Build input file to simserver to specify initial coil currents. This function is for generic simserver. To generate a patch panel file for input to d3d simserver, use make_d3d_simserver_dat. INPUT: init_file = name of file to create Icoil0 = initial coil currents (Amps) Ip0 = initial plasma current (Amps) OUTPUT: writes out data into file \"init_file\" Dependencies \u00b6","title":"make_simserver_dat.m"},{"location":"function-guide/simserver/make_simserver_dat_m/#make_simserver_datm","text":"","title":"make_simserver_dat.m"},{"location":"function-guide/simserver/make_simserver_dat_m/#basic-information","text":"SYNTAX: make_simserver_dat(init_file,Icoil0,Ip0) PURPOSE: Build input file to simserver to specify initial coil currents. This function is for generic simserver. To generate a patch panel file for input to d3d simserver, use make_d3d_simserver_dat. INPUT: init_file = name of file to create Icoil0 = initial coil currents (Amps) Ip0 = initial plasma current (Amps) OUTPUT: writes out data into file \"init_file\"","title":"Basic Information"},{"location":"function-guide/simserver/make_simserver_dat_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/simserver/ohmic_dist1_m/","text":"ohmic_dist1.m \u00b6 Basic Information \u00b6 USAGE: [ohmic_dist_data] = ohmic_dist1(ohmic_calc_inputs) PURPOSE: Calculates the Best Ohmic current distribution for F coils INPUTS: [default] ohmic_calc_inputs = structure, containing one or more of following: cccirc = coil connection vector Pcc = mapping from coil states to all PF coils (only one of cccirc or Pcc should be provided) pfcoils_oh = indices of PF coil to use in ohmic distribution flux0 = target flux at center, scaler (Vs) [1] bz_targ = target vertical field scaler or (npt,1) (T) [0] ic_min = minimum coil currents (A), either full set or current states ic_max = maximum coil currents (A), either full set or current states vacuum_objs = vacuum model objects for the device npt = Number of points on boundary for optimization [101] r_plasma = Major radius of breakdown circle (m) z_plasma = Z Location of center of breakdown circle (m) [0] rpt, zpt = R,Z Plasma boundary Points (m) (alternatively, use a,k,d below) a_plasma = Minor radius of breakdown circle (only needed if no rpt,zpt) k_plasma = Elongation of breakdown circle (only needed if no rpt,zpt) [1] d_plasma = Triangularity of breakdown circle(only needed if no rpt,zpt)[0] minimize_i = 0.1; Includes currents in opts. to reduce +-I [0] minimize_i weights how much I smooting to perform Value of 0 to 0.1 are reasonable pause_it= 1; => pause between figures [0]; figure_num = optional, if not provided then no plotting OUTPUTS: ohmic_dist_data = structure, containing: ic_ohmic = Optimum Ohmic Terminal Current vector (A) ict_ohmic= Optimum Ohmic Amp-Turn Current vector (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) figure_num = updated figure number (if figure_num is input) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m now very similar to CUROPT by including Bz and constraints on currents now calculates based on terminal currents rather than (amp-turns) Dependencies \u00b6 pause_fig plot_box proj_turn dee_shape wait plot_tok_geo","title":"ohmic_dist1.m"},{"location":"function-guide/simserver/ohmic_dist1_m/#ohmic_dist1m","text":"","title":"ohmic_dist1.m"},{"location":"function-guide/simserver/ohmic_dist1_m/#basic-information","text":"USAGE: [ohmic_dist_data] = ohmic_dist1(ohmic_calc_inputs) PURPOSE: Calculates the Best Ohmic current distribution for F coils INPUTS: [default] ohmic_calc_inputs = structure, containing one or more of following: cccirc = coil connection vector Pcc = mapping from coil states to all PF coils (only one of cccirc or Pcc should be provided) pfcoils_oh = indices of PF coil to use in ohmic distribution flux0 = target flux at center, scaler (Vs) [1] bz_targ = target vertical field scaler or (npt,1) (T) [0] ic_min = minimum coil currents (A), either full set or current states ic_max = maximum coil currents (A), either full set or current states vacuum_objs = vacuum model objects for the device npt = Number of points on boundary for optimization [101] r_plasma = Major radius of breakdown circle (m) z_plasma = Z Location of center of breakdown circle (m) [0] rpt, zpt = R,Z Plasma boundary Points (m) (alternatively, use a,k,d below) a_plasma = Minor radius of breakdown circle (only needed if no rpt,zpt) k_plasma = Elongation of breakdown circle (only needed if no rpt,zpt) [1] d_plasma = Triangularity of breakdown circle(only needed if no rpt,zpt)[0] minimize_i = 0.1; Includes currents in opts. to reduce +-I [0] minimize_i weights how much I smooting to perform Value of 0 to 0.1 are reasonable pause_it= 1; => pause between figures [0]; figure_num = optional, if not provided then no plotting OUTPUTS: ohmic_dist_data = structure, containing: ic_ohmic = Optimum Ohmic Terminal Current vector (A) ict_ohmic= Optimum Ohmic Amp-Turn Current vector (A-Turns) fl = Flux on Boundary (Vs) br = Br-field on Boundary (T) bz = Bz-field on Boundary (T) rpt zpt = R,Z boundary points used in analysis (m) err = Average Error in booundary flux value (Delta_Vs/Vs) figure_num = updated figure number (if figure_num is input) Plots: figure(1): geometry -- Flux contour -- cccirc numbering -- coil current figure(2): geometry -- B-field contour -- A-turn for full coil system figure(3): flux variation around circumference of breakdown circle figure(4): B-field variation around circumference of breakdown circle RESTRICTIONS: METHOD: Determine optimum Coil current distribution using least square technique to produce a uniform 1 Vs flux on the boundary see ohmic_dist.m now very similar to CUROPT by including Bz and constraints on currents now calculates based on terminal currents rather than (amp-turns)","title":"Basic Information"},{"location":"function-guide/simserver/ohmic_dist1_m/#dependencies","text":"pause_fig plot_box proj_turn dee_shape wait plot_tok_geo","title":"Dependencies"},{"location":"function-guide/simserver/pack_io_PCS_data_m/","text":"pack_io_PCS_data.m \u00b6 Basic Information \u00b6 SYNTAX: io_PCS_data = pack_io_PCS_data(pcs_connect_data) PURPOSE: Utility function to pack the data from connection data structure into one long vector for input to io_PCS S-function. INPUT: pcs_connect_data = data structure with separate fields defined by variables listed in comment header of io_PCS.c OUTPUT: io_PCS_data = single vector containing the same information Dependencies \u00b6 wait","title":"pack_io_PCS_data.m"},{"location":"function-guide/simserver/pack_io_PCS_data_m/#pack_io_pcs_datam","text":"","title":"pack_io_PCS_data.m"},{"location":"function-guide/simserver/pack_io_PCS_data_m/#basic-information","text":"SYNTAX: io_PCS_data = pack_io_PCS_data(pcs_connect_data) PURPOSE: Utility function to pack the data from connection data structure into one long vector for input to io_PCS S-function. INPUT: pcs_connect_data = data structure with separate fields defined by variables listed in comment header of io_PCS.c OUTPUT: io_PCS_data = single vector containing the same information","title":"Basic Information"},{"location":"function-guide/simserver/pack_io_PCS_data_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/simserver/read_simserver_init_file_m/","text":"read_simserver_init_file.m \u00b6 Basic Information \u00b6 USAGE: [i_init, nc, i_ip ] = read_simserver_init_file(sim_init_filename,inc_plasma,system); PURPOSE: Read simserver current initialization file. Replaces code in sim_device_init INPUTS: sim_init_filename: name of initialization file inc_plasma: set=1 to include an initial condition for the Ip equation system: toksys system model OUTPUTS: i_init: initial values of conductor currents [PF_coils, vessel, Ip] nc: number of total PF-coil currents i_ip: initial value of Ip RESTRICTIONS: Returns zeros for vessel currents right now. Could be extended in the future to also read and return vessel currents from the initial conditions file. Dependencies \u00b6","title":"read_simserver_init_file.m"},{"location":"function-guide/simserver/read_simserver_init_file_m/#read_simserver_init_filem","text":"","title":"read_simserver_init_file.m"},{"location":"function-guide/simserver/read_simserver_init_file_m/#basic-information","text":"USAGE: [i_init, nc, i_ip ] = read_simserver_init_file(sim_init_filename,inc_plasma,system); PURPOSE: Read simserver current initialization file. Replaces code in sim_device_init INPUTS: sim_init_filename: name of initialization file inc_plasma: set=1 to include an initial condition for the Ip equation system: toksys system model OUTPUTS: i_init: initial values of conductor currents [PF_coils, vessel, Ip] nc: number of total PF-coil currents i_ip: initial value of Ip RESTRICTIONS: Returns zeros for vessel currents right now. Could be extended in the future to also read and return vessel currents from the initial conditions file.","title":"Basic Information"},{"location":"function-guide/simserver/read_simserver_init_file_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/simserver/setup_io_PCS_Sfn_m/","text":"setup_io_PCS_Sfn.m \u00b6 Basic Information \u00b6 USAGE: setup_io_PCS_Sfn.m PURPOSE: set inputs for io_PCS S-function INPUTS: tokamak = name of device, e.g., 'd3d', 'east', 'kstar', etc. shot(OR shotnum) = number of shot start_time = starting time for simulation of what you care about init_sim_time = initial simulation time (seconds) = any time before baseline calc in PCS ncpus = number of realtime cpus executing (or being simulated) in the PCS master_cpu_num = number of cpu whos cycle time defines the multiplier for all cpus cpu_order = order to feed data to cpus (master cpu first) cycle_times = cycle times of real-time cpus, in order 1...ncpus calc_delay_times = computational delay for each cpu, entry i corresponds to cpu i cmd_delay_times = delay in sending commands from each cpu, entry i corresponds to cpu i NUM_SIM_OUTPUTS = number of PCS channels (width of diags signal fed to the PCS interface block) pcs_channels2 = indices of PCS channels corresponding to simulated signals fed to the PCS interface block's input, indexed from 1 (see input_data2.m in INTEL_DIR or INTEL64_DIR or run get_input_channels.m) pcs_channels2_names = signal names corresponding to indices in pcs_channels (optional, used only for human understanding) simulation_includes.m = file containing definitions of command signal indices in PCS and conversion factors from counts into DAC to command voltages OUTPUTS: pcs_connect_data = a structure with fields: ncpus integer = number of cpus that PCS is compiled for master_cpu_num integer = master cpu number in PCS start_time float = time in seconds to jump to in beginning simulation (optional, default 0) init_sim_time floag = time in seconds at which to start the process for baseline calculation shotnum integer = shot number to get PCS initial condition data from DA_GAIN = multiplier that converts digitizer volts to counts Note: PCS sends out digitizer counts (not volts) Further, PCS and matlab simulation maintain the VME ranges: 4096 counts = -10 to 10 V But, sysmain_master.h multiplies commands by 16 to get DAC* commands in 16-bit count range So count-to-volt conversion is (20/4096)*(1/16)=10.0/32767.0=3.0518e-04, which is the inherent number (IN) for DAC* commands, DA_GAIN = 1/IN. IN values are documented in simulation_includes.h. use_fpcom = flag, if 1 use fpcom (unclipped) data for commands instead of intcom (optional, default=0) cycle_times float(ncpu) = cycle times of real-time cpus, in order 1...ncpus calc_delay_times float(ncpu) = computational delay for each cpu, entry i corresponds to cpu i cmd_delay_times = delay in sending commands, entry i corresponds to cpu i num_pcs_inputs integer = number of PCS channels (defines input port size) pcs_channels integer(num_pcs_inputs) = indices of PCS channels input to io_PCS; these are <device>_sim outputs, indexed from 1 (see input_data.h) pcs_channel_names = names of signals corresponding to pcs_channels (for human readability) num_commands = number of intcommand channels (defines output port size) intcom_channels = indices of intcommand channels defining PCS Sfn output, indexed from 1 intcom_cpus = cpu numbers where intcom values are coming from, indexed from 1 cpu_order = order to feed data to cpus (master cpu first) OTHER VARIABLES pcs_channels_ids integer(num_pcs_inputs) = used in <device>_simX_model Selector block to id PCS variables for Diag. Physics Out port RESTRICTIONS: METHOD Script initializes variables needed by io_PCS S-function. Inputs are needed from both <device>_sim and the PCS compiled to use in the simulation. <device>_sim code is found in this directory. PCS header files are found in the user's PCS directory by default The intention is to allow for changes in the PCS to be made without bothering this workflow. Inputs to <device>_sim.mdl are PCS commands. Outputs are signals sent to the pcs. Conversely, inputs to io_PCS are <device>_sim signals and outputs are PCS commands. The signals generated by <device>_sim are defined in SIMULATION_TO_PCS.h. The commands generated by io_PCS are defined in input_data2.h <device>_sim_struct.output_signals contains PCS pointnames for the signals in the simulink model, <device>_sim_struct.output_signals begins with <device>_system.output_signals(:,1) and continues with signals added in <device>_sim2.mdl <device>_sim_struct.input_signals: These are commands from the PCS used to identify the intcom_channels, which are indices of the Sfn output DAC are actual commands that go out. FSF is the command calculated, FSC is the clipped value and should agree with DAC IPFEPS is the command calculated and IPCEPS is the clipped value pcsinputs2 are the macros extracted from input_data2.h pcs_channels2 are the indices of the macros for the pcs therefore, pcsinputs2(pcs_channels2) are the macros for the pcs To extract the indices of <device>_sim_struct.output_signals we need for the pcs from the simulation data, we match pcsinputs2(pcs_channels2) with <device>_sim_struct.output_signals Dependencies \u00b6 get_cpu_indices get_command_indices get_command_da_gain make_function truncate_header","title":"setup_io_PCS_Sfn.m"},{"location":"function-guide/simserver/setup_io_PCS_Sfn_m/#setup_io_pcs_sfnm","text":"","title":"setup_io_PCS_Sfn.m"},{"location":"function-guide/simserver/setup_io_PCS_Sfn_m/#basic-information","text":"USAGE: setup_io_PCS_Sfn.m PURPOSE: set inputs for io_PCS S-function INPUTS: tokamak = name of device, e.g., 'd3d', 'east', 'kstar', etc. shot(OR shotnum) = number of shot start_time = starting time for simulation of what you care about init_sim_time = initial simulation time (seconds) = any time before baseline calc in PCS ncpus = number of realtime cpus executing (or being simulated) in the PCS master_cpu_num = number of cpu whos cycle time defines the multiplier for all cpus cpu_order = order to feed data to cpus (master cpu first) cycle_times = cycle times of real-time cpus, in order 1...ncpus calc_delay_times = computational delay for each cpu, entry i corresponds to cpu i cmd_delay_times = delay in sending commands from each cpu, entry i corresponds to cpu i NUM_SIM_OUTPUTS = number of PCS channels (width of diags signal fed to the PCS interface block) pcs_channels2 = indices of PCS channels corresponding to simulated signals fed to the PCS interface block's input, indexed from 1 (see input_data2.m in INTEL_DIR or INTEL64_DIR or run get_input_channels.m) pcs_channels2_names = signal names corresponding to indices in pcs_channels (optional, used only for human understanding) simulation_includes.m = file containing definitions of command signal indices in PCS and conversion factors from counts into DAC to command voltages OUTPUTS: pcs_connect_data = a structure with fields: ncpus integer = number of cpus that PCS is compiled for master_cpu_num integer = master cpu number in PCS start_time float = time in seconds to jump to in beginning simulation (optional, default 0) init_sim_time floag = time in seconds at which to start the process for baseline calculation shotnum integer = shot number to get PCS initial condition data from DA_GAIN = multiplier that converts digitizer volts to counts Note: PCS sends out digitizer counts (not volts) Further, PCS and matlab simulation maintain the VME ranges: 4096 counts = -10 to 10 V But, sysmain_master.h multiplies commands by 16 to get DAC* commands in 16-bit count range So count-to-volt conversion is (20/4096)*(1/16)=10.0/32767.0=3.0518e-04, which is the inherent number (IN) for DAC* commands, DA_GAIN = 1/IN. IN values are documented in simulation_includes.h. use_fpcom = flag, if 1 use fpcom (unclipped) data for commands instead of intcom (optional, default=0) cycle_times float(ncpu) = cycle times of real-time cpus, in order 1...ncpus calc_delay_times float(ncpu) = computational delay for each cpu, entry i corresponds to cpu i cmd_delay_times = delay in sending commands, entry i corresponds to cpu i num_pcs_inputs integer = number of PCS channels (defines input port size) pcs_channels integer(num_pcs_inputs) = indices of PCS channels input to io_PCS; these are <device>_sim outputs, indexed from 1 (see input_data.h) pcs_channel_names = names of signals corresponding to pcs_channels (for human readability) num_commands = number of intcommand channels (defines output port size) intcom_channels = indices of intcommand channels defining PCS Sfn output, indexed from 1 intcom_cpus = cpu numbers where intcom values are coming from, indexed from 1 cpu_order = order to feed data to cpus (master cpu first) OTHER VARIABLES pcs_channels_ids integer(num_pcs_inputs) = used in <device>_simX_model Selector block to id PCS variables for Diag. Physics Out port RESTRICTIONS: METHOD Script initializes variables needed by io_PCS S-function. Inputs are needed from both <device>_sim and the PCS compiled to use in the simulation. <device>_sim code is found in this directory. PCS header files are found in the user's PCS directory by default The intention is to allow for changes in the PCS to be made without bothering this workflow. Inputs to <device>_sim.mdl are PCS commands. Outputs are signals sent to the pcs. Conversely, inputs to io_PCS are <device>_sim signals and outputs are PCS commands. The signals generated by <device>_sim are defined in SIMULATION_TO_PCS.h. The commands generated by io_PCS are defined in input_data2.h <device>_sim_struct.output_signals contains PCS pointnames for the signals in the simulink model, <device>_sim_struct.output_signals begins with <device>_system.output_signals(:,1) and continues with signals added in <device>_sim2.mdl <device>_sim_struct.input_signals: These are commands from the PCS used to identify the intcom_channels, which are indices of the Sfn output DAC are actual commands that go out. FSF is the command calculated, FSC is the clipped value and should agree with DAC IPFEPS is the command calculated and IPCEPS is the clipped value pcsinputs2 are the macros extracted from input_data2.h pcs_channels2 are the indices of the macros for the pcs therefore, pcsinputs2(pcs_channels2) are the macros for the pcs To extract the indices of <device>_sim_struct.output_signals we need for the pcs from the simulation data, we match pcsinputs2(pcs_channels2) with <device>_sim_struct.output_signals","title":"Basic Information"},{"location":"function-guide/simserver/setup_io_PCS_Sfn_m/#dependencies","text":"get_cpu_indices get_command_indices get_command_da_gain make_function truncate_header","title":"Dependencies"},{"location":"function-guide/simserver/setup_plasma_sim_m/","text":"setup_plasma_sim.m \u00b6 Basic Information \u00b6 SYNTAX: setup_plasma_sim PURPOSE: Define variables needed for simulink models that include plasma. Also defines some data that can be used to program the PCS when running in closed loop versus a simserver constructed from simulink model. (Only works for EAST and KSTAR right now.) INPUT: vacuum_objs = vacuum model data structure iplcirc = set equal to 1 to include plasma circuit eqn in model ichooseq = choose type of equilibrium data to use: 0 = vacuum model (no plasma equilibrium required) 1 = efit gfile 2 = Corsica equilibrium files 3 = saved corsica equilibrium 4 = TokSys equilibrium data structure efit_gfile = EFIT equilibrium file (g-file), only needed if ichooseq=1 corsica_inputs = name of ??? (required only if ichooseq=2) corsica_savefile = name of saved corsica equilibrium (required only if ichooseq=3) equil_data = name of TokSys format equilibrium data structure (required only if ichooseq=4) ip_init = initial value for Ip dt_rz = time step for R and Z feedback control Gp_z,Gd_z,Gi_z = gains for Z control taup_z,taud_z,taui_z = time constants for Z control Gp_r,Gd_r,Gi_r = gains for R control taup_r,taud_r,taui_r = time constants for R control Vlimits_PF = upper and lower bounds on PF coil voltages idx_vcntl_ckts = indices of vertical control circuits in system model OUTPUT: many variables needed to initialize simulink (*.mdl) models Ip_gains = gain vector that can be used for Ip control in PCS FILES: <tokamak>_PCS_mutuals.dat = matrices needed by PCS to compute V trajs init_currents.dat = initial currents file (set = equilibrium values) RESTRICTIONS: (1) Assumes that first 3 sets of diagnostics are: coils, flux loops, probes (2) Works only when ohmic distribution currents all the same sign right now. (3) Does not work (incorrect diags_0) with nonzero equilibrium vessel currents. Dependencies \u00b6 calc_equil_diags wait transform_states bld_filter","title":"setup_plasma_sim.m"},{"location":"function-guide/simserver/setup_plasma_sim_m/#setup_plasma_simm","text":"","title":"setup_plasma_sim.m"},{"location":"function-guide/simserver/setup_plasma_sim_m/#basic-information","text":"SYNTAX: setup_plasma_sim PURPOSE: Define variables needed for simulink models that include plasma. Also defines some data that can be used to program the PCS when running in closed loop versus a simserver constructed from simulink model. (Only works for EAST and KSTAR right now.) INPUT: vacuum_objs = vacuum model data structure iplcirc = set equal to 1 to include plasma circuit eqn in model ichooseq = choose type of equilibrium data to use: 0 = vacuum model (no plasma equilibrium required) 1 = efit gfile 2 = Corsica equilibrium files 3 = saved corsica equilibrium 4 = TokSys equilibrium data structure efit_gfile = EFIT equilibrium file (g-file), only needed if ichooseq=1 corsica_inputs = name of ??? (required only if ichooseq=2) corsica_savefile = name of saved corsica equilibrium (required only if ichooseq=3) equil_data = name of TokSys format equilibrium data structure (required only if ichooseq=4) ip_init = initial value for Ip dt_rz = time step for R and Z feedback control Gp_z,Gd_z,Gi_z = gains for Z control taup_z,taud_z,taui_z = time constants for Z control Gp_r,Gd_r,Gi_r = gains for R control taup_r,taud_r,taui_r = time constants for R control Vlimits_PF = upper and lower bounds on PF coil voltages idx_vcntl_ckts = indices of vertical control circuits in system model OUTPUT: many variables needed to initialize simulink (*.mdl) models Ip_gains = gain vector that can be used for Ip control in PCS FILES: <tokamak>_PCS_mutuals.dat = matrices needed by PCS to compute V trajs init_currents.dat = initial currents file (set = equilibrium values) RESTRICTIONS: (1) Assumes that first 3 sets of diagnostics are: coils, flux loops, probes (2) Works only when ohmic distribution currents all the same sign right now. (3) Does not work (incorrect diags_0) with nonzero equilibrium vessel currents.","title":"Basic Information"},{"location":"function-guide/simserver/setup_plasma_sim_m/#dependencies","text":"calc_equil_diags wait transform_states bld_filter","title":"Dependencies"},{"location":"function-guide/simserver/simserver_setup_MSE_m/","text":"simserver_setup_MSE.m \u00b6 Basic Information \u00b6 SYNTAX: setup_MSE PURPOSE: Define configuration data for MSE module. INPUT: OUTPUT: Dependencies \u00b6","title":"simserver_setup_MSE.m"},{"location":"function-guide/simserver/simserver_setup_MSE_m/#simserver_setup_msem","text":"","title":"simserver_setup_MSE.m"},{"location":"function-guide/simserver/simserver_setup_MSE_m/#basic-information","text":"SYNTAX: setup_MSE PURPOSE: Define configuration data for MSE module. INPUT: OUTPUT:","title":"Basic Information"},{"location":"function-guide/simserver/simserver_setup_MSE_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/simserver/simserver_setup_limited_system_m/","text":"simserver_setup_limited_system.m \u00b6 Basic Information \u00b6 SYNTAX: setup_limited_system PURPOSE: Define configuration data for limited_system module. INPUT: ichooseq = model equilibrium selection flag (see build_tokamak_systea.m) tok_system = system model for the tokamak min_currents = max_currents = num_Ecoils = number of E-coils (for most devices, this is 0) nv = inc_plasma = set to 1 to include plasma ODE in the system model adiagfilter,bdiagfilter,cdiagfilter,ddiagfilter = A,B,C,D matrices for diagnostics filter (optional, use only if your model includes diagnostics filter block) OUTPUT: limited_system = struct containing config info needed for the limited_system block in toksim_generic library Dependencies \u00b6","title":"simserver_setup_limited_system.m"},{"location":"function-guide/simserver/simserver_setup_limited_system_m/#simserver_setup_limited_systemm","text":"","title":"simserver_setup_limited_system.m"},{"location":"function-guide/simserver/simserver_setup_limited_system_m/#basic-information","text":"SYNTAX: setup_limited_system PURPOSE: Define configuration data for limited_system module. INPUT: ichooseq = model equilibrium selection flag (see build_tokamak_systea.m) tok_system = system model for the tokamak min_currents = max_currents = num_Ecoils = number of E-coils (for most devices, this is 0) nv = inc_plasma = set to 1 to include plasma ODE in the system model adiagfilter,bdiagfilter,cdiagfilter,ddiagfilter = A,B,C,D matrices for diagnostics filter (optional, use only if your model includes diagnostics filter block) OUTPUT: limited_system = struct containing config info needed for the limited_system block in toksim_generic library","title":"Basic Information"},{"location":"function-guide/simserver/simserver_setup_limited_system_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/simserver/simserver_setup_lin_plasma_sim_m/","text":"simserver_setup_lin_plasma_sim.m \u00b6 Basic Information \u00b6 SYNTAX: simserver_setup_lin_plasma_sim PURPOSE: Define configuration data for lin_plasma_sim module. INPUT: Same inputs as function simserver_setup_limited_system, and in addition: d0 nc nv inc_plasma select_coils = indices of coil current initial values that constitute initial conditions for the current states in system model i_init = initial coil current values (all coils) OUTPUT: Dependencies \u00b6 simserver_setup_limited_system","title":"simserver_setup_lin_plasma_sim.m"},{"location":"function-guide/simserver/simserver_setup_lin_plasma_sim_m/#simserver_setup_lin_plasma_simm","text":"","title":"simserver_setup_lin_plasma_sim.m"},{"location":"function-guide/simserver/simserver_setup_lin_plasma_sim_m/#basic-information","text":"SYNTAX: simserver_setup_lin_plasma_sim PURPOSE: Define configuration data for lin_plasma_sim module. INPUT: Same inputs as function simserver_setup_limited_system, and in addition: d0 nc nv inc_plasma select_coils = indices of coil current initial values that constitute initial conditions for the current states in system model i_init = initial coil current values (all coils) OUTPUT:","title":"Basic Information"},{"location":"function-guide/simserver/simserver_setup_lin_plasma_sim_m/#dependencies","text":"simserver_setup_limited_system","title":"Dependencies"},{"location":"function-guide/simserver/write_simserver_init_file_m/","text":"write_simserver_init_file.m \u00b6 Basic Information \u00b6 USAGE: write_simserver_init_file PURPOSE: Write simserver current initialization file. (duplicates existing function in make_simserver_dat.m) Eg. ncoils: nc initial_coil_currents: i_coils initial_plasma_current: i_ip INPUTS: sim_init_filename: name of simserver initialization file nc: number of PF coils i_coils: coil currents (A) ## These are E-coil followed by F-coil currents (MA/turn, i.e. terminal currents). ## i_ip: Plasma current (A) OUTPUTS: ier: error flag Dependencies \u00b6 make_simserver_dat","title":"write_simserver_init_file.m"},{"location":"function-guide/simserver/write_simserver_init_file_m/#write_simserver_init_filem","text":"","title":"write_simserver_init_file.m"},{"location":"function-guide/simserver/write_simserver_init_file_m/#basic-information","text":"USAGE: write_simserver_init_file PURPOSE: Write simserver current initialization file. (duplicates existing function in make_simserver_dat.m) Eg. ncoils: nc initial_coil_currents: i_coils initial_plasma_current: i_ip INPUTS: sim_init_filename: name of simserver initialization file nc: number of PF coils i_coils: coil currents (A) ## These are E-coil followed by F-coil currents (MA/turn, i.e. terminal currents). ## i_ip: Plasma current (A) OUTPUTS: ier: error flag","title":"Basic Information"},{"location":"function-guide/simserver/write_simserver_init_file_m/#dependencies","text":"make_simserver_dat","title":"Dependencies"},{"location":"function-guide/teq/create_corsica_flat_files_m/","text":"create_corsica_flat_files.m \u00b6 Basic Information \u00b6 USAGE: create_corsica_flat_files PURPOSE: Invoke caltrans and create flat files INPUTS: corsica_save_file, name of corsica save file OUTPUTS: RESTRICTIONS: METHOD: corsica is invoked with the name of the *.sav file as first argument and basis script [gatools_root '/matlab/teq/create_corsica_flat_files.bas'] as second. Dependencies \u00b6","title":"create_corsica_flat_files.m"},{"location":"function-guide/teq/create_corsica_flat_files_m/#create_corsica_flat_filesm","text":"","title":"create_corsica_flat_files.m"},{"location":"function-guide/teq/create_corsica_flat_files_m/#basic-information","text":"USAGE: create_corsica_flat_files PURPOSE: Invoke caltrans and create flat files INPUTS: corsica_save_file, name of corsica save file OUTPUTS: RESTRICTIONS: METHOD: corsica is invoked with the name of the *.sav file as first argument and basis script [gatools_root '/matlab/teq/create_corsica_flat_files.bas'] as second.","title":"Basic Information"},{"location":"function-guide/teq/create_corsica_flat_files_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/teq/read_corsica_data_m/","text":"read_corsica_data.m \u00b6 Basic Information \u00b6 USAGE: equil_data = read_corsica_data(dirname,tok_data_struct) PURPOSE: Read flat files made with create_corsica_flat_files.m (or .bas) INPUTS: dirname, the directory with all the flat files, such as: sys_dims.flat psi.flat cc.flat crj.flat, and many more... OR (for backwards compatibility) dirname can be a struct containing paths to sysdims.flat, psi.flat, cc.flat, crj.flat In this latter case only a subset of the outputs are returned tok_data_struct, standard toksys description of the tokamak tok_data_struct is used to make fcturn, turnfc, fcid, ecid Everything else comes from the corsica flat files in dirname. OUTPUTS: equil_data, a standard toksys equilibrium structure: cpasma: 'Plasma current [A]' jphi: 'Current density on grid [MA/m^2]' pcurrt: 'Current within rectangular grid elements [A]' psizr: 'Total flux on grid [Wb]' pres: 'Pressure at flux values [Pa]' pprime: 'pprime at flux values [Pa/(Wb/rad)]' fpol: 'fpol at flux values' fprime: 'fprime at flux values' ffprim: 'ffprim at flux values' qpsi: 'q at flux values' bzero: 'Vacuum toroidal field at rzero [T]' rzero: 'Reference point for bzero [m]' rmaxis: 'R of magnetic axis [m]' zmaxis: 'Z of magnetic axis [m]' psimag: 'Flux at magnetic axis [Wb]' psibry: 'Flux at boundary [Wb]' rcur: 'R of current centroid [m]' zcur: 'Z of current centroid [m]' nbbbs: 'Number of boundary points = length(rbbbs)' rbbbs: 'R of boundary points [m]' zbbbs: 'Z of boundary points [m]' xlim: 'R of limiter [m]' ylim: 'Z of limiter [m]' rxps: 'R of X points [m]' zxps: 'Z of X points [m]' psixps: 'Flux at X points [Wb]' cc: 'PF coil currents in MA-turns' cc2: 'PF coil currents in MA-turns' dr: 'Radial distance between grid points [m]' dz: 'Vertical distance between grid points [m]' rg: 'Radial coordinates of grid points [m]' zg: 'Vertical coordinates of grid points [m]' nw: 'Number of radial grid points [m]' nh: 'Number of vertical grid points [m]' fcturn: 'Number of turns in PF coils = tok_data_struct.fcnturn' turnfc: 'ones(nff,1) (nff derived from tok_data_struct)' fcid: '1:nff (nff derived from tok_data_struct)' ecid: 'tok_data_struct.ecdata(5,:)' RESTRICTIONS: METHOD: Reads flat files generated by create_corsica_flat_files.m This function converts units and saves to efit variable names tok_data_struct is needed to create fcturn, turnfc, ecid, fcid If only 4 flat files are available then the grid and limdata from tok_data_struct are used in findlcfs which derives psibry, psibnd. Dependencies \u00b6 wait findlcfs","title":"read_corsica_data.m"},{"location":"function-guide/teq/read_corsica_data_m/#read_corsica_datam","text":"","title":"read_corsica_data.m"},{"location":"function-guide/teq/read_corsica_data_m/#basic-information","text":"USAGE: equil_data = read_corsica_data(dirname,tok_data_struct) PURPOSE: Read flat files made with create_corsica_flat_files.m (or .bas) INPUTS: dirname, the directory with all the flat files, such as: sys_dims.flat psi.flat cc.flat crj.flat, and many more... OR (for backwards compatibility) dirname can be a struct containing paths to sysdims.flat, psi.flat, cc.flat, crj.flat In this latter case only a subset of the outputs are returned tok_data_struct, standard toksys description of the tokamak tok_data_struct is used to make fcturn, turnfc, fcid, ecid Everything else comes from the corsica flat files in dirname. OUTPUTS: equil_data, a standard toksys equilibrium structure: cpasma: 'Plasma current [A]' jphi: 'Current density on grid [MA/m^2]' pcurrt: 'Current within rectangular grid elements [A]' psizr: 'Total flux on grid [Wb]' pres: 'Pressure at flux values [Pa]' pprime: 'pprime at flux values [Pa/(Wb/rad)]' fpol: 'fpol at flux values' fprime: 'fprime at flux values' ffprim: 'ffprim at flux values' qpsi: 'q at flux values' bzero: 'Vacuum toroidal field at rzero [T]' rzero: 'Reference point for bzero [m]' rmaxis: 'R of magnetic axis [m]' zmaxis: 'Z of magnetic axis [m]' psimag: 'Flux at magnetic axis [Wb]' psibry: 'Flux at boundary [Wb]' rcur: 'R of current centroid [m]' zcur: 'Z of current centroid [m]' nbbbs: 'Number of boundary points = length(rbbbs)' rbbbs: 'R of boundary points [m]' zbbbs: 'Z of boundary points [m]' xlim: 'R of limiter [m]' ylim: 'Z of limiter [m]' rxps: 'R of X points [m]' zxps: 'Z of X points [m]' psixps: 'Flux at X points [Wb]' cc: 'PF coil currents in MA-turns' cc2: 'PF coil currents in MA-turns' dr: 'Radial distance between grid points [m]' dz: 'Vertical distance between grid points [m]' rg: 'Radial coordinates of grid points [m]' zg: 'Vertical coordinates of grid points [m]' nw: 'Number of radial grid points [m]' nh: 'Number of vertical grid points [m]' fcturn: 'Number of turns in PF coils = tok_data_struct.fcnturn' turnfc: 'ones(nff,1) (nff derived from tok_data_struct)' fcid: '1:nff (nff derived from tok_data_struct)' ecid: 'tok_data_struct.ecdata(5,:)' RESTRICTIONS: METHOD: Reads flat files generated by create_corsica_flat_files.m This function converts units and saves to efit variable names tok_data_struct is needed to create fcturn, turnfc, ecid, fcid If only 4 flat files are available then the grid and limdata from tok_data_struct are used in findlcfs which derives psibry, psibnd.","title":"Basic Information"},{"location":"function-guide/teq/read_corsica_data_m/#dependencies","text":"wait findlcfs","title":"Dependencies"},{"location":"function-guide/teq/read_corsica_flat_files_m/","text":"read_corsica_flat_files.m \u00b6 Basic Information \u00b6 USAGE: equil_data = read_corsica_flat_files(dirname) PURPOSE: Read flat files made with create_corsica_flat_files.m (or .bas) INPUTS: dirname, the directory with all the flat files, such as: sys_dims.flat psi.flat cc.flat crj.flat, etc... OUTPUTS: Standard toksys equilibrium structure: cpasma: 'Plasma current [A]' jphi: 'Current density on grid [MA/m^2]' psizr: 'Total flux on grid [Wb]' pres: 'Pressure at flux values [Pa]' pprime: 'pprime at flux values [Pa/(Wb/rad)]' fpol: 'fpol at flux values' fprime: 'fprime at flux values' ffprim: 'ffprim at flux values' qpsi: 'q at flux values' bzero: 'Vacuum toroidal field at rzero [T]' rzero: 'Reference point for bzero [m]' rmaxis: 'R of magnetic axis [m]' zmaxis: 'Z of magnetic axis [m]' psimag: 'Flux at magnetic axis [Wb]' psibry: 'Flux at boundary [Wb]' rcur: 'R of current centroid [m]' zcur: 'Z of current centroid [m]' nbbbs: 'Number of boundary points = length(rbbbs)' rbbbs: 'R of boundary points [m]' zbbbs: 'Z of boundary points [m]' xlim: 'R of limiter [m]' ylim: 'Z of limiter [m]' rxps: 'R of X points [m]' zxps: 'Z of X points [m]' psixps: 'Flux at X points [Wb]' cc: 'PF coil currents in MA-turns' dr: 'Radial distance between grid points [m]' dz: 'Vertical distance between grid points [m]' rg: 'Radial coordinates of grid points [m]' zg: 'Vertical coordinates of grid points [m]' RESTRICTIONS: METHOD: Reads flat files generated by create_corsica_flat_files.m This function converts units and saves to efit variable names Dependencies \u00b6","title":"read_corsica_flat_files.m"},{"location":"function-guide/teq/read_corsica_flat_files_m/#read_corsica_flat_filesm","text":"","title":"read_corsica_flat_files.m"},{"location":"function-guide/teq/read_corsica_flat_files_m/#basic-information","text":"USAGE: equil_data = read_corsica_flat_files(dirname) PURPOSE: Read flat files made with create_corsica_flat_files.m (or .bas) INPUTS: dirname, the directory with all the flat files, such as: sys_dims.flat psi.flat cc.flat crj.flat, etc... OUTPUTS: Standard toksys equilibrium structure: cpasma: 'Plasma current [A]' jphi: 'Current density on grid [MA/m^2]' psizr: 'Total flux on grid [Wb]' pres: 'Pressure at flux values [Pa]' pprime: 'pprime at flux values [Pa/(Wb/rad)]' fpol: 'fpol at flux values' fprime: 'fprime at flux values' ffprim: 'ffprim at flux values' qpsi: 'q at flux values' bzero: 'Vacuum toroidal field at rzero [T]' rzero: 'Reference point for bzero [m]' rmaxis: 'R of magnetic axis [m]' zmaxis: 'Z of magnetic axis [m]' psimag: 'Flux at magnetic axis [Wb]' psibry: 'Flux at boundary [Wb]' rcur: 'R of current centroid [m]' zcur: 'Z of current centroid [m]' nbbbs: 'Number of boundary points = length(rbbbs)' rbbbs: 'R of boundary points [m]' zbbbs: 'Z of boundary points [m]' xlim: 'R of limiter [m]' ylim: 'Z of limiter [m]' rxps: 'R of X points [m]' zxps: 'Z of X points [m]' psixps: 'Flux at X points [Wb]' cc: 'PF coil currents in MA-turns' dr: 'Radial distance between grid points [m]' dz: 'Vertical distance between grid points [m]' rg: 'Radial coordinates of grid points [m]' zg: 'Vertical coordinates of grid points [m]' RESTRICTIONS: METHOD: Reads flat files generated by create_corsica_flat_files.m This function converts units and saves to efit variable names","title":"Basic Information"},{"location":"function-guide/teq/read_corsica_flat_files_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/build_model_m/","text":"build_model.m \u00b6 Basic Information \u00b6 SYNTAX: build_model PURPOSE: Generate data objects which can be used to construct complete system model, based on linearized plasma response. INPUT: shot = shot number tmodel = time to derive model from (in ms) tokamak = name of device to build model for tok_data_struct = vacuum data objects for this device output_irzresp = irzresp for output equation object generation eqdir = directory where efit equilibrium files are located efit_source = tree in mdsplus to get equilibrium from (only one of either eqdir or efit_source should be specified) outflag = flag to determine what output files to produce 0 = none 1 = run plasma_output, save results 2 = run plasma_output2, save results 3 = run both plasma_output, plasma_output2 - save (default) Rp = plasma resistance (only needed if outflag>0) OUTPUT: files = drzdi_<shot>_<tmodel>.mat out_objs_<shot>_<tmodel>.mat out2_objs_<shot>_<tmodel>.mat Dependencies \u00b6 read_afile make_out_objs read_gfile_tok wait read_mds_eqdsk rzrig","title":"build_model.m"},{"location":"function-guide/tok_models/build_model_m/#build_modelm","text":"","title":"build_model.m"},{"location":"function-guide/tok_models/build_model_m/#basic-information","text":"SYNTAX: build_model PURPOSE: Generate data objects which can be used to construct complete system model, based on linearized plasma response. INPUT: shot = shot number tmodel = time to derive model from (in ms) tokamak = name of device to build model for tok_data_struct = vacuum data objects for this device output_irzresp = irzresp for output equation object generation eqdir = directory where efit equilibrium files are located efit_source = tree in mdsplus to get equilibrium from (only one of either eqdir or efit_source should be specified) outflag = flag to determine what output files to produce 0 = none 1 = run plasma_output, save results 2 = run plasma_output2, save results 3 = run both plasma_output, plasma_output2 - save (default) Rp = plasma resistance (only needed if outflag>0) OUTPUT: files = drzdi_<shot>_<tmodel>.mat out_objs_<shot>_<tmodel>.mat out2_objs_<shot>_<tmodel>.mat","title":"Basic Information"},{"location":"function-guide/tok_models/build_model_m/#dependencies","text":"read_afile make_out_objs read_gfile_tok wait read_mds_eqdsk rzrig","title":"Dependencies"},{"location":"function-guide/tok_models/build_tokamak_system_m/","text":"build_tokamak_system.m \u00b6 Basic Information \u00b6 USAGE: tok_system= build_tokamak_system(build_inputs) PURPOSE: Generic script to build tokamak axisymmetric system from pre-calculated objects. Includes R,Z,Ip response in system. INPUTS: (in build_inputs structure) tokamak = name of tokamak system to construct (required) vacuum_objs = structure containing device model objects (required) cccirc = connection vector for CC's netlist = network connection description (Only one of cccirc or netlist can be input. If neither is input, default connections are used.) efit_gfile = equilibrium gfile to read (not required if ichooseq=0) ichooseq= equilibrium file type: 0 = vacuum model (no equilibrium data required) 1 = efit_gfile 2 = corsica generated flat files 3 = saved corsica equilibrium 4 = TokSys equilibrium data structure corsica_inputs = name of directory containing corsica input (flat) files (required only if ichooseq=2) corsica_savefile = name of saved corsica equilibrium (required only if ichooseq=3) equil_data = name of TokSys format equilibrium data structure (required only if ichooseq=4) irzresp_dynamic, irzresp_output = flags determining plasma contribution to dynamic (state) and output equations (default = 3 for both): 0 = motionless plasma 1 = rigid R motion 2 = rigid Z 3 = both R and Z rigid motions 4 = nonrigid plasma response based on vst in corsica 5 = gspert, (perturbed grad-shafronv equation plasma response) OPTIONAL INPUTS: vvgroup = vacuum vessel grouping vector: length = all vessel elements set element value = k to belong to group k, 0 to not include (default= [1:total # elements]) vvcirc = circuit connection vector for vac. vessel(default=all independent) iplcirc = flag to select inclusion of plasma circuit in state space(1) or not(0) (optional, default = 1 if ichooseq>0) Rp = (optional) user override of computed plasma resistance Rext = extra circuit resistance to add to each coil and vessel element can be either length=#coils or #coils + #vessel (default=0) Lext = extra circuit inductance to add to each coil/vessel can be either length=#coils or #coils + #vessel (default=0) replace_Rext= if 1, instead of adding Rext, replace the computed coil/vessel resistance with Rext (default=0) cc_file = file containing coil currents (optional, usually given by efit) idx_efit_to_tok = optional map of efit indices to toksys indices, s.t. if I=currents in efit order, then I(idx_efit_to_tok)=currents in toksys order scldzdis = To increase gamma when irzresp_dynamic=irzresp_output=4, make scldzdis<1.0. (optional, default=1) tok_geo_plot_fn = one of 'generic', 'plot_east_geo', 'plot_kstar_geo', etc. (optional, default = '' or 'none' => no plots) Te_res = plasma electron temp for plasma resistance calc [eV] (optional, default = 4000eV) li_res = plasma internal inductance for resistance calculation (optional,default = 0.5) Zeff_res = Zeff for resistance calc (optional, default = 1.5) scale_R_scpf = scale factor to multiply resistance of superconducting PF coils, scalar or vector of length = number of coils (optional, default = 1 applied to ALL coils) netlist_currents = array of strings defining branches for which to output currents (optional, default = no current outputs, not used if cccirc used for circuit connectivity) netlist_voltages = n x 2 matrix, each row containing node numbers [N1 N2], with voltage output defined as V(N1)-V(N2) (optional, default = no voltage outputs, not used if cccirc used for circuit connectivity) gspert_options = options for gspert calculation (only used if irzresp values=5) iwait = (optional) flag: 1=wait when error messages, 0(default)=no wait verbose = level of screen output. Allowed values are: 0 = no messages or uncritical warnings (default) 1 = display warnings 2 = display warnings and other messages OUTPUTS: tok_system = structure containing model of tokamak system RESTRICTIONS: Must have specified objects files in specified path. Dimensions of equilibrium objects much match electromagnetic system dimensions (eg grid rg,zg must match crj dimensions). METHOD: Loads and defines objects needed for control analysis/design. cccirc uses Corsica connection vector convention: vector of indices identifying which circuit each coil belongs to (\"index\" is negative to denote antiseries...). So eg [1 2 3 1 -2 -3] means coil 1 is series'd with coil 4, coil 2 is antiseries'd with coil 5, coil 3 is antiseriesd with coil 6, and there are 3 total circuits in the final connected system. Dependencies \u00b6 eigsort model_from_netlist plasma_response_vst calc_LR wait plot_tok_geo rzrig cccirc_to_netlist read_gfile_tok read_corsica_data scale_equil_response","title":"build_tokamak_system.m"},{"location":"function-guide/tok_models/build_tokamak_system_m/#build_tokamak_systemm","text":"","title":"build_tokamak_system.m"},{"location":"function-guide/tok_models/build_tokamak_system_m/#basic-information","text":"USAGE: tok_system= build_tokamak_system(build_inputs) PURPOSE: Generic script to build tokamak axisymmetric system from pre-calculated objects. Includes R,Z,Ip response in system. INPUTS: (in build_inputs structure) tokamak = name of tokamak system to construct (required) vacuum_objs = structure containing device model objects (required) cccirc = connection vector for CC's netlist = network connection description (Only one of cccirc or netlist can be input. If neither is input, default connections are used.) efit_gfile = equilibrium gfile to read (not required if ichooseq=0) ichooseq= equilibrium file type: 0 = vacuum model (no equilibrium data required) 1 = efit_gfile 2 = corsica generated flat files 3 = saved corsica equilibrium 4 = TokSys equilibrium data structure corsica_inputs = name of directory containing corsica input (flat) files (required only if ichooseq=2) corsica_savefile = name of saved corsica equilibrium (required only if ichooseq=3) equil_data = name of TokSys format equilibrium data structure (required only if ichooseq=4) irzresp_dynamic, irzresp_output = flags determining plasma contribution to dynamic (state) and output equations (default = 3 for both): 0 = motionless plasma 1 = rigid R motion 2 = rigid Z 3 = both R and Z rigid motions 4 = nonrigid plasma response based on vst in corsica 5 = gspert, (perturbed grad-shafronv equation plasma response) OPTIONAL INPUTS: vvgroup = vacuum vessel grouping vector: length = all vessel elements set element value = k to belong to group k, 0 to not include (default= [1:total # elements]) vvcirc = circuit connection vector for vac. vessel(default=all independent) iplcirc = flag to select inclusion of plasma circuit in state space(1) or not(0) (optional, default = 1 if ichooseq>0) Rp = (optional) user override of computed plasma resistance Rext = extra circuit resistance to add to each coil and vessel element can be either length=#coils or #coils + #vessel (default=0) Lext = extra circuit inductance to add to each coil/vessel can be either length=#coils or #coils + #vessel (default=0) replace_Rext= if 1, instead of adding Rext, replace the computed coil/vessel resistance with Rext (default=0) cc_file = file containing coil currents (optional, usually given by efit) idx_efit_to_tok = optional map of efit indices to toksys indices, s.t. if I=currents in efit order, then I(idx_efit_to_tok)=currents in toksys order scldzdis = To increase gamma when irzresp_dynamic=irzresp_output=4, make scldzdis<1.0. (optional, default=1) tok_geo_plot_fn = one of 'generic', 'plot_east_geo', 'plot_kstar_geo', etc. (optional, default = '' or 'none' => no plots) Te_res = plasma electron temp for plasma resistance calc [eV] (optional, default = 4000eV) li_res = plasma internal inductance for resistance calculation (optional,default = 0.5) Zeff_res = Zeff for resistance calc (optional, default = 1.5) scale_R_scpf = scale factor to multiply resistance of superconducting PF coils, scalar or vector of length = number of coils (optional, default = 1 applied to ALL coils) netlist_currents = array of strings defining branches for which to output currents (optional, default = no current outputs, not used if cccirc used for circuit connectivity) netlist_voltages = n x 2 matrix, each row containing node numbers [N1 N2], with voltage output defined as V(N1)-V(N2) (optional, default = no voltage outputs, not used if cccirc used for circuit connectivity) gspert_options = options for gspert calculation (only used if irzresp values=5) iwait = (optional) flag: 1=wait when error messages, 0(default)=no wait verbose = level of screen output. Allowed values are: 0 = no messages or uncritical warnings (default) 1 = display warnings 2 = display warnings and other messages OUTPUTS: tok_system = structure containing model of tokamak system RESTRICTIONS: Must have specified objects files in specified path. Dimensions of equilibrium objects much match electromagnetic system dimensions (eg grid rg,zg must match crj dimensions). METHOD: Loads and defines objects needed for control analysis/design. cccirc uses Corsica connection vector convention: vector of indices identifying which circuit each coil belongs to (\"index\" is negative to denote antiseries...). So eg [1 2 3 1 -2 -3] means coil 1 is series'd with coil 4, coil 2 is antiseries'd with coil 5, coil 3 is antiseriesd with coil 6, and there are 3 total circuits in the final connected system.","title":"Basic Information"},{"location":"function-guide/tok_models/build_tokamak_system_m/#dependencies","text":"eigsort model_from_netlist plasma_response_vst calc_LR wait plot_tok_geo rzrig cccirc_to_netlist read_gfile_tok read_corsica_data scale_equil_response","title":"Dependencies"},{"location":"function-guide/tok_models/calc_Iq_m/","text":"calc_Iq.m \u00b6 Basic Information \u00b6 USAGE: [Iqresp,Iq,eqx] = calc_Iq(q,tok_data_struct,eq,options) PURPOSE: Calculate amount of current within q-surfaces and responses thereof INPUTS: q: q-values for surfaces tok_data_struct: toksys description of tokamak eq: equilibrium structure options (optional), do help gspert for description OUTPUTS: Iqresp: response structure with fields: dIqdis: response of current inside q to conductor currents dIqdip,*dli,*dbphi, etc: exogenous responses Iq: current within q-contours eqx: extra equilibrium information, help gspert for description Dependencies \u00b6","title":"calc_Iq.m"},{"location":"function-guide/tok_models/calc_Iq_m/#calc_iqm","text":"","title":"calc_Iq.m"},{"location":"function-guide/tok_models/calc_Iq_m/#basic-information","text":"USAGE: [Iqresp,Iq,eqx] = calc_Iq(q,tok_data_struct,eq,options) PURPOSE: Calculate amount of current within q-surfaces and responses thereof INPUTS: q: q-values for surfaces tok_data_struct: toksys description of tokamak eq: equilibrium structure options (optional), do help gspert for description OUTPUTS: Iqresp: response structure with fields: dIqdis: response of current inside q to conductor currents dIqdip,*dli,*dbphi, etc: exogenous responses Iq: current within q-contours eqx: extra equilibrium information, help gspert for description","title":"Basic Information"},{"location":"function-guide/tok_models/calc_Iq_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/calc_fluxexp_m/","text":"calc_fluxexp.m \u00b6 Basic Information \u00b6 USAGE: fluxexp = calc_fluxexp(eq, r, z) [fluxexp, r2, d2] = calc_fluxexp(eq, r, z, d) PURPOSE: Calculate flux expansion at points r,z for equilibrium eq INPUTS: eq, TokSys description of an equilibrium containing fields: rg, zg = grid coordinates psizr = flux at points rg, zg rbbbs, zbbbs, nbbbs = nbbbs plasma boundary coordinates psibry = boundary flux r,z, coordinates of points where flux expansion is calculated d, distance in outboard midplane to outside boundary (default 0) OUTPUTS: fluxexp, if d==0,flux expansion = abs(pr)./sqrt(yr.^2+yz.^2) where pr = d(psi)/dR at maximum major radius for the boundary and sqrt(yr.^2+yz.^2) is magnitude of flux gradient at points r,z if d > 0, fluxexp = D/d, where D is perpendicular distance from r,z to point r2, z2 with same flux difference as distance d in midplane Dependencies \u00b6","title":"calc_fluxexp.m"},{"location":"function-guide/tok_models/calc_fluxexp_m/#calc_fluxexpm","text":"","title":"calc_fluxexp.m"},{"location":"function-guide/tok_models/calc_fluxexp_m/#basic-information","text":"USAGE: fluxexp = calc_fluxexp(eq, r, z) [fluxexp, r2, d2] = calc_fluxexp(eq, r, z, d) PURPOSE: Calculate flux expansion at points r,z for equilibrium eq INPUTS: eq, TokSys description of an equilibrium containing fields: rg, zg = grid coordinates psizr = flux at points rg, zg rbbbs, zbbbs, nbbbs = nbbbs plasma boundary coordinates psibry = boundary flux r,z, coordinates of points where flux expansion is calculated d, distance in outboard midplane to outside boundary (default 0) OUTPUTS: fluxexp, if d==0,flux expansion = abs(pr)./sqrt(yr.^2+yz.^2) where pr = d(psi)/dR at maximum major radius for the boundary and sqrt(yr.^2+yz.^2) is magnitude of flux gradient at points r,z if d > 0, fluxexp = D/d, where D is perpendicular distance from r,z to point r2, z2 with same flux difference as distance d in midplane","title":"Basic Information"},{"location":"function-guide/tok_models/calc_fluxexp_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/calc_gaps_m/","text":"calc_gaps.m \u00b6 Basic Information \u00b6 USAGE: [gapresp,gaps,gapspec] = calc_gaps(gapspec,tok_data_struct,resp,eq,idoplot) PURPOSE: Calculate gaps and responses thereof at specified locations A gap is defined as the distance between the plasma boundary and the wall along a line through a specified \"gap location\", with direction of measurement defined by gradient of flux for a nominal equilibrium at that prescribed \"gap location\". (This nominal equilibrium is also used to generate the linearized plasma response model.) INPUTS: gapspec: gap specification on the form [r z gr gz] r,z is gap location and gr,gz nominal gradient If nominal gradient is 0,0 then it is taken from eq This creates a gapspec with eq as nominal equilibrium If gapspec is empty, a default inner, upper, outer, lower gap are set tok_data_struct: toksys description of tokamak resp: (optional) the output from a response model (gspert or rzrig) eq: equilibrium structure idoplot: flag to plot limiter, boundary, gap location, and gap vector OUTPUTS: gapresp: response structure with fields: dgapdis: gap response to conductors [m/A] dgapdip,*dli,*dbetap, etc: exogenous responses gaps: distances from boundary to wall through r,z along gr,gz [m] gapspec: Complete gap specification on form [r z gr gz]. Dependencies \u00b6 wait","title":"calc_gaps.m"},{"location":"function-guide/tok_models/calc_gaps_m/#calc_gapsm","text":"","title":"calc_gaps.m"},{"location":"function-guide/tok_models/calc_gaps_m/#basic-information","text":"USAGE: [gapresp,gaps,gapspec] = calc_gaps(gapspec,tok_data_struct,resp,eq,idoplot) PURPOSE: Calculate gaps and responses thereof at specified locations A gap is defined as the distance between the plasma boundary and the wall along a line through a specified \"gap location\", with direction of measurement defined by gradient of flux for a nominal equilibrium at that prescribed \"gap location\". (This nominal equilibrium is also used to generate the linearized plasma response model.) INPUTS: gapspec: gap specification on the form [r z gr gz] r,z is gap location and gr,gz nominal gradient If nominal gradient is 0,0 then it is taken from eq This creates a gapspec with eq as nominal equilibrium If gapspec is empty, a default inner, upper, outer, lower gap are set tok_data_struct: toksys description of tokamak resp: (optional) the output from a response model (gspert or rzrig) eq: equilibrium structure idoplot: flag to plot limiter, boundary, gap location, and gap vector OUTPUTS: gapresp: response structure with fields: dgapdis: gap response to conductors [m/A] dgapdip,*dli,*dbetap, etc: exogenous responses gaps: distances from boundary to wall through r,z along gr,gz [m] gapspec: Complete gap specification on form [r z gr gz].","title":"Basic Information"},{"location":"function-guide/tok_models/calc_gaps_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/tok_models/calc_iso_m/","text":"calc_iso.m \u00b6 Basic Information \u00b6 USAGE: [isoresp,iso] = calc_iso(rziso,tok_data_struct,resp,eq) PURPOSE: Calculate flux, field and responses thereof at isoflux points INPUTS: rziso: R, Z of isoflux points arranged as [R(:) Z(:)] (unit: meters) tok_data_struct: toksys description of tokamak resp (optional): the output from a response model (gspert or rzrig) eq (optional): either equilibrium with field psizr or psizr itself OUTPUTS: isoresp: response structure with fields: dpsidis: flux response to conductors [Wb/A] dpsidip,*dli,*dbetap, etc: exogenous responses dbrdis, dbzdis: Br, Bz responses to conductors [T/A] dbrdip,dbzdip, etc: exogenous Br, Bz responses iso: equilibrium structure with fields: psi: flux at rziso points br, bz: Br, Bz at rziso points RESTRICTIONS: rziso must be within the grid Dependencies \u00b6 wait","title":"calc_iso.m"},{"location":"function-guide/tok_models/calc_iso_m/#calc_isom","text":"","title":"calc_iso.m"},{"location":"function-guide/tok_models/calc_iso_m/#basic-information","text":"USAGE: [isoresp,iso] = calc_iso(rziso,tok_data_struct,resp,eq) PURPOSE: Calculate flux, field and responses thereof at isoflux points INPUTS: rziso: R, Z of isoflux points arranged as [R(:) Z(:)] (unit: meters) tok_data_struct: toksys description of tokamak resp (optional): the output from a response model (gspert or rzrig) eq (optional): either equilibrium with field psizr or psizr itself OUTPUTS: isoresp: response structure with fields: dpsidis: flux response to conductors [Wb/A] dpsidip,*dli,*dbetap, etc: exogenous responses dbrdis, dbzdis: Br, Bz responses to conductors [T/A] dbrdip,dbzdip, etc: exogenous Br, Bz responses iso: equilibrium structure with fields: psi: flux at rziso points br, bz: Br, Bz at rziso points RESTRICTIONS: rziso must be within the grid","title":"Basic Information"},{"location":"function-guide/tok_models/calc_iso_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/tok_models/calc_ndecay_m/","text":"calc_ndecay.m \u00b6 Basic Information \u00b6 SYNTAX: ndecay = calc_ndecay(psivac,rg,zg,r0,z0,rdec,zdec); PURPOSE: Calculate decay index at point (or vector of points) from vacuum flux on grid. INPUTS: psivac = flux on grid (either vector or nz x nr array) (Wb) rg = grid radial position vector [m] zg = grid vertical position vector [m] r0 = radial position of reference point for Bz0 (scalar) [m] z0 = vertical position of reference point for Bz0 (scalar) [m] rdec = radial position(s) to calc decay index at (scalar/vector) [m] zdec = vertical position(s) to calc decay index at (scalar/vector) [m] OUTPUTS: ndecay = decay index (indices if rdec, zdec are vectors) RESTRICTIONS: r0,z0 must be scalar. rdec,zdec can be vectors. If only r0,z0 are given (no rdec,zdec), will use that point as both Bz0 reference and location to calculate ndecay. But if rdec,zdec are given as well, r0,z0 will be location of Bz0 reference, and rdec,zdec will be location(s) at which to calc ndecay. METHOD: see rzrig.m, calc_decind_victor.m Dependencies \u00b6","title":"calc_ndecay.m"},{"location":"function-guide/tok_models/calc_ndecay_m/#calc_ndecaym","text":"","title":"calc_ndecay.m"},{"location":"function-guide/tok_models/calc_ndecay_m/#basic-information","text":"SYNTAX: ndecay = calc_ndecay(psivac,rg,zg,r0,z0,rdec,zdec); PURPOSE: Calculate decay index at point (or vector of points) from vacuum flux on grid. INPUTS: psivac = flux on grid (either vector or nz x nr array) (Wb) rg = grid radial position vector [m] zg = grid vertical position vector [m] r0 = radial position of reference point for Bz0 (scalar) [m] z0 = vertical position of reference point for Bz0 (scalar) [m] rdec = radial position(s) to calc decay index at (scalar/vector) [m] zdec = vertical position(s) to calc decay index at (scalar/vector) [m] OUTPUTS: ndecay = decay index (indices if rdec, zdec are vectors) RESTRICTIONS: r0,z0 must be scalar. rdec,zdec can be vectors. If only r0,z0 are given (no rdec,zdec), will use that point as both Bz0 reference and location to calculate ndecay. But if rdec,zdec are given as well, r0,z0 will be location of Bz0 reference, and rdec,zdec will be location(s) at which to calc ndecay. METHOD: see rzrig.m, calc_decind_victor.m","title":"Basic Information"},{"location":"function-guide/tok_models/calc_ndecay_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/calc_ssop_from_I_m/","text":"calc_ssop_from_I.m \u00b6 Basic Information \u00b6 SYNTAX: ssop = calc_ssop_from_I(tok_system,ssop_inputs) PURPOSE: Compute steady-state operating point (ynom,Inom,Vnom), where Inom contains closest approximation to Icnom consistent with being a valid steady- state operating point. Values of ynom are always nonzero when default values of zero nominal currents are used. INPUT: tok_system = tokamak system model, as constructed by build_tokamak_system ssop_inputs = structure containing all optional inputs: Icnom = vector of PF coil currents defining center of coordinates for model. To use plasma equilibrium currents, let Icnom = Pcc*Ieq(1:ncx) (optional, default = all 0) Ipnom = value of plasma current defining center of coordinates for model (optional, default = 0). Nonzero value should be used only if non-ohmic drive is available to hold plasma current = Ipnom in steady-state. OUTPUT: ssop = steady state operating point, containing: ynom = nominal values for outputs y Inom = vector of nominal coil, vessel, and plasma currents (coil currents in Inom are best match to Icnom that is consistent with steady-state gain) Vnom = vector of voltages that produce coil currents in Inom vector Inomstates = vector of nominal coil, vessel, and plasma current states RESTRICTIONS: Only works right now for outputs that are modeled as linear relative to a plasma equilibrium. METHOD: See Prop. 3 of Walker & Humphreys, Valid Coordinate Systems for Linearized Plasma Shape Response Models in Tokamaks (where it is shown that the only valid choice for nominal vessel currents is 0). The Icnom vector is projected onto the range of the steady-state gain to compute Inom; the pseudo-inverse of steady-state gain is applied to compute Vnom (this is true inverse for vectors in range of steady-state gain). Dependencies \u00b6 wait","title":"calc_ssop_from_I.m"},{"location":"function-guide/tok_models/calc_ssop_from_I_m/#calc_ssop_from_im","text":"","title":"calc_ssop_from_I.m"},{"location":"function-guide/tok_models/calc_ssop_from_I_m/#basic-information","text":"SYNTAX: ssop = calc_ssop_from_I(tok_system,ssop_inputs) PURPOSE: Compute steady-state operating point (ynom,Inom,Vnom), where Inom contains closest approximation to Icnom consistent with being a valid steady- state operating point. Values of ynom are always nonzero when default values of zero nominal currents are used. INPUT: tok_system = tokamak system model, as constructed by build_tokamak_system ssop_inputs = structure containing all optional inputs: Icnom = vector of PF coil currents defining center of coordinates for model. To use plasma equilibrium currents, let Icnom = Pcc*Ieq(1:ncx) (optional, default = all 0) Ipnom = value of plasma current defining center of coordinates for model (optional, default = 0). Nonzero value should be used only if non-ohmic drive is available to hold plasma current = Ipnom in steady-state. OUTPUT: ssop = steady state operating point, containing: ynom = nominal values for outputs y Inom = vector of nominal coil, vessel, and plasma currents (coil currents in Inom are best match to Icnom that is consistent with steady-state gain) Vnom = vector of voltages that produce coil currents in Inom vector Inomstates = vector of nominal coil, vessel, and plasma current states RESTRICTIONS: Only works right now for outputs that are modeled as linear relative to a plasma equilibrium. METHOD: See Prop. 3 of Walker & Humphreys, Valid Coordinate Systems for Linearized Plasma Shape Response Models in Tokamaks (where it is shown that the only valid choice for nominal vessel currents is 0). The Icnom vector is projected onto the range of the steady-state gain to compute Inom; the pseudo-inverse of steady-state gain is applied to compute Vnom (this is true inverse for vectors in range of steady-state gain).","title":"Basic Information"},{"location":"function-guide/tok_models/calc_ssop_from_I_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/tok_models/calc_taupen_m/","text":"calc_taupen.m \u00b6 Basic Information \u00b6 USAGE: >> taupen = calc_taupen(tok_data_struct,ipf,Rmeas,Zmeas,options); PURPOSE: Function to calculate pentration time for generic tokamak by driving PF coils with step CURRENT to produce VV currents and calculate field at meas point INPUTS: tok_data_struct = standard TokSys vacuum objects structure ipf = index of PF coil to drive and calculate measurement time Rmeas,Zmeas = R,Z values at which to measure penetration [m] options.iplot = (optional) flag to enable plotting of time history for estimation of penetration time for PF ipf at (Rmeas,Zmeas). Default = 1 options.Gpc = (optional) Green function object desired for penetration time estimation. Must be a PF-coil-to-grid object. Default = mpc options.Gpv = (optional) Green function object desired for penetration time estimation. Must be a VV-element-to-grid object. Default = mpv options.taupf = (optional) time constant for PF current rise [s] Default = 1e-3. options.tmax = (optional) max time for evolution [s]. Default = 50e-3 options.nt = (optional) # of time points in evolution. Default = calculated on basis of taupf and tmax: nt = 10*(tmax/taupf) options.resv_fix = (optional) modified resv vector to use for calculation. Default = resv from tok_data_struct. OUTPUTS: taupen = estimated penetration time for ipf and Rmeas,Zmeas outputs = structure with other useful quantities (Plots showing fit, if iplot=1) RESTRICTIONS: METHOD: Run lsim for step CURRENT applied to PF coil ipf, generate field history at (Rmeas,Zmeas) measurement point with field type specified by options.Gpc, Gpv, fit result to exponential rise to extract approx single time constant taupen. Fit only to early time corre. to one e-folding (if were pure single-tau exponential) to extract effective single time constant for dominant rise time... Remove all other PF coils from problem, so they're not doing any shielding. USE EXAMPLE: >> tok_data_struct = load_tok_objects('kstar','2010','6565'); >> resv_fix = tok_data_struct.resv; >> resv_fix(71:end) = resv_fix(71:end)*1000; kill all but VV walls >> options.resv_fix = resv_fix; >> taupfs = zeros(14,1); just SC PF's >> for ii=1:14 >> [taupen,ymeas,t] = calc_taupen(tok_data_struct,ii,1.8,0,options); >> taupfs(ii)=taupen; >> end Dependencies \u00b6 eigsort plot_tok_geo deriv find_near","title":"calc_taupen.m"},{"location":"function-guide/tok_models/calc_taupen_m/#calc_taupenm","text":"","title":"calc_taupen.m"},{"location":"function-guide/tok_models/calc_taupen_m/#basic-information","text":"USAGE: >> taupen = calc_taupen(tok_data_struct,ipf,Rmeas,Zmeas,options); PURPOSE: Function to calculate pentration time for generic tokamak by driving PF coils with step CURRENT to produce VV currents and calculate field at meas point INPUTS: tok_data_struct = standard TokSys vacuum objects structure ipf = index of PF coil to drive and calculate measurement time Rmeas,Zmeas = R,Z values at which to measure penetration [m] options.iplot = (optional) flag to enable plotting of time history for estimation of penetration time for PF ipf at (Rmeas,Zmeas). Default = 1 options.Gpc = (optional) Green function object desired for penetration time estimation. Must be a PF-coil-to-grid object. Default = mpc options.Gpv = (optional) Green function object desired for penetration time estimation. Must be a VV-element-to-grid object. Default = mpv options.taupf = (optional) time constant for PF current rise [s] Default = 1e-3. options.tmax = (optional) max time for evolution [s]. Default = 50e-3 options.nt = (optional) # of time points in evolution. Default = calculated on basis of taupf and tmax: nt = 10*(tmax/taupf) options.resv_fix = (optional) modified resv vector to use for calculation. Default = resv from tok_data_struct. OUTPUTS: taupen = estimated penetration time for ipf and Rmeas,Zmeas outputs = structure with other useful quantities (Plots showing fit, if iplot=1) RESTRICTIONS: METHOD: Run lsim for step CURRENT applied to PF coil ipf, generate field history at (Rmeas,Zmeas) measurement point with field type specified by options.Gpc, Gpv, fit result to exponential rise to extract approx single time constant taupen. Fit only to early time corre. to one e-folding (if were pure single-tau exponential) to extract effective single time constant for dominant rise time... Remove all other PF coils from problem, so they're not doing any shielding. USE EXAMPLE: >> tok_data_struct = load_tok_objects('kstar','2010','6565'); >> resv_fix = tok_data_struct.resv; >> resv_fix(71:end) = resv_fix(71:end)*1000; kill all but VV walls >> options.resv_fix = resv_fix; >> taupfs = zeros(14,1); just SC PF's >> for ii=1:14 >> [taupen,ymeas,t] = calc_taupen(tok_data_struct,ii,1.8,0,options); >> taupfs(ii)=taupen; >> end","title":"Basic Information"},{"location":"function-guide/tok_models/calc_taupen_m/#dependencies","text":"eigsort plot_tok_geo deriv find_near","title":"Dependencies"},{"location":"function-guide/tok_models/calc_vv_resvals_m/","text":"calc_vv_resvals.m \u00b6 Basic Information \u00b6 SYNTAX: [resvv,vals,vecs] = calc_vv_resvals(tok_data_struct) PURPOSE: Calculate one-turn resistance of vacuum vessel from tok_data_struct objects, and also calculate eigenvalues/ vectors from the vessel-only passive system. Prints various values to standard output and passes to output variables. INPUTS: tok_data_struct = standard TokSys passive system data structure which must include mvv, resv OUTPUTS: resvv = one-turn resistance of VV [Ohms] vals = eigenvalues of vessel system amatvv=-inv(mvv)*diag(resv); vecs = eigenvectors of vessel system amatvv=-inv(mvv)*diag(resv); RESTRICTIONS: METHOD: Dependencies \u00b6 eigsort","title":"calc_vv_resvals.m"},{"location":"function-guide/tok_models/calc_vv_resvals_m/#calc_vv_resvalsm","text":"","title":"calc_vv_resvals.m"},{"location":"function-guide/tok_models/calc_vv_resvals_m/#basic-information","text":"SYNTAX: [resvv,vals,vecs] = calc_vv_resvals(tok_data_struct) PURPOSE: Calculate one-turn resistance of vacuum vessel from tok_data_struct objects, and also calculate eigenvalues/ vectors from the vessel-only passive system. Prints various values to standard output and passes to output variables. INPUTS: tok_data_struct = standard TokSys passive system data structure which must include mvv, resv OUTPUTS: resvv = one-turn resistance of VV [Ohms] vals = eigenvalues of vessel system amatvv=-inv(mvv)*diag(resv); vecs = eigenvectors of vessel system amatvv=-inv(mvv)*diag(resv); RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/calc_vv_resvals_m/#dependencies","text":"eigsort","title":"Dependencies"},{"location":"function-guide/tok_models/calc_x_m/","text":"calc_x.m \u00b6 Basic Information \u00b6 USAGE: [xresp,x,bresp,b,xtarget] = calc_x(xtarget,tok_data_struct,resp,eq,idoplot) PURPOSE: Find x-points and responses thereof *in vicinity of* specified target points and also return Br, Bz and their responses *at* specified target points. INPUTS: xtarget: specification on the form [r z] where r and z are column vectors of approximate or target x-point locations. If xtarget is empty, the default is bottom and top of boundary. tok_data_struct: toksys description of tokamak resp: (optional) the output from a response model (gspert or rzrig) eq: equilibrium structure idoplot: flag to plot limiter, boundary, xtarget points and x-points OUTPUTS: xresp: response structure with fields: drxdis: rx response to conductors [m/A] dzxdis: zx response to conductors [m/A] drxdip,*dli,*dbetap, etc: exogenous responses x: the x-points on form [rx zx] found near xtarget points bresp: response structure with fields: dbrdis: br response at points xtarget to conductors [T/A] dbzdis: bz response at points xtarget to conductors [T/A] dbrdip,*dli,*dbetap, etc: exogenous responses b: The fields at xtarget points on the form [br bz] xtarget: Target location for x-points (same as input if input is not empty) Dependencies \u00b6 wait","title":"calc_x.m"},{"location":"function-guide/tok_models/calc_x_m/#calc_xm","text":"","title":"calc_x.m"},{"location":"function-guide/tok_models/calc_x_m/#basic-information","text":"USAGE: [xresp,x,bresp,b,xtarget] = calc_x(xtarget,tok_data_struct,resp,eq,idoplot) PURPOSE: Find x-points and responses thereof *in vicinity of* specified target points and also return Br, Bz and their responses *at* specified target points. INPUTS: xtarget: specification on the form [r z] where r and z are column vectors of approximate or target x-point locations. If xtarget is empty, the default is bottom and top of boundary. tok_data_struct: toksys description of tokamak resp: (optional) the output from a response model (gspert or rzrig) eq: equilibrium structure idoplot: flag to plot limiter, boundary, xtarget points and x-points OUTPUTS: xresp: response structure with fields: drxdis: rx response to conductors [m/A] dzxdis: zx response to conductors [m/A] drxdip,*dli,*dbetap, etc: exogenous responses x: the x-points on form [rx zx] found near xtarget points bresp: response structure with fields: dbrdis: br response at points xtarget to conductors [T/A] dbzdis: bz response at points xtarget to conductors [T/A] dbrdip,*dli,*dbetap, etc: exogenous responses b: The fields at xtarget points on the form [br bz] xtarget: Target location for x-points (same as input if input is not empty)","title":"Basic Information"},{"location":"function-guide/tok_models/calc_x_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/tok_models/change_tokobj_units_m/","text":"change_tokobj_units.m \u00b6 Basic Information \u00b6 USAGE: mod_data_struct=change_tokobj_units(tok_data_struct,imks,iterminal) PURPOSE: Create a copy of the tokamak vacuum data objects data structure with specified units and turns convention. INPUTS: tok_data_struct = data structure, contents defined by creation in make_tok_objects.m imks = if 1, create data objects in MKS units, 0 means currents in MA iterminal = if 1, all multi-turn coils are interpreted to be in \"terminal mode\", e.g. currents are as measured at input or output terminals, 0 means \"lumped mode\", e.g. current is total cross-sectional current in multi-turn coil. OUTPUTS: mod_data_struct = same data structure, but with modified data objects Dependencies \u00b6 wait","title":"change_tokobj_units.m"},{"location":"function-guide/tok_models/change_tokobj_units_m/#change_tokobj_unitsm","text":"","title":"change_tokobj_units.m"},{"location":"function-guide/tok_models/change_tokobj_units_m/#basic-information","text":"USAGE: mod_data_struct=change_tokobj_units(tok_data_struct,imks,iterminal) PURPOSE: Create a copy of the tokamak vacuum data objects data structure with specified units and turns convention. INPUTS: tok_data_struct = data structure, contents defined by creation in make_tok_objects.m imks = if 1, create data objects in MKS units, 0 means currents in MA iterminal = if 1, all multi-turn coils are interpreted to be in \"terminal mode\", e.g. currents are as measured at input or output terminals, 0 means \"lumped mode\", e.g. current is total cross-sectional current in multi-turn coil. OUTPUTS: mod_data_struct = same data structure, but with modified data objects","title":"Basic Information"},{"location":"function-guide/tok_models/change_tokobj_units_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/tok_models/changeq_m/","text":"changeq.m \u00b6 Basic Information \u00b6 USAGE: [eq, eqx] = changeq(eq0,eq_target,tok_data_struct,options,idoplot) PURPOSE: Change an equilibrium from eq0 to eq_target Targeted variables are: (rbbbs,zbbbs), cc, cpasma, betap, li Bus constraint such as the VFI on DIII-D can be imposed on cc INPUTS: eq0: Original equilibrium structure on toksys format eq_target: Equilibrium structure containing target quantities Specify NaN for variables to adjust in order to achieve target example: if cc can be adjusted then set eq_target.cc(:) = NaN; tok_data_struct: standard toksys object for tokamak description options.converrmax = upper limit on flux error in resulting eq options.maxiter: maximum convergence iterations, default = 25; options.cccirc: standard toksys assignment of circuit numbers to coils, options.bus_code: indices are 1 for coils on bus, 0 for others For DIII-D do: PP_objs = get_PP_objs(shot) options.bus_code = [0 0 PP_objs.bus_code] idoplot: plot each iteration for idoplot seconds, default 0 = no plot OUTPUTS: eq: structure containing new converged equilibrium on tok_data_struct grid eqx: structure containing extra information (see eqx.descriptions) RESTRICTIONS: MAXIMUM grid size is 65x65 Only these quantities are updated for the new equilibrium: rbbbs, zbbbs, jphi, psizr, pprime, ffprim, pres, fpol cc, psimag, psibry, cpasma, rmaxis, zmaxis, rg, zg, dr, dz nw, nh, psirz, ssibry, ssimag, qpsi METHOD: Linear solution is found by gspert and converged with convergeq Dependencies \u00b6 convergeq cc_efit_to_tok","title":"changeq.m"},{"location":"function-guide/tok_models/changeq_m/#changeqm","text":"","title":"changeq.m"},{"location":"function-guide/tok_models/changeq_m/#basic-information","text":"USAGE: [eq, eqx] = changeq(eq0,eq_target,tok_data_struct,options,idoplot) PURPOSE: Change an equilibrium from eq0 to eq_target Targeted variables are: (rbbbs,zbbbs), cc, cpasma, betap, li Bus constraint such as the VFI on DIII-D can be imposed on cc INPUTS: eq0: Original equilibrium structure on toksys format eq_target: Equilibrium structure containing target quantities Specify NaN for variables to adjust in order to achieve target example: if cc can be adjusted then set eq_target.cc(:) = NaN; tok_data_struct: standard toksys object for tokamak description options.converrmax = upper limit on flux error in resulting eq options.maxiter: maximum convergence iterations, default = 25; options.cccirc: standard toksys assignment of circuit numbers to coils, options.bus_code: indices are 1 for coils on bus, 0 for others For DIII-D do: PP_objs = get_PP_objs(shot) options.bus_code = [0 0 PP_objs.bus_code] idoplot: plot each iteration for idoplot seconds, default 0 = no plot OUTPUTS: eq: structure containing new converged equilibrium on tok_data_struct grid eqx: structure containing extra information (see eqx.descriptions) RESTRICTIONS: MAXIMUM grid size is 65x65 Only these quantities are updated for the new equilibrium: rbbbs, zbbbs, jphi, psizr, pprime, ffprim, pres, fpol cc, psimag, psibry, cpasma, rmaxis, zmaxis, rg, zg, dr, dz nw, nh, psirz, ssibry, ssimag, qpsi METHOD: Linear solution is found by gspert and converged with convergeq","title":"Basic Information"},{"location":"function-guide/tok_models/changeq_m/#dependencies","text":"convergeq cc_efit_to_tok","title":"Dependencies"},{"location":"function-guide/tok_models/check_tok_objects_m/","text":"check_tok_objects.m \u00b6 Basic Information \u00b6 USAGE: >> check_tok_objects(tok_data_struct,plot_geo_fun, ... efit_gfile,read_gfile_fun); PURPOSE: Function to do checks of mutuals, Green functions for tokamak system analogous to D3D Electromagnetic Environment. INPUTS: tok_data_struct = standard structure containing vacuum objects plot_geo_fun = name of geometry plotting script to use (e.g. 'plot_east_geo') efit_gfile = (opt) name of EFIT gfile for equilibrium plotting read_gfile_fun = (opt) name of gfile reader to use (if efit_gfile) OUTPUTS: Checks of various objects, plots to confirm... valsv = VV eigenvalues (rad/sec) RESTRICTIONS: METHOD: cmpares some object values with grid-to-s.t., does some eigenvalue calculations, displays results to check... Dependencies \u00b6 eigsort","title":"check_tok_objects.m"},{"location":"function-guide/tok_models/check_tok_objects_m/#check_tok_objectsm","text":"","title":"check_tok_objects.m"},{"location":"function-guide/tok_models/check_tok_objects_m/#basic-information","text":"USAGE: >> check_tok_objects(tok_data_struct,plot_geo_fun, ... efit_gfile,read_gfile_fun); PURPOSE: Function to do checks of mutuals, Green functions for tokamak system analogous to D3D Electromagnetic Environment. INPUTS: tok_data_struct = standard structure containing vacuum objects plot_geo_fun = name of geometry plotting script to use (e.g. 'plot_east_geo') efit_gfile = (opt) name of EFIT gfile for equilibrium plotting read_gfile_fun = (opt) name of gfile reader to use (if efit_gfile) OUTPUTS: Checks of various objects, plots to confirm... valsv = VV eigenvalues (rad/sec) RESTRICTIONS: METHOD: cmpares some object values with grid-to-s.t., does some eigenvalue calculations, displays results to check...","title":"Basic Information"},{"location":"function-guide/tok_models/check_tok_objects_m/#dependencies","text":"eigsort","title":"Dependencies"},{"location":"function-guide/tok_models/convergeq_m/","text":"convergeq.m \u00b6 Basic Information \u00b6 USAGE: [ceq, eqx] = convergeq(eq,tok_data_struct,options,idoplot) PURPOSE: Converge equilibrium, i.e. minimize psizr_app+psizr_pla - psizr where psizr_app is calculated from mpc, cc and psizr_pla from mpp, jphi and jphi in turn is calculated using psizr, pprime, ffprim \u0006 The converged equilibrium is on the grid in tok_data_struct which can be different from the grid in the original efit. Bus constraint such as the VFI on DIII-D can be imposed on cc INPUTS: eq: An equilibrium containing at least psizr, pprime, ffprim, cc tok_data_struct: standard toksys object for tokamak description options.converrmax = upper limit on resulting flux error max(abs(psizr_app(:)+psizr_pla(:)-psizr(:))), default 1e-12 options.iconstraints: (default is 3) 0. conserve pres and fpol as functions of normalized flux 1: conserve pres and total plasma current 2: conserve thermal energy and fpol 3: conserve thermal energy and total plasma current options.maxiter: maximum number of iterations, default = 25; options.icx: Specify a subset of cc that can change, default icx=1:nc options.cccirc: standard toksys assignment of circuit numbers to coils, options.bus_code: indices are 1 for coils on bus, 0 for others bus_code*cc = 0 (bus_code is row vector and cc is column vector) cc will be adjusted to meet the constraint: bus_code*cc = 0 For DIII-D: PP_objs = get_PP_objs(shot) options.bus_code = [0 0 PP_objs.bus_code] idoplot: plot each iteration for idoplot seconds, default 0 = no plot OUTPUTS: ceq: structure containing converged equilibrium on tok_data_struct grid eqx: structure containing extra information (see eqx.descriptions) RESTRICTIONS: The following quantities are updated for converged equilibrium: rbbbs, zbbbs, jphi, psizr, pprime, ffprim, pres, fpol cc, psimag, psibry, cpasma, rmaxis, zmaxis, rg, zg, dr, dz nw, nh, psirz, ssibry, ssimag, qpsi METHOD: The Newton-Rhapson method is used to converge to the solution. Dependencies \u00b6 wait cc_efit_to_tok","title":"convergeq.m"},{"location":"function-guide/tok_models/convergeq_m/#convergeqm","text":"","title":"convergeq.m"},{"location":"function-guide/tok_models/convergeq_m/#basic-information","text":"USAGE: [ceq, eqx] = convergeq(eq,tok_data_struct,options,idoplot) PURPOSE: Converge equilibrium, i.e. minimize psizr_app+psizr_pla - psizr where psizr_app is calculated from mpc, cc and psizr_pla from mpp, jphi and jphi in turn is calculated using psizr, pprime, ffprim \u0006 The converged equilibrium is on the grid in tok_data_struct which can be different from the grid in the original efit. Bus constraint such as the VFI on DIII-D can be imposed on cc INPUTS: eq: An equilibrium containing at least psizr, pprime, ffprim, cc tok_data_struct: standard toksys object for tokamak description options.converrmax = upper limit on resulting flux error max(abs(psizr_app(:)+psizr_pla(:)-psizr(:))), default 1e-12 options.iconstraints: (default is 3) 0. conserve pres and fpol as functions of normalized flux 1: conserve pres and total plasma current 2: conserve thermal energy and fpol 3: conserve thermal energy and total plasma current options.maxiter: maximum number of iterations, default = 25; options.icx: Specify a subset of cc that can change, default icx=1:nc options.cccirc: standard toksys assignment of circuit numbers to coils, options.bus_code: indices are 1 for coils on bus, 0 for others bus_code*cc = 0 (bus_code is row vector and cc is column vector) cc will be adjusted to meet the constraint: bus_code*cc = 0 For DIII-D: PP_objs = get_PP_objs(shot) options.bus_code = [0 0 PP_objs.bus_code] idoplot: plot each iteration for idoplot seconds, default 0 = no plot OUTPUTS: ceq: structure containing converged equilibrium on tok_data_struct grid eqx: structure containing extra information (see eqx.descriptions) RESTRICTIONS: The following quantities are updated for converged equilibrium: rbbbs, zbbbs, jphi, psizr, pprime, ffprim, pres, fpol cc, psimag, psibry, cpasma, rmaxis, zmaxis, rg, zg, dr, dz nw, nh, psirz, ssibry, ssimag, qpsi METHOD: The Newton-Rhapson method is used to converge to the solution.","title":"Basic Information"},{"location":"function-guide/tok_models/convergeq_m/#dependencies","text":"wait cc_efit_to_tok","title":"Dependencies"},{"location":"function-guide/tok_models/create_noise_link_m/","text":"create_noise_link.m \u00b6 Basic Information \u00b6 SYNTAX: create_noise_link(filename) PURPOSE: Creates a soft link in the working directory called \"noise.mat\" to an existing file named by filename. The file specified by filename must exist or the fucntion will error out. INPUTS: filename = the full path to the existing file that is to be linked to \"noise.mat\" OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise_file, make_noise Dependencies \u00b6","title":"create_noise_link.m"},{"location":"function-guide/tok_models/create_noise_link_m/#create_noise_linkm","text":"","title":"create_noise_link.m"},{"location":"function-guide/tok_models/create_noise_link_m/#basic-information","text":"SYNTAX: create_noise_link(filename) PURPOSE: Creates a soft link in the working directory called \"noise.mat\" to an existing file named by filename. The file specified by filename must exist or the fucntion will error out. INPUTS: filename = the full path to the existing file that is to be linked to \"noise.mat\" OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise_file, make_noise","title":"Basic Information"},{"location":"function-guide/tok_models/create_noise_link_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/divertor_model_m/","text":"divertor_model.m \u00b6 Basic Information \u00b6 SYNTAX: [nec,Wth,Qtard,nec2,nrc2,nrd2,output_data]= divertor_model(Gamec,Gamrc,Gamrd,nec1,nrc1,nrd1,dt); PURPOSE: Model evolution of divertor (and core) plasma states in response to changing gas flow rates. Outputs quantities useful to measure for active feedback control of divertor (and core) properties. Evolves single time step on call INPUTS: Gamec = core fueling gas flow rate (hydrogenic, so same as electron) [atoms/m^3/sec = electrons/m^3/sec] Gamrc = core radiating impurity (RI) flow rate [atoms/m^3/sec] Gamrd = divertor radiating impurity flow rate [atoms/m^3/sec] nec1 = initial core electron density [electrons/m^3] nrc1 = initial core RI density [ions/m^3] nrd1 = initial divertor RI density [ions/m^3] dt = time step [sec] OUTPUTS: nec = present core electron density output (same as nec2) [electrons/m^3] Wth = core thermal stored energy output [J] Qtard = heat flux to divertor target output [W/s] nec2 = core electron density after time step dt [electrons/m^3] nrc2 = core RI density after time step dt [ions/m^3] nrd2 = divertor RI density after time step dt [ions/m^3] output_data = structure with useful data to provide to analyze output: Pradc, Pradd RESTRICTIONS: METHOD: State equations are the three continuity equations for nec, nrc, nrd. Output equations describe Wth Qtard as function of input heating power Pheat and radiated core power Pradc. nec is the third output variable. Pradc represented by Bremsstrahlung-like expression including both core electron-electron and electron-impurity collisions. Pradd (radiation from divertor) represented by empirical function to capture observed behavior of ionization/density front up and along divertor legs, with corresponding maximum in radiation as function of upstream density (nec). Scale factor of 150 makes function produce ~ 1 MW total rad pwr for 2 keV, 2e19 plasma w/ no impurity... Pradd coeff Crd is chosen so 2e19 core density makes ~1.5 MW rad in div State equations evolved by implicit scheme (exponential solution over time step) Dependencies \u00b6","title":"divertor_model.m"},{"location":"function-guide/tok_models/divertor_model_m/#divertor_modelm","text":"","title":"divertor_model.m"},{"location":"function-guide/tok_models/divertor_model_m/#basic-information","text":"SYNTAX: [nec,Wth,Qtard,nec2,nrc2,nrd2,output_data]= divertor_model(Gamec,Gamrc,Gamrd,nec1,nrc1,nrd1,dt); PURPOSE: Model evolution of divertor (and core) plasma states in response to changing gas flow rates. Outputs quantities useful to measure for active feedback control of divertor (and core) properties. Evolves single time step on call INPUTS: Gamec = core fueling gas flow rate (hydrogenic, so same as electron) [atoms/m^3/sec = electrons/m^3/sec] Gamrc = core radiating impurity (RI) flow rate [atoms/m^3/sec] Gamrd = divertor radiating impurity flow rate [atoms/m^3/sec] nec1 = initial core electron density [electrons/m^3] nrc1 = initial core RI density [ions/m^3] nrd1 = initial divertor RI density [ions/m^3] dt = time step [sec] OUTPUTS: nec = present core electron density output (same as nec2) [electrons/m^3] Wth = core thermal stored energy output [J] Qtard = heat flux to divertor target output [W/s] nec2 = core electron density after time step dt [electrons/m^3] nrc2 = core RI density after time step dt [ions/m^3] nrd2 = divertor RI density after time step dt [ions/m^3] output_data = structure with useful data to provide to analyze output: Pradc, Pradd RESTRICTIONS: METHOD: State equations are the three continuity equations for nec, nrc, nrd. Output equations describe Wth Qtard as function of input heating power Pheat and radiated core power Pradc. nec is the third output variable. Pradc represented by Bremsstrahlung-like expression including both core electron-electron and electron-impurity collisions. Pradd (radiation from divertor) represented by empirical function to capture observed behavior of ionization/density front up and along divertor legs, with corresponding maximum in radiation as function of upstream density (nec). Scale factor of 150 makes function produce ~ 1 MW total rad pwr for 2 keV, 2e19 plasma w/ no impurity... Pradd coeff Crd is chosen so 2e19 core density makes ~1.5 MW rad in div State equations evolved by implicit scheme (exponential solution over time step)","title":"Basic Information"},{"location":"function-guide/tok_models/divertor_model_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/evolveq_m/","text":"evolveq.m \u00b6 Basic Information \u00b6 USAGE: [y, e, eq, eqx] = evolveq(u,C,tok,eq0) PURPOSE: Evolve an equilibrium. Initialize by calling with all arguments: y = evolveq(u,C,tok,eq0) Evolve by calling with new inputs in u: y = evolveq(u) INPUTS: u, structure with inputs that affect the equilibrium: cc0t: coil currents such that psizr_app = mpc*cc0t vc0t: vessel currents such that psizr_app = mpv*vc0t ip: plasma current li: normalized inductance betap: poloidal beta If an input is missing then no change of the quantity is made. C, output matrix such that y = C*[cc0t; vc0t; pcurrt], where pcurrt is plasma currents within grid elements [A] Example: C = [[mcc mcv mpc']; [mcv' mvv mpv']] outputs flux at conductors tok, Toksys description of the tokamak eq0, initial equilibrium OUTPUTS: y, outputs defined by C e, structure with all persistent variables eq, equilibrium (returning eq increases execution time) eqx. last analyzed equilibrium and some simulation parameters METHOD: The equilibrium and its response matrix are persistent variables. When the routine is called, the equilibrium is updated by the linear response to the changes that have occurred in u, and a new output, y is calculated. Large changes can be made in one step, evolveq estimates magnitude of nonlinear response and divides large changes into several smaller internally. When uncertainties in the linear response have accrued, a correction is made. When the response matrix becomes inaccurate a new is calculated. Dependencies \u00b6 cc_efit_to_tok","title":"evolveq.m"},{"location":"function-guide/tok_models/evolveq_m/#evolveqm","text":"","title":"evolveq.m"},{"location":"function-guide/tok_models/evolveq_m/#basic-information","text":"USAGE: [y, e, eq, eqx] = evolveq(u,C,tok,eq0) PURPOSE: Evolve an equilibrium. Initialize by calling with all arguments: y = evolveq(u,C,tok,eq0) Evolve by calling with new inputs in u: y = evolveq(u) INPUTS: u, structure with inputs that affect the equilibrium: cc0t: coil currents such that psizr_app = mpc*cc0t vc0t: vessel currents such that psizr_app = mpv*vc0t ip: plasma current li: normalized inductance betap: poloidal beta If an input is missing then no change of the quantity is made. C, output matrix such that y = C*[cc0t; vc0t; pcurrt], where pcurrt is plasma currents within grid elements [A] Example: C = [[mcc mcv mpc']; [mcv' mvv mpv']] outputs flux at conductors tok, Toksys description of the tokamak eq0, initial equilibrium OUTPUTS: y, outputs defined by C e, structure with all persistent variables eq, equilibrium (returning eq increases execution time) eqx. last analyzed equilibrium and some simulation parameters METHOD: The equilibrium and its response matrix are persistent variables. When the routine is called, the equilibrium is updated by the linear response to the changes that have occurred in u, and a new output, y is calculated. Large changes can be made in one step, evolveq estimates magnitude of nonlinear response and divides large changes into several smaller internally. When uncertainties in the linear response have accrued, a correction is made. When the response matrix becomes inaccurate a new is calculated.","title":"Basic Information"},{"location":"function-guide/tok_models/evolveq_m/#dependencies","text":"cc_efit_to_tok","title":"Dependencies"},{"location":"function-guide/tok_models/gbr2p_x_vec_m/","text":"gbr2p_x_vec.m \u00b6 Basic Information \u00b6 SYNTAX: product = gbr2p_x_vec(gbr2p,vec) PURPOSE: Compute product of matrix gbr2p and vector vec, where gbr2p is stored in compressed format. Use mpp_x_vec for multiplication with either mpp or gbz2p. INPUT: gbr2p = plasma grid to plasma grid mutuals in compressed format OUTPUT: product = product of matrix multiplication SEE ALSO: get_plasma_greens, mpp_x_vec Dependencies \u00b6","title":"gbr2p_x_vec.m"},{"location":"function-guide/tok_models/gbr2p_x_vec_m/#gbr2p_x_vecm","text":"","title":"gbr2p_x_vec.m"},{"location":"function-guide/tok_models/gbr2p_x_vec_m/#basic-information","text":"SYNTAX: product = gbr2p_x_vec(gbr2p,vec) PURPOSE: Compute product of matrix gbr2p and vector vec, where gbr2p is stored in compressed format. Use mpp_x_vec for multiplication with either mpp or gbz2p. INPUT: gbr2p = plasma grid to plasma grid mutuals in compressed format OUTPUT: product = product of matrix multiplication SEE ALSO: get_plasma_greens, mpp_x_vec","title":"Basic Information"},{"location":"function-guide/tok_models/gbr2p_x_vec_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/getIq_m/","text":"getIq.m \u00b6 Basic Information \u00b6 USAGE: [Iq, t, Iqn] = getIq(shot,q,t1,t2,efit_source,tokamak) PURPOSE: get current within q-surface INPUTS: shot: shot number q: q-values for surfaces (default 2) t1, t2: Specification of the time samples (t) t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: (default efit02) tokamak: (default d3d) OUTPUTS: Iq: current within q-contours t: times [sec] Iqn: Iq/cpasma, i.e. fraction of current within q-surfaces Dependencies \u00b6 read_eq","title":"getIq.m"},{"location":"function-guide/tok_models/getIq_m/#getiqm","text":"","title":"getIq.m"},{"location":"function-guide/tok_models/getIq_m/#basic-information","text":"USAGE: [Iq, t, Iqn] = getIq(shot,q,t1,t2,efit_source,tokamak) PURPOSE: get current within q-surface INPUTS: shot: shot number q: q-values for surfaces (default 2) t1, t2: Specification of the time samples (t) t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: (default efit02) tokamak: (default d3d) OUTPUTS: Iq: current within q-contours t: times [sec] Iqn: Iq/cpasma, i.e. fraction of current within q-surfaces","title":"Basic Information"},{"location":"function-guide/tok_models/getIq_m/#dependencies","text":"read_eq","title":"Dependencies"},{"location":"function-guide/tok_models/get_plasma_greens_m/","text":"get_plasma_greens.m \u00b6 Basic Information \u00b6 SYNTAX: [mp,gbr,gbz]=... get_plasma_greens(mpp,gbr2p,gbz2p,src_r_idx,src_z_idx,nz) PURPOSE: Get mutual inductance, Br, and Bz green's function responses (plasma green's functions) to a given grid point current source. INPUT: mpp = plasma grid to plasma grid mutuals in compressed format gbr2p = Br green's functions from plasma grid to plasma grid in compressed format gbz2p = Bz green's functions from plasma grid to plasma grid in compressed format src_r_idx = index of r coordinate of current source in overall grid (0 < src_r_idx <= nr) src_z_idx = index of z coordinate of current source in overall grid (0 < src_z_idx <= nz) nz = number of grids in z dimension OUTPUT: mp = mutuals from selected grid current source to all other grids gbr = Br greens fns from selected grid current source to all other grids gbz = Bz greens fns from selected grid current source to all other grids (Output units are same as input objects mpp, gbr2p, gbz2p.) SEE ALSO: mpp_x_vec Dependencies \u00b6","title":"get_plasma_greens.m"},{"location":"function-guide/tok_models/get_plasma_greens_m/#get_plasma_greensm","text":"","title":"get_plasma_greens.m"},{"location":"function-guide/tok_models/get_plasma_greens_m/#basic-information","text":"SYNTAX: [mp,gbr,gbz]=... get_plasma_greens(mpp,gbr2p,gbz2p,src_r_idx,src_z_idx,nz) PURPOSE: Get mutual inductance, Br, and Bz green's function responses (plasma green's functions) to a given grid point current source. INPUT: mpp = plasma grid to plasma grid mutuals in compressed format gbr2p = Br green's functions from plasma grid to plasma grid in compressed format gbz2p = Bz green's functions from plasma grid to plasma grid in compressed format src_r_idx = index of r coordinate of current source in overall grid (0 < src_r_idx <= nr) src_z_idx = index of z coordinate of current source in overall grid (0 < src_z_idx <= nz) nz = number of grids in z dimension OUTPUT: mp = mutuals from selected grid current source to all other grids gbr = Br greens fns from selected grid current source to all other grids gbz = Bz greens fns from selected grid current source to all other grids (Output units are same as input objects mpp, gbr2p, gbz2p.) SEE ALSO: mpp_x_vec","title":"Basic Information"},{"location":"function-guide/tok_models/get_plasma_greens_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/getgaps_m/","text":"getgaps.m \u00b6 Basic Information \u00b6 USAGE: [gaps,t, gapspec] = getgaps(shot,gapspec,t1,t2,efit_source,tokamak,idoplot) PURPOSE: Get gaps defined by gapspec A gap is defined as the distance between the plasma boundary and the wall along a line through a specified \"gap location\", with direction of measurement defined by gradient of flux for a nominal equilibrium at that prescribed \"gap location\". INPUTS: shot: shot number gapspec: gap specification on the form [r z gr gz] r,z is gap location and gr,gz nominal gradient default gaps are: inner, upper, outer, lower see also calc_gaps t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: string with name of efit-tree OR equil_data default efit01 for shot<900000, efitrt1 for shot>=900000 tokamak: default d3d idoplot: flag to plot limiter, gap locations, and gap vectors OUTPUTS: gaps: distances from boundary to wall through r,z along gr,gz [m] t: time [sec] gapspec: gapspec that was used (supplied in call or default) Dependencies \u00b6 wait read_eq","title":"getgaps.m"},{"location":"function-guide/tok_models/getgaps_m/#getgapsm","text":"","title":"getgaps.m"},{"location":"function-guide/tok_models/getgaps_m/#basic-information","text":"USAGE: [gaps,t, gapspec] = getgaps(shot,gapspec,t1,t2,efit_source,tokamak,idoplot) PURPOSE: Get gaps defined by gapspec A gap is defined as the distance between the plasma boundary and the wall along a line through a specified \"gap location\", with direction of measurement defined by gradient of flux for a nominal equilibrium at that prescribed \"gap location\". INPUTS: shot: shot number gapspec: gap specification on the form [r z gr gz] r,z is gap location and gr,gz nominal gradient default gaps are: inner, upper, outer, lower see also calc_gaps t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: string with name of efit-tree OR equil_data default efit01 for shot<900000, efitrt1 for shot>=900000 tokamak: default d3d idoplot: flag to plot limiter, gap locations, and gap vectors OUTPUTS: gaps: distances from boundary to wall through r,z along gr,gz [m] t: time [sec] gapspec: gapspec that was used (supplied in call or default)","title":"Basic Information"},{"location":"function-guide/tok_models/getgaps_m/#dependencies","text":"wait read_eq","title":"Dependencies"},{"location":"function-guide/tok_models/getiso_m/","text":"getiso.m \u00b6 Basic Information \u00b6 USAGE: [iso,t] = getiso(shot,rziso,t1,t2,efit_source,tokamak,idoplot) PURPOSE: Get iso fluxes and fields at rziso points INPUTS: shot: shot number rziso: R, Z of isoflux points arranged as [R(:) Z(:)] (unit: meters) t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: string with name of efit-tree OR equil_data default efit01 for shot<900000, efitrt1 for shot>=900000 tokamak: default d3d idoplot: flag to plot limiter and rziso points OUTPUTS: iso: structure with fields: psi: flux at rziso points br, bz: Br, Bz at rziso points t: time [sec] Dependencies \u00b6 read_eq","title":"getiso.m"},{"location":"function-guide/tok_models/getiso_m/#getisom","text":"","title":"getiso.m"},{"location":"function-guide/tok_models/getiso_m/#basic-information","text":"USAGE: [iso,t] = getiso(shot,rziso,t1,t2,efit_source,tokamak,idoplot) PURPOSE: Get iso fluxes and fields at rziso points INPUTS: shot: shot number rziso: R, Z of isoflux points arranged as [R(:) Z(:)] (unit: meters) t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: string with name of efit-tree OR equil_data default efit01 for shot<900000, efitrt1 for shot>=900000 tokamak: default d3d idoplot: flag to plot limiter and rziso points OUTPUTS: iso: structure with fields: psi: flux at rziso points br, bz: Br, Bz at rziso points t: time [sec]","title":"Basic Information"},{"location":"function-guide/tok_models/getiso_m/#dependencies","text":"read_eq","title":"Dependencies"},{"location":"function-guide/tok_models/getxpt_m/","text":"getxpt.m \u00b6 Basic Information \u00b6 USAGE: [rx,zx,psix,t,br,bz,eqs] = getxpt(shot,t1,t2,efit_source,tokamak,xtarget,idoplot) PURPOSE: Get coordinates for 1 x-point below and 1 above the magnetic axis. The points where flux is closest to the boundary flux are chosen. Also return the flux at these x-points and at the boundary. In addition return Br, Bz at xtarget points (if specified) INPUTS: shot: shot number t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: Structure with equilibria or name of MDS tree or directory with gfiles or corsica flat files (see help read_eq), default EFIT01 for shot<900000, EFITRT1 for shot>=900000 tokamak: default D3D xtarget: specification on the form [r z] where r and z are column vectors of target x-point locations, for calculation of Br, Bz. idoplot: flag to plot x-point trajectories and limiter, bit 0 plots x's, bit 1 plots limiter, bit 2 adds text, bit 3 adds color coding of times, bit 4 adds colorbar, idoplot=31 plots it all, default is 0. OUTPUTS: rx: radial position of x-points [lower; upper] [m] zx: vertical position of x-points [lower; upper] [m] psix: fluxes at [lower x; upper x; boundary] [Wb] t: time [sec] br: radial magnetic field at xtarget points bz: vertical magnetic field at xtarget points eqs: The structure with equilibria from efit_source Dependencies \u00b6 read_eq","title":"getxpt.m"},{"location":"function-guide/tok_models/getxpt_m/#getxptm","text":"","title":"getxpt.m"},{"location":"function-guide/tok_models/getxpt_m/#basic-information","text":"USAGE: [rx,zx,psix,t,br,bz,eqs] = getxpt(shot,t1,t2,efit_source,tokamak,xtarget,idoplot) PURPOSE: Get coordinates for 1 x-point below and 1 above the magnetic axis. The points where flux is closest to the boundary flux are chosen. Also return the flux at these x-points and at the boundary. In addition return Br, Bz at xtarget points (if specified) INPUTS: shot: shot number t1, t2: Specification of the time samples (t) t = all efit times, if t1,t2 are empty or not supplied t1 <= t <= t2, if length(t1)==1 & length(t2)==1 t = t1, if length(t1)>=1 & length(t2)==0 efit_source: Structure with equilibria or name of MDS tree or directory with gfiles or corsica flat files (see help read_eq), default EFIT01 for shot<900000, EFITRT1 for shot>=900000 tokamak: default D3D xtarget: specification on the form [r z] where r and z are column vectors of target x-point locations, for calculation of Br, Bz. idoplot: flag to plot x-point trajectories and limiter, bit 0 plots x's, bit 1 plots limiter, bit 2 adds text, bit 3 adds color coding of times, bit 4 adds colorbar, idoplot=31 plots it all, default is 0. OUTPUTS: rx: radial position of x-points [lower; upper] [m] zx: vertical position of x-points [lower; upper] [m] psix: fluxes at [lower x; upper x; boundary] [Wb] t: time [sec] br: radial magnetic field at xtarget points bz: vertical magnetic field at xtarget points eqs: The structure with equilibria from efit_source","title":"Basic Information"},{"location":"function-guide/tok_models/getxpt_m/#dependencies","text":"read_eq","title":"Dependencies"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DN_m/","text":"gsdesign_demo_d3d_DN.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_d3d_DN PURPOSE: DEMO of gsdesign showing design of EAST-like double-x-point for DIII-D INPUTS: none OUTPUTS: eq, a double snowflake equilibrium Dependencies \u00b6 regrid","title":"gsdesign_demo_d3d_DN.m"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DN_m/#gsdesign_demo_d3d_dnm","text":"","title":"gsdesign_demo_d3d_DN.m"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DN_m/#basic-information","text":"USAGE: gsdesign_demo_d3d_DN PURPOSE: DEMO of gsdesign showing design of EAST-like double-x-point for DIII-D INPUTS: none OUTPUTS: eq, a double snowflake equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DN_m/#dependencies","text":"regrid","title":"Dependencies"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DSNF_m/","text":"gsdesign_demo_d3d_DSNF.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_d3d_DSNF PURPOSE: DEMO of gsdesign showing design of double-snowflake for DIII-D INPUTS: none OUTPUTS: eq, a double snowflake equilibrium Dependencies \u00b6","title":"gsdesign_demo_d3d_DSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DSNF_m/#gsdesign_demo_d3d_dsnfm","text":"","title":"gsdesign_demo_d3d_DSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DSNF_m/#basic-information","text":"USAGE: gsdesign_demo_d3d_DSNF PURPOSE: DEMO of gsdesign showing design of double-snowflake for DIII-D INPUTS: none OUTPUTS: eq, a double snowflake equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_d3d_DSNF_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/gsdesign_demo_east_DSNF_m/","text":"gsdesign_demo_east_DSNF.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_east_DSNF PURPOSE: DEMO of gsdesign showing design of double-snowflake for EAST INPUTS: none OUTPUTS: eq, a double snowflake equilibrium Dependencies \u00b6","title":"gsdesign_demo_east_DSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_east_DSNF_m/#gsdesign_demo_east_dsnfm","text":"","title":"gsdesign_demo_east_DSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_east_DSNF_m/#basic-information","text":"USAGE: gsdesign_demo_east_DSNF PURPOSE: DEMO of gsdesign showing design of double-snowflake for EAST INPUTS: none OUTPUTS: eq, a double snowflake equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_east_DSNF_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/gsdesign_demo_east_LSNF_m/","text":"gsdesign_demo_east_LSNF.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_east_LSNF PURPOSE: DEMO of gsdesign showing design of lower-snowflake for EAST INPUTS: none OUTPUTS: eq, a lower-snowflake equilibrium Dependencies \u00b6","title":"gsdesign_demo_east_LSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_east_LSNF_m/#gsdesign_demo_east_lsnfm","text":"","title":"gsdesign_demo_east_LSNF.m"},{"location":"function-guide/tok_models/gsdesign_demo_east_LSNF_m/#basic-information","text":"USAGE: gsdesign_demo_east_LSNF PURPOSE: DEMO of gsdesign showing design of lower-snowflake for EAST INPUTS: none OUTPUTS: eq, a lower-snowflake equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_east_LSNF_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/gsdesign_demo_iter_m/","text":"gsdesign_demo_iter.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_iter PURPOSE: Design equilibrium for ITER INPUTS: None (just run the code) OUTPUTS: Plots and designed equilibrium METHOD: Dependencies \u00b6","title":"gsdesign_demo_iter.m"},{"location":"function-guide/tok_models/gsdesign_demo_iter_m/#gsdesign_demo_iterm","text":"","title":"gsdesign_demo_iter.m"},{"location":"function-guide/tok_models/gsdesign_demo_iter_m/#basic-information","text":"USAGE: gsdesign_demo_iter PURPOSE: Design equilibrium for ITER INPUTS: None (just run the code) OUTPUTS: Plots and designed equilibrium METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_iter_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/gsdesign_demo_kstar_ISS_m/","text":"gsdesign_demo_kstar_ISS.m \u00b6 Basic Information \u00b6 USAGE: gsdesign_demo_kstar_ISS PURPOSE: Design ITER-similar shape for KSTAR INPUTS: None (just run the code) OUTPUTS: Plots of and tables of feedforward currents METHOD: Dependencies \u00b6","title":"gsdesign_demo_kstar_ISS.m"},{"location":"function-guide/tok_models/gsdesign_demo_kstar_ISS_m/#gsdesign_demo_kstar_issm","text":"","title":"gsdesign_demo_kstar_ISS.m"},{"location":"function-guide/tok_models/gsdesign_demo_kstar_ISS_m/#basic-information","text":"USAGE: gsdesign_demo_kstar_ISS PURPOSE: Design ITER-similar shape for KSTAR INPUTS: None (just run the code) OUTPUTS: Plots of and tables of feedforward currents METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/gsdesign_demo_kstar_ISS_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/lim2vv_m/","text":"lim2vv.m \u00b6 Basic Information \u00b6 SYNTAX: [vvdata,dirnu,iacnu,fracnu]=lim2vv(limdata,dperp,dw,idir,frac,iac); PURPOSE: Calculate vessel elements from limiter specification given by limdata = set of vertices in limiter, between which will be located vessel elements. INPUTS: limdata = set of vertices in limiter, between which will be located vessel elements. limdata has format [[r1 z1];[r2 z2]...] dperp = amount vessel elements are displaced from limiter dw = width of vessel elements idir = (optional) direction indices corr to each vessel element (nvv = nlim - 1). Default corresponds to +1; reverses direction of wall displacement if set element of idir to -1. frac = (optional) fraction by which to scale each VVelement iac = (optional) indices telling if AC or AC2 type element. Default = all AC (index 1) elements. Note that automatically sets vertical or horizontal elements to type 0... OUTPUTS: vvdata = vvdata array with standard format idirnu = new idir vector (actually used) iacnu = new iac vector (which was used in specifying actual vvdata) fracnu = new frac vector (actually used) plots of corresponding geometry RESTRICTIONS: METHOD: Dependencies \u00b6","title":"lim2vv.m"},{"location":"function-guide/tok_models/lim2vv_m/#lim2vvm","text":"","title":"lim2vv.m"},{"location":"function-guide/tok_models/lim2vv_m/#basic-information","text":"SYNTAX: [vvdata,dirnu,iacnu,fracnu]=lim2vv(limdata,dperp,dw,idir,frac,iac); PURPOSE: Calculate vessel elements from limiter specification given by limdata = set of vertices in limiter, between which will be located vessel elements. INPUTS: limdata = set of vertices in limiter, between which will be located vessel elements. limdata has format [[r1 z1];[r2 z2]...] dperp = amount vessel elements are displaced from limiter dw = width of vessel elements idir = (optional) direction indices corr to each vessel element (nvv = nlim - 1). Default corresponds to +1; reverses direction of wall displacement if set element of idir to -1. frac = (optional) fraction by which to scale each VVelement iac = (optional) indices telling if AC or AC2 type element. Default = all AC (index 1) elements. Note that automatically sets vertical or horizontal elements to type 0... OUTPUTS: vvdata = vvdata array with standard format idirnu = new idir vector (actually used) iacnu = new iac vector (which was used in specifying actual vvdata) fracnu = new frac vector (actually used) plots of corresponding geometry RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/lim2vv_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/linsim_tok_zctrl_m/","text":"linsim_tok_zctrl.m \u00b6 Basic Information \u00b6 USAGE: [out_data] = linsim_tok_zctrl(tok_system,tau_ps,T_ps,Vvec, ... Vlims,Kpvec,Kdvec,taupd,iplot,zdisp0,tmax,zmax, ... Gpsweep,Gdsweep,idxacsw) PURPOSE: Function to simulate linear vertical control with standard tau_ps, T_ps power supply definition. Called by script sim_iter_zctrl.m. Simulates response to zdisp0 initial condition INPUTS: tok_system = structure gen. by build_* script containing system data tau_ps = power supply time constant [s] T_ps = power supply delay time (in addition to one-pole tau_ps) [s] Vvec = vector specifying active coils (entries: 0=not active, +/-1 = active positive(negative) voltage/current Vlims = vector giving voltage saturation levels [V] Kpvec = vector giving proportional gain [V/m] Kdvec = vector giving derivative gain [V/m/s] taupd = time constant for 1-pole filter on PD operation [s] iplot = (opt) flag to select plotting (1=plot, 0=don't(default)) zdisp0 = (opt) specific value to calculate displacement trajectory for and plot (if selected) tmax = (opt) max time for simulation (def=1.0 sec) zmax = (opt) max z for plotting (def = 0.9 m) Gpsweep = vector with Gpmin, Gpmax, ngp Gdsweep = vector with Gdmin, Gdmax, ngd idxacsw = idx scalar for selected active coil to plot contours (this must be idx of coil whose peak I, V are negative, since code finds min of time history for contouring) OUTPUTS: out_data = structure that includes histories + plots (if selected) RESTRICTIONS: METHOD: Dependencies \u00b6 eigsort","title":"linsim_tok_zctrl.m"},{"location":"function-guide/tok_models/linsim_tok_zctrl_m/#linsim_tok_zctrlm","text":"","title":"linsim_tok_zctrl.m"},{"location":"function-guide/tok_models/linsim_tok_zctrl_m/#basic-information","text":"USAGE: [out_data] = linsim_tok_zctrl(tok_system,tau_ps,T_ps,Vvec, ... Vlims,Kpvec,Kdvec,taupd,iplot,zdisp0,tmax,zmax, ... Gpsweep,Gdsweep,idxacsw) PURPOSE: Function to simulate linear vertical control with standard tau_ps, T_ps power supply definition. Called by script sim_iter_zctrl.m. Simulates response to zdisp0 initial condition INPUTS: tok_system = structure gen. by build_* script containing system data tau_ps = power supply time constant [s] T_ps = power supply delay time (in addition to one-pole tau_ps) [s] Vvec = vector specifying active coils (entries: 0=not active, +/-1 = active positive(negative) voltage/current Vlims = vector giving voltage saturation levels [V] Kpvec = vector giving proportional gain [V/m] Kdvec = vector giving derivative gain [V/m/s] taupd = time constant for 1-pole filter on PD operation [s] iplot = (opt) flag to select plotting (1=plot, 0=don't(default)) zdisp0 = (opt) specific value to calculate displacement trajectory for and plot (if selected) tmax = (opt) max time for simulation (def=1.0 sec) zmax = (opt) max z for plotting (def = 0.9 m) Gpsweep = vector with Gpmin, Gpmax, ngp Gdsweep = vector with Gdmin, Gdmax, ngd idxacsw = idx scalar for selected active coil to plot contours (this must be idx of coil whose peak I, V are negative, since code finds min of time history for contouring) OUTPUTS: out_data = structure that includes histories + plots (if selected) RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/linsim_tok_zctrl_m/#dependencies","text":"eigsort","title":"Dependencies"},{"location":"function-guide/tok_models/load_tok_objects_m/","text":"load_tok_objects.m \u00b6 Basic Information \u00b6 SYNTAX: tok_data_struct = load_tok_objects(tok,config_name, grid) PURPOSE: Load vacuum data objects for selected device configuration. Provides general access to load_<device>_object.m scripts INPUT: tok = string defining tokamak device or requests for help, eg help or help d3d config_name = string defining configuration name efit_grid = string identifying the EFIT grid resolution OUTPUT: tok_data_struct = vacuum objects data structure CALLING SEQUENCE: tok_data_struct = load_tok_objects('help') tok_data_struct = load_tok_objects('help d3d') Most Current TokSys Models as of 20121005 (need to confirm these...) tok_data_struct = load_tok_objects('d3d','current') RESTRICTIONS: METHOD: WRITTEN BY: Matthew J. Lanctot MODIFICATIONS: MJL 2012/10/05 Created.Provide access to all load_<device>_object.m scripts DAH 2014/7/11 Updated EAST current to 2014 Dependencies \u00b6 wait","title":"load_tok_objects.m"},{"location":"function-guide/tok_models/load_tok_objects_m/#load_tok_objectsm","text":"","title":"load_tok_objects.m"},{"location":"function-guide/tok_models/load_tok_objects_m/#basic-information","text":"SYNTAX: tok_data_struct = load_tok_objects(tok,config_name, grid) PURPOSE: Load vacuum data objects for selected device configuration. Provides general access to load_<device>_object.m scripts INPUT: tok = string defining tokamak device or requests for help, eg help or help d3d config_name = string defining configuration name efit_grid = string identifying the EFIT grid resolution OUTPUT: tok_data_struct = vacuum objects data structure CALLING SEQUENCE: tok_data_struct = load_tok_objects('help') tok_data_struct = load_tok_objects('help d3d') Most Current TokSys Models as of 20121005 (need to confirm these...) tok_data_struct = load_tok_objects('d3d','current') RESTRICTIONS: METHOD: WRITTEN BY: Matthew J. Lanctot MODIFICATIONS: MJL 2012/10/05 Created.Provide access to all load_<device>_object.m scripts DAH 2014/7/11 Updated EAST current to 2014","title":"Basic Information"},{"location":"function-guide/tok_models/load_tok_objects_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/tok_models/make_ctrlvecs_m/","text":"make_ctrlvecs.m \u00b6 Basic Information \u00b6 USAGE: >> make_ctrlvecs PURPOSE: Script to construct control vectors for M-matrix in PCS. Called from scripts such as make_east_ctrlvecs or make_kstar_ctrlvecs. INPUTS: (Defined in workspace prior to calling make_predictors) Required: objdir = directory containing objects file objfile = objects file name (eg kstar_obj_struct.mat) tokamak = machine name, eg 'KSTAR', 'EAST', (needed for read_gfile_tok) idxcr = PF coil index vector for Rctrlvec idxcz = PF coil index vector for Zctrlvec idxcip = PF coil index vector for Ipctrlvec rrange1 = maj radius range of sub-grid for fields (m) eg [1.5 2] zrange1 = vert range of sub-grid for fields (m) eg [-.5 .5] iusejphi = 1 = use jphi (all current) region for fields, else ??? efit_gfile_grid = gfile to use to define grid from jphi if iusejphi=1 gfile_data = gfile data to use to define grid from jphi (Only one of efit_gfile_grid or gfile_data should be specified.) rrefk zrefk Optional: separate_figures = set to 1 to get 1 figure per plot, otherwise multiple (default) sign_ip = either +1/-1, assuming standard convention for all Ip, PF coils (default 1) iconstraint = set to 1 to constrain Ip ctrl vector elements all one sign, else 0 (default) ipltbp = 1 to plot Bprobes in plot_geo call (0 to not) ipltfl = 1 to plot flux loops in plot_geo call (0 to not) USED??? nprtst = # of princ comp of grid to mag set to use in test nsvdz1,2 = # of sing vals to keep in R pred inverse (for P*pred1,2) nsvdr1,2 = # of sing vals to keep in R pred inverse nsvdi1,2 = # of sing vals to keep in Ip pred inverse nsvdk1,2 = # of sing vals to keep in Kappa pred inverse OUTPUTS: Zctrlvec = Z-ctrl vector (Vpf_Z = Zctrlvec*PID*Zerror) Rctrlvec = R-ctrl vector (Vpf_R = Rctrlvec*PID*Zerror) Ipctrlvec = Ip-ctrl vector (Vpf_R = Rctrlvec*PID*Zerror) (Sign is such that multiplying ctrlvec by positive value => positive change in controlled parameter, except kappa which has indeterminate sign.) + many plots evaluating quality of control vectors in producing specified field RESTRICTIONS: If iusejphi==1, must have efit_gfile_grid defined (which is source of jphi on which grid is based if iusejphi=1) METHOD: Variety of inversions of grid-to-mag objects, linear fits to selected data from subgrids, subset of magnetics... Dependencies \u00b6 read_gfile_tok wait plot_tok_geo find_near","title":"make_ctrlvecs.m"},{"location":"function-guide/tok_models/make_ctrlvecs_m/#make_ctrlvecsm","text":"","title":"make_ctrlvecs.m"},{"location":"function-guide/tok_models/make_ctrlvecs_m/#basic-information","text":"USAGE: >> make_ctrlvecs PURPOSE: Script to construct control vectors for M-matrix in PCS. Called from scripts such as make_east_ctrlvecs or make_kstar_ctrlvecs. INPUTS: (Defined in workspace prior to calling make_predictors) Required: objdir = directory containing objects file objfile = objects file name (eg kstar_obj_struct.mat) tokamak = machine name, eg 'KSTAR', 'EAST', (needed for read_gfile_tok) idxcr = PF coil index vector for Rctrlvec idxcz = PF coil index vector for Zctrlvec idxcip = PF coil index vector for Ipctrlvec rrange1 = maj radius range of sub-grid for fields (m) eg [1.5 2] zrange1 = vert range of sub-grid for fields (m) eg [-.5 .5] iusejphi = 1 = use jphi (all current) region for fields, else ??? efit_gfile_grid = gfile to use to define grid from jphi if iusejphi=1 gfile_data = gfile data to use to define grid from jphi (Only one of efit_gfile_grid or gfile_data should be specified.) rrefk zrefk Optional: separate_figures = set to 1 to get 1 figure per plot, otherwise multiple (default) sign_ip = either +1/-1, assuming standard convention for all Ip, PF coils (default 1) iconstraint = set to 1 to constrain Ip ctrl vector elements all one sign, else 0 (default) ipltbp = 1 to plot Bprobes in plot_geo call (0 to not) ipltfl = 1 to plot flux loops in plot_geo call (0 to not) USED??? nprtst = # of princ comp of grid to mag set to use in test nsvdz1,2 = # of sing vals to keep in R pred inverse (for P*pred1,2) nsvdr1,2 = # of sing vals to keep in R pred inverse nsvdi1,2 = # of sing vals to keep in Ip pred inverse nsvdk1,2 = # of sing vals to keep in Kappa pred inverse OUTPUTS: Zctrlvec = Z-ctrl vector (Vpf_Z = Zctrlvec*PID*Zerror) Rctrlvec = R-ctrl vector (Vpf_R = Rctrlvec*PID*Zerror) Ipctrlvec = Ip-ctrl vector (Vpf_R = Rctrlvec*PID*Zerror) (Sign is such that multiplying ctrlvec by positive value => positive change in controlled parameter, except kappa which has indeterminate sign.) + many plots evaluating quality of control vectors in producing specified field RESTRICTIONS: If iusejphi==1, must have efit_gfile_grid defined (which is source of jphi on which grid is based if iusejphi=1) METHOD: Variety of inversions of grid-to-mag objects, linear fits to selected data from subgrids, subset of magnetics...","title":"Basic Information"},{"location":"function-guide/tok_models/make_ctrlvecs_m/#dependencies","text":"read_gfile_tok wait plot_tok_geo find_near","title":"Dependencies"},{"location":"function-guide/tok_models/make_model_script_m/","text":"make_model_script.m \u00b6 Basic Information \u00b6 SYNTAX: make_model_script PURPOSE: Script to build output objects needed to build isoflux models. INPUT: shotnum = shot number time = equilibrium time (ms) tokamak = name of device to build model for tok_data_struct = vacuum data objects for this device out_irzresp = output irzresp value (1, 2, or 3) eqdir = directory where efit equilibrium files are located efit_source = tree in mdsplus to get equilibrium, e.g. EFIT01, EFITRT (only one of either eqdir or efit_source should be specified) OUTPUT: out_objs_<shotnum>_<time>.mat - mat file containing isoflux objects out2_objs_<shotnum>_<time>.mat - mat file containing magnetics objects RESTRICTIONS: Requires existence of script mdl_parms_<shotnum>_<time>.m in your matlab path. Dependencies \u00b6 build_model wait","title":"make_model_script.m"},{"location":"function-guide/tok_models/make_model_script_m/#make_model_scriptm","text":"","title":"make_model_script.m"},{"location":"function-guide/tok_models/make_model_script_m/#basic-information","text":"SYNTAX: make_model_script PURPOSE: Script to build output objects needed to build isoflux models. INPUT: shotnum = shot number time = equilibrium time (ms) tokamak = name of device to build model for tok_data_struct = vacuum data objects for this device out_irzresp = output irzresp value (1, 2, or 3) eqdir = directory where efit equilibrium files are located efit_source = tree in mdsplus to get equilibrium, e.g. EFIT01, EFITRT (only one of either eqdir or efit_source should be specified) OUTPUT: out_objs_<shotnum>_<time>.mat - mat file containing isoflux objects out2_objs_<shotnum>_<time>.mat - mat file containing magnetics objects RESTRICTIONS: Requires existence of script mdl_parms_<shotnum>_<time>.m in your matlab path.","title":"Basic Information"},{"location":"function-guide/tok_models/make_model_script_m/#dependencies","text":"build_model wait","title":"Dependencies"},{"location":"function-guide/tok_models/make_noise_file_m/","text":"make_noise_file.m \u00b6 Basic Information \u00b6 SYNTAX: make_noise_file(filename, tstart, tend, dt, num_diags) make_noise_file(filename, tstart, tend, dt, num_diags, vars) make_noise_file(filename, tstart, tend, dt, num_diags, vars, noise_type) PURPOSE: Generate a file containing a noise matrix that can be read into a \"from file\" simulink block and create a soft link to that file called \"noise.mat\". The matrix is formatted such that the first row is a vector of times. Each subsequent row is a time series of noise that can be added to a diagnostic output signal. Row i of the matrix maps to the i-1 diagnostic. INPUTS: filename = the full path to the .mat file that will be created tstart = the starting time of the time vector tend = the end time of the time vector dt = the time step of the time vector num_diags = the number of diagnostic outputs vars = (optional) a vector of variances (sigma^2). Must be of length num_diags. noise_type = (optional) the type of noise to be generated. If vars is specified, defaults to 'gaussian'. Otherwise defaults to 'zeros' (ie no noise). Allowed Values: - 'gaussian' - Noise will be gaussian - 'zeros' - No noise OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise, create_noise_link Dependencies \u00b6","title":"make_noise_file.m"},{"location":"function-guide/tok_models/make_noise_file_m/#make_noise_filem","text":"","title":"make_noise_file.m"},{"location":"function-guide/tok_models/make_noise_file_m/#basic-information","text":"SYNTAX: make_noise_file(filename, tstart, tend, dt, num_diags) make_noise_file(filename, tstart, tend, dt, num_diags, vars) make_noise_file(filename, tstart, tend, dt, num_diags, vars, noise_type) PURPOSE: Generate a file containing a noise matrix that can be read into a \"from file\" simulink block and create a soft link to that file called \"noise.mat\". The matrix is formatted such that the first row is a vector of times. Each subsequent row is a time series of noise that can be added to a diagnostic output signal. Row i of the matrix maps to the i-1 diagnostic. INPUTS: filename = the full path to the .mat file that will be created tstart = the starting time of the time vector tend = the end time of the time vector dt = the time step of the time vector num_diags = the number of diagnostic outputs vars = (optional) a vector of variances (sigma^2). Must be of length num_diags. noise_type = (optional) the type of noise to be generated. If vars is specified, defaults to 'gaussian'. Otherwise defaults to 'zeros' (ie no noise). Allowed Values: - 'gaussian' - Noise will be gaussian - 'zeros' - No noise OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise, create_noise_link","title":"Basic Information"},{"location":"function-guide/tok_models/make_noise_file_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/make_noise_m/","text":"make_noise.m \u00b6 Basic Information \u00b6 SYNTAX: make_noise(filename, tstart, tend, dt, num_diags) make_noise(filename, tstart, tend, dt, num_diags, vars) PURPOSE: Generate a file containing a noise matrix that can be read into a \"from file\" simulink block and create a soft link to that file called \"noise.mat\" in the working directory. The matrix is formatted such that the first row is a vector of times. Each subsequent row is a time series of noise that can be added to a diagnostic output signal. Row i of the matrix maps to the i-1 diagnostic. INPUTS: filename = the full path to the .mat file that will be created tstart = the starting time of the time vector tend = the end time of the time vector dt = the time step of the time vector num_diags = the number of diagnostic outputs vars = (optional) a vector of variances (sigma^2). Must be of length num_diags. If vars is not used, then a zero-noise matrix is generated. OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise_file, create_noise_link Dependencies \u00b6 make_noise_file create_noise_link","title":"make_noise.m"},{"location":"function-guide/tok_models/make_noise_m/#make_noisem","text":"","title":"make_noise.m"},{"location":"function-guide/tok_models/make_noise_m/#basic-information","text":"SYNTAX: make_noise(filename, tstart, tend, dt, num_diags) make_noise(filename, tstart, tend, dt, num_diags, vars) PURPOSE: Generate a file containing a noise matrix that can be read into a \"from file\" simulink block and create a soft link to that file called \"noise.mat\" in the working directory. The matrix is formatted such that the first row is a vector of times. Each subsequent row is a time series of noise that can be added to a diagnostic output signal. Row i of the matrix maps to the i-1 diagnostic. INPUTS: filename = the full path to the .mat file that will be created tstart = the starting time of the time vector tend = the end time of the time vector dt = the time step of the time vector num_diags = the number of diagnostic outputs vars = (optional) a vector of variances (sigma^2). Must be of length num_diags. If vars is not used, then a zero-noise matrix is generated. OUTPUTS: None. RESTRICTIONS: None. WRITTEN BY: Brian Sammuli on 6/9/08 MODIFICATION HISTORY: SEE ALSO: make_noise_file, create_noise_link","title":"Basic Information"},{"location":"function-guide/tok_models/make_noise_m/#dependencies","text":"make_noise_file create_noise_link","title":"Dependencies"},{"location":"function-guide/tok_models/make_out_objs_m/","text":"make_out_objs.m \u00b6 Basic Information \u00b6 SYNTAX: make_out_objs PURPOSE: make output object files using both plasma_output.m and plasma_output2.m INPUT: tokamak ichooseq shotnum = shot number to generate model from tmodel = time of equilibrium to generate model from (ms) outflag = flag to determine which set(s) of output objects to generate 0 = none 1 = run plasma_output, save results 2 = run plasma_output2, save results 3 = run both plasma_output, plasma_output2 - save (default) output_irzresp = set to one of: 0 = use no rigid response 1 = use only rigid r response 2 = use both rigid r and z response vacuum_model', 0, ... iplcirc', 1, ... num_Ecoils = number of E-coils (2 or 5) eqdir = directory where nominal EFIT equilibrium files are located Te_res = li_res = Rp = plasma resistance Zeff_res = isonms = names of isoflux segments bgdnms = names of grids used to compute magnetic field near X points scale_cc_resp = scaling vector for coil currents in response objects scale_vv_resp = scaling vector for vessel currents in response objects OUTPUT files: out_eqn_objects.mat = objects from plasma_output.m out2_eqn_objects.mat = objects from plasma_output2.m RESTRICTIONS: Assumes that drzdi files is of form drzdi_<shotnum>_<tmodel>.mat Dependencies \u00b6 plasma_output wait plasma_output2","title":"make_out_objs.m"},{"location":"function-guide/tok_models/make_out_objs_m/#make_out_objsm","text":"","title":"make_out_objs.m"},{"location":"function-guide/tok_models/make_out_objs_m/#basic-information","text":"SYNTAX: make_out_objs PURPOSE: make output object files using both plasma_output.m and plasma_output2.m INPUT: tokamak ichooseq shotnum = shot number to generate model from tmodel = time of equilibrium to generate model from (ms) outflag = flag to determine which set(s) of output objects to generate 0 = none 1 = run plasma_output, save results 2 = run plasma_output2, save results 3 = run both plasma_output, plasma_output2 - save (default) output_irzresp = set to one of: 0 = use no rigid response 1 = use only rigid r response 2 = use both rigid r and z response vacuum_model', 0, ... iplcirc', 1, ... num_Ecoils = number of E-coils (2 or 5) eqdir = directory where nominal EFIT equilibrium files are located Te_res = li_res = Rp = plasma resistance Zeff_res = isonms = names of isoflux segments bgdnms = names of grids used to compute magnetic field near X points scale_cc_resp = scaling vector for coil currents in response objects scale_vv_resp = scaling vector for vessel currents in response objects OUTPUT files: out_eqn_objects.mat = objects from plasma_output.m out2_eqn_objects.mat = objects from plasma_output2.m RESTRICTIONS: Assumes that drzdi files is of form drzdi_<shotnum>_<tmodel>.mat","title":"Basic Information"},{"location":"function-guide/tok_models/make_out_objs_m/#dependencies","text":"plasma_output wait plasma_output2","title":"Dependencies"},{"location":"function-guide/tok_models/make_predictors_m/","text":"make_predictors.m \u00b6 Basic Information \u00b6 USAGE: predictors = make_predictors(predictor_inputs) PURPOSE: Script to construct plasma geometry predictors from standard environment inputs. Intended to be generic to any standard tokamak system environment.Called from scripts such as make_east_predictors or make_kstar_predictors. INPUTS: (in structure \"predictor_inputs\") tok_data_struct = vacuum geometry objects structure for the device efit_gfile_test = gfile to use (for testing of predictors only) tokamak = machine name, eg 'KSTAR', 'EAST', (needed for read_gfile_tok) idxbpr = index vector to select desired probes for R-predictors idxbpz = index vector to select desired probes for Z-predictors idxbpip = index vector to select desired probes for Ip-predictors idxbpk = index vector to select desired probes for kappa-predictors idxflr = index vector to select desired flux loops for R-predictors idxflz = index vector to select desired flux loops for Z-predictors idxflip = index vector to select desired flux loops for Ip-predictors idxflk = index vector to select desired flux loops for kappa-predictors idxc = PF coil index vector for fitting/testing with EFIT idxv = VV index vector for testing with VV currents rrange1 = maj radius range of sub-grid for predictor 1 (m) eg [1.5 2] zrange1 = vert range of sub-grid for predictor 1 (m) eg [-.5 .5] iusejphi = flag to use jphi (all current) region for fits efit_gfile_grid = gfile to use to define grid from jphi if iusejphi=1 nprtst = # of princ comp of grid to mag set to use in test nsvdz2 = # of sing vals to keep in R pred inverse (for P*pred1,2) nsvdr2 = # of sing vals to keep in R pred inverse nsvdi2 = # of sing vals to keep in Ip pred inverse nsvdk1 = # of sing vals to keep in Kappa pred inverse nrs nzs nkaps nls Rmin,Rmax Zmin,Zmax kapmin,kapmax limin,limax amax Z1,Z2 R1,R2 cctest icomppfr icomppfz icomppfip icomppfk OUTPUTS: (in structure \"predictors\") Pzpred = Z-predictor (Pzpred*[mag]/Ip0 = predicted Z) Prpred = R-predictor (Prpred*[mag]/Ip0 + Rrel = predicted R) Pipred = Ip-predictor (Pipred*[Bprobes] = predicted Ip) Pkpred = kappa-predictor (Pkpred*[mag]/Ip0??? = predicted kappa) Rpred Zpred Ippred Kpred + many plots evaluating quality of predictors RESTRICTIONS: Specified objects file must provide units desired in predictor (eg if want predictor based on mks, must use mks object file). Comments in code assume MA-based objects (eg east_objects.mat), but should be consistent with mks/terminal choice if use those object files). If iusejphi==1, must have efit_gfile_grid defined (which is source of jphi on which grid is based if iusejphi=1) METHOD: Variety of inversions of grid-to-mag objects, linear fits to selected data from subgrids, subset of magnetics... Dependencies \u00b6 plot_tok_geo find_near makelpcur minvert read_gfile_tok","title":"make_predictors.m"},{"location":"function-guide/tok_models/make_predictors_m/#make_predictorsm","text":"","title":"make_predictors.m"},{"location":"function-guide/tok_models/make_predictors_m/#basic-information","text":"USAGE: predictors = make_predictors(predictor_inputs) PURPOSE: Script to construct plasma geometry predictors from standard environment inputs. Intended to be generic to any standard tokamak system environment.Called from scripts such as make_east_predictors or make_kstar_predictors. INPUTS: (in structure \"predictor_inputs\") tok_data_struct = vacuum geometry objects structure for the device efit_gfile_test = gfile to use (for testing of predictors only) tokamak = machine name, eg 'KSTAR', 'EAST', (needed for read_gfile_tok) idxbpr = index vector to select desired probes for R-predictors idxbpz = index vector to select desired probes for Z-predictors idxbpip = index vector to select desired probes for Ip-predictors idxbpk = index vector to select desired probes for kappa-predictors idxflr = index vector to select desired flux loops for R-predictors idxflz = index vector to select desired flux loops for Z-predictors idxflip = index vector to select desired flux loops for Ip-predictors idxflk = index vector to select desired flux loops for kappa-predictors idxc = PF coil index vector for fitting/testing with EFIT idxv = VV index vector for testing with VV currents rrange1 = maj radius range of sub-grid for predictor 1 (m) eg [1.5 2] zrange1 = vert range of sub-grid for predictor 1 (m) eg [-.5 .5] iusejphi = flag to use jphi (all current) region for fits efit_gfile_grid = gfile to use to define grid from jphi if iusejphi=1 nprtst = # of princ comp of grid to mag set to use in test nsvdz2 = # of sing vals to keep in R pred inverse (for P*pred1,2) nsvdr2 = # of sing vals to keep in R pred inverse nsvdi2 = # of sing vals to keep in Ip pred inverse nsvdk1 = # of sing vals to keep in Kappa pred inverse nrs nzs nkaps nls Rmin,Rmax Zmin,Zmax kapmin,kapmax limin,limax amax Z1,Z2 R1,R2 cctest icomppfr icomppfz icomppfip icomppfk OUTPUTS: (in structure \"predictors\") Pzpred = Z-predictor (Pzpred*[mag]/Ip0 = predicted Z) Prpred = R-predictor (Prpred*[mag]/Ip0 + Rrel = predicted R) Pipred = Ip-predictor (Pipred*[Bprobes] = predicted Ip) Pkpred = kappa-predictor (Pkpred*[mag]/Ip0??? = predicted kappa) Rpred Zpred Ippred Kpred + many plots evaluating quality of predictors RESTRICTIONS: Specified objects file must provide units desired in predictor (eg if want predictor based on mks, must use mks object file). Comments in code assume MA-based objects (eg east_objects.mat), but should be consistent with mks/terminal choice if use those object files). If iusejphi==1, must have efit_gfile_grid defined (which is source of jphi on which grid is based if iusejphi=1) METHOD: Variety of inversions of grid-to-mag objects, linear fits to selected data from subgrids, subset of magnetics...","title":"Basic Information"},{"location":"function-guide/tok_models/make_predictors_m/#dependencies","text":"plot_tok_geo find_near makelpcur minvert read_gfile_tok","title":"Dependencies"},{"location":"function-guide/tok_models/make_tok_data_struct_m/","text":"make_tok_data_struct.m \u00b6 Basic Information \u00b6 SYNTAX: tok_data = make_tok_data_struct(datafiles,imks,iterminal) PURPOSE: Convert data contained in \"environment\" files into a standard format tokamak data structure. INPUT: datafiles = string array (size nfiles by max name length) of *.mat files containing tokamak environment data imks = if 1, input objects in datafiles are mks, else 0 (default=MA,uH) iterminal = if 1, input objects are terminal units, else 0 (default) OUTPUT: tok_data = data structure constructed from this data. Contains: - data objects - units = units of data objects - description = descriptions of data objects Dependencies \u00b6 make_units_struct","title":"make_tok_data_struct.m"},{"location":"function-guide/tok_models/make_tok_data_struct_m/#make_tok_data_structm","text":"","title":"make_tok_data_struct.m"},{"location":"function-guide/tok_models/make_tok_data_struct_m/#basic-information","text":"SYNTAX: tok_data = make_tok_data_struct(datafiles,imks,iterminal) PURPOSE: Convert data contained in \"environment\" files into a standard format tokamak data structure. INPUT: datafiles = string array (size nfiles by max name length) of *.mat files containing tokamak environment data imks = if 1, input objects in datafiles are mks, else 0 (default=MA,uH) iterminal = if 1, input objects are terminal units, else 0 (default) OUTPUT: tok_data = data structure constructed from this data. Contains: - data objects - units = units of data objects - description = descriptions of data objects","title":"Basic Information"},{"location":"function-guide/tok_models/make_tok_data_struct_m/#dependencies","text":"make_units_struct","title":"Dependencies"},{"location":"function-guide/tok_models/make_tok_objects_m/","text":"make_tok_objects.m \u00b6 Basic Information \u00b6 USAGE: make_tok_objects(make_tok_inputs,procedures) PURPOSE: Script to calculate vacuum data objects (e.g. mutuals, Green fns) for a tokamak system model. The \"minimal\" set of objects which must be defined is VV, FC. INPUTS (see TokSys_Users_Guide.pdf): make_tok_inputs = data structure defining how to make data objects. This structure must contain: tokamak = string defining tokamak being constructed, used in file names config_name = string label identifying machine configuration (Warning: non-alphanumeric chars in config_name may cause problems) datadir = directory where files defining tokamak are located vvdata_file = Filename for vvdata data (must be of form *.data) (actually just has to have 4 characters after \".\", and must have a name distinct from all the other *.data) fcdata_file = Fcoil data file (name must be of same form as vvdata) fcnturn_file = file with PF turns nminvv = # of conductors in *min* dimension of vacuum vessel elts (can be scalar or vector with length=#vessel elts) nminfc = # of conductors in *min* dimension of fcoils (can be scalar or vector with length=#fcoils) Vessel resistance data, either: etav = VV resistivity vector, uOhm-m OR vvres_file = file with vessel element (terminal) resistances (Ohms) PF coil resistance data, either: etaf = Fcoil resistivity vector, uOhm-m (NOTE: for SC coils, set etaf=1e-3*eta(Cu)) OR fcres_file = file with coil element (terminal) resistances (Ohms) TD coil resistance data, either: etat = TD coil resistivity vector, uOhm-m OR tdres_file = file with coil element (terminal) resistances (Ohms) Optionally, it may contain: ecdata_file = Ecoil data file (name must be of same form as vvdata) ecturn_file = ecoil turn groupings vvfrac_file = file with vacuum vessel fractions of currents fldata_file = Flux loop data file bpdata_file = Bprobe data file msedata_file = MSE loci file rldata_file = Rogowski loop data file lvdata_file = Loop voltage data file limdata_file = file containing limiter definition data (npts x 2) nr,nz = # of grid elem. in r,z dir. (if~=0, must also enter values for rgmin,rgmax,zgmin,zgmax - see below) rgmin,rgmax = Min,max in major radial dimension on plasma grid [m] zgmin,zgmax = Min,max in vertical dimension on plasma grid [m] E-coil resistance data (required if ecdata_file used), either: etae = Ecoil resistivity vector, uOhm-m OR ecres_file = file with coil element (terminal) resistances (Ohms) fcnames_file = file containing fcoil names vvnames_file = file containing vessel element names flnames_file = file containing flux loop names bpnames_file = file containing Bprobe names msenames_file = file containing names of MSE channels that view points in msedata rlnames_file = file containing Rogowski loop names lvnames_file = file containing loop voltage names nminec = # of conductors in *min* dimension of ecoils. Required if ecdata_file is used. (scalar or vector of length=#ecoils) nmingg = scalar # of conductors in *min* dimension of plasma grid Required if plasma grid inputs used. plot_tok_geo_fn = string defining script to execute to plot the geometry of the device (e.g. 'plot_kstar_geo', 'plot_east_geo'... set to 'generic' (default) to use default to plot X-section ecsignals_file = E coil signal names file fcsignals_file = F coil signal names file flsignals_file = flux loop signal names file bpsignals_file = B probe signal names file rlsignals_file = Rogowski loop signal names file lvsignals_file = loop voltage signal names file procedures = array of strings defining procedures to operate on the data after generation (optional, default = []) OUTPUTS: save files <tokamak>_obj_<config_name> = contains structure tok_data_struct, units= terminal, MKS (in file name, '/' replaced by '-', ' ' by '_', '\\' by '') Dependencies \u00b6 plot_fils mut_fine_fil bgreens_fine wait mutind_fine mut_filcs2filcs strarr_to_cellarr plot_tok_geo make_tok_data_struct green_paths2pts calc_mpp fils2filcs","title":"make_tok_objects.m"},{"location":"function-guide/tok_models/make_tok_objects_m/#make_tok_objectsm","text":"","title":"make_tok_objects.m"},{"location":"function-guide/tok_models/make_tok_objects_m/#basic-information","text":"USAGE: make_tok_objects(make_tok_inputs,procedures) PURPOSE: Script to calculate vacuum data objects (e.g. mutuals, Green fns) for a tokamak system model. The \"minimal\" set of objects which must be defined is VV, FC. INPUTS (see TokSys_Users_Guide.pdf): make_tok_inputs = data structure defining how to make data objects. This structure must contain: tokamak = string defining tokamak being constructed, used in file names config_name = string label identifying machine configuration (Warning: non-alphanumeric chars in config_name may cause problems) datadir = directory where files defining tokamak are located vvdata_file = Filename for vvdata data (must be of form *.data) (actually just has to have 4 characters after \".\", and must have a name distinct from all the other *.data) fcdata_file = Fcoil data file (name must be of same form as vvdata) fcnturn_file = file with PF turns nminvv = # of conductors in *min* dimension of vacuum vessel elts (can be scalar or vector with length=#vessel elts) nminfc = # of conductors in *min* dimension of fcoils (can be scalar or vector with length=#fcoils) Vessel resistance data, either: etav = VV resistivity vector, uOhm-m OR vvres_file = file with vessel element (terminal) resistances (Ohms) PF coil resistance data, either: etaf = Fcoil resistivity vector, uOhm-m (NOTE: for SC coils, set etaf=1e-3*eta(Cu)) OR fcres_file = file with coil element (terminal) resistances (Ohms) TD coil resistance data, either: etat = TD coil resistivity vector, uOhm-m OR tdres_file = file with coil element (terminal) resistances (Ohms) Optionally, it may contain: ecdata_file = Ecoil data file (name must be of same form as vvdata) ecturn_file = ecoil turn groupings vvfrac_file = file with vacuum vessel fractions of currents fldata_file = Flux loop data file bpdata_file = Bprobe data file msedata_file = MSE loci file rldata_file = Rogowski loop data file lvdata_file = Loop voltage data file limdata_file = file containing limiter definition data (npts x 2) nr,nz = # of grid elem. in r,z dir. (if~=0, must also enter values for rgmin,rgmax,zgmin,zgmax - see below) rgmin,rgmax = Min,max in major radial dimension on plasma grid [m] zgmin,zgmax = Min,max in vertical dimension on plasma grid [m] E-coil resistance data (required if ecdata_file used), either: etae = Ecoil resistivity vector, uOhm-m OR ecres_file = file with coil element (terminal) resistances (Ohms) fcnames_file = file containing fcoil names vvnames_file = file containing vessel element names flnames_file = file containing flux loop names bpnames_file = file containing Bprobe names msenames_file = file containing names of MSE channels that view points in msedata rlnames_file = file containing Rogowski loop names lvnames_file = file containing loop voltage names nminec = # of conductors in *min* dimension of ecoils. Required if ecdata_file is used. (scalar or vector of length=#ecoils) nmingg = scalar # of conductors in *min* dimension of plasma grid Required if plasma grid inputs used. plot_tok_geo_fn = string defining script to execute to plot the geometry of the device (e.g. 'plot_kstar_geo', 'plot_east_geo'... set to 'generic' (default) to use default to plot X-section ecsignals_file = E coil signal names file fcsignals_file = F coil signal names file flsignals_file = flux loop signal names file bpsignals_file = B probe signal names file rlsignals_file = Rogowski loop signal names file lvsignals_file = loop voltage signal names file procedures = array of strings defining procedures to operate on the data after generation (optional, default = []) OUTPUTS: save files <tokamak>_obj_<config_name> = contains structure tok_data_struct, units= terminal, MKS (in file name, '/' replaced by '-', ' ' by '_', '\\' by '')","title":"Basic Information"},{"location":"function-guide/tok_models/make_tok_objects_m/#dependencies","text":"plot_fils mut_fine_fil bgreens_fine wait mutind_fine mut_filcs2filcs strarr_to_cellarr plot_tok_geo make_tok_data_struct green_paths2pts calc_mpp fils2filcs","title":"Dependencies"},{"location":"function-guide/tok_models/makelpcur_m/","text":"makelpcur.m \u00b6 Basic Information \u00b6 SYNTAX: (function) [cphi,ipfil,izg,irg]=makelpcur(zgg,rgg,ip,zp,rp,ap,kap,limod,nfil,iaddctr) PURPOSE: Function to make elliptical cross-section, flat to parabolic plasma current distr. defined on standard EPGenv grid. INPUTS: zgg = array of vertical position of grid points on nzxnr grid [m] rgg = array of maj. radial position of grid points on nzxnr grid [m] ip = total plasma current = sum(sum(cphi)) [conventionally MA, but can be any units] zp = current centroid vertical position [m] rp = current centroid major radial position [m] ap = minor radius at plasma midplane [m] kap = elongation of elliptical current distribution limod = (optional) specifies the distribution type & peakedness of profile: if limod>0 (continuous distribution): limod=0.5 -> flat profile, limod>=1.0 -> parabolic profile. Default = 1.0 (parabolic distribution) if limod<=0 (discrete filamentary distribution, MFIT-like): limod=0 -> filament at nearest grid point to rp,zp limod=-0.5 -> filaments at 0.5ap, kap ellipse. limod=-1 -> filaments at edge of ap,kap ellipse. nfil = (optional; required if limod<=0) number of filaments. Should be even number >= 4 to have 2 filaments on midplane, equal number above and below midplane. However, algorithm will work with any number. iaddctr = (optional; use only if limod<0) if =1, adds filament at grid point nearest (zp,rp) location. OUTPUTS: cphi = plasma current distribution on nzxnr grid [MA, but see ip above] Note that cphi consists of current filaments, NOT CURRENT DENSITY!! Thus ip = total(cphi); ipfil = vector of currents in each filament irg = vector of radial indices corresponding to locations of current fils in order of ipfil (indices are indices of nrx1 rg vector) izg = vector of vertical indices corresponding to locations of current fils in order of ipfil (indices are indices of nzx1 zg vector) RESTRICTIONS: Must have loaded DIII-D geometry environment (>> load_d3denv) or otherwise defined rgg, zgg. nfil should be even number >=4 to have up-down symmetric distribution with 2 filaments on plasma midplane. However, algorithm will work with any number. Note that the final number of filaments may not equal nfil if the original distribution of nfil filaments is too dense for the grid. Note also that limod=0 will produce a one-filament distribution regardless of nfil (since the nfil points will all be located at rp,zp, resulting in a single grid point being used for the filament. METHOD: Taken from IDL makelpcur.pro. Filament ring algorithm (limod<=0) developed after Matlab version. For this case, the filaments are placed in the grid points nearest to the originally calculated locations on the ellipse. The current in each filament is simply ip/nfil, so that the resulting current centroid is not necessarily at (rp,zp). Should fix this at some point... DAH Another option is to make limod (when negative) tell it what fraction of current goes in the central filamnet relative to the edge ones. DAH Dependencies \u00b6","title":"makelpcur.m"},{"location":"function-guide/tok_models/makelpcur_m/#makelpcurm","text":"","title":"makelpcur.m"},{"location":"function-guide/tok_models/makelpcur_m/#basic-information","text":"SYNTAX: (function) [cphi,ipfil,izg,irg]=makelpcur(zgg,rgg,ip,zp,rp,ap,kap,limod,nfil,iaddctr) PURPOSE: Function to make elliptical cross-section, flat to parabolic plasma current distr. defined on standard EPGenv grid. INPUTS: zgg = array of vertical position of grid points on nzxnr grid [m] rgg = array of maj. radial position of grid points on nzxnr grid [m] ip = total plasma current = sum(sum(cphi)) [conventionally MA, but can be any units] zp = current centroid vertical position [m] rp = current centroid major radial position [m] ap = minor radius at plasma midplane [m] kap = elongation of elliptical current distribution limod = (optional) specifies the distribution type & peakedness of profile: if limod>0 (continuous distribution): limod=0.5 -> flat profile, limod>=1.0 -> parabolic profile. Default = 1.0 (parabolic distribution) if limod<=0 (discrete filamentary distribution, MFIT-like): limod=0 -> filament at nearest grid point to rp,zp limod=-0.5 -> filaments at 0.5ap, kap ellipse. limod=-1 -> filaments at edge of ap,kap ellipse. nfil = (optional; required if limod<=0) number of filaments. Should be even number >= 4 to have 2 filaments on midplane, equal number above and below midplane. However, algorithm will work with any number. iaddctr = (optional; use only if limod<0) if =1, adds filament at grid point nearest (zp,rp) location. OUTPUTS: cphi = plasma current distribution on nzxnr grid [MA, but see ip above] Note that cphi consists of current filaments, NOT CURRENT DENSITY!! Thus ip = total(cphi); ipfil = vector of currents in each filament irg = vector of radial indices corresponding to locations of current fils in order of ipfil (indices are indices of nrx1 rg vector) izg = vector of vertical indices corresponding to locations of current fils in order of ipfil (indices are indices of nzx1 zg vector) RESTRICTIONS: Must have loaded DIII-D geometry environment (>> load_d3denv) or otherwise defined rgg, zgg. nfil should be even number >=4 to have up-down symmetric distribution with 2 filaments on plasma midplane. However, algorithm will work with any number. Note that the final number of filaments may not equal nfil if the original distribution of nfil filaments is too dense for the grid. Note also that limod=0 will produce a one-filament distribution regardless of nfil (since the nfil points will all be located at rp,zp, resulting in a single grid point being used for the filament. METHOD: Taken from IDL makelpcur.pro. Filament ring algorithm (limod<=0) developed after Matlab version. For this case, the filaments are placed in the grid points nearest to the originally calculated locations on the ellipse. The current in each filament is simply ip/nfil, so that the resulting current centroid is not necessarily at (rp,zp). Should fix this at some point... DAH Another option is to make limod (when negative) tell it what fraction of current goes in the central filamnet relative to the edge ones. DAH","title":"Basic Information"},{"location":"function-guide/tok_models/makelpcur_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/mpp_x_vec_m/","text":"mpp_x_vec.m \u00b6 Basic Information \u00b6 SYNTAX: product = mpp_x_vec(mpp,vec) PURPOSE: Compute product of matrix mpp and vector vec, where mpp is stored in compressed format with dimension nz*nr x nr. Can be used also for gbz2p in place of mpp. Use gbr2p_x_vec for multiplication with gbr2p. INPUT: mpp = grid to grid mutuals in compressed format vec = vector or matrix with size = nz x nr x n OR nz*nr x n, where final dimension n is arbitrary. (E.g., n=1 usually represents a single current distribution on plasma grid, while n>1 can represent current distributions at multiple times.) OUTPUT: product = product of matrix multiplication, same size as vec SEE ALSO: get_plasma_greens, gbr2p_x_vec Dependencies \u00b6","title":"mpp_x_vec.m"},{"location":"function-guide/tok_models/mpp_x_vec_m/#mpp_x_vecm","text":"","title":"mpp_x_vec.m"},{"location":"function-guide/tok_models/mpp_x_vec_m/#basic-information","text":"SYNTAX: product = mpp_x_vec(mpp,vec) PURPOSE: Compute product of matrix mpp and vector vec, where mpp is stored in compressed format with dimension nz*nr x nr. Can be used also for gbz2p in place of mpp. Use gbr2p_x_vec for multiplication with gbr2p. INPUT: mpp = grid to grid mutuals in compressed format vec = vector or matrix with size = nz x nr x n OR nz*nr x n, where final dimension n is arbitrary. (E.g., n=1 usually represents a single current distribution on plasma grid, while n>1 can represent current distributions at multiple times.) OUTPUT: product = product of matrix multiplication, same size as vec SEE ALSO: get_plasma_greens, gbr2p_x_vec","title":"Basic Information"},{"location":"function-guide/tok_models/mpp_x_vec_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/plasma_out_common_m/","text":"plasma_out_common.m \u00b6 Basic Information \u00b6 SYNTAX: plasma_out_common PURPOSE: common code for all \"plasma_output\" routines INPUT: equil_data = rzrig_data = irzresp = set to: 0 = use no rigid response 1 = use only rigid r response 2 = use both rigid r and z response num_Ecoils rgg zg rg mvv jphi0 fcnturn cc0 = coil currents from EFIT (MA-turns) include_Ip EB_out (optional, default=1 if num_Ecoils=5) plasma_obj_file = name of plasma_objects.mat file (if include_Ip=1) OUTPUT: (units depend on input objects - need to correct comments) cvnturn drdi (m/MA) dzdi (m/MA) CRZmat (m/A) dcrzdi (A/A) dcrzdip (A/A) dcrzdbetap (A/?) dcrzdli (A/?) ir iz idxpf cphi0 = EFIT equilibrium plasma current distribution (MA) cc0 = cc0 converted to MA from MA-turns mu0 = 0.4*pi; twopi = 2*pi; twopir = twopi*rgg(:) dz = (m) dr = (m) nvv = size(mvv,1) ncurrents irscl izscl ccnturn Dependencies \u00b6 cc_efit_to_tok wait","title":"plasma_out_common.m"},{"location":"function-guide/tok_models/plasma_out_common_m/#plasma_out_commonm","text":"","title":"plasma_out_common.m"},{"location":"function-guide/tok_models/plasma_out_common_m/#basic-information","text":"SYNTAX: plasma_out_common PURPOSE: common code for all \"plasma_output\" routines INPUT: equil_data = rzrig_data = irzresp = set to: 0 = use no rigid response 1 = use only rigid r response 2 = use both rigid r and z response num_Ecoils rgg zg rg mvv jphi0 fcnturn cc0 = coil currents from EFIT (MA-turns) include_Ip EB_out (optional, default=1 if num_Ecoils=5) plasma_obj_file = name of plasma_objects.mat file (if include_Ip=1) OUTPUT: (units depend on input objects - need to correct comments) cvnturn drdi (m/MA) dzdi (m/MA) CRZmat (m/A) dcrzdi (A/A) dcrzdip (A/A) dcrzdbetap (A/?) dcrzdli (A/?) ir iz idxpf cphi0 = EFIT equilibrium plasma current distribution (MA) cc0 = cc0 converted to MA from MA-turns mu0 = 0.4*pi; twopi = 2*pi; twopir = twopi*rgg(:) dz = (m) dr = (m) nvv = size(mvv,1) ncurrents irscl izscl ccnturn","title":"Basic Information"},{"location":"function-guide/tok_models/plasma_out_common_m/#dependencies","text":"cc_efit_to_tok wait","title":"Dependencies"},{"location":"function-guide/tok_models/plasma_output2_m/","text":"plasma_output2.m \u00b6 Basic Information \u00b6 ARE UNITS ON MPL AND GPB CORRECT?? SYNTAX: output2_objs= ... plasma_output2(equil_data,rzrig_data,vacuum_objs,build_inputs) PURPOSE: Calculate DIII-D plasma response output equation objects for rigid plasma. Diagnostics are some or all of normal DIII-D diagnostics. Run plasma_dynamics.m first to create the file plasma_objects.mat. INPUT: equil_data = equilibrium data structure rzrig_data = data structure generated by rzrig vacuum_objs = data structure containing standard tokamak geometry objects build_inputs = (see plasma_dynamics) OUTPUTS: output2_objs: CXd = diagnostics flux, Br, Bz response due to plasma motion from I_cond (=d[Psi, B ]pl/dIcond), Wb/A and T/A CXp = diagnostics flux, Br, Bz response due to plasma current change from I_cond (=d[Psi, B ]pl/dIcond), Wb/A and T/A Gp = diagnostics flux, Br, Bz response due to plasma current (Ip) change CRZmat = Plasma R, Z response to I_cond (m/A) plasma_row = row vector to multiply by conductor currents to get Ip in the case that Rp=0 dcrzdi', dcrzdi, ... dcrzdip', dcrzdip, ... dcrzdbetap', dcrzdbetap, ... dcrzdli', dcrzdli, ... CXbetap = diagnostics flux, Br, Bz response due to changes in betap (=d[Psi, B ]pl/dbetap), Wb/? and T/? CXli = diagnostics flux, Br, Bz response due to changes in li (=d[Psi, B ]pl/dli), Wb/? and T/? Dependencies \u00b6 plasma_out_common","title":"plasma_output2.m"},{"location":"function-guide/tok_models/plasma_output2_m/#plasma_output2m","text":"","title":"plasma_output2.m"},{"location":"function-guide/tok_models/plasma_output2_m/#basic-information","text":"ARE UNITS ON MPL AND GPB CORRECT?? SYNTAX: output2_objs= ... plasma_output2(equil_data,rzrig_data,vacuum_objs,build_inputs) PURPOSE: Calculate DIII-D plasma response output equation objects for rigid plasma. Diagnostics are some or all of normal DIII-D diagnostics. Run plasma_dynamics.m first to create the file plasma_objects.mat. INPUT: equil_data = equilibrium data structure rzrig_data = data structure generated by rzrig vacuum_objs = data structure containing standard tokamak geometry objects build_inputs = (see plasma_dynamics) OUTPUTS: output2_objs: CXd = diagnostics flux, Br, Bz response due to plasma motion from I_cond (=d[Psi, B ]pl/dIcond), Wb/A and T/A CXp = diagnostics flux, Br, Bz response due to plasma current change from I_cond (=d[Psi, B ]pl/dIcond), Wb/A and T/A Gp = diagnostics flux, Br, Bz response due to plasma current (Ip) change CRZmat = Plasma R, Z response to I_cond (m/A) plasma_row = row vector to multiply by conductor currents to get Ip in the case that Rp=0 dcrzdi', dcrzdi, ... dcrzdip', dcrzdip, ... dcrzdbetap', dcrzdbetap, ... dcrzdli', dcrzdli, ... CXbetap = diagnostics flux, Br, Bz response due to changes in betap (=d[Psi, B ]pl/dbetap), Wb/? and T/? CXli = diagnostics flux, Br, Bz response due to changes in li (=d[Psi, B ]pl/dli), Wb/? and T/?","title":"Basic Information"},{"location":"function-guide/tok_models/plasma_output2_m/#dependencies","text":"plasma_out_common","title":"Dependencies"},{"location":"function-guide/tok_models/plasma_response_vst_m/","text":"plasma_response_vst.m \u00b6 Basic Information \u00b6 USAGE: vst_data = plasma_response_vst(equil_data,iefit,tokamak,tok_data_struct,ichooseq) PURPOSE: Calculate plasma response objects using vst in corsica INPUTS: eq_file = name of an efit gfile or a saved corsica equilibrium tokamak = device to construct model objects for (e.g. 'NSTX','KSTAR',etc) vac_objs = structure containing: mcc, mvv, mcv, mpc, mpv, resc, resv, zg, rg, ecdata (Note that imks and iterminal in this structure define the units of the data objects to be produced. imks=1 gives MKS units, otherwise units are MA,uH,uOhms. iterminal=1 gives terminal mode, 0 gives lumped.) ichooseq= equilibrium file type: 1 = efit_gfile 2 = corsica generated flat files 3 = saved corsica equilibrium OUTPUTS: vst = structure containing: METHOD: The matlab script generates a basis script file and invokes corsica with this file to generate plasma response objects with vst. After that execution returns to matlab. VERSION: @(#)plasma_response_vst.m 1.2 06/25/09 Dependencies \u00b6","title":"plasma_response_vst.m"},{"location":"function-guide/tok_models/plasma_response_vst_m/#plasma_response_vstm","text":"","title":"plasma_response_vst.m"},{"location":"function-guide/tok_models/plasma_response_vst_m/#basic-information","text":"USAGE: vst_data = plasma_response_vst(equil_data,iefit,tokamak,tok_data_struct,ichooseq) PURPOSE: Calculate plasma response objects using vst in corsica INPUTS: eq_file = name of an efit gfile or a saved corsica equilibrium tokamak = device to construct model objects for (e.g. 'NSTX','KSTAR',etc) vac_objs = structure containing: mcc, mvv, mcv, mpc, mpv, resc, resv, zg, rg, ecdata (Note that imks and iterminal in this structure define the units of the data objects to be produced. imks=1 gives MKS units, otherwise units are MA,uH,uOhms. iterminal=1 gives terminal mode, 0 gives lumped.) ichooseq= equilibrium file type: 1 = efit_gfile 2 = corsica generated flat files 3 = saved corsica equilibrium OUTPUTS: vst = structure containing: METHOD: The matlab script generates a basis script file and invokes corsica with this file to generate plasma response objects with vst. After that execution returns to matlab. VERSION: @(#)plasma_response_vst.m 1.2 06/25/09","title":"Basic Information"},{"location":"function-guide/tok_models/plasma_response_vst_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/plot_tok_geo_config_m/","text":"plot_tok_geo_config.m \u00b6 Basic Information \u00b6 SYNTAX: plot_tok_geo_config(tok) PURPOSE: call plot_tok_geo for multiple vacuum data objects INPUT: tok: name of the device OUTPUT: Figure plotted to screen and .ps file RESTRICTIONS: METHOD: WRITTEN BY: MJL 20121002 MODIFICATIONS: So far only ITER and D3D cases are implemented Dependencies \u00b6 plot_tok_geo","title":"plot_tok_geo_config.m"},{"location":"function-guide/tok_models/plot_tok_geo_config_m/#plot_tok_geo_configm","text":"","title":"plot_tok_geo_config.m"},{"location":"function-guide/tok_models/plot_tok_geo_config_m/#basic-information","text":"SYNTAX: plot_tok_geo_config(tok) PURPOSE: call plot_tok_geo for multiple vacuum data objects INPUT: tok: name of the device OUTPUT: Figure plotted to screen and .ps file RESTRICTIONS: METHOD: WRITTEN BY: MJL 20121002 MODIFICATIONS: So far only ITER and D3D cases are implemented","title":"Basic Information"},{"location":"function-guide/tok_models/plot_tok_geo_config_m/#dependencies","text":"plot_tok_geo","title":"Dependencies"},{"location":"function-guide/tok_models/plot_tok_geo_m/","text":"plot_tok_geo.m \u00b6 Basic Information \u00b6 USAGE: plot_tok_geo(tok_data_struct,options,equil_data) Examples: plot_tok_geo(tok_data_struct,options,east_system.equil_data) plot_tok_geo(tok_data_struct,options,psizr) PURPOSE: Plot the basic tokamak geometry. INPUTS: [default] tok_data_struct = structure containing tokamak geometry data options = structure containing any of the following options: iblackbg = flag: 0= white figure background, [1]=black figure background ipltpsi = flag: 1= contour equilibrium psizr, >1= #contours to plot (default = 1 if psizr exists, else 0) ipltrho = flag 1= contour equilibrium normalized rho surfaces, >1= #contours to plot ipltB = flag: 1= contour equilibrium |B|, >1= #contours to plot [0] ipltJ = flag: 1= contour equilibrium jphi, >1= #contours to plot [0] (Only one of ipltpsi, iltrho, ipltB, ipltJ may be specified; all need equil_data.) ipltfc = flag; 1= plot the f-coils [1] ipltvv = flag; 1= plot the vacuum vessel elements [1] ipltlim = flag: 1= plot limiter switch [1] ipltfl = flag: 1= plot Flux Loops [0] ipltbp = flag: 1= plot B-Probe indices [0] ipltgap = flag: 1= plot gap locations [0] ilabeleq = flag: 1= contour label flux values [0] ilabelfc = flag: 1= label PF's with indices, >1 => use name labels, with fontsize=ilabelfc [0] ilabelcc = flag: 1= label PF coil STATES with indices (cannot also set ilabelfc) Pcc = matrix that computes PF currents from states (required if ilabelcc=1) ilabelvv = flag: 1= label VV elements with indices [0] ilabelfl = flag: 1= label FL's with indices [0] >1 => use name labels, with fontsize=ilabelfl [0] ilabelbp = flag: 1= label BP's with indices, >1 => use name labels, with fontsize=ilabelbp [0] ilabelgap= flag: 1= label gaps with indices [0] idxvv = indices of vacuum vessel to plot (default = all) idxfl = indices of flux loops to plot (default all, used only if ipltfl) idxbp = indices of Bprobes to plot (default all, used only if ipltbp) vvgroup = grouping vector for vacuum vessel elements, used only if ilabelvv=1 to define vessel element labels ileftright: bit 1 = plot left side, bit 0 = plot right side (default) equil_data = equilibrium psizr from EFIT OR structure containing psizr and psibnd (e.g. equil_data in *_system struct produced by build_*_sys.m script. OUTPUTS: Plot of tokamak geometry","title":"plot_tok_geo.m"},{"location":"function-guide/tok_models/plot_tok_geo_m/#plot_tok_geom","text":"","title":"plot_tok_geo.m"},{"location":"function-guide/tok_models/plot_tok_geo_m/#basic-information","text":"USAGE: plot_tok_geo(tok_data_struct,options,equil_data) Examples: plot_tok_geo(tok_data_struct,options,east_system.equil_data) plot_tok_geo(tok_data_struct,options,psizr) PURPOSE: Plot the basic tokamak geometry. INPUTS: [default] tok_data_struct = structure containing tokamak geometry data options = structure containing any of the following options: iblackbg = flag: 0= white figure background, [1]=black figure background ipltpsi = flag: 1= contour equilibrium psizr, >1= #contours to plot (default = 1 if psizr exists, else 0) ipltrho = flag 1= contour equilibrium normalized rho surfaces, >1= #contours to plot ipltB = flag: 1= contour equilibrium |B|, >1= #contours to plot [0] ipltJ = flag: 1= contour equilibrium jphi, >1= #contours to plot [0] (Only one of ipltpsi, iltrho, ipltB, ipltJ may be specified; all need equil_data.) ipltfc = flag; 1= plot the f-coils [1] ipltvv = flag; 1= plot the vacuum vessel elements [1] ipltlim = flag: 1= plot limiter switch [1] ipltfl = flag: 1= plot Flux Loops [0] ipltbp = flag: 1= plot B-Probe indices [0] ipltgap = flag: 1= plot gap locations [0] ilabeleq = flag: 1= contour label flux values [0] ilabelfc = flag: 1= label PF's with indices, >1 => use name labels, with fontsize=ilabelfc [0] ilabelcc = flag: 1= label PF coil STATES with indices (cannot also set ilabelfc) Pcc = matrix that computes PF currents from states (required if ilabelcc=1) ilabelvv = flag: 1= label VV elements with indices [0] ilabelfl = flag: 1= label FL's with indices [0] >1 => use name labels, with fontsize=ilabelfl [0] ilabelbp = flag: 1= label BP's with indices, >1 => use name labels, with fontsize=ilabelbp [0] ilabelgap= flag: 1= label gaps with indices [0] idxvv = indices of vacuum vessel to plot (default = all) idxfl = indices of flux loops to plot (default all, used only if ipltfl) idxbp = indices of Bprobes to plot (default all, used only if ipltbp) vvgroup = grouping vector for vacuum vessel elements, used only if ilabelvv=1 to define vessel element labels ileftright: bit 1 = plot left side, bit 0 = plot right side (default) equil_data = equilibrium psizr from EFIT OR structure containing psizr and psibnd (e.g. equil_data in *_system struct produced by build_*_sys.m script. OUTPUTS: Plot of tokamak geometry","title":"Basic Information"},{"location":"function-guide/tok_models/regrid_m/","text":"regrid.m \u00b6 Basic Information \u00b6 USAGE: config = regrid(rg, zg, config0) config = regrid(nr, nz, config0) PURPOSE: Replace the grid in config0 with the grid rg, zg If first input is scalar (= nr) then: rg = linspace(config0.rg(1),config0.rg(end),nr)' If second input is scalar (= nz) then: zg = linspace(config0.zg(1),config0.zg(end),nz)' INPUTS: rg, radii of grid points [m] zg, height of grid points [m] config0, a.k.a. tok_data_struct or vac_objs a structure containing (TokSys) tokamak information OUTPUTS: config, like config0 but all grid quantities are for rg, zg Dependencies \u00b6 mutind","title":"regrid.m"},{"location":"function-guide/tok_models/regrid_m/#regridm","text":"","title":"regrid.m"},{"location":"function-guide/tok_models/regrid_m/#basic-information","text":"USAGE: config = regrid(rg, zg, config0) config = regrid(nr, nz, config0) PURPOSE: Replace the grid in config0 with the grid rg, zg If first input is scalar (= nr) then: rg = linspace(config0.rg(1),config0.rg(end),nr)' If second input is scalar (= nz) then: zg = linspace(config0.zg(1),config0.zg(end),nz)' INPUTS: rg, radii of grid points [m] zg, height of grid points [m] config0, a.k.a. tok_data_struct or vac_objs a structure containing (TokSys) tokamak information OUTPUTS: config, like config0 but all grid quantities are for rg, zg","title":"Basic Information"},{"location":"function-guide/tok_models/regrid_m/#dependencies","text":"mutind","title":"Dependencies"},{"location":"function-guide/tok_models/run_divertor_model_m/","text":"run_divertor_model.m \u00b6 Basic Information \u00b6 USAGE: >> run_divertor_model PURPOSE: Script to run divertor_model.m to evolve divertor/core dynamics with specified inputs, intended to execute open loop OR closed loop evolution. For open loop, inputs waveforms (Gamec(t), Gamrc(t),Gamrd(t)) are defined explicitly below. For open loop, input waveforms are determined dynamic by feedback laws defined below. INPUTS: OUTPUTS: RESTRICTIONS: METHOD: Dependencies \u00b6 divertor_model","title":"run_divertor_model.m"},{"location":"function-guide/tok_models/run_divertor_model_m/#run_divertor_modelm","text":"","title":"run_divertor_model.m"},{"location":"function-guide/tok_models/run_divertor_model_m/#basic-information","text":"USAGE: >> run_divertor_model PURPOSE: Script to run divertor_model.m to evolve divertor/core dynamics with specified inputs, intended to execute open loop OR closed loop evolution. For open loop, inputs waveforms (Gamec(t), Gamrc(t),Gamrd(t)) are defined explicitly below. For open loop, input waveforms are determined dynamic by feedback laws defined below. INPUTS: OUTPUTS: RESTRICTIONS: METHOD:","title":"Basic Information"},{"location":"function-guide/tok_models/run_divertor_model_m/#dependencies","text":"divertor_model","title":"Dependencies"},{"location":"function-guide/tok_models/rzrig_m/","text":"rzrig.m \u00b6 Basic Information \u00b6 USAGE: function [model_data,cc0,vc0,dbg_objs]=rzrig( ... equil_data,tokamak,vac_objs,idoplots,idoncal,idxvv,iwait) PURPOSE: Script to calculate vertical and radial response using rigid current-conserving model of plasma for GENERAL systems. Takes basic data from EFIT g-file or external data input (cc, jphi; eg from Corsica) and needs environment objects of same names as D3D environment. cc and jphi are ASSUMED to be in MA when read from gfile or defined externally. INPUTS: equil_data = structure containing equilibrium information tokamak = device to construct model objects for (e.g. 'NSTX','KSTAR',etc) vac_objs = structure containing: mcc, mvv, mcv, mpc, mpv, resc, resv, zg, rg, ecdata (Note that imks and iterminal in this structure define the units of the data objects to be produced. imks=1 gives MKS units, otherwise units are MA,uH,uOhms. iterminal=1 gives terminal mode, 0 gives lumped.) idoplots= (optional) flag to select plotting: 1=plot, 0=don't(default) idoncal = (optional) flag to select calc of decay index: 1=calc, 0=don't(default) idxvv = (optional) indices of VV elements to use in force calculation (default=1:nvv) iwait = (optional) 1(default)=wait with error messages, 0=no wait iverbose = (optional) Flag to display messages, default is 0 OUTPUTS: model_data = quantities describing vertical/radial force balance&couplings - data objects - units = units of data objects - desc = descriptions of data objects cc0 = equilibrium coil currents (size matching objects in vac_objs, with units as specified by imks and iterminal in vac_objs) vc0 = equilibrium vessel currents (size matching objects in vac_objs, with units as specified by imks and iterminal in vac_objs) Also displays max positive eigenvalue for various conductor modifications. RESTRICTIONS: Plasma current density must be zero within 1 grid of upper & lower walls (for 2-sided calculations of gradients). Circuits defaulted to be lumped (one-turn) elements (see ccnturn def below). If magnetic mapping objects (mcc, mpc, etc...) are in terminal mode (iterminal==1), ccnturn must correspond to turns in them. cc coming from read_gfile (or wherever) assumed to be lumped mode. METHOD: Described in Walker/Humphreys, Valid Coordinate Systems for Linearized Plasma Shape Response Models in Tokamaks, FS&T,Nov.06; GA report GA-A25042 Dependencies \u00b6 eigsort wait cc_efit_to_tok","title":"rzrig.m"},{"location":"function-guide/tok_models/rzrig_m/#rzrigm","text":"","title":"rzrig.m"},{"location":"function-guide/tok_models/rzrig_m/#basic-information","text":"USAGE: function [model_data,cc0,vc0,dbg_objs]=rzrig( ... equil_data,tokamak,vac_objs,idoplots,idoncal,idxvv,iwait) PURPOSE: Script to calculate vertical and radial response using rigid current-conserving model of plasma for GENERAL systems. Takes basic data from EFIT g-file or external data input (cc, jphi; eg from Corsica) and needs environment objects of same names as D3D environment. cc and jphi are ASSUMED to be in MA when read from gfile or defined externally. INPUTS: equil_data = structure containing equilibrium information tokamak = device to construct model objects for (e.g. 'NSTX','KSTAR',etc) vac_objs = structure containing: mcc, mvv, mcv, mpc, mpv, resc, resv, zg, rg, ecdata (Note that imks and iterminal in this structure define the units of the data objects to be produced. imks=1 gives MKS units, otherwise units are MA,uH,uOhms. iterminal=1 gives terminal mode, 0 gives lumped.) idoplots= (optional) flag to select plotting: 1=plot, 0=don't(default) idoncal = (optional) flag to select calc of decay index: 1=calc, 0=don't(default) idxvv = (optional) indices of VV elements to use in force calculation (default=1:nvv) iwait = (optional) 1(default)=wait with error messages, 0=no wait iverbose = (optional) Flag to display messages, default is 0 OUTPUTS: model_data = quantities describing vertical/radial force balance&couplings - data objects - units = units of data objects - desc = descriptions of data objects cc0 = equilibrium coil currents (size matching objects in vac_objs, with units as specified by imks and iterminal in vac_objs) vc0 = equilibrium vessel currents (size matching objects in vac_objs, with units as specified by imks and iterminal in vac_objs) Also displays max positive eigenvalue for various conductor modifications. RESTRICTIONS: Plasma current density must be zero within 1 grid of upper & lower walls (for 2-sided calculations of gradients). Circuits defaulted to be lumped (one-turn) elements (see ccnturn def below). If magnetic mapping objects (mcc, mpc, etc...) are in terminal mode (iterminal==1), ccnturn must correspond to turns in them. cc coming from read_gfile (or wherever) assumed to be lumped mode. METHOD: Described in Walker/Humphreys, Valid Coordinate Systems for Linearized Plasma Shape Response Models in Tokamaks, FS&T,Nov.06; GA report GA-A25042","title":"Basic Information"},{"location":"function-guide/tok_models/rzrig_m/#dependencies","text":"eigsort wait cc_efit_to_tok","title":"Dependencies"},{"location":"function-guide/tok_models/scale_equil_response_m/","text":"scale_equil_response.m \u00b6 Basic Information \u00b6 SYNTAX: scaled_system = scale_equil_response(tok_system,scaleip) PURPOSE: Modify the response model contained in tok_system for an equilibrium scaled by the factor scaleip. INPUT: tok_system = system model of the type built by build_tokamak_system scale_ip = scalar to multiply by currents in equilibrium that was used when generating tok_system OUTPUT: scaled_system = system model of the same type representing an equilibrium scaled by the factor scaleip Dependencies \u00b6","title":"scale_equil_response.m"},{"location":"function-guide/tok_models/scale_equil_response_m/#scale_equil_responsem","text":"","title":"scale_equil_response.m"},{"location":"function-guide/tok_models/scale_equil_response_m/#basic-information","text":"SYNTAX: scaled_system = scale_equil_response(tok_system,scaleip) PURPOSE: Modify the response model contained in tok_system for an equilibrium scaled by the factor scaleip. INPUT: tok_system = system model of the type built by build_tokamak_system scale_ip = scalar to multiply by currents in equilibrium that was used when generating tok_system OUTPUT: scaled_system = system model of the same type representing an equilibrium scaled by the factor scaleip","title":"Basic Information"},{"location":"function-guide/tok_models/scale_equil_response_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/strikepoints_m/","text":"strikepoints.m \u00b6 Basic Information \u00b6 USAGE: sr = strikepoints(equ,resp1) sr = strikepoints(equ,resp2,tok) PURPOSE: Find strike points and related response objects Some of the returned points may not be true strike points INPUTS: equ, equilibrium description, required fields are: rg, zg = grid coordinates psizr = flux on grid psibry = boundary flux xlim, ylim OR Rlim, Zlim OR limdata = limiter coordinates resp1, plasma response, required fields are: dpsizrdx, dpsibrydx = response to a variable called x resp2, plasma response from gspert (x=[is;Ip;li;betap]) Fields dcphid* from gspert are used internally with tok.mpp to calculate dpsizrdx, dpsibrydx, for x=[is;Ip;li;betap] tok, TokSys description of tokamak (tok_data_struct) OUTPUTS: sr, strike points and responses in a structure with fields: rst, zst = *all* points on limiter where flux = psibry dpsistdx = flux change at rst, zst in response to x drstdx, dzstdx = displacement along limiter in response to x Dependencies \u00b6","title":"strikepoints.m"},{"location":"function-guide/tok_models/strikepoints_m/#strikepointsm","text":"","title":"strikepoints.m"},{"location":"function-guide/tok_models/strikepoints_m/#basic-information","text":"USAGE: sr = strikepoints(equ,resp1) sr = strikepoints(equ,resp2,tok) PURPOSE: Find strike points and related response objects Some of the returned points may not be true strike points INPUTS: equ, equilibrium description, required fields are: rg, zg = grid coordinates psizr = flux on grid psibry = boundary flux xlim, ylim OR Rlim, Zlim OR limdata = limiter coordinates resp1, plasma response, required fields are: dpsizrdx, dpsibrydx = response to a variable called x resp2, plasma response from gspert (x=[is;Ip;li;betap]) Fields dcphid* from gspert are used internally with tok.mpp to calculate dpsizrdx, dpsibrydx, for x=[is;Ip;li;betap] tok, TokSys description of tokamak (tok_data_struct) OUTPUTS: sr, strike points and responses in a structure with fields: rst, zst = *all* points on limiter where flux = psibry dpsistdx = flux change at rst, zst in response to x drstdx, dzstdx = displacement along limiter in response to x","title":"Basic Information"},{"location":"function-guide/tok_models/strikepoints_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/tok_models/test_gseq_iter_m/","text":"test_gseq_iter.m \u00b6 Basic Information \u00b6 USAGE: test_gseq_iter PURPOSE: Examples on how to run gseq INPUTS: None (just run the code) OUTPUTS: Demonstration of gseq, including plots of evolving equilibrium Dependencies \u00b6 read_corsica_flat_files cc_efit_to_tok","title":"test_gseq_iter.m"},{"location":"function-guide/tok_models/test_gseq_iter_m/#test_gseq_iterm","text":"","title":"test_gseq_iter.m"},{"location":"function-guide/tok_models/test_gseq_iter_m/#basic-information","text":"USAGE: test_gseq_iter PURPOSE: Examples on how to run gseq INPUTS: None (just run the code) OUTPUTS: Demonstration of gseq, including plots of evolving equilibrium","title":"Basic Information"},{"location":"function-guide/tok_models/test_gseq_iter_m/#dependencies","text":"read_corsica_flat_files cc_efit_to_tok","title":"Dependencies"},{"location":"function-guide/tok_models/test_output_objs_m/","text":"test_output_objs.m \u00b6 Basic Information \u00b6 SYNTAX: test_output_objs PURPOSE: Test consistency of EFIT equilibrium, output_objs data from PCS calculations, and calculations from objects in toksys vacuum data structure. Only tested for D3D and NSTX right now. INPUT: tok_system = data structure created by build_<device>_sys.m tok_data_struct = vacuum data model structure output_objs = data structure created by plasma_outputs.m wait_for_plots = set to 1 to pause after each plot [0] figure_num = figure number for incrementing figures [0] OUTPUT: plots comparing various calculation results Dependencies \u00b6 calc_isoflux_response read_response plot_tok_geo mpp_x_vec","title":"test_output_objs.m"},{"location":"function-guide/tok_models/test_output_objs_m/#test_output_objsm","text":"","title":"test_output_objs.m"},{"location":"function-guide/tok_models/test_output_objs_m/#basic-information","text":"SYNTAX: test_output_objs PURPOSE: Test consistency of EFIT equilibrium, output_objs data from PCS calculations, and calculations from objects in toksys vacuum data structure. Only tested for D3D and NSTX right now. INPUT: tok_system = data structure created by build_<device>_sys.m tok_data_struct = vacuum data model structure output_objs = data structure created by plasma_outputs.m wait_for_plots = set to 1 to pause after each plot [0] figure_num = figure number for incrementing figures [0] OUTPUT: plots comparing various calculation results","title":"Basic Information"},{"location":"function-guide/tok_models/test_output_objs_m/#dependencies","text":"calc_isoflux_response read_response plot_tok_geo mpp_x_vec","title":"Dependencies"},{"location":"function-guide/tok_models/update_maxis_m/","text":"update_maxis.m \u00b6 Basic Information \u00b6 USAGE: Initial call must include config: [rmaxis, zmaxis, maxis, iia, wa, drmaxisdpsi, dzmaxisdpsi] = ... update_maxis(rmaxis, zmaxis, psizr, config) Initial call that only configures: update_maxis([], [], [], config) Repeat calls execute faster if config is omitted: [rmaxis, zmaxis, maxis, iia, wa, drmaxisdpsi, dzmaxisdpsi] = ... update_maxis(rmaxis, zmaxis, psizr) PURPOSE: Zoom in on magnetic axis INPUTS: rmaxis, zmaxis, approximate axis position psizr, flux on the grid config, a structure with fields: rg, zg, grid coordinates limdata, limiter coordinates [Zlim; Rlim] OUTPUTS: rmaxis, zmaxis, updated position of magnetic axis maxis, boolean true if axis still inside limiter after update iia, wa, indices and weights such that psimag = wa*psizr(iia) drmaxisdpsi, weights so that drmaxis = drmaxisdpsi*dpsizr(iia) dzmaxisdpsi, weights so that dzmaxis = dzmaxisdpsi*dpsizr(iia) METHOD: interpolation with bicubic Hermite splines, Newton-Rhapson to zoom, private version of isinpoly to check that axis is inside limiter","title":"update_maxis.m"},{"location":"function-guide/tok_models/update_maxis_m/#update_maxism","text":"","title":"update_maxis.m"},{"location":"function-guide/tok_models/update_maxis_m/#basic-information","text":"USAGE: Initial call must include config: [rmaxis, zmaxis, maxis, iia, wa, drmaxisdpsi, dzmaxisdpsi] = ... update_maxis(rmaxis, zmaxis, psizr, config) Initial call that only configures: update_maxis([], [], [], config) Repeat calls execute faster if config is omitted: [rmaxis, zmaxis, maxis, iia, wa, drmaxisdpsi, dzmaxisdpsi] = ... update_maxis(rmaxis, zmaxis, psizr) PURPOSE: Zoom in on magnetic axis INPUTS: rmaxis, zmaxis, approximate axis position psizr, flux on the grid config, a structure with fields: rg, zg, grid coordinates limdata, limiter coordinates [Zlim; Rlim] OUTPUTS: rmaxis, zmaxis, updated position of magnetic axis maxis, boolean true if axis still inside limiter after update iia, wa, indices and weights such that psimag = wa*psizr(iia) drmaxisdpsi, weights so that drmaxis = drmaxisdpsi*dpsizr(iia) dzmaxisdpsi, weights so that dzmaxis = dzmaxisdpsi*dpsizr(iia) METHOD: interpolation with bicubic Hermite splines, Newton-Rhapson to zoom, private version of isinpoly to check that axis is inside limiter","title":"Basic Information"},{"location":"function-guide/toksim/GSevolve_setup_m/","text":"GSevolve_setup.m \u00b6 Basic Information \u00b6 SYNTAX: GSevolve_setup(module_path) PURPOSE: Define configuration, initial, and tsdata for GSevolve module INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data Dependencies \u00b6","title":"GSevolve_setup.m"},{"location":"function-guide/toksim/GSevolve_setup_m/#gsevolve_setupm","text":"","title":"GSevolve_setup.m"},{"location":"function-guide/toksim/GSevolve_setup_m/#basic-information","text":"SYNTAX: GSevolve_setup(module_path) PURPOSE: Define configuration, initial, and tsdata for GSevolve module INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data","title":"Basic Information"},{"location":"function-guide/toksim/GSevolve_setup_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/toksim/Ip_evolution_setup_m/","text":"Ip_evolution_setup.m \u00b6 Basic Information \u00b6 SYNTAX: Ip_evolution_setup PURPOSE: Define configuration data structure for Ip_evolution module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module Dependencies \u00b6","title":"Ip_evolution_setup.m"},{"location":"function-guide/toksim/Ip_evolution_setup_m/#ip_evolution_setupm","text":"","title":"Ip_evolution_setup.m"},{"location":"function-guide/toksim/Ip_evolution_setup_m/#basic-information","text":"SYNTAX: Ip_evolution_setup PURPOSE: Define configuration data structure for Ip_evolution module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/Ip_evolution_setup_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/toksim/LH_module_setup_m/","text":"LH_module_setup.m \u00b6 Basic Information \u00b6 SYNTAX: LH_module_setup PURPOSE: Define configuration data structure for LH_module module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"LH_module_setup.m"},{"location":"function-guide/toksim/LH_module_setup_m/#lh_module_setupm","text":"","title":"LH_module_setup.m"},{"location":"function-guide/toksim/LH_module_setup_m/#basic-information","text":"SYNTAX: LH_module_setup PURPOSE: Define configuration data structure for LH_module module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/gsevolve_sfun_m/","text":"gsevolve_sfun.m \u00b6 Basic Information \u00b6 USAGE: called by gsevolve module PURPOSE: interface between simulink and gsevolve INPUTS: xs, the state of the plasma vps, voltages on coils from power supplies vcd, voltages induced by current drive time, the time in the simulation OUTPUTS: y, outputs defined by config.outputs For more detailed information, type gsevolve at the matlab prompt","title":"gsevolve_sfun.m"},{"location":"function-guide/toksim/gsevolve_sfun_m/#gsevolve_sfunm","text":"","title":"gsevolve_sfun.m"},{"location":"function-guide/toksim/gsevolve_sfun_m/#basic-information","text":"USAGE: called by gsevolve module PURPOSE: interface between simulink and gsevolve INPUTS: xs, the state of the plasma vps, voltages on coils from power supplies vcd, voltages induced by current drive time, the time in the simulation OUTPUTS: y, outputs defined by config.outputs For more detailed information, type gsevolve at the matlab prompt","title":"Basic Information"},{"location":"function-guide/toksim/gsupdates_m/","text":"gsupdates.m \u00b6 Basic Information \u00b6 USAGE: called by gsevolve module PURPOSE: interface between simulink and gsevolve INPUTS: x, state of the plasma OUTPUTS: d, dynamics objects For more detailed information, type gsevolve at the matlab prompt","title":"gsupdates.m"},{"location":"function-guide/toksim/gsupdates_m/#gsupdatesm","text":"","title":"gsupdates.m"},{"location":"function-guide/toksim/gsupdates_m/#basic-information","text":"USAGE: called by gsevolve module PURPOSE: interface between simulink and gsevolve INPUTS: x, state of the plasma OUTPUTS: d, dynamics objects For more detailed information, type gsevolve at the matlab prompt","title":"Basic Information"},{"location":"function-guide/toksim/limited_system_setup_m/","text":"limited_system_setup.m \u00b6 Basic Information \u00b6 SYNTAX: setup_data = limited_system_setup(module_path) PURPOSE: Define configuration data structure for limited_system module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"limited_system_setup.m"},{"location":"function-guide/toksim/limited_system_setup_m/#limited_system_setupm","text":"","title":"limited_system_setup.m"},{"location":"function-guide/toksim/limited_system_setup_m/#basic-information","text":"SYNTAX: setup_data = limited_system_setup(module_path) PURPOSE: Define configuration data structure for limited_system module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/lin_plasma_sim_setup_m/","text":"lin_plasma_sim_setup.m \u00b6 Basic Information \u00b6 SYNTAX: lin_plasma_sim_setup PURPOSE: Define configuration data structure for limited_system module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"lin_plasma_sim_setup.m"},{"location":"function-guide/toksim/lin_plasma_sim_setup_m/#lin_plasma_sim_setupm","text":"","title":"lin_plasma_sim_setup.m"},{"location":"function-guide/toksim/lin_plasma_sim_setup_m/#basic-information","text":"SYNTAX: lin_plasma_sim_setup PURPOSE: Define configuration data structure for limited_system module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/make_Vector2Bus_m/","text":"make_Vector2Bus.m \u00b6 Basic Information \u00b6 SYNTAX: make_Vector2Bus(block_name,output_signals) PURPOSE: Create a Vector2Bus block in the currently selected block of your simulink model. INPUT: block_name = what to call the block (string) output_signals = structure with field names defining the separate output bus fields OUTPUT: creates a Simulink block in the currently active subsystem window RESTRICTIONS: Currently allows sub-buses only 1 level down from top. All leaf nodes must be column vectors.","title":"make_Vector2Bus.m"},{"location":"function-guide/toksim/make_Vector2Bus_m/#make_vector2busm","text":"","title":"make_Vector2Bus.m"},{"location":"function-guide/toksim/make_Vector2Bus_m/#basic-information","text":"SYNTAX: make_Vector2Bus(block_name,output_signals) PURPOSE: Create a Vector2Bus block in the currently selected block of your simulink model. INPUT: block_name = what to call the block (string) output_signals = structure with field names defining the separate output bus fields OUTPUT: creates a Simulink block in the currently active subsystem window RESTRICTIONS: Currently allows sub-buses only 1 level down from top. All leaf nodes must be column vectors.","title":"Basic Information"},{"location":"function-guide/toksim/read_torbeam_eqdata_m/","text":"read_torbeam_eqdata.m \u00b6 Basic Information \u00b6 SYNTAX: eqdata = read_torbeam_eqdata(eqdata_file) PURPOSE: Read torbeam eqdata input files into matlab environment. INPUT: eqdata_file = string specifying name of file containing equil data OUTPUT: eqdata = eqdata data array as specified in torbeam documentation nw = number of radial coordinates in grid nh = number of vertical coordinates in grid Dependencies \u00b6 torbeam_sizes wait","title":"read_torbeam_eqdata.m"},{"location":"function-guide/toksim/read_torbeam_eqdata_m/#read_torbeam_eqdatam","text":"","title":"read_torbeam_eqdata.m"},{"location":"function-guide/toksim/read_torbeam_eqdata_m/#basic-information","text":"SYNTAX: eqdata = read_torbeam_eqdata(eqdata_file) PURPOSE: Read torbeam eqdata input files into matlab environment. INPUT: eqdata_file = string specifying name of file containing equil data OUTPUT: eqdata = eqdata data array as specified in torbeam documentation nw = number of radial coordinates in grid nh = number of vertical coordinates in grid","title":"Basic Information"},{"location":"function-guide/toksim/read_torbeam_eqdata_m/#dependencies","text":"torbeam_sizes wait","title":"Dependencies"},{"location":"function-guide/toksim/read_torbeam_prdata_m/","text":"read_torbeam_prdata.m \u00b6 Basic Information \u00b6 SYNTAX: [prdata,dens_len,temp_len] = read_torbeam_prdata(ne_file,Te_file) PURPOSE: Read torbeam prdata input files into matlab environment. INPUT: ne_file = string specifying name of file containing electron density data Te_file = string specifying name of file containing electron temperature data OUTPUT: prdata = prdata data array as specified in torbeam documentation dens_len = length of valid density array data (k in torbeam documentation) temp_len = length of valid temperature array data (l in torbeam documentation) Dependencies \u00b6 wait","title":"read_torbeam_prdata.m"},{"location":"function-guide/toksim/read_torbeam_prdata_m/#read_torbeam_prdatam","text":"","title":"read_torbeam_prdata.m"},{"location":"function-guide/toksim/read_torbeam_prdata_m/#basic-information","text":"SYNTAX: [prdata,dens_len,temp_len] = read_torbeam_prdata(ne_file,Te_file) PURPOSE: Read torbeam prdata input files into matlab environment. INPUT: ne_file = string specifying name of file containing electron density data Te_file = string specifying name of file containing electron temperature data OUTPUT: prdata = prdata data array as specified in torbeam documentation dens_len = length of valid density array data (k in torbeam documentation) temp_len = length of valid temperature array data (l in torbeam documentation)","title":"Basic Information"},{"location":"function-guide/toksim/read_torbeam_prdata_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/toksim/rtplots_m/","text":"rtplots.m \u00b6 Basic Information \u00b6 USAGE: rtplots(block) PURPOSE: time-triggered plotting during simulations INPUTS: x, state vector persistent variables are read from gsupdate PARAMETER: c, config data for gsupdate & plot settings OUTPUTS: tp, next time to plot figure with plots","title":"rtplots.m"},{"location":"function-guide/toksim/rtplots_m/#rtplotsm","text":"","title":"rtplots.m"},{"location":"function-guide/toksim/rtplots_m/#basic-information","text":"USAGE: rtplots(block) PURPOSE: time-triggered plotting during simulations INPUTS: x, state vector persistent variables are read from gsupdate PARAMETER: c, config data for gsupdate & plot settings OUTPUTS: tp, next time to plot figure with plots","title":"Basic Information"},{"location":"function-guide/toksim/simple_HCD_actuator_setup_m/","text":"simple_HCD_actuator_setup.m \u00b6 Basic Information \u00b6 SYNTAX: simple_HCD_actuator_setup PURPOSE: Define configuration data structure for simple_HCD_actuator module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"simple_HCD_actuator_setup.m"},{"location":"function-guide/toksim/simple_HCD_actuator_setup_m/#simple_hcd_actuator_setupm","text":"","title":"simple_HCD_actuator_setup.m"},{"location":"function-guide/toksim/simple_HCD_actuator_setup_m/#basic-information","text":"SYNTAX: simple_HCD_actuator_setup PURPOSE: Define configuration data structure for simple_HCD_actuator module. This function is called by invoking pcssp_bld_setup to provide structured data objects illustrating what fields need to be filled in for this module. INPUT: module_path = path of module for which setup_data is being constructed OUTPUT: setup_data = setup data for this module","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_eqdata_m/","text":"read_torbeam_eqdata.m \u00b6 Basic Information \u00b6 SYNTAX: eqdata = read_torbeam_eqdata(eqdata_file) PURPOSE: Read torbeam eqdata input files into matlab environment. INPUT: eqdata_file = string specifying name of file containing equil data OUTPUT: eqdata = eqdata data array as specified in torbeam documentation nw = number of radial coordinates in grid nh = number of vertical coordinates in grid Dependencies \u00b6 torbeam_sizes wait","title":"read_torbeam_eqdata.m"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_eqdata_m/#read_torbeam_eqdatam","text":"","title":"read_torbeam_eqdata.m"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_eqdata_m/#basic-information","text":"SYNTAX: eqdata = read_torbeam_eqdata(eqdata_file) PURPOSE: Read torbeam eqdata input files into matlab environment. INPUT: eqdata_file = string specifying name of file containing equil data OUTPUT: eqdata = eqdata data array as specified in torbeam documentation nw = number of radial coordinates in grid nh = number of vertical coordinates in grid","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_eqdata_m/#dependencies","text":"torbeam_sizes wait","title":"Dependencies"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_prdata_m/","text":"read_torbeam_prdata.m \u00b6 Basic Information \u00b6 SYNTAX: [prdata,dens_len,temp_len] = read_torbeam_prdata(ne_file,Te_file) PURPOSE: Read torbeam prdata input files into matlab environment. INPUT: ne_file = string specifying name of file containing electron density data Te_file = string specifying name of file containing electron temperature data OUTPUT: prdata = prdata data array as specified in torbeam documentation dens_len = length of valid density array data (k in torbeam documentation) temp_len = length of valid temperature array data (l in torbeam documentation) Dependencies \u00b6 wait","title":"read_torbeam_prdata.m"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_prdata_m/#read_torbeam_prdatam","text":"","title":"read_torbeam_prdata.m"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_prdata_m/#basic-information","text":"SYNTAX: [prdata,dens_len,temp_len] = read_torbeam_prdata(ne_file,Te_file) PURPOSE: Read torbeam prdata input files into matlab environment. INPUT: ne_file = string specifying name of file containing electron density data Te_file = string specifying name of file containing electron temperature data OUTPUT: prdata = prdata data array as specified in torbeam documentation dens_len = length of valid density array data (k in torbeam documentation) temp_len = length of valid temperature array data (l in torbeam documentation)","title":"Basic Information"},{"location":"function-guide/toksim/build_torbeam/read_torbeam_prdata_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/utilities/ETA_m/","text":"ETA.m \u00b6 Basic Information \u00b6 USAGE: [str, sec] = ETA(frac) PURPOSE: Estimate day and time that lengthy calculations will finish INPUTS: frac, fraction of calculations that have been completed OUTPUTS: str, string with date and time when calculations will finish sec, number of seconds remaining until calculations finish EXAMPLE: ETA(0) Reset timer for i = 1:n Calculation fprintf(char(8+zeros(1,45))) fprintf('Calculations will finish s',ETA(i/n)) end disp(' ') Dependencies \u00b6","title":"ETA.m"},{"location":"function-guide/utilities/ETA_m/#etam","text":"","title":"ETA.m"},{"location":"function-guide/utilities/ETA_m/#basic-information","text":"USAGE: [str, sec] = ETA(frac) PURPOSE: Estimate day and time that lengthy calculations will finish INPUTS: frac, fraction of calculations that have been completed OUTPUTS: str, string with date and time when calculations will finish sec, number of seconds remaining until calculations finish EXAMPLE: ETA(0) Reset timer for i = 1:n Calculation fprintf(char(8+zeros(1,45))) fprintf('Calculations will finish s',ETA(i/n)) end disp(' ')","title":"Basic Information"},{"location":"function-guide/utilities/ETA_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/det_poly_m/","text":"det_poly.m \u00b6 Basic Information \u00b6 SYNTAX: det = det_poly(matrix) PURPOSE: Compute determinant of polynomial matrix. A poly matrix is of the form matrix(P,M,M), which represents an MxM matrix of polynomials of at most degree P-1. The P elements of matrix(:,k,j) represent a poly in matlab representation. INPUT: matrix = matrix of polynomials OUTPUT: det = polynomial that is determinant of matrix Dependencies \u00b6 submatrix_poly wait","title":"det_poly.m"},{"location":"function-guide/utilities/det_poly_m/#det_polym","text":"","title":"det_poly.m"},{"location":"function-guide/utilities/det_poly_m/#basic-information","text":"SYNTAX: det = det_poly(matrix) PURPOSE: Compute determinant of polynomial matrix. A poly matrix is of the form matrix(P,M,M), which represents an MxM matrix of polynomials of at most degree P-1. The P elements of matrix(:,k,j) represent a poly in matlab representation. INPUT: matrix = matrix of polynomials OUTPUT: det = polynomial that is determinant of matrix","title":"Basic Information"},{"location":"function-guide/utilities/det_poly_m/#dependencies","text":"submatrix_poly wait","title":"Dependencies"},{"location":"function-guide/utilities/dijkstra_m/","text":"dijkstra.m \u00b6 Basic Information \u00b6 SYNTAX: [path, totalCost] = dijkstra(n, CostMatrix, s, d) PURPOSE: Find the least cost path between two nodes in a network. INPUT: n = the number of nodes in the network CostMatrix = matrix whose (i,j)th entry defines the cost of moving from node i to node j or conversely. Use Inf if impossible. s = source node index d = destination node index OUTPUT: path = the list of nodes in the path from source to destination totalCost = the total cost of the path RESTRICTIONS: Node numbers must be consecutive, starting at 1. Dependencies \u00b6","title":"dijkstra.m"},{"location":"function-guide/utilities/dijkstra_m/#dijkstram","text":"","title":"dijkstra.m"},{"location":"function-guide/utilities/dijkstra_m/#basic-information","text":"SYNTAX: [path, totalCost] = dijkstra(n, CostMatrix, s, d) PURPOSE: Find the least cost path between two nodes in a network. INPUT: n = the number of nodes in the network CostMatrix = matrix whose (i,j)th entry defines the cost of moving from node i to node j or conversely. Use Inf if impossible. s = source node index d = destination node index OUTPUT: path = the list of nodes in the path from source to destination totalCost = the total cost of the path RESTRICTIONS: Node numbers must be consecutive, starting at 1.","title":"Basic Information"},{"location":"function-guide/utilities/dijkstra_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/find_conflicts_m/","text":"find_conflicts.m \u00b6 Basic Information \u00b6 SYNTAX: find_conflicts PURPOSE: Find potential conflicts between variable names in your environment and function names in your search path. INPUT: none OUTPUT: printed warnings of potential conflicts RESTRICTIONS: METHOD: Entire environment is saved at beginning of execution and restore when complete; this may take some time if large workspace is used. Dependencies \u00b6","title":"find_conflicts.m"},{"location":"function-guide/utilities/find_conflicts_m/#find_conflictsm","text":"","title":"find_conflicts.m"},{"location":"function-guide/utilities/find_conflicts_m/#basic-information","text":"SYNTAX: find_conflicts PURPOSE: Find potential conflicts between variable names in your environment and function names in your search path. INPUT: none OUTPUT: printed warnings of potential conflicts RESTRICTIONS: METHOD: Entire environment is saved at beginning of execution and restore when complete; this may take some time if large workspace is used.","title":"Basic Information"},{"location":"function-guide/utilities/find_conflicts_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/fix_undscr_m/","text":"fix_undscr.m \u00b6 Basic Information \u00b6 PURPOSE: put \\ infront of any _ so it plots correctly when using TEX SYNTAX: [string_ot]= fix_undscr(string_in); INPUT: string_in= string containing _ which are converted to \\_ OUTPUT: string_ot= string containing \\_ which prints ok in TEX Note: Now works on string arrays Dependencies \u00b6","title":"fix_undscr.m"},{"location":"function-guide/utilities/fix_undscr_m/#fix_undscrm","text":"","title":"fix_undscr.m"},{"location":"function-guide/utilities/fix_undscr_m/#basic-information","text":"PURPOSE: put \\ infront of any _ so it plots correctly when using TEX SYNTAX: [string_ot]= fix_undscr(string_in); INPUT: string_in= string containing _ which are converted to \\_ OUTPUT: string_ot= string containing \\_ which prints ok in TEX Note: Now works on string arrays","title":"Basic Information"},{"location":"function-guide/utilities/fix_undscr_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/gfile_shot_time_m/","text":"gfile_shot_time.m \u00b6 Basic Information \u00b6 SYNTAX: [shot, time] = gfile_shot_time(filename,typeflag) PURPOSE: Return shot and time values from gfile or afile name. INPUT: filename = name of gfile or afile typeflag = 0 to return as integer values (time in ms), 1 to return as string values (default) OUTPUT: shot = shot number stripped from file name time = time (in ms) stripped from file name Dependencies \u00b6","title":"gfile_shot_time.m"},{"location":"function-guide/utilities/gfile_shot_time_m/#gfile_shot_timem","text":"","title":"gfile_shot_time.m"},{"location":"function-guide/utilities/gfile_shot_time_m/#basic-information","text":"SYNTAX: [shot, time] = gfile_shot_time(filename,typeflag) PURPOSE: Return shot and time values from gfile or afile name. INPUT: filename = name of gfile or afile typeflag = 0 to return as integer values (time in ms), 1 to return as string values (default) OUTPUT: shot = shot number stripped from file name time = time (in ms) stripped from file name","title":"Basic Information"},{"location":"function-guide/utilities/gfile_shot_time_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/hdcopy_m/","text":"hdcopy.m \u00b6 Basic Information \u00b6 SYNTAX: hdcopy(figures,keep_ps,device) PURPOSE: Create hardcopy plots of figures on screen. (See hdcopysys.m for hardcopies of SIMULINK block diagrams.) INPUT: figures = list of figure numbers (optional: if omitted, current figure is plotted) keep_ps = set to 1 to retain postscript file (hdcopytemp.ps) in local directory, if a string, then plots are stored in file with that name, else deleted (optional, default=0) device = string defining print device (optional, default='hplj21') - note that device can be 'eps' or 'epsc', but set keep_ps=1 to keep it. - Set device=0 to prevent printing (e.g. when keep_ps=1). OUTPUT: hardcopy plots to printer hdcopytemp.ps = local postscript file (if keep_ps=1) (or hdcopytemp.eps if device='eps' or 'epsc') METHOD: Creates postscript file using matlab print command, then sends to printer using !lp. Dependencies \u00b6","title":"hdcopy.m"},{"location":"function-guide/utilities/hdcopy_m/#hdcopym","text":"","title":"hdcopy.m"},{"location":"function-guide/utilities/hdcopy_m/#basic-information","text":"SYNTAX: hdcopy(figures,keep_ps,device) PURPOSE: Create hardcopy plots of figures on screen. (See hdcopysys.m for hardcopies of SIMULINK block diagrams.) INPUT: figures = list of figure numbers (optional: if omitted, current figure is plotted) keep_ps = set to 1 to retain postscript file (hdcopytemp.ps) in local directory, if a string, then plots are stored in file with that name, else deleted (optional, default=0) device = string defining print device (optional, default='hplj21') - note that device can be 'eps' or 'epsc', but set keep_ps=1 to keep it. - Set device=0 to prevent printing (e.g. when keep_ps=1). OUTPUT: hardcopy plots to printer hdcopytemp.ps = local postscript file (if keep_ps=1) (or hdcopytemp.eps if device='eps' or 'epsc') METHOD: Creates postscript file using matlab print command, then sends to printer using !lp.","title":"Basic Information"},{"location":"function-guide/utilities/hdcopy_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/hdcopysys_m/","text":"hdcopysys.m \u00b6 Basic Information \u00b6 SYNTAX: hdcopysys(system,keep_ps,device) PURPOSE: Create hardcopy plots of system block diagram. (See hdcopy.m for ordinary figures.) INPUT: system = text string specifying system name keep_ps = set to 1 to retain postscript file in local directory, else deleted (optional, default=0) device = string defining print device (optional, default='hplj21') - Set = 0 to prevent printing (e.g. when keep_ps=1). - Device can be 'eps', in which case keep_ps must=1 to save the eps file. OUTPUT: hardcopy plot to printer hdcopytemp.ps = local postscript file (if keep_ps=1) RESTRICTIONS: The system to be printed must be opened by SIMULINK within your MATLAB session in order for this function to work. METHOD: Creates postscript file using matlab print command, then sends to printer using !lp. Modify printer device for your local printer. Dependencies \u00b6","title":"hdcopysys.m"},{"location":"function-guide/utilities/hdcopysys_m/#hdcopysysm","text":"","title":"hdcopysys.m"},{"location":"function-guide/utilities/hdcopysys_m/#basic-information","text":"SYNTAX: hdcopysys(system,keep_ps,device) PURPOSE: Create hardcopy plots of system block diagram. (See hdcopy.m for ordinary figures.) INPUT: system = text string specifying system name keep_ps = set to 1 to retain postscript file in local directory, else deleted (optional, default=0) device = string defining print device (optional, default='hplj21') - Set = 0 to prevent printing (e.g. when keep_ps=1). - Device can be 'eps', in which case keep_ps must=1 to save the eps file. OUTPUT: hardcopy plot to printer hdcopytemp.ps = local postscript file (if keep_ps=1) RESTRICTIONS: The system to be printed must be opened by SIMULINK within your MATLAB session in order for this function to work. METHOD: Creates postscript file using matlab print command, then sends to printer using !lp. Modify printer device for your local printer.","title":"Basic Information"},{"location":"function-guide/utilities/hdcopysys_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/in_script_m/","text":"in_script.m \u00b6 Basic Information \u00b6 SYNTAX: in_script PURPOSE: reads variable identified by string vnam into function from calling area or from base area, in this order INPUT: vnam= name of variable to bring in from calling or base area ex: vnam='vac_objects'; vnam='time'; vnam= 'ip'; ... OUTPUT: variable identified by string vnam is set in routine from calling or base area dumm= 1 if variable set, 0 if variable not found and not set EXAMPLE USE in Function to allow call of function as script if nargin <= 0 vnam= 'rbs'; in_script; if ~dumm return; end vnam= 'minimize_i'; in_script end NOTE: This script when used inside a function allows the function to act like a script for input. If variable doesnt exist it does not set RESTRICTIONS: vnam must be a character variable Caution: overwrites variable identified in vnam in routine and variable dumm see also ot_script Dependencies \u00b6","title":"in_script.m"},{"location":"function-guide/utilities/in_script_m/#in_scriptm","text":"","title":"in_script.m"},{"location":"function-guide/utilities/in_script_m/#basic-information","text":"SYNTAX: in_script PURPOSE: reads variable identified by string vnam into function from calling area or from base area, in this order INPUT: vnam= name of variable to bring in from calling or base area ex: vnam='vac_objects'; vnam='time'; vnam= 'ip'; ... OUTPUT: variable identified by string vnam is set in routine from calling or base area dumm= 1 if variable set, 0 if variable not found and not set EXAMPLE USE in Function to allow call of function as script if nargin <= 0 vnam= 'rbs'; in_script; if ~dumm return; end vnam= 'minimize_i'; in_script end NOTE: This script when used inside a function allows the function to act like a script for input. If variable doesnt exist it does not set RESTRICTIONS: vnam must be a character variable Caution: overwrites variable identified in vnam in routine and variable dumm see also ot_script","title":"Basic Information"},{"location":"function-guide/utilities/in_script_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/ineqconstr_lsqs_m/","text":"ineqconstr_lsqs.m \u00b6 Basic Information \u00b6 SYNTAX: x = ineqconstr_lsqs(A,b,B,d) PURPOSE: Inequality constrained least squares solution. Solves min || Ax - b || subject to ||Bx - d|| <= a. **************NOT WORKING YET************** INPUT: A = mxn matrix in LHS of Ax=b least squares problem b = mx1 vector in RHS of Ax=b least squares problem B = pxn matrix in constraint equation Bx=d d = px1 vector (all elts >=0) in constraint equation Bx=d OUTPUT: x = solution vector for constrained least squares problem RESTRICTIONS: A and B must be full rank. Dependencies \u00b6","title":"ineqconstr_lsqs.m"},{"location":"function-guide/utilities/ineqconstr_lsqs_m/#ineqconstr_lsqsm","text":"","title":"ineqconstr_lsqs.m"},{"location":"function-guide/utilities/ineqconstr_lsqs_m/#basic-information","text":"SYNTAX: x = ineqconstr_lsqs(A,b,B,d) PURPOSE: Inequality constrained least squares solution. Solves min || Ax - b || subject to ||Bx - d|| <= a. **************NOT WORKING YET************** INPUT: A = mxn matrix in LHS of Ax=b least squares problem b = mx1 vector in RHS of Ax=b least squares problem B = pxn matrix in constraint equation Bx=d d = px1 vector (all elts >=0) in constraint equation Bx=d OUTPUT: x = solution vector for constrained least squares problem RESTRICTIONS: A and B must be full rank.","title":"Basic Information"},{"location":"function-guide/utilities/ineqconstr_lsqs_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/insert_string_m/","text":"insert_string.m \u00b6 Basic Information \u00b6 SYNTAX: strout = insert_string(str2insert,string,indices) PURPOSE: Insert a specified substring within a given string at one or more locations. INPUT: str2insert = string to insert string = string to insert it into indices = indices in string at which to insert (length>=1) (inserts BEFORE the character located at each index) OUTPUT: strout = string resulting from the insertions RESTRICTIONS: Dependencies \u00b6","title":"insert_string.m"},{"location":"function-guide/utilities/insert_string_m/#insert_stringm","text":"","title":"insert_string.m"},{"location":"function-guide/utilities/insert_string_m/#basic-information","text":"SYNTAX: strout = insert_string(str2insert,string,indices) PURPOSE: Insert a specified substring within a given string at one or more locations. INPUT: str2insert = string to insert string = string to insert it into indices = indices in string at which to insert (length>=1) (inserts BEFORE the character located at each index) OUTPUT: strout = string resulting from the insertions RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/utilities/insert_string_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/intersect_bdry_m/","text":"intersect_bdry.m \u00b6 Basic Information \u00b6 SYNTAX: [xi,yi,found] = intersect_bdry(x,y,xstart,ystart,xend,yend,bounded) PURPOSE: Given a set of connected line segments (such as a closed boundary) and the end points of an independent line segment, find the intersection of the independent segment and the boundary. The first intersection found will be returned so for reliability the segment should intersect the boundary in at most one place. INPUT: x,y = (x,y) of boundary (vectors) xstart,ystart = (x,y) of start of independent segment xend,yend = (x,y) of end of independent segment bounded = set to 1 to require the intersection to be between endpoints. set to 0 to allow intersection anywhere along the infinite lines defined by extending the independent line segment and a segment in the boundary. (In this case, the intersection will be found for the first segment in the bdry which is not parallel to the independent segment. OUTPUT: xi,yi = (x,y) coordinate of intersection found = 0, if no intersection found. = index of second point on intersecting bdry segment, otherwise. Dependencies \u00b6","title":"intersect_bdry.m"},{"location":"function-guide/utilities/intersect_bdry_m/#intersect_bdrym","text":"","title":"intersect_bdry.m"},{"location":"function-guide/utilities/intersect_bdry_m/#basic-information","text":"SYNTAX: [xi,yi,found] = intersect_bdry(x,y,xstart,ystart,xend,yend,bounded) PURPOSE: Given a set of connected line segments (such as a closed boundary) and the end points of an independent line segment, find the intersection of the independent segment and the boundary. The first intersection found will be returned so for reliability the segment should intersect the boundary in at most one place. INPUT: x,y = (x,y) of boundary (vectors) xstart,ystart = (x,y) of start of independent segment xend,yend = (x,y) of end of independent segment bounded = set to 1 to require the intersection to be between endpoints. set to 0 to allow intersection anywhere along the infinite lines defined by extending the independent line segment and a segment in the boundary. (In this case, the intersection will be found for the first segment in the bdry which is not parallel to the independent segment. OUTPUT: xi,yi = (x,y) coordinate of intersection found = 0, if no intersection found. = index of second point on intersecting bdry segment, otherwise.","title":"Basic Information"},{"location":"function-guide/utilities/intersect_bdry_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/intvec2str_m/","text":"intvec2str.m \u00b6 Basic Information \u00b6 SYNTAX: string = intvec2str(intvec) PURPOSE: Convert vector of integers to string. Puts commas between entries. INPUT: intvec = vector of integers OUTPUT: string = vector converted into string WRITTEN BY: Mike Walker ON ??/94 Dependencies \u00b6","title":"intvec2str.m"},{"location":"function-guide/utilities/intvec2str_m/#intvec2strm","text":"","title":"intvec2str.m"},{"location":"function-guide/utilities/intvec2str_m/#basic-information","text":"SYNTAX: string = intvec2str(intvec) PURPOSE: Convert vector of integers to string. Puts commas between entries. INPUT: intvec = vector of integers OUTPUT: string = vector converted into string WRITTEN BY: Mike Walker ON ??/94","title":"Basic Information"},{"location":"function-guide/utilities/intvec2str_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/is_inuse_m/","text":"is_inuse.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: Determine if a name is already in use as a function name INPUT: name = string defining name to be tested OUTPUT: inuse = returns: 1 if already in use as a function 0 if not in use Dependencies \u00b6","title":"is_inuse.m"},{"location":"function-guide/utilities/is_inuse_m/#is_inusem","text":"","title":"is_inuse.m"},{"location":"function-guide/utilities/is_inuse_m/#basic-information","text":"SYNTAX: PURPOSE: Determine if a name is already in use as a function name INPUT: name = string defining name to be tested OUTPUT: inuse = returns: 1 if already in use as a function 0 if not in use","title":"Basic Information"},{"location":"function-guide/utilities/is_inuse_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/isblank_m/","text":"isblank.m \u00b6 Basic Information \u00b6 SYNTAX: result = isblank(string) PURPOSE: Determine if input string (strings) is (are) blank. INPUT: string = string or string array OUTPUT: result = boolean (0 or 1), 1 if string is blank, else 0 Dependencies \u00b6","title":"isblank.m"},{"location":"function-guide/utilities/isblank_m/#isblankm","text":"","title":"isblank.m"},{"location":"function-guide/utilities/isblank_m/#basic-information","text":"SYNTAX: result = isblank(string) PURPOSE: Determine if input string (strings) is (are) blank. INPUT: string = string or string array OUTPUT: result = boolean (0 or 1), 1 if string is blank, else 0","title":"Basic Information"},{"location":"function-guide/utilities/isblank_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/keep_v5_m/","text":"keep_v5.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: INPUT: keepstr = string containing names of variables to keep OUTPUT: RESTRICTIONS: Dependencies \u00b6","title":"keep_v5.m"},{"location":"function-guide/utilities/keep_v5_m/#keep_v5m","text":"","title":"keep_v5.m"},{"location":"function-guide/utilities/keep_v5_m/#basic-information","text":"SYNTAX: PURPOSE: INPUT: keepstr = string containing names of variables to keep OUTPUT: RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/utilities/keep_v5_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/make_HP_m/","text":"make_HP.m \u00b6 Basic Information \u00b6 SYNTAX: make_HP PURPOSE: Customizes the specified template makefile. Customized makefile can be used to build an executable from the generated model code. Used only by SIMULINK realtime code generation. Modified from make_rtw.m provided with Matlab. INPUT: varargin OUTPUT: RESTRICTIONS: METHOD: MAKE_RTW first invokes the Target Language Compiler to generate the code and then invokes the language specific make procedure. WRITTEN BY: Mike Walker ON 11/14/97 ------------------------------------ Get model name and build arguments ------------------------------------","title":"make_HP.m"},{"location":"function-guide/utilities/make_HP_m/#make_hpm","text":"","title":"make_HP.m"},{"location":"function-guide/utilities/make_HP_m/#basic-information","text":"SYNTAX: make_HP PURPOSE: Customizes the specified template makefile. Customized makefile can be used to build an executable from the generated model code. Used only by SIMULINK realtime code generation. Modified from make_rtw.m provided with Matlab. INPUT: varargin OUTPUT: RESTRICTIONS: METHOD: MAKE_RTW first invokes the Target Language Compiler to generate the code and then invokes the language specific make procedure. WRITTEN BY: Mike Walker ON 11/14/97 ------------------------------------ Get model name and build arguments ------------------------------------","title":"Basic Information"},{"location":"function-guide/utilities/make_function_m/","text":"make_function.m \u00b6 Basic Information \u00b6 USAGE: make_function(infile,outfile) PURPOSE: make a matlab script a function that returns a structure INPUTS: The script is read from infile. OUTPUTS: The function is written into outfile. Dependencies \u00b6","title":"make_function.m"},{"location":"function-guide/utilities/make_function_m/#make_functionm","text":"","title":"make_function.m"},{"location":"function-guide/utilities/make_function_m/#basic-information","text":"USAGE: make_function(infile,outfile) PURPOSE: make a matlab script a function that returns a structure INPUTS: The script is read from infile. OUTPUTS: The function is written into outfile.","title":"Basic Information"},{"location":"function-guide/utilities/make_function_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/make_psc_file_m/","text":"make_psc_file.m \u00b6 Basic Information \u00b6 SYNTAX: make_psc_file(figures,filename) PURPOSE: Make a color postscript file for printing or viewing with \"gs\". INPUT: figures = list (vector) of figure numbers filename = name of postscript file to create OUTPUT: postscript file Dependencies \u00b6","title":"make_psc_file.m"},{"location":"function-guide/utilities/make_psc_file_m/#make_psc_filem","text":"","title":"make_psc_file.m"},{"location":"function-guide/utilities/make_psc_file_m/#basic-information","text":"SYNTAX: make_psc_file(figures,filename) PURPOSE: Make a color postscript file for printing or viewing with \"gs\". INPUT: figures = list (vector) of figure numbers filename = name of postscript file to create OUTPUT: postscript file","title":"Basic Information"},{"location":"function-guide/utilities/make_psc_file_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/modulo_m/","text":"modulo.m \u00b6 Basic Information \u00b6 SYNTAX: modvalue = modulo(number,base) PURPOSE: Calculates remainder when number is divided by base value. INPUT: number = number to reduce modulo base base = base of modular arithmetic OUTPUT: modvalue = number reduced modulo base RESTRICTIONS: This works for \"all\" floating point numbers and for every pair of integers I've tried, but since matlab does only floating point arithmetic I expect that some combination of integers will give the wrong answer. Some additional logic needs to be added sometime to address this. Dependencies \u00b6","title":"modulo.m"},{"location":"function-guide/utilities/modulo_m/#modulom","text":"","title":"modulo.m"},{"location":"function-guide/utilities/modulo_m/#basic-information","text":"SYNTAX: modvalue = modulo(number,base) PURPOSE: Calculates remainder when number is divided by base value. INPUT: number = number to reduce modulo base base = base of modular arithmetic OUTPUT: modvalue = number reduced modulo base RESTRICTIONS: This works for \"all\" floating point numbers and for every pair of integers I've tried, but since matlab does only floating point arithmetic I expect that some combination of integers will give the wrong answer. Some additional logic needs to be added sometime to address this.","title":"Basic Information"},{"location":"function-guide/utilities/modulo_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/ot_script_m/","text":"ot_script.m \u00b6 Basic Information \u00b6 SYNTAX: ot_script PURPOSE: writes variable identified by string vnam into base area INPUT: vnam= name of variable to write to the base area ex: vnam='vac_objects'; vnam='time'; vnam= 'ip'; ... OUTPUT: variable identified by string vnam is set in base area EXAMPLE USE in Function to allow call of function as script if nargout<=0 vnam= 'rbs'; ot_script; vnam= 'minimize_i'; ot_script end NOTE: This script when used inside a function allows the function to act like a script for output to base. If variable doesnt exist it isnt set RESTRICTIONS: vnam must be a character variable presently only puts output variables in base (not calling routine) Caution: overwrites variable identified in vnam in base See also in_script Dependencies \u00b6","title":"ot_script.m"},{"location":"function-guide/utilities/ot_script_m/#ot_scriptm","text":"","title":"ot_script.m"},{"location":"function-guide/utilities/ot_script_m/#basic-information","text":"SYNTAX: ot_script PURPOSE: writes variable identified by string vnam into base area INPUT: vnam= name of variable to write to the base area ex: vnam='vac_objects'; vnam='time'; vnam= 'ip'; ... OUTPUT: variable identified by string vnam is set in base area EXAMPLE USE in Function to allow call of function as script if nargout<=0 vnam= 'rbs'; ot_script; vnam= 'minimize_i'; ot_script end NOTE: This script when used inside a function allows the function to act like a script for output to base. If variable doesnt exist it isnt set RESTRICTIONS: vnam must be a character variable presently only puts output variables in base (not calling routine) Caution: overwrites variable identified in vnam in base See also in_script","title":"Basic Information"},{"location":"function-guide/utilities/ot_script_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/packnlstr_m/","text":"packnlstr.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: Pack namelist string (remove all the extraneous separators). INPUT: str_in = string to pack OUTPUT: str_out = string after packing","title":"packnlstr.m"},{"location":"function-guide/utilities/packnlstr_m/#packnlstrm","text":"","title":"packnlstr.m"},{"location":"function-guide/utilities/packnlstr_m/#basic-information","text":"SYNTAX: PURPOSE: Pack namelist string (remove all the extraneous separators). INPUT: str_in = string to pack OUTPUT: str_out = string after packing","title":"Basic Information"},{"location":"function-guide/utilities/parseXML_m/","text":"parseXML.m \u00b6 Basic Information \u00b6 SYNTAX: theStruct = parseXML(filename) PURPOSE: Convert XML file to a MATLAB structure. INPUT: input_file = xml file to parse OUTPUT: theStruct = matlab structure (DOM format) parsed from xml file RESTRICTIONS: METHOD: For a description of a Document Object Model (DOM), see Mathworks online help at: https://www.mathworks.com/help/releases/R2017a/matlab/import_export/importing-xml-documents.html#bsmj8la","title":"parseXML.m"},{"location":"function-guide/utilities/parseXML_m/#parsexmlm","text":"","title":"parseXML.m"},{"location":"function-guide/utilities/parseXML_m/#basic-information","text":"SYNTAX: theStruct = parseXML(filename) PURPOSE: Convert XML file to a MATLAB structure. INPUT: input_file = xml file to parse OUTPUT: theStruct = matlab structure (DOM format) parsed from xml file RESTRICTIONS: METHOD: For a description of a Document Object Model (DOM), see Mathworks online help at: https://www.mathworks.com/help/releases/R2017a/matlab/import_export/importing-xml-documents.html#bsmj8la","title":"Basic Information"},{"location":"function-guide/utilities/parse_filename_m/","text":"parse_filename.m \u00b6 Basic Information \u00b6 PURPOSE: determine the directory, name and extention of a file SYNTAX: [dir,nam,ext]= parse_filename(string_in) INPUT: string_in= string containing full file name (ex: /dir/subdir/name.ext) OUTPUT: (example: /dir/subdir/name.ext) dir= directory name of file with last / (ex: /dir/subdir/) nam= name of file without extention (ex: name) ext= extention name with pre . (ex: .ext) CAUTION: Only works for single row vector of ASCII characterics Dependencies \u00b6","title":"parse_filename.m"},{"location":"function-guide/utilities/parse_filename_m/#parse_filenamem","text":"","title":"parse_filename.m"},{"location":"function-guide/utilities/parse_filename_m/#basic-information","text":"PURPOSE: determine the directory, name and extention of a file SYNTAX: [dir,nam,ext]= parse_filename(string_in) INPUT: string_in= string containing full file name (ex: /dir/subdir/name.ext) OUTPUT: (example: /dir/subdir/name.ext) dir= directory name of file with last / (ex: /dir/subdir/) nam= name of file without extention (ex: name) ext= extention name with pre . (ex: .ext) CAUTION: Only works for single row vector of ASCII characterics","title":"Basic Information"},{"location":"function-guide/utilities/parse_filename_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/read_namelist_m/","text":"read_namelist.m \u00b6 Basic Information \u00b6 SYNTAX: FUNCTION CALL: [nlnames,nlstr,nlall]= read_namelist(filename,to_upper); SCRIPT CALL (compatable with old script) read_namelist; SCRIPT FORM reads & writes to caller area PURPOSE: Read a FORTRAN namelist file and create variables in the matlab workspace defined by variables in the namelist. INPUT: [default] filename = name of namelist file to read to_upper = 1; makes variables UPPER case; -1= LOWER case;s [0] NOTE: if any input variable missing it looks 1st in \"caller\" then in \"base\" OUTPUT: nlnames= Name of all namelists found in file nlstr= Structure of namelist and variables nlall= total list of all namelists and variable (for write_namelist) NOTE: if output variable \"nlstr\" is not present, routine puts all namelist variables in \"caller\" routine. Same for \"nlall\" (duplicate variable names in \"caller\" routine are overwritten) NOTE: To get all structure namelist variables into environment: [names, isstruc]= struct_to_ws(nlstr); Do 1st level if any(isstruc) Loop to do 2nd level id= find(isstruc); for ii= 1:length(id) str= ['[names1,isstruc1]= struct_to_ws(' char(names(id(ii))) ');']; eval(str) end for end if any clear nlstr RESTRICTIONS: won't work if '=' signs in quotes in any of string data won't work for multiple (*) string variables Dependencies \u00b6 remove_space modulo packnlstr","title":"read_namelist.m"},{"location":"function-guide/utilities/read_namelist_m/#read_namelistm","text":"","title":"read_namelist.m"},{"location":"function-guide/utilities/read_namelist_m/#basic-information","text":"SYNTAX: FUNCTION CALL: [nlnames,nlstr,nlall]= read_namelist(filename,to_upper); SCRIPT CALL (compatable with old script) read_namelist; SCRIPT FORM reads & writes to caller area PURPOSE: Read a FORTRAN namelist file and create variables in the matlab workspace defined by variables in the namelist. INPUT: [default] filename = name of namelist file to read to_upper = 1; makes variables UPPER case; -1= LOWER case;s [0] NOTE: if any input variable missing it looks 1st in \"caller\" then in \"base\" OUTPUT: nlnames= Name of all namelists found in file nlstr= Structure of namelist and variables nlall= total list of all namelists and variable (for write_namelist) NOTE: if output variable \"nlstr\" is not present, routine puts all namelist variables in \"caller\" routine. Same for \"nlall\" (duplicate variable names in \"caller\" routine are overwritten) NOTE: To get all structure namelist variables into environment: [names, isstruc]= struct_to_ws(nlstr); Do 1st level if any(isstruc) Loop to do 2nd level id= find(isstruc); for ii= 1:length(id) str= ['[names1,isstruc1]= struct_to_ws(' char(names(id(ii))) ');']; eval(str) end for end if any clear nlstr RESTRICTIONS: won't work if '=' signs in quotes in any of string data won't work for multiple (*) string variables","title":"Basic Information"},{"location":"function-guide/utilities/read_namelist_m/#dependencies","text":"remove_space modulo packnlstr","title":"Dependencies"},{"location":"function-guide/utilities/read_namelist_new_m/","text":"read_namelist_new.m \u00b6 Basic Information \u00b6 SYNTAX: read_namelist PURPOSE: Read a FORTRAN namelist file and create variables in the matlab workspace defined by variables in the namelist. INPUT: [default] filename = name of namelist file to read to_upper = 1; makes all variables UPPER case [0] to_upper =-1; makes all variables lower case [0] OUTPUT: varlist = list of variables read from namelist file All variables found in namelist(s) within the file are made into matlab variables. Duplicate names are overwritten with subsequent data. RESTRICTIONS: (1) won't work if '=' signs in quotes in any of data (2) won't work for multiple (*) string variables Dependencies \u00b6 modulo wait packnlstr","title":"read_namelist_new.m"},{"location":"function-guide/utilities/read_namelist_new_m/#read_namelist_newm","text":"","title":"read_namelist_new.m"},{"location":"function-guide/utilities/read_namelist_new_m/#basic-information","text":"SYNTAX: read_namelist PURPOSE: Read a FORTRAN namelist file and create variables in the matlab workspace defined by variables in the namelist. INPUT: [default] filename = name of namelist file to read to_upper = 1; makes all variables UPPER case [0] to_upper =-1; makes all variables lower case [0] OUTPUT: varlist = list of variables read from namelist file All variables found in namelist(s) within the file are made into matlab variables. Duplicate names are overwritten with subsequent data. RESTRICTIONS: (1) won't work if '=' signs in quotes in any of data (2) won't work for multiple (*) string variables","title":"Basic Information"},{"location":"function-guide/utilities/read_namelist_new_m/#dependencies","text":"modulo wait packnlstr","title":"Dependencies"},{"location":"function-guide/utilities/regstrmatch_m/","text":"regstrmatch.m \u00b6 Basic Information \u00b6 SYNTAX: PURPOSE: Regular string match a'la UNIX string matching. INPUT: OUTPUT: RESTRICTIONS: Only one of * or is permitted in string_pattern. Dependencies \u00b6 strwcmp strlen","title":"regstrmatch.m"},{"location":"function-guide/utilities/regstrmatch_m/#regstrmatchm","text":"","title":"regstrmatch.m"},{"location":"function-guide/utilities/regstrmatch_m/#basic-information","text":"SYNTAX: PURPOSE: Regular string match a'la UNIX string matching. INPUT: OUTPUT: RESTRICTIONS: Only one of * or is permitted in string_pattern.","title":"Basic Information"},{"location":"function-guide/utilities/regstrmatch_m/#dependencies","text":"strwcmp strlen","title":"Dependencies"},{"location":"function-guide/utilities/remove_space_m/","text":"remove_space.m \u00b6 Basic Information \u00b6 SYNTAX: string_ot= remove_space(string_in, position); PURPOSE: Removes spaces in string (like deblank but allows different location removal) INPUT: [default] string_in= input string (single row string NOT string array) position= 0 all spaces, 1=front, [2=END], 3=front&end {OPTIONAL) OUTPUT: string_ot= output string with spaces removed RESTRICTIONS: Only tested on 2-d arrays (not on vectors or scalars) Dependencies \u00b6 wait","title":"remove_space.m"},{"location":"function-guide/utilities/remove_space_m/#remove_spacem","text":"","title":"remove_space.m"},{"location":"function-guide/utilities/remove_space_m/#basic-information","text":"SYNTAX: string_ot= remove_space(string_in, position); PURPOSE: Removes spaces in string (like deblank but allows different location removal) INPUT: [default] string_in= input string (single row string NOT string array) position= 0 all spaces, 1=front, [2=END], 3=front&end {OPTIONAL) OUTPUT: string_ot= output string with spaces removed RESTRICTIONS: Only tested on 2-d arrays (not on vectors or scalars)","title":"Basic Information"},{"location":"function-guide/utilities/remove_space_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/utilities/rmchar_m/","text":"rmchar.m \u00b6 Basic Information \u00b6 SYNTAX: result = rmchar(string,char) PURPOSE: Remove all instances of a specified character from a string. INPUT: string = string to remove character from char = character to remove OUTPUT: result = string after removing char Dependencies \u00b6","title":"rmchar.m"},{"location":"function-guide/utilities/rmchar_m/#rmcharm","text":"","title":"rmchar.m"},{"location":"function-guide/utilities/rmchar_m/#basic-information","text":"SYNTAX: result = rmchar(string,char) PURPOSE: Remove all instances of a specified character from a string. INPUT: string = string to remove character from char = character to remove OUTPUT: result = string after removing char","title":"Basic Information"},{"location":"function-guide/utilities/rmchar_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/save_whos_data_m/","text":"save_whos_data.m \u00b6 Basic Information \u00b6 SYNTAX: save_whos_data(whos_data) PURPOSE: Save to file the information you get when typing \"whos\". INPUT: whos_data = data structure you get by typing >> whos_data = whos OUTPUT: Local file called \"whos_data.dat\". Dependencies \u00b6","title":"save_whos_data.m"},{"location":"function-guide/utilities/save_whos_data_m/#save_whos_datam","text":"","title":"save_whos_data.m"},{"location":"function-guide/utilities/save_whos_data_m/#basic-information","text":"SYNTAX: save_whos_data(whos_data) PURPOSE: Save to file the information you get when typing \"whos\". INPUT: whos_data = data structure you get by typing >> whos_data = whos OUTPUT: Local file called \"whos_data.dat\".","title":"Basic Information"},{"location":"function-guide/utilities/save_whos_data_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/search_path_m/","text":"search_path.m \u00b6 Basic Information \u00b6 SYNTAX: results = search_path(string,path_depth,search_depth) PURPOSE: String search of the matlabpath for documentation about a function, or model, or whatever, whose documentation contains the search string. (See also lookfor, whatfunction) INPUT: string = string to search for path_depth = one of the following (optional argument): - integer specifying how many directories in path to search - string specifying last directory to search (e.g. 'GAcontrol') - 'all', i.e. search all directories (default) search_depth = 'shallow' or 'deep' (optional, default='shallow') 'shallow' = look at Contents.m files only 'deep' = search both Contents.m files and all m-files (deep search takes awhile) OUTPUT: results = string containing documentation lines where strings matched and files where found RESTRICTIONS: Bug in MATLAB restricts when the 'deep' option will work. Uses the \"unix\" command to find m-files in a directory and sometimes this command doesn't work. Dependencies \u00b6","title":"search_path.m"},{"location":"function-guide/utilities/search_path_m/#search_pathm","text":"","title":"search_path.m"},{"location":"function-guide/utilities/search_path_m/#basic-information","text":"SYNTAX: results = search_path(string,path_depth,search_depth) PURPOSE: String search of the matlabpath for documentation about a function, or model, or whatever, whose documentation contains the search string. (See also lookfor, whatfunction) INPUT: string = string to search for path_depth = one of the following (optional argument): - integer specifying how many directories in path to search - string specifying last directory to search (e.g. 'GAcontrol') - 'all', i.e. search all directories (default) search_depth = 'shallow' or 'deep' (optional, default='shallow') 'shallow' = look at Contents.m files only 'deep' = search both Contents.m files and all m-files (deep search takes awhile) OUTPUT: results = string containing documentation lines where strings matched and files where found RESTRICTIONS: Bug in MATLAB restricts when the 'deep' option will work. Uses the \"unix\" command to find m-files in a directory and sometimes this command doesn't work.","title":"Basic Information"},{"location":"function-guide/utilities/search_path_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/slope_m/","text":"slope.m \u00b6 Basic Information \u00b6 SYNTAX: m = slope(x,y) PURPOSE: Calculate slope of line specified by two points. INPUT: x = length 2 vector giving x values y = length 2 vector giving y values OUTPUT: m = slope of line","title":"slope.m"},{"location":"function-guide/utilities/slope_m/#slopem","text":"","title":"slope.m"},{"location":"function-guide/utilities/slope_m/#basic-information","text":"SYNTAX: m = slope(x,y) PURPOSE: Calculate slope of line specified by two points. INPUT: x = length 2 vector giving x values y = length 2 vector giving y values OUTPUT: m = slope of line","title":"Basic Information"},{"location":"function-guide/utilities/splitstring_m/","text":"splitstring.m \u00b6 Basic Information \u00b6 SYNTAX: len =splitstring( str, varargin ) PURPOSE: ARRAY = SPLITSTRING( STR, DELIM, ALLOWEMPTYENTRIES ) splits the character string STR, using the delimiter DELIM (which must be a character array). ARRAY is a cell array containing the resulting strings. If DELIM is not specified, space delimiter is assumed (see ISSPACE documentation). ALLOWEMPTYENTRIES should be a logical single element, specifying weather empty elements should be included in the results. If not specified, the value of ALLOWEMPTYENTRIES is false. INPUT: string = text string to find length of varargin is either DELIM or ALLOWEMPTYENTRIES OUTPUT: len = length of character string Dependencies \u00b6","title":"splitstring.m"},{"location":"function-guide/utilities/splitstring_m/#splitstringm","text":"","title":"splitstring.m"},{"location":"function-guide/utilities/splitstring_m/#basic-information","text":"SYNTAX: len =splitstring( str, varargin ) PURPOSE: ARRAY = SPLITSTRING( STR, DELIM, ALLOWEMPTYENTRIES ) splits the character string STR, using the delimiter DELIM (which must be a character array). ARRAY is a cell array containing the resulting strings. If DELIM is not specified, space delimiter is assumed (see ISSPACE documentation). ALLOWEMPTYENTRIES should be a logical single element, specifying weather empty elements should be included in the results. If not specified, the value of ALLOWEMPTYENTRIES is false. INPUT: string = text string to find length of varargin is either DELIM or ALLOWEMPTYENTRIES OUTPUT: len = length of character string","title":"Basic Information"},{"location":"function-guide/utilities/splitstring_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/strarr_to_cellarr_m/","text":"strarr_to_cellarr.m \u00b6 Basic Information \u00b6 SYNTAX: cellarr = strarr_to_cellarr(strarr) PURPOSE: Convert string array with multiple strings on each line, delimited by spaces or tabs, to cell array. INPUT: strarr = either a string array or (an integer) file id corresponding to a data file (open for reading) containing the string array. OUTPUT: cellarr = cell array containing strings defined by strarr Dependencies \u00b6 remove_space","title":"strarr_to_cellarr.m"},{"location":"function-guide/utilities/strarr_to_cellarr_m/#strarr_to_cellarrm","text":"","title":"strarr_to_cellarr.m"},{"location":"function-guide/utilities/strarr_to_cellarr_m/#basic-information","text":"SYNTAX: cellarr = strarr_to_cellarr(strarr) PURPOSE: Convert string array with multiple strings on each line, delimited by spaces or tabs, to cell array. INPUT: strarr = either a string array or (an integer) file id corresponding to a data file (open for reading) containing the string array. OUTPUT: cellarr = cell array containing strings defined by strarr","title":"Basic Information"},{"location":"function-guide/utilities/strarr_to_cellarr_m/#dependencies","text":"remove_space","title":"Dependencies"},{"location":"function-guide/utilities/stringlen_m/","text":"stringlen.m \u00b6 Basic Information \u00b6 SYNTAX: len = stringlen(string) PURPOSE: Find length of string as defined by locating last nonblank character INPUT: string = text string to find length of OUTPUT: len = length of character string Dependencies \u00b6","title":"stringlen.m"},{"location":"function-guide/utilities/stringlen_m/#stringlenm","text":"","title":"stringlen.m"},{"location":"function-guide/utilities/stringlen_m/#basic-information","text":"SYNTAX: len = stringlen(string) PURPOSE: Find length of string as defined by locating last nonblank character INPUT: string = text string to find length of OUTPUT: len = length of character string","title":"Basic Information"},{"location":"function-guide/utilities/stringlen_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/strlen_m/","text":"strlen.m \u00b6 Basic Information \u00b6 SYNTAX: len = strlen(string) PURPOSE: Find length of string as defined by locating last nonblank character INPUT: string = text string to find length of OUTPUT: len = length of character string Dependencies \u00b6","title":"strlen.m"},{"location":"function-guide/utilities/strlen_m/#strlenm","text":"","title":"strlen.m"},{"location":"function-guide/utilities/strlen_m/#basic-information","text":"SYNTAX: len = strlen(string) PURPOSE: Find length of string as defined by locating last nonblank character INPUT: string = text string to find length of OUTPUT: len = length of character string","title":"Basic Information"},{"location":"function-guide/utilities/strlen_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/strmatch_anywhr_m/","text":"strmatch_anywhr.m \u00b6 Basic Information \u00b6 SYNTAX: FUNCTION CALL: irow= strmatch_anywhr(str,strs); rows containing str [irow, jcol]= strmatch_anywhr(str,strs,'all'); return all matches PURPOSE: Returns rows of strs which have str anywhere in line INPUT: [default] str= single row of text (ex: 'F2a') strs= string array to look for str (ex: strvcat('PF1a','PF2a') flag= 'all'; returns all matches [remove duplicate row entrys] OUTPUT: irow= row index of strs which have str (ex: 2) jcol= colum index of 1st occurance of strs (ex: 2) RESTRICTIONS: str and strs must be type character; str is a single row Dependencies \u00b6","title":"strmatch_anywhr.m"},{"location":"function-guide/utilities/strmatch_anywhr_m/#strmatch_anywhrm","text":"","title":"strmatch_anywhr.m"},{"location":"function-guide/utilities/strmatch_anywhr_m/#basic-information","text":"SYNTAX: FUNCTION CALL: irow= strmatch_anywhr(str,strs); rows containing str [irow, jcol]= strmatch_anywhr(str,strs,'all'); return all matches PURPOSE: Returns rows of strs which have str anywhere in line INPUT: [default] str= single row of text (ex: 'F2a') strs= string array to look for str (ex: strvcat('PF1a','PF2a') flag= 'all'; returns all matches [remove duplicate row entrys] OUTPUT: irow= row index of strs which have str (ex: 2) jcol= colum index of 1st occurance of strs (ex: 2) RESTRICTIONS: str and strs must be type character; str is a single row","title":"Basic Information"},{"location":"function-guide/utilities/strmatch_anywhr_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/strmatch_cell_m/","text":"strmatch_cell.m \u00b6 Basic Information \u00b6 SYNTAX: idx = strmatch_cell(str,cellarray) PURPOSE: Replacement for matlab strmatch function, which doesn't work correctly for cell arrays. INPUT: str = string cellarray = cell array (n x 1) of strings OUTPUT: idx = indices of matching entries in cellarray Dependencies \u00b6 wait","title":"strmatch_cell.m"},{"location":"function-guide/utilities/strmatch_cell_m/#strmatch_cellm","text":"","title":"strmatch_cell.m"},{"location":"function-guide/utilities/strmatch_cell_m/#basic-information","text":"SYNTAX: idx = strmatch_cell(str,cellarray) PURPOSE: Replacement for matlab strmatch function, which doesn't work correctly for cell arrays. INPUT: str = string cellarray = cell array (n x 1) of strings OUTPUT: idx = indices of matching entries in cellarray","title":"Basic Information"},{"location":"function-guide/utilities/strmatch_cell_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/utilities/strsfind_m/","text":"strsfind.m \u00b6 Basic Information \u00b6 SYNTAX: [jtext,ipatt] = strsfind(text,patterns); PURPOSE: Multiple \"patterns\" version of \"strfind\" Finds patterns (1 or more rows) in single text (single row) NOTE: trailing blanks in patterns are removed INPUT: text= single row of text (ex: '/home/leuer/tokamaks/nstx/efit/') patterns= patterns to search \"text\" (ex: ['east'; 'nstx'; 'iter'...]) NOTE: trailing blanks in patterns(ii,:) are removed OUTPUT: jtext= index in text(j) of start of pattern ipatt= row of patterns assoicated with a each particular jtext id note: jtext and ipatt have same length RESTRICTIONS: text and patterns must be type character; text is a single row Dependencies \u00b6","title":"strsfind.m"},{"location":"function-guide/utilities/strsfind_m/#strsfindm","text":"","title":"strsfind.m"},{"location":"function-guide/utilities/strsfind_m/#basic-information","text":"SYNTAX: [jtext,ipatt] = strsfind(text,patterns); PURPOSE: Multiple \"patterns\" version of \"strfind\" Finds patterns (1 or more rows) in single text (single row) NOTE: trailing blanks in patterns are removed INPUT: text= single row of text (ex: '/home/leuer/tokamaks/nstx/efit/') patterns= patterns to search \"text\" (ex: ['east'; 'nstx'; 'iter'...]) NOTE: trailing blanks in patterns(ii,:) are removed OUTPUT: jtext= index in text(j) of start of pattern ipatt= row of patterns assoicated with a each particular jtext id note: jtext and ipatt have same length RESTRICTIONS: text and patterns must be type character; text is a single row","title":"Basic Information"},{"location":"function-guide/utilities/strsfind_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/struct_names_m/","text":"struct_names.m \u00b6 Basic Information \u00b6 PURPOSE: Returns names of all variables and substructures within structure SYNTAX: [var_names, str_names]= struct_names(struc); Normal Execution INPUT: <default> struc structure object to find internal variable and structure names OUTPUT: var_names full name of all variables in structure (ex. eq.GEQDSK.PSIRZ) str_names full name of all substructures (ex. eq.GEQDSK) NOTE: TO GET ALL VARIABLES IN STRUCTURE TO WORKSPACE see struct_to_ws_all NOTE: Uses Recursive execution of struct_names to get all variables and structures in recursive operation is includes additional inputs: [var_names, str_names]= struct_names(struc, var_names, str_names, pre_name); where: var_names input var_names to append output str_names input str_names to append output pre_name is name of previous structure to prepend on str_names Dependencies \u00b6","title":"struct_names.m"},{"location":"function-guide/utilities/struct_names_m/#struct_namesm","text":"","title":"struct_names.m"},{"location":"function-guide/utilities/struct_names_m/#basic-information","text":"PURPOSE: Returns names of all variables and substructures within structure SYNTAX: [var_names, str_names]= struct_names(struc); Normal Execution INPUT: <default> struc structure object to find internal variable and structure names OUTPUT: var_names full name of all variables in structure (ex. eq.GEQDSK.PSIRZ) str_names full name of all substructures (ex. eq.GEQDSK) NOTE: TO GET ALL VARIABLES IN STRUCTURE TO WORKSPACE see struct_to_ws_all NOTE: Uses Recursive execution of struct_names to get all variables and structures in recursive operation is includes additional inputs: [var_names, str_names]= struct_names(struc, var_names, str_names, pre_name); where: var_names input var_names to append output str_names input str_names to append output pre_name is name of previous structure to prepend on str_names","title":"Basic Information"},{"location":"function-guide/utilities/struct_names_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/struct_to_ws_all_m/","text":"struct_to_ws_all.m \u00b6 Basic Information \u00b6 PURPOSE: Places all variables found in structure in WS works through all substructures to find ALL variables (no structures copied to WS only variables) SYNTAX: [names, str_names]= struct_to_ws_all(struc); INPUT: <default> s = Any Matlab Structure toupper = 1; make all variables UPPER CASE, -1=lower case, <0>=no change putwhere = 'base'; puts variables in base WS; <'caller'>=in calling routine OUTPUT: names name of all variables made in environment (ex. PSIRZ) str_names full name of all substructures found in struc (ex. eq.GEQDSK) NOTE: No structures copied to WS (only variables are copied) NOTE: Uses Recursive execution of struc_names to get all variables and structures SEE: struct_to_ws for only 1st level (variables and structures copy to environment) Dependencies \u00b6 remove_space struct_names","title":"struct_to_ws_all.m"},{"location":"function-guide/utilities/struct_to_ws_all_m/#struct_to_ws_allm","text":"","title":"struct_to_ws_all.m"},{"location":"function-guide/utilities/struct_to_ws_all_m/#basic-information","text":"PURPOSE: Places all variables found in structure in WS works through all substructures to find ALL variables (no structures copied to WS only variables) SYNTAX: [names, str_names]= struct_to_ws_all(struc); INPUT: <default> s = Any Matlab Structure toupper = 1; make all variables UPPER CASE, -1=lower case, <0>=no change putwhere = 'base'; puts variables in base WS; <'caller'>=in calling routine OUTPUT: names name of all variables made in environment (ex. PSIRZ) str_names full name of all substructures found in struc (ex. eq.GEQDSK) NOTE: No structures copied to WS (only variables are copied) NOTE: Uses Recursive execution of struc_names to get all variables and structures SEE: struct_to_ws for only 1st level (variables and structures copy to environment)","title":"Basic Information"},{"location":"function-guide/utilities/struct_to_ws_all_m/#dependencies","text":"remove_space struct_names","title":"Dependencies"},{"location":"function-guide/utilities/submatrix_poly_m/","text":"submatrix_poly.m \u00b6 Basic Information \u00b6 SYNTAX: submatrix = submatrix_poly(matrix,rowindex,colindex) PURPOSE: Extract selected submatrix out of matrix of polynomials. INPUT: matrix = matrix of polys to extract from rowindex = indices of rows to extract colindex = indices of columns to extract OUTPUT: submatrix = extracted sub-matrix Dependencies \u00b6 wait","title":"submatrix_poly.m"},{"location":"function-guide/utilities/submatrix_poly_m/#submatrix_polym","text":"","title":"submatrix_poly.m"},{"location":"function-guide/utilities/submatrix_poly_m/#basic-information","text":"SYNTAX: submatrix = submatrix_poly(matrix,rowindex,colindex) PURPOSE: Extract selected submatrix out of matrix of polynomials. INPUT: matrix = matrix of polys to extract from rowindex = indices of rows to extract colindex = indices of columns to extract OUTPUT: submatrix = extracted sub-matrix","title":"Basic Information"},{"location":"function-guide/utilities/submatrix_poly_m/#dependencies","text":"wait","title":"Dependencies"},{"location":"function-guide/utilities/tok_from_pwd_m/","text":"tok_from_pwd.m \u00b6 Basic Information \u00b6 PURPOSE: determines \"tokamak\" from your \"present working directory\" pwd sets global variable TOKAMAK runs startup_\"tok\".m routine for particular machine SYNTAX: tokamak= tok_from_pwd; tok_from_pwd tokamak= tok_from_pwd(tokamak); if you know tokamak to work on tokamak= tok_from_pwd([]); return tokamak but no run of startup INPUT: tokamak= OPTIONAL name of tokamak is known [default= looks in pwd] OUTPUT: tokamak= tokamak name based on search of pwd runs appropriate startup routine as long as tokamak not empty EXAMPLE: pwd= '/home/leuer/tokamaks/d3d/d3d_sim' tokamak= tok_from_pwd; ==> tokamak= 'd3d'; TOKAMAK= 'd3d'; Routine runs: ...startup_d3d.m Dependencies \u00b6 strsfind","title":"tok_from_pwd.m"},{"location":"function-guide/utilities/tok_from_pwd_m/#tok_from_pwdm","text":"","title":"tok_from_pwd.m"},{"location":"function-guide/utilities/tok_from_pwd_m/#basic-information","text":"PURPOSE: determines \"tokamak\" from your \"present working directory\" pwd sets global variable TOKAMAK runs startup_\"tok\".m routine for particular machine SYNTAX: tokamak= tok_from_pwd; tok_from_pwd tokamak= tok_from_pwd(tokamak); if you know tokamak to work on tokamak= tok_from_pwd([]); return tokamak but no run of startup INPUT: tokamak= OPTIONAL name of tokamak is known [default= looks in pwd] OUTPUT: tokamak= tokamak name based on search of pwd runs appropriate startup routine as long as tokamak not empty EXAMPLE: pwd= '/home/leuer/tokamaks/d3d/d3d_sim' tokamak= tok_from_pwd; ==> tokamak= 'd3d'; TOKAMAK= 'd3d'; Routine runs: ...startup_d3d.m","title":"Basic Information"},{"location":"function-guide/utilities/tok_from_pwd_m/#dependencies","text":"strsfind","title":"Dependencies"},{"location":"function-guide/utilities/truncate_header_m/","text":"truncate_header.m \u00b6 Basic Information \u00b6 USAGE: truncate_header(infile,outfile,nlines) PURPOSE: remove header from a file INPUTS: infile = input file outfile = output file nlines = ??? OUTPUTS: none Dependencies \u00b6","title":"truncate_header.m"},{"location":"function-guide/utilities/truncate_header_m/#truncate_headerm","text":"","title":"truncate_header.m"},{"location":"function-guide/utilities/truncate_header_m/#basic-information","text":"USAGE: truncate_header(infile,outfile,nlines) PURPOSE: remove header from a file INPUTS: infile = input file outfile = output file nlines = ??? OUTPUTS: none","title":"Basic Information"},{"location":"function-guide/utilities/truncate_header_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/wait_m/","text":"wait.m \u00b6 Basic Information \u00b6 SYNTAX: wait(message) PURPOSE: Procedure to implement a pause with a message to let user know that carriage return is required in order to continue. (This eliminates confusion over whether long wait for MATLAB is due to a pause or to a very long computation.) If the environemt variable 'SKIPWAIT' exists on the workspace, then the pause is bypassed. This is useful for automated builds. INPUT: message = optional string to print out at pause OUTPUT: printed message to terminal Dependencies \u00b6","title":"wait.m"},{"location":"function-guide/utilities/wait_m/#waitm","text":"","title":"wait.m"},{"location":"function-guide/utilities/wait_m/#basic-information","text":"SYNTAX: wait(message) PURPOSE: Procedure to implement a pause with a message to let user know that carriage return is required in order to continue. (This eliminates confusion over whether long wait for MATLAB is due to a pause or to a very long computation.) If the environemt variable 'SKIPWAIT' exists on the workspace, then the pause is bypassed. This is useful for automated builds. INPUT: message = optional string to print out at pause OUTPUT: printed message to terminal","title":"Basic Information"},{"location":"function-guide/utilities/wait_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/whatfunction_m/","text":"whatfunction.m \u00b6 Basic Information \u00b6 SYNTAX: whatfunction(name_string) PURPOSE: Find a function name given only a partial name string. (See also lookfor, search_path) INPUT: name_string = function name string to match OUTPUT: names of functions containing name_string RESTRICTIONS: Bug in MATLAB restricts when this command will work. Uses the \"unix\" command to find m-files in a directory and sometimes this command doesn't work. Dependencies \u00b6","title":"whatfunction.m"},{"location":"function-guide/utilities/whatfunction_m/#whatfunctionm","text":"","title":"whatfunction.m"},{"location":"function-guide/utilities/whatfunction_m/#basic-information","text":"SYNTAX: whatfunction(name_string) PURPOSE: Find a function name given only a partial name string. (See also lookfor, search_path) INPUT: name_string = function name string to match OUTPUT: names of functions containing name_string RESTRICTIONS: Bug in MATLAB restricts when this command will work. Uses the \"unix\" command to find m-files in a directory and sometimes this command doesn't work.","title":"Basic Information"},{"location":"function-guide/utilities/whatfunction_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/write_ascii_table_m/","text":"write_ascii_table.m \u00b6 Basic Information \u00b6 SYNTAX: write_ascii_table(table,filename,format) PURPOSE: Write out table to ascii file for easy import into MSWord INPUT: table = table to write filename = name of file to write table into format = can be either string or integer. string = defines format for write to file integer = defines number of digits to write out for each entry OUTPUT: file with formatted data (name=filename) Dependencies \u00b6 dlmwrite","title":"write_ascii_table.m"},{"location":"function-guide/utilities/write_ascii_table_m/#write_ascii_tablem","text":"","title":"write_ascii_table.m"},{"location":"function-guide/utilities/write_ascii_table_m/#basic-information","text":"SYNTAX: write_ascii_table(table,filename,format) PURPOSE: Write out table to ascii file for easy import into MSWord INPUT: table = table to write filename = name of file to write table into format = can be either string or integer. string = defines format for write to file integer = defines number of digits to write out for each entry OUTPUT: file with formatted data (name=filename)","title":"Basic Information"},{"location":"function-guide/utilities/write_ascii_table_m/#dependencies","text":"dlmwrite","title":"Dependencies"},{"location":"function-guide/utilities/write_namelist_m/","text":"write_namelist.m \u00b6 Basic Information \u00b6 SYNTAX: write_namelist runs like script with variableread from calling routn. PURPOSE: write FORTRAN namelist file . Typically used after a read_namelist has been read in and data changed and then written out. INPUT: [default] nlall= namelist names and variables (typical from read_namelist) filename_ot = name of namelist file to written to_upper = 1; Variables: 1-UPPER CASE, -1=LOWER CASE, [0=no change] n_per_line = number of numeric data to put on single line [5] OUTPUT: All variables found in namelist(s) within the file are made into matlab variables. Duplicate names are overwritten with subsequent data. nlnames= Character Array contaning names of each namelist read NAMELIST_list= list of each variable in NAMELIST NAMELIST is name of each item in nlnames ex. if file contains &IN then IN_list contains variable nms. nlall= total list of all namelists and variable (write_namelist) RESTRICTIONS: Dependencies \u00b6 remove_space read_namelist write_namelist","title":"write_namelist.m"},{"location":"function-guide/utilities/write_namelist_m/#write_namelistm","text":"","title":"write_namelist.m"},{"location":"function-guide/utilities/write_namelist_m/#basic-information","text":"SYNTAX: write_namelist runs like script with variableread from calling routn. PURPOSE: write FORTRAN namelist file . Typically used after a read_namelist has been read in and data changed and then written out. INPUT: [default] nlall= namelist names and variables (typical from read_namelist) filename_ot = name of namelist file to written to_upper = 1; Variables: 1-UPPER CASE, -1=LOWER CASE, [0=no change] n_per_line = number of numeric data to put on single line [5] OUTPUT: All variables found in namelist(s) within the file are made into matlab variables. Duplicate names are overwritten with subsequent data. nlnames= Character Array contaning names of each namelist read NAMELIST_list= list of each variable in NAMELIST NAMELIST is name of each item in nlnames ex. if file contains &IN then IN_list contains variable nms. nlall= total list of all namelists and variable (write_namelist) RESTRICTIONS:","title":"Basic Information"},{"location":"function-guide/utilities/write_namelist_m/#dependencies","text":"remove_space read_namelist write_namelist","title":"Dependencies"},{"location":"function-guide/utilities/ws2struct_m/","text":"ws2struct.m \u00b6 Basic Information \u00b6 @(#)ws2struct.m 1.1 14/02/14 USAGE: ws2struct PURPOSE: This function allows to save all the variables from the 'caller' workspace into a struct array INPUTS: OUTPUTS: RESTRICTIONS: METHOD: Example: a='LALALA' b=[1:12:258] c={'cell1', 'cell2', 'cell3'} d=768 e=true(3) theworkspace=ws2struct(); theworkspace = a: 'LALALA' b: [1x22 double] c: {'cell1' 'cell2' 'cell3'} d: 768 e: [3x3 logical] VERSION WRITTEN BY: Matthew J. Lanctot on March 19 2013 MODIFICATION HISTORY: 2013-03-19 Created Dependencies \u00b6","title":"ws2struct.m"},{"location":"function-guide/utilities/ws2struct_m/#ws2structm","text":"","title":"ws2struct.m"},{"location":"function-guide/utilities/ws2struct_m/#basic-information","text":"@(#)ws2struct.m 1.1 14/02/14 USAGE: ws2struct PURPOSE: This function allows to save all the variables from the 'caller' workspace into a struct array INPUTS: OUTPUTS: RESTRICTIONS: METHOD: Example: a='LALALA' b=[1:12:258] c={'cell1', 'cell2', 'cell3'} d=768 e=true(3) theworkspace=ws2struct(); theworkspace = a: 'LALALA' b: [1x22 double] c: {'cell1' 'cell2' 'cell3'} d: 768 e: [3x3 logical] VERSION WRITTEN BY: Matthew J. Lanctot on March 19 2013 MODIFICATION HISTORY: 2013-03-19 Created","title":"Basic Information"},{"location":"function-guide/utilities/ws2struct_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/utilities/zero_crossing_m/","text":"zero_crossing.m \u00b6 Basic Information \u00b6 SYNTAX: [zero_x_set,nearest_idx] = zero_crossing(x,y,plot_zeros) PURPOSE: For a function defined by (x,y) data pairs, estimate the value(s) of x at which the function crosses y=0 (assuming linear interpolation between data points). INPUT: x,y = set of data pairs defining function plot_zeros = (optional) flag to plot zeros on top of function OUTPUT: zero_x_set = x values at which y=0 nearest_idx = index of point nearest to the zero crossing Dependencies \u00b6","title":"zero_crossing.m"},{"location":"function-guide/utilities/zero_crossing_m/#zero_crossingm","text":"","title":"zero_crossing.m"},{"location":"function-guide/utilities/zero_crossing_m/#basic-information","text":"SYNTAX: [zero_x_set,nearest_idx] = zero_crossing(x,y,plot_zeros) PURPOSE: For a function defined by (x,y) data pairs, estimate the value(s) of x at which the function crosses y=0 (assuming linear interpolation between data points). INPUT: x,y = set of data pairs defining function plot_zeros = (optional) flag to plot zeros on top of function OUTPUT: zero_x_set = x values at which y=0 nearest_idx = index of point nearest to the zero crossing","title":"Basic Information"},{"location":"function-guide/utilities/zero_crossing_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/validation/Imodel_1coil_m/","text":"Imodel_1coil.m \u00b6 Basic Information \u00b6 SYNTAX: model = Imodel_1coil(tok_system,coil_index,output_index) PURPOSE: Construct a 1 coil Icdot-input A,B,C,D model from the full voltage input model. (Preliminary version.) INPUT: tok_system = full voltage input system model coil_index = see compare_vacuum_fresp (needs clarifying) output_index = indices of outputs to include in generated model OUTPUT: model = A,B,C,D model representing response to current in selected coil. RESTRICTIONS: tok_system.dmat rows corresponding to output_index must = 0. Dependencies \u00b6","title":"Imodel_1coil.m"},{"location":"function-guide/validation/Imodel_1coil_m/#imodel_1coilm","text":"","title":"Imodel_1coil.m"},{"location":"function-guide/validation/Imodel_1coil_m/#basic-information","text":"SYNTAX: model = Imodel_1coil(tok_system,coil_index,output_index) PURPOSE: Construct a 1 coil Icdot-input A,B,C,D model from the full voltage input model. (Preliminary version.) INPUT: tok_system = full voltage input system model coil_index = see compare_vacuum_fresp (needs clarifying) output_index = indices of outputs to include in generated model OUTPUT: model = A,B,C,D model representing response to current in selected coil. RESTRICTIONS: tok_system.dmat rows corresponding to output_index must = 0.","title":"Basic Information"},{"location":"function-guide/validation/Imodel_1coil_m/#dependencies","text":"","title":"Dependencies"},{"location":"function-guide/validation/clean_fresp_data_m/","text":"clean_fresp_data.m \u00b6 Basic Information \u00b6 SYNTAX: clean_fresp_data PURPOSE: Perform some manual \"cleaning\" of measured frequency response data. INPUT: coil = string defining signal name of coil from which data was generated model_type = type of model that generated data : 0=voltage input, 1=current input These define input files <coil>_fresp_mdltype<model_type>.mat that are loaded for cleaning. OUTPUT: Cleaned data is stored in files <coil>_fresp_mdltype<model_type>_cleaned.mat RESTRICTIONS: Input file with name convention described above must exist and contain output generated by compare_vacuum_fresp.m. METHOD: Bode plots comparing measured freq. response samples overlayed on model shown for reference. Interactive prompts provide user options to clean the data: n: normalize first so that measured and modeled DC gain match k: keep all data samples d: delete all data samples m: manually select samples for deletion Dependencies \u00b6 overlay_fresp_data","title":"clean_fresp_data.m"},{"location":"function-guide/validation/clean_fresp_data_m/#clean_fresp_datam","text":"","title":"clean_fresp_data.m"},{"location":"function-guide/validation/clean_fresp_data_m/#basic-information","text":"SYNTAX: clean_fresp_data PURPOSE: Perform some manual \"cleaning\" of measured frequency response data. INPUT: coil = string defining signal name of coil from which data was generated model_type = type of model that generated data : 0=voltage input, 1=current input These define input files <coil>_fresp_mdltype<model_type>.mat that are loaded for cleaning. OUTPUT: Cleaned data is stored in files <coil>_fresp_mdltype<model_type>_cleaned.mat RESTRICTIONS: Input file with name convention described above must exist and contain output generated by compare_vacuum_fresp.m. METHOD: Bode plots comparing measured freq. response samples overlayed on model shown for reference. Interactive prompts provide user options to clean the data: n: normalize first so that measured and modeled DC gain match k: keep all data samples d: delete all data samples m: manually select samples for deletion","title":"Basic Information"},{"location":"function-guide/validation/clean_fresp_data_m/#dependencies","text":"overlay_fresp_data","title":"Dependencies"},{"location":"function-guide/validation/compare_isobgd_data_m/","text":"compare_isobgd_data.m \u00b6 Basic Information \u00b6 SYNTAX: compare_isobgd_data PURPOSE: To extract coil current and R,z-data from efit-generated g0-files, read isoflux/Bgrid Green functions, and compare EFIT response at control points with predicted values from rigid predictors generated by rzrig. Also does R,Z comparison from compare_efit_rig along the way. (Works only for D3D right now, but should be generalizable.) INPUT: shot = shot number of data to compare with model. Must agree with g0-files in default directory. model_shotnum = shot number of model (appearing in model data file names, e.g. out_objs_<shot>_<time>.mat) model_dir = directory where out_objs*, out2_objs*, drzdi* files located tref = reference time for EFIT data (in ms) model_tref = reference time for model files (in ms) t1ms = initial g0-file time (msec) t2ms = final g0-file time (msec) dtms = time interval (msec) between g0-file times eqdir = directory w/ eqdsk files (end with \"/\", eg '/matlab/plresp/') efit_times (optional) = vector of efit_times (if not supplied, constructs from t1ms,t2ms,dtms). create_plotfile = 1 if you want color postscript file of all plots ildefit = 1 to load EFIT data (0 to disable to save time for later runs) iloaddi = 1 to load model response files (0 to disable loading) ikillE = 1 to kill effect of E-coil currents in prediction (else incl) iuseIp = 1 to use drdip object in predicted response niso = index of isoflux segment to use for comparison nbgd = index of Bgrid row to use for comparison icompall = flag to enable comparison plotting of entire segments for all time points (scroll through with CR...) 1=plot, 0=skip (if skip just compares average over the segment) create_plotfile = set to 1 to create *.psc file containing plots (optional, default = 0) OUTPUT: t = time vector (secs) zm_efit = vertical position data vector from EFIT g0-file data zo_efit = LCFS vertical position data vector from EFIT g0-file data z_rig = vertical position data vector from rigid predictor dzdis rm_efit = vertical position data vector from EFIT g0-file data ro_efit = LCFS vertical position data vector from EFIT g0-file data r_rig = vertical position data vector from vst predictor drdi Plots comparison of EFIT and corresponding R,Z predictor data in figures 1 and 2. RESTRICTIONS: Must have generated efits in eqdir from t1ms to t2ms Dependencies \u00b6 read_afile remove_space read_response time_slice wait plot_tok_geo fft_filter build_design_model seg_error_name resamplev read_gfile_tok","title":"compare_isobgd_data.m"},{"location":"function-guide/validation/compare_isobgd_data_m/#compare_isobgd_datam","text":"","title":"compare_isobgd_data.m"},{"location":"function-guide/validation/compare_isobgd_data_m/#basic-information","text":"SYNTAX: compare_isobgd_data PURPOSE: To extract coil current and R,z-data from efit-generated g0-files, read isoflux/Bgrid Green functions, and compare EFIT response at control points with predicted values from rigid predictors generated by rzrig. Also does R,Z comparison from compare_efit_rig along the way. (Works only for D3D right now, but should be generalizable.) INPUT: shot = shot number of data to compare with model. Must agree with g0-files in default directory. model_shotnum = shot number of model (appearing in model data file names, e.g. out_objs_<shot>_<time>.mat) model_dir = directory where out_objs*, out2_objs*, drzdi* files located tref = reference time for EFIT data (in ms) model_tref = reference time for model files (in ms) t1ms = initial g0-file time (msec) t2ms = final g0-file time (msec) dtms = time interval (msec) between g0-file times eqdir = directory w/ eqdsk files (end with \"/\", eg '/matlab/plresp/') efit_times (optional) = vector of efit_times (if not supplied, constructs from t1ms,t2ms,dtms). create_plotfile = 1 if you want color postscript file of all plots ildefit = 1 to load EFIT data (0 to disable to save time for later runs) iloaddi = 1 to load model response files (0 to disable loading) ikillE = 1 to kill effect of E-coil currents in prediction (else incl) iuseIp = 1 to use drdip object in predicted response niso = index of isoflux segment to use for comparison nbgd = index of Bgrid row to use for comparison icompall = flag to enable comparison plotting of entire segments for all time points (scroll through with CR...) 1=plot, 0=skip (if skip just compares average over the segment) create_plotfile = set to 1 to create *.psc file containing plots (optional, default = 0) OUTPUT: t = time vector (secs) zm_efit = vertical position data vector from EFIT g0-file data zo_efit = LCFS vertical position data vector from EFIT g0-file data z_rig = vertical position data vector from rigid predictor dzdis rm_efit = vertical position data vector from EFIT g0-file data ro_efit = LCFS vertical position data vector from EFIT g0-file data r_rig = vertical position data vector from vst predictor drdi Plots comparison of EFIT and corresponding R,Z predictor data in figures 1 and 2. RESTRICTIONS: Must have generated efits in eqdir from t1ms to t2ms","title":"Basic Information"},{"location":"function-guide/validation/compare_isobgd_data_m/#dependencies","text":"read_afile remove_space read_response time_slice wait plot_tok_geo fft_filter build_design_model seg_error_name resamplev read_gfile_tok","title":"Dependencies"},{"location":"function-guide/validation/compare_system_outputs_m/","text":"compare_system_outputs.m \u00b6 Basic Information \u00b6 SYNTAX: compare_system_outputs PURPOSE: Compare outputs of generic-constructed system model with measured signals that correspond to these outputs. This script builds the model, simulates system outputs (driven by measurements) and compares those simulations with measured data. INPUT (see build_<tokamak>_sys help for additional inputs): tokamak = name of tokamak (e.g. 'd3d', 'kstar', 'nstx', ...) config_name = string defining model configuration ichooseq = see input to build_tokamak_system.m (ichooseq=0 => vacuum model) model_shotnum = shot number to derive model from (only required if ichooseq > 0) equil_time = time of plasma equilibrium in sec (only required if ichooseq > 0) efit_source = source of mdsplus efit (only required if ichooseq = 4) data_shotnum = number of shot to get data for model comparison tmin, tmax = min and max times (sec) for data window out_signals_col = index of column in output_signals array to define measured data to compare against output_index = indices of model outputs to compare model and data (coil currents are always included) input_index = indices of model inputs (coil circuits) that are connected to power supplies (default = all) output_index = defines which outputs to look at (default = all) get_data_fn_input = string defining function to call when fetching input signals get_data_fn_output = string defining function to call when fetching output signals model_type = 1 for coil current inputs, 0 for voltage inputs (default = 0) iplcirc = set to 1 to include plasma current circuit, else 0 (default 1, only needed if ichooseq>0) first_time = set to 1 first time this script used (optional, default=1) equil_avg_time = [sec] window over which to avg ptname data used to calculate nominal equilibrium (optional, default=10ms) cutoff = cutoff frequency (in Hz) to filter signals when plotting ohstates_idx = index of coils to use to ramp in coil nominal trajectories for Ip drive OUTPUT: comparison plots for model versus data. Dependencies \u00b6 get_signals dynamic_equil wait read_mds_eqdsk resamplev fft_filter","title":"compare_system_outputs.m"},{"location":"function-guide/validation/compare_system_outputs_m/#compare_system_outputsm","text":"","title":"compare_system_outputs.m"},{"location":"function-guide/validation/compare_system_outputs_m/#basic-information","text":"SYNTAX: compare_system_outputs PURPOSE: Compare outputs of generic-constructed system model with measured signals that correspond to these outputs. This script builds the model, simulates system outputs (driven by measurements) and compares those simulations with measured data. INPUT (see build_<tokamak>_sys help for additional inputs): tokamak = name of tokamak (e.g. 'd3d', 'kstar', 'nstx', ...) config_name = string defining model configuration ichooseq = see input to build_tokamak_system.m (ichooseq=0 => vacuum model) model_shotnum = shot number to derive model from (only required if ichooseq > 0) equil_time = time of plasma equilibrium in sec (only required if ichooseq > 0) efit_source = source of mdsplus efit (only required if ichooseq = 4) data_shotnum = number of shot to get data for model comparison tmin, tmax = min and max times (sec) for data window out_signals_col = index of column in output_signals array to define measured data to compare against output_index = indices of model outputs to compare model and data (coil currents are always included) input_index = indices of model inputs (coil circuits) that are connected to power supplies (default = all) output_index = defines which outputs to look at (default = all) get_data_fn_input = string defining function to call when fetching input signals get_data_fn_output = string defining function to call when fetching output signals model_type = 1 for coil current inputs, 0 for voltage inputs (default = 0) iplcirc = set to 1 to include plasma current circuit, else 0 (default 1, only needed if ichooseq>0) first_time = set to 1 first time this script used (optional, default=1) equil_avg_time = [sec] window over which to avg ptname data used to calculate nominal equilibrium (optional, default=10ms) cutoff = cutoff frequency (in Hz) to filter signals when plotting ohstates_idx = index of coils to use to ramp in coil nominal trajectories for Ip drive OUTPUT: comparison plots for model versus data.","title":"Basic Information"},{"location":"function-guide/validation/compare_system_outputs_m/#dependencies","text":"get_signals dynamic_equil wait read_mds_eqdsk resamplev fft_filter","title":"Dependencies"},{"location":"function-guide/validation/compare_vacuum_fresp_m/","text":"compare_vacuum_fresp.m \u00b6 Basic Information \u00b6 SYNTAX: compare_vacuum_fresp PURPOSE: Use in analyzing sine-wave excitation data collected for model validation. Perform generic build of single-input system model, then compare frequency response of that model with frequency response data calculated from acquired experiment data. INPUT: tokamak = name of tokamak (e.g. 'd3d', 'kstar', 'nstx', ...) config_name = string specifying which model configuration to use model_type = type of model to generate: 0=voltage input, 1=current input fresp_data_input = array of structures, each structure containing data for response to 1 input: input_index = value depends on model_type: if 0, set to index of model input that is connected to a power supply during experiment if 1, must be set to 1 sin_shots = single shot number or vector of shot numbers, one for each interval defined below t_intervals = array of pairs [ [tstart(1), tend(1)]; [tstart(2), tend(2)]; ... ] defining time intervals containing sine wave data (of a single frequency) to be analyzed f_intervals = array of pairs [fmin,fmax] = intervals in frequency (Hz) to search for sine wave frequency dc_shot = shot number containing data from which to compute dc gain dc_interval = time interval [tstart, tend] (containing ~constant data) to use for dc gain calculation get_data_fn_input = string defining function to call when fetching input signals get_data_fn_output = string defining function to call when fetching output signals cccirc = vector defining coil connections (see help build_tokamak_system) OR (not both) netlist = netlist input defining coil connections (see help build_tokamak_system) PLUS, add any other parameters that build_<device>_sys needs to execute OPTIONAL INPUTS: output_set = column number in the tok_system.output_signals array to use to define output signals (default 1) output_index = indices of model outputs to compare model and data or 'all' (default 'all') model_type = 0 for voltage input, or 1 for current input (default 0) drift_correct = vector [tmin1,tmax1] or [tmin1,tmax1,tmin2,tmax2] defining times to compute offset(s) needed to correct for integrator drift; 2 times=>offset only, 4 times=>correct linear drift freq_vals = interval of frequency values (Hz) to include in modeled frequency response plots (default is defined to cover experiment data frequency responses) show_plots = set >= 1 to see plots during calculation of frequency response (default 0), larger => more info verbose = set to value greater than 0 to get diagnostic prints, larger value gives more info save_response = set to 1 to save frequency response in file named <coil>_fresp.mat (default 0) snr_reject_thresh = reject calculated frequency response if output SNR (dB) < this value (default 20) snr_accept_thresh = automatically accept calculated response f output SNR (dB) > this value (default 26) sin_offset_intvals dc_offset_intvals min_ncounts = minimum number of digitizer counts required in dynamic range of data; if an output signal has less dynamic range than this value, the response data for that signal is ignored (default 7) create_plotfile = set to 1 to create postscript file containing all frequency response plots (default 0) OUTPUT: comparison plots for model frequency response versus gain/phase computed from experimental data. RESTRICTIONS: Currently only models correctly those outputs without direct feedthrough (i.e. with D=0 in plant model) when model_type = 1. Also, the netlist input option does not work correctly yet. Dependencies \u00b6 window_data inout_fresp wait plot_tok_geo fft_filter Imodel_1coil bodehz get_signals hdcopy resamplev rm_x_label detect_peaks","title":"compare_vacuum_fresp.m"},{"location":"function-guide/validation/compare_vacuum_fresp_m/#compare_vacuum_frespm","text":"","title":"compare_vacuum_fresp.m"},{"location":"function-guide/validation/compare_vacuum_fresp_m/#basic-information","text":"SYNTAX: compare_vacuum_fresp PURPOSE: Use in analyzing sine-wave excitation data collected for model validation. Perform generic build of single-input system model, then compare frequency response of that model with frequency response data calculated from acquired experiment data. INPUT: tokamak = name of tokamak (e.g. 'd3d', 'kstar', 'nstx', ...) config_name = string specifying which model configuration to use model_type = type of model to generate: 0=voltage input, 1=current input fresp_data_input = array of structures, each structure containing data for response to 1 input: input_index = value depends on model_type: if 0, set to index of model input that is connected to a power supply during experiment if 1, must be set to 1 sin_shots = single shot number or vector of shot numbers, one for each interval defined below t_intervals = array of pairs [ [tstart(1), tend(1)]; [tstart(2), tend(2)]; ... ] defining time intervals containing sine wave data (of a single frequency) to be analyzed f_intervals = array of pairs [fmin,fmax] = intervals in frequency (Hz) to search for sine wave frequency dc_shot = shot number containing data from which to compute dc gain dc_interval = time interval [tstart, tend] (containing ~constant data) to use for dc gain calculation get_data_fn_input = string defining function to call when fetching input signals get_data_fn_output = string defining function to call when fetching output signals cccirc = vector defining coil connections (see help build_tokamak_system) OR (not both) netlist = netlist input defining coil connections (see help build_tokamak_system) PLUS, add any other parameters that build_<device>_sys needs to execute OPTIONAL INPUTS: output_set = column number in the tok_system.output_signals array to use to define output signals (default 1) output_index = indices of model outputs to compare model and data or 'all' (default 'all') model_type = 0 for voltage input, or 1 for current input (default 0) drift_correct = vector [tmin1,tmax1] or [tmin1,tmax1,tmin2,tmax2] defining times to compute offset(s) needed to correct for integrator drift; 2 times=>offset only, 4 times=>correct linear drift freq_vals = interval of frequency values (Hz) to include in modeled frequency response plots (default is defined to cover experiment data frequency responses) show_plots = set >= 1 to see plots during calculation of frequency response (default 0), larger => more info verbose = set to value greater than 0 to get diagnostic prints, larger value gives more info save_response = set to 1 to save frequency response in file named <coil>_fresp.mat (default 0) snr_reject_thresh = reject calculated frequency response if output SNR (dB) < this value (default 20) snr_accept_thresh = automatically accept calculated response f output SNR (dB) > this value (default 26) sin_offset_intvals dc_offset_intvals min_ncounts = minimum number of digitizer counts required in dynamic range of data; if an output signal has less dynamic range than this value, the response data for that signal is ignored (default 7) create_plotfile = set to 1 to create postscript file containing all frequency response plots (default 0) OUTPUT: comparison plots for model frequency response versus gain/phase computed from experimental data. RESTRICTIONS: Currently only models correctly those outputs without direct feedthrough (i.e. with D=0 in plant model) when model_type = 1. Also, the netlist input option does not work correctly yet.","title":"Basic Information"},{"location":"function-guide/validation/compare_vacuum_fresp_m/#dependencies","text":"window_data inout_fresp wait plot_tok_geo fft_filter Imodel_1coil bodehz get_signals hdcopy resamplev rm_x_label detect_peaks","title":"Dependencies"},{"location":"function-guide/validation/get_signals_m/","text":"get_signals.m \u00b6 Basic Information \u00b6 SYNTAX: [d,t,ier]=get_signals(shotnum,signal_names,tmin,tmax,get_data_fn,options) PURPOSE: Generic function for fetching signals of the type stored in the \"output_signals\" field of the generic system model data structure. INPUT: shotnum = shot number signal_names = signal names, either string array or cell array (1 column). Can be a numerical expression involving valid pointnames. tmin, tmax = min and max time for data interval get_data_fn = string defining function to call to get data; must have argument list of the form: (shotnum,signal_name,tmin,tmax) options = structure defining optional processing to do, allowed fields = drift_correct = vector [tmin1,tmax1] or [tmin1,tmax1,tmin2,tmax2] defining times to compute offset(s) needed to correct for integrator drift; 2 times=>offset only, 4 times=>correct linear drift (tmin, tmax must be chosen where the data \"should\" be zero) resample_time = time vector at which to resample data OR integer 1 indicating resample time is defined by signal in first entry of signal_names verbose = set>=1 to display various messages (larger # => more msgs) (If an option is not specified, the operation is not performed.) OUTPUT: d = data array; one column per signal name t = corresponding time vector ier = number of signal ptnames that could not be successfully fetched RESTRICTIONS: Doesn't currently handle multiple signals with different timebases - logic needs to be added. Dependencies \u00b6 remove_space correct_drift_intvals strsfind wait window_data resamplev","title":"get_signals.m"},{"location":"function-guide/validation/get_signals_m/#get_signalsm","text":"","title":"get_signals.m"},{"location":"function-guide/validation/get_signals_m/#basic-information","text":"SYNTAX: [d,t,ier]=get_signals(shotnum,signal_names,tmin,tmax,get_data_fn,options) PURPOSE: Generic function for fetching signals of the type stored in the \"output_signals\" field of the generic system model data structure. INPUT: shotnum = shot number signal_names = signal names, either string array or cell array (1 column). Can be a numerical expression involving valid pointnames. tmin, tmax = min and max time for data interval get_data_fn = string defining function to call to get data; must have argument list of the form: (shotnum,signal_name,tmin,tmax) options = structure defining optional processing to do, allowed fields = drift_correct = vector [tmin1,tmax1] or [tmin1,tmax1,tmin2,tmax2] defining times to compute offset(s) needed to correct for integrator drift; 2 times=>offset only, 4 times=>correct linear drift (tmin, tmax must be chosen where the data \"should\" be zero) resample_time = time vector at which to resample data OR integer 1 indicating resample time is defined by signal in first entry of signal_names verbose = set>=1 to display various messages (larger # => more msgs) (If an option is not specified, the operation is not performed.) OUTPUT: d = data array; one column per signal name t = corresponding time vector ier = number of signal ptnames that could not be successfully fetched RESTRICTIONS: Doesn't currently handle multiple signals with different timebases - logic needs to be added.","title":"Basic Information"},{"location":"function-guide/validation/get_signals_m/#dependencies","text":"remove_space correct_drift_intvals strsfind wait window_data resamplev","title":"Dependencies"},{"location":"function-guide/validation/overlay_fresp_data_m/","text":"overlay_fresp_data.m \u00b6 Basic Information \u00b6 SYNTAX: overlay_fresp_data(fresp_data) PURPOSE: Overlay measured frequency response data samples on top of bode plot. INPUT: fresp_data: structure containing: wout = frequencies (Hz) of bode plot mag = magnitudes in bode plot phi = phases in bode plot (degrees) f = frequencies (Hz) of measured frequency response data g = gain of measured frequency response data ph = phase (deg) measured frequency response data model_type = 0 for voltage input, 1 for current input tok_system = system model from build_<device>_sys.m coil_index = index of coil defining input to model (if model_type=1) output_set = column of output_signals array used to compute responses output_index = index of all output signals used to compute responses inp_num = index of input of model being shown in bode plot out_num = index of output of model being shown in bode plot OUTPUT: Overlay plot, measured samples on top of \"continuous\" modeled response. Dependencies \u00b6 rm_x_label","title":"overlay_fresp_data.m"},{"location":"function-guide/validation/overlay_fresp_data_m/#overlay_fresp_datam","text":"","title":"overlay_fresp_data.m"},{"location":"function-guide/validation/overlay_fresp_data_m/#basic-information","text":"SYNTAX: overlay_fresp_data(fresp_data) PURPOSE: Overlay measured frequency response data samples on top of bode plot. INPUT: fresp_data: structure containing: wout = frequencies (Hz) of bode plot mag = magnitudes in bode plot phi = phases in bode plot (degrees) f = frequencies (Hz) of measured frequency response data g = gain of measured frequency response data ph = phase (deg) measured frequency response data model_type = 0 for voltage input, 1 for current input tok_system = system model from build_<device>_sys.m coil_index = index of coil defining input to model (if model_type=1) output_set = column of output_signals array used to compute responses output_index = index of all output signals used to compute responses inp_num = index of input of model being shown in bode plot out_num = index of output of model being shown in bode plot OUTPUT: Overlay plot, measured samples on top of \"continuous\" modeled response.","title":"Basic Information"},{"location":"function-guide/validation/overlay_fresp_data_m/#dependencies","text":"rm_x_label","title":"Dependencies"},{"location":"function-guide/validation/validate_isoflux_response_m/","text":"validate_isoflux_response.m \u00b6 Basic Information \u00b6 SYNTAX: validate_isoflux_response PURPOSE: Comparison of isoflux model predictions with experimental data. INPUT: shotnum = shot number to use for validation data tmin,tmax = min and max times to get data from shot dt_smooth = window length (sec) for smoothing isoflux_response = structure built by build_isoflux_response.m tok_data_struct = vacuum model structure resp_mdl = either the rzrig_data or gspert_data structure (from system model) equil_data = equilibrium used to generate resp_mdl (equil time must be in [tmin,tmax]) OUTPUT: comparison plots of predicted isoflux errors versus errors during shot Dependencies \u00b6 wait window_data calc_centroid smoothdt cc_efit_to_tok resamplev","title":"validate_isoflux_response.m"},{"location":"function-guide/validation/validate_isoflux_response_m/#validate_isoflux_responsem","text":"","title":"validate_isoflux_response.m"},{"location":"function-guide/validation/validate_isoflux_response_m/#basic-information","text":"SYNTAX: validate_isoflux_response PURPOSE: Comparison of isoflux model predictions with experimental data. INPUT: shotnum = shot number to use for validation data tmin,tmax = min and max times to get data from shot dt_smooth = window length (sec) for smoothing isoflux_response = structure built by build_isoflux_response.m tok_data_struct = vacuum model structure resp_mdl = either the rzrig_data or gspert_data structure (from system model) equil_data = equilibrium used to generate resp_mdl (equil time must be in [tmin,tmax]) OUTPUT: comparison plots of predicted isoflux errors versus errors during shot","title":"Basic Information"},{"location":"function-guide/validation/validate_isoflux_response_m/#dependencies","text":"wait window_data calc_centroid smoothdt cc_efit_to_tok resamplev","title":"Dependencies"},{"location":"tutorials/documentation/","text":"How to write documentation \u00b6 All documentation is written in an extended Markdown markup language. TokSys documentation is created using the MkDocs static site generator with the MkDocs-Material theme which has extended Markdown capabilities. Installing Documentation Dependencies \u00b6 pip pip install mkdocs pip install pymdown-extensions pip install mkdocs-material pip install mkdocs-material-extensions conda conda config --add channels conda-forge conda config --set channel_priority strict conda install mkdocs conda install pymdown-extensions conda install mkdocs-material conda install mkdocs-material-extensions Documentation Pages \u00b6 As mentioned, documentation pages are written in an extended Markdown. MkDocs parses Markdown files contained in the docs directory. To create a new documenation page just make a new Markdown file in the docs directory and MkDocs will transform it into valid HTML. For example, the markdown file for this page is located at docs/tutorials/documentation.md . Note The documentation page title is taken from the first Markdown header in the file and not the name of the file. Function and Script Documentation \u00b6 Documentation can be written along side code. For example: Matlab function c = add ( a,b ) % SYNTAX: c = add(a,b) % % PURPOSE: Add two numbers % % INPUT: % a, b = two numbers % % OUTPUT: % c = sum of a and b %+## Extra Markdown %+ %+Here is some extra information that might be useful %+ %+\\begin{equation} %+ c = a + b %+\\end{equation} %+ %+!!! warning \"Deprecated\" %+ This function has been deprecated. Please use the built in + operator % Regular code follows Python def add ( a , b ): # SYNTAX: c = add(a,b) # # PURPOSE: Add two numbers # # INPUT: # a, b = two numbers # # OUTPUT: # c = sum of a and b #+## Extra Markdown #+ #+Here is some extra information that might be useful #+ #+\\begin{equation} #+ c = a + b #+\\end{equation} #+ #+!!! warning \"Deprecated\" #+ This function has been deprecated. Please use the built in + operator # Regular code follows C int add ( int a , int b ) { // SYNTAX: c = add(a,b) // // PURPOSE: Add two numbers // // INPUT: // a, b = two numbers // // OUTPUT: // c = sum of a and b //+## Extra Markdown //+ //+Here is some extra information that might be useful //+ //+\\begin{equation} //+ c = a + b //+\\end{equation} //+ //+!!! warning \"Deprecated\" //+ This function has been deprecated. Please use the built in + operator // Regular code follows Fortran 77 real function add ( a , b ) result ( c ) C SYNTAX : c = add ( a , b ) C C PURPOSE : Add two numbers C C INPUT : C a , b = two numbers C C OUTPUT : C c = sum of a and b C + ## Extra Markdown C + C + Here is some extra information that might be useful C + C + \\ begin { equation } C + c = a + b C + \\ end { equation } C + C + !!! warning \"Deprecated\" C + This function has been deprecated . Please use the built in + operator C Regular code follows Fortran 90+ real function add ( a , b ) result ( c ) ! SYNTAX: c = add(a,b) ! ! PURPOSE: Add two numbers ! ! INPUT: ! a, b = two numbers ! ! OUTPUT: ! c = sum of a and b !+## Extra Markdown !+ !+Here is some extra information that might be useful !+ !+\\begin{equation} !+ c = a + b !+\\end{equation} !+ !+!!! warning \"Deprecated\" !+ This function has been deprecated. Please use the built in + operator ! Regular code follows Tip The fields SYNTAX or USAGE , PURPOSE , INPUT , and OUTPUT in the first part of the documentation is recommended The script create_docs is used to extract the documentation from the source files. The script does two passes over a file. The first pass is to extract the basic information denoted by the first continguous comment block denoted by a single comment mark e.g. % or // depending on the source file. This documentation is interpreted as raw text and is wrapped in a markdown code block. Note Matlab documentation denoted by a single % will be displayed when using Matlab's built-in help command The second pass extracts the contents in the first contiguous comment block denoted denoted with a comment mark and a + sign e.g. %+ . This documenation is interpreted as markdown. The above examples will be rendered as the following: Example Documentation Basic Information \u00b6 SYNTAX: c = add(a,b) PURPOSE: Add two numbers INPUT: a, b = two numbers OUTPUT: c = sum of a and b Extra Markdown \u00b6 Here is some extra information that might be useful \\[\\begin{equation} c = a + b \\end{equation}\\] Deprecated This function has been deprecated. Please use the built in + operator To extract the inline documentation from the source files run the following in the docs directory rm -rf function -guide # remove old files ./create_docs ../matlab function -guide This will create a cooresponding markdown file for every source file in the matlab directory in the docs/function-guide directory with the directory tree mirroring the matlab directory. For example, the documenation in matlab/GAcontrol/bodehz.m gets parsed into a file called docs/function-guide/GAcontrol/bodehz_m.md . Previewing the Documentation Website \u00b6 You can create a live preview your documentation by running mkdocs serve # Creates a live-updating webpage at http://127.0.0.1:8000 Building the Website \u00b6 You can create the function/script documentation by running makeit docs in the TokSys directory. This will pull the documenation from the source files using the create_docs script and build the website fom the Markdown files in the docs directory. Deploying Website \u00b6 Todo Automagically deploy website when pushed to repo","title":"How to write documentation"},{"location":"tutorials/documentation/#how-to-write-documentation","text":"All documentation is written in an extended Markdown markup language. TokSys documentation is created using the MkDocs static site generator with the MkDocs-Material theme which has extended Markdown capabilities.","title":"How to write documentation"},{"location":"tutorials/documentation/#installing-documentation-dependencies","text":"pip pip install mkdocs pip install pymdown-extensions pip install mkdocs-material pip install mkdocs-material-extensions conda conda config --add channels conda-forge conda config --set channel_priority strict conda install mkdocs conda install pymdown-extensions conda install mkdocs-material conda install mkdocs-material-extensions","title":"Installing Documentation Dependencies"},{"location":"tutorials/documentation/#documentation-pages","text":"As mentioned, documentation pages are written in an extended Markdown. MkDocs parses Markdown files contained in the docs directory. To create a new documenation page just make a new Markdown file in the docs directory and MkDocs will transform it into valid HTML. For example, the markdown file for this page is located at docs/tutorials/documentation.md . Note The documentation page title is taken from the first Markdown header in the file and not the name of the file.","title":"Documentation Pages"},{"location":"tutorials/documentation/#function-and-script-documentation","text":"Documentation can be written along side code. For example: Matlab function c = add ( a,b ) % SYNTAX: c = add(a,b) % % PURPOSE: Add two numbers % % INPUT: % a, b = two numbers % % OUTPUT: % c = sum of a and b %+## Extra Markdown %+ %+Here is some extra information that might be useful %+ %+\\begin{equation} %+ c = a + b %+\\end{equation} %+ %+!!! warning \"Deprecated\" %+ This function has been deprecated. Please use the built in + operator % Regular code follows Python def add ( a , b ): # SYNTAX: c = add(a,b) # # PURPOSE: Add two numbers # # INPUT: # a, b = two numbers # # OUTPUT: # c = sum of a and b #+## Extra Markdown #+ #+Here is some extra information that might be useful #+ #+\\begin{equation} #+ c = a + b #+\\end{equation} #+ #+!!! warning \"Deprecated\" #+ This function has been deprecated. Please use the built in + operator # Regular code follows C int add ( int a , int b ) { // SYNTAX: c = add(a,b) // // PURPOSE: Add two numbers // // INPUT: // a, b = two numbers // // OUTPUT: // c = sum of a and b //+## Extra Markdown //+ //+Here is some extra information that might be useful //+ //+\\begin{equation} //+ c = a + b //+\\end{equation} //+ //+!!! warning \"Deprecated\" //+ This function has been deprecated. Please use the built in + operator // Regular code follows Fortran 77 real function add ( a , b ) result ( c ) C SYNTAX : c = add ( a , b ) C C PURPOSE : Add two numbers C C INPUT : C a , b = two numbers C C OUTPUT : C c = sum of a and b C + ## Extra Markdown C + C + Here is some extra information that might be useful C + C + \\ begin { equation } C + c = a + b C + \\ end { equation } C + C + !!! warning \"Deprecated\" C + This function has been deprecated . Please use the built in + operator C Regular code follows Fortran 90+ real function add ( a , b ) result ( c ) ! SYNTAX: c = add(a,b) ! ! PURPOSE: Add two numbers ! ! INPUT: ! a, b = two numbers ! ! OUTPUT: ! c = sum of a and b !+## Extra Markdown !+ !+Here is some extra information that might be useful !+ !+\\begin{equation} !+ c = a + b !+\\end{equation} !+ !+!!! warning \"Deprecated\" !+ This function has been deprecated. Please use the built in + operator ! Regular code follows Tip The fields SYNTAX or USAGE , PURPOSE , INPUT , and OUTPUT in the first part of the documentation is recommended The script create_docs is used to extract the documentation from the source files. The script does two passes over a file. The first pass is to extract the basic information denoted by the first continguous comment block denoted by a single comment mark e.g. % or // depending on the source file. This documentation is interpreted as raw text and is wrapped in a markdown code block. Note Matlab documentation denoted by a single % will be displayed when using Matlab's built-in help command The second pass extracts the contents in the first contiguous comment block denoted denoted with a comment mark and a + sign e.g. %+ . This documenation is interpreted as markdown. The above examples will be rendered as the following: Example Documentation","title":"Function and Script Documentation"},{"location":"tutorials/documentation/#basic-information","text":"SYNTAX: c = add(a,b) PURPOSE: Add two numbers INPUT: a, b = two numbers OUTPUT: c = sum of a and b","title":"Basic Information"},{"location":"tutorials/documentation/#extra-markdown","text":"Here is some extra information that might be useful \\[\\begin{equation} c = a + b \\end{equation}\\] Deprecated This function has been deprecated. Please use the built in + operator To extract the inline documentation from the source files run the following in the docs directory rm -rf function -guide # remove old files ./create_docs ../matlab function -guide This will create a cooresponding markdown file for every source file in the matlab directory in the docs/function-guide directory with the directory tree mirroring the matlab directory. For example, the documenation in matlab/GAcontrol/bodehz.m gets parsed into a file called docs/function-guide/GAcontrol/bodehz_m.md .","title":"Extra Markdown"},{"location":"tutorials/documentation/#previewing-the-documentation-website","text":"You can create a live preview your documentation by running mkdocs serve # Creates a live-updating webpage at http://127.0.0.1:8000","title":"Previewing the Documentation Website"},{"location":"tutorials/documentation/#building-the-website","text":"You can create the function/script documentation by running makeit docs in the TokSys directory. This will pull the documenation from the source files using the create_docs script and build the website fom the Markdown files in the docs directory.","title":"Building the Website"},{"location":"tutorials/documentation/#deploying-website","text":"Todo Automagically deploy website when pushed to repo","title":"Deploying Website"}]}